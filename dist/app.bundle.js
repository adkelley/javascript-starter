/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/sanctuary-def/index.js":
/*!*********************************************!*\
  !*** ./node_modules/sanctuary-def/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*              ___                 ______
               /  /\               /  ___/\
        ______/  / / _______    __/  /___\/
       /  ___   / / /  ___  \  /_   __/\
      /  /\_/  / / /  /__/  /\ \/  /\_\/
     /  / //  / / /  ______/ / /  / /
    /  /_//  / / /  /______\/ /  / /
    \_______/ /  \_______/\  /__/ /
     \______\/    \______\/  \__*/

//. # sanctuary-def
//.
//. sanctuary-def is a run-time type system for JavaScript. It facilitates
//. the definition of curried JavaScript functions which are explicit about
//. the number of arguments to which they may be applied and the types of
//. those arguments.
//.
//. It is conventional to import the package as `$`:
//.
//. ```javascript
//. const $ = require ('sanctuary-def');
//. ```
//.
//. The next step is to define an environment. An environment is an array
//. of [types][]. [`env`][] is an environment containing all the built-in
//. JavaScript types. It may be used as the basis for environments which
//. include custom types in addition to the built-in types:
//.
//. ```javascript
//. //    Integer :: Type
//. const Integer = '...';
//.
//. //    NonZeroInteger :: Type
//. const NonZeroInteger = '...';
//.
//. //    env :: Array Type
//. const env = $.env.concat ([Integer, NonZeroInteger]);
//. ```
//.
//. Type constructors such as `List :: Type -> Type` cannot be included in
//. an environment as they're not of the correct type. One could, though,
//. use a type constructor to define a fixed number of concrete types:
//.
//. ```javascript
//. //    env :: Array Type
//. const env = $.env.concat ([
//.   List ($.Number),                // :: Type
//.   List ($.String),                // :: Type
//.   List (List ($.Number)),         // :: Type
//.   List (List ($.String)),         // :: Type
//.   List (List (List ($.Number))),  // :: Type
//.   List (List (List ($.String))),  // :: Type
//. ]);
//. ```
//.
//. Not only would this be tedious, but one could never enumerate all possible
//. types as there are infinitely many. Instead, one should use [`Unknown`][]:
//.
//. ```javascript
//. //    env :: Array Type
//. const env = $.env.concat ([List ($.Unknown)]);
//. ```
//.
//. The next step is to define a `def` function for the environment:
//.
//. ```javascript
//. const def = $.create ({checkTypes: true, env});
//. ```
//.
//. The `checkTypes` option determines whether type checking is enabled.
//. This allows one to only pay the performance cost of run-time type checking
//. during development. For example:
//.
//. ```javascript
//. const def = $.create ({
//.   checkTypes: process.env.NODE_ENV === 'development',
//.   env,
//. });
//. ```
//.
//. `def` is a function for defining functions. For example:
//.
//. ```javascript
//. //    add :: Number -> Number -> Number
//. const add =
//. def ('add')
//.     ({})
//.     ([$.Number, $.Number, $.Number])
//.     (x => y => x + y);
//. ```
//.
//. `[$.Number, $.Number, $.Number]` specifies that `add` takes two arguments
//. of type `Number`, one at a time, and returns a value of type `Number`.
//.
//. Applying `add` to two arguments, one at a time, gives the expected result:
//.
//. ```javascript
//. add (2) (2);
//. // => 4
//. ```
//.
//. Applying `add` to multiple arguments at once results in an exception being
//. thrown:
//.
//. ```javascript
//. add (2, 2, 2);
//. // ! TypeError: ‘add’ applied to the wrong number of arguments
//. //
//. //   add :: Number -> Number -> Number
//. //          ^^^^^^
//. //            1
//. //
//. //   Expected one argument but received three arguments:
//. //
//. //     - 2
//. //     - 2
//. //     - 2
//. ```
//.
//. Applying `add` to one argument produces a function awaiting the remaining
//. argument. This is known as partial application. Partial application allows
//. more specific functions to be defined in terms of more general ones:
//.
//. ```javascript
//. //    inc :: Number -> Number
//. const inc = add (1);
//.
//. inc (7);
//. // => 8
//. ```
//.
//. JavaScript's implicit type coercion often obfuscates the source of type
//. errors. Consider the following function:
//.
//. ```javascript
//. //    _add :: Number -> Number -> Number
//. const _add = x => y => x + y;
//. ```
//.
//. The type signature indicates that `_add` takes arguments of type `Number`,
//. but this is not enforced. This allows type errors to be silently ignored:
//.
//. ```javascript
//. _add ('2') ('2');
//. // => '22'
//. ```
//.
//. `add`, on the other hand, throws if applied to arguments of the wrong
//. types:
//.
//. ```javascript
//. add ('2') ('2');
//. // ! TypeError: Invalid value
//. //
//. //   add :: Number -> Number -> Number
//. //          ^^^^^^
//. //            1
//. //
//. //   1)  "2" :: String
//. //
//. //   The value at position 1 is not a member of ‘Number’.
//. ```
//.
//. Type checking is performed as arguments are provided (rather than once all
//. arguments have been provided), so type errors are reported early:
//.
//. ```javascript
//. add ('X');
//. // ! TypeError: Invalid value
//. //
//. //   add :: Number -> Number -> Number
//. //          ^^^^^^
//. //            1
//. //
//. //   1)  "X" :: String
//. //
//. //   The value at position 1 is not a member of ‘Number’.
//. ```

(function(f) {

  'use strict';

  /* istanbul ignore else */
  if ( true && typeof module.exports === 'object') {
    module.exports = f (__webpack_require__ (/*! sanctuary-either */ "./node_modules/sanctuary-either/index.js"),
                        __webpack_require__ (/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"),
                        __webpack_require__ (/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"),
                        __webpack_require__ (/*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-identifiers/index.js"));
  } else if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! sanctuary-either */ "./node_modules/sanctuary-either/index.js"),
             __webpack_require__(/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"),
             __webpack_require__(/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"),
             __webpack_require__(/*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-identifiers/index.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    self.sanctuaryDef = f (self.sanctuaryEither,
                           self.sanctuaryShow,
                           self.sanctuaryTypeClasses,
                           self.sanctuaryTypeIdentifiers);
  }

} (function(Either, show, Z, type) {

  'use strict';

  var MAX_SAFE_INTEGER = Math.pow (2, 53) - 1;
  var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;

  var slice             = Array.prototype.slice;
  var hasOwnProperty    = Object.prototype.hasOwnProperty;
  var toString          = Object.prototype.toString;

  var inspect = (function() {
    /* istanbul ignore else */
    if ( true && typeof module.exports === 'object') {
      var util = __webpack_require__ (/*! util */ "./node_modules/util/util.js");
      /* istanbul ignore else */
      if (typeof util.inspect.custom === 'symbol') return util.inspect.custom;
    }
    return 'inspect';
  } ());

  //  Left :: a -> Either a b
  var Left = Either.Left;

  //  Right :: b -> Either a b
  var Right = Either.Right;

  //  K :: a -> b -> a
  function K(x) { return function(y) { return x; }; }

  //  W :: (a -> a -> b) -> a -> b
  function W(f) { return function(x) { return f (x) (x); }; }

  //  always0 :: a -> () -> a
  function always0(x) { return function() { return x; }; }

  //  always2 :: a -> (b, c) -> a
  function always2(x) { return function(y, z) { return x; }; }

  //  compose :: (b -> c, a -> b) -> (a -> c)
  function compose(f, g) {
    return function(x) {
      return f (g (x));
    };
  }

  //  id :: a -> a
  function id(x) { return x; }

  //  init :: Array a -> Array a
  function init(xs) { return xs.slice (0, -1); }

  //  isEmpty :: Array a -> Boolean
  function isEmpty(xs) { return xs.length === 0; }

  //  isPrefix :: Array a -> Array a -> Boolean
  function isPrefix(candidate) {
    return function(xs) {
      if (candidate.length > xs.length) return false;
      for (var idx = 0; idx < candidate.length; idx += 1) {
        if (candidate[idx] !== xs[idx]) return false;
      }
      return true;
    };
  }

  //  joinWith :: (String, Array String) -> String
  function joinWith(separator, ss) {
    return ss.join (separator);
  }

  //  last :: Array a -> a
  function last(xs) { return xs[xs.length - 1]; }

  //  memberOf :: Array a -> a -> Boolean
  function memberOf(xs) {
    return function(y) {
      return xs.some (function(x) { return Z.equals (x, y); });
    };
  }

  //  or :: (Array a, Array a) -> Array a
  function or(xs, ys) { return isEmpty (xs) ? ys : xs; }

  //  strRepeat :: (String, Integer) -> String
  function strRepeat(s, times) {
    return joinWith (s, Array (times + 1));
  }

  //  r :: Char -> String -> String
  function r(c) {
    return function(s) {
      return strRepeat (c, s.length);
    };
  }

  //  _ :: String -> String
  var _ = r (' ');

  //  sortedKeys :: Object -> Array String
  function sortedKeys(o) {
    return (Object.keys (o)).sort ();
  }

  //  stripOutermostParens :: String -> String
  function stripOutermostParens(s) {
    return s.slice ('('.length, -')'.length);
  }

  //  toMarkdownList :: (String, String, a -> String, Array a) -> String
  function toMarkdownList(empty, s, f, xs) {
    return isEmpty (xs) ?
      empty :
      Z.reduce (function(s, x) { return s + '  - ' + f (x) + '\n'; }, s, xs);
  }

  //  trimTrailingSpaces :: String -> String
  function trimTrailingSpaces(s) {
    return s.replace (/[ ]+$/gm, '');
  }

  //  unless :: (Boolean, (a -> a), a) -> a
  function unless(bool, f, x) {
    return bool ? x : f (x);
  }

  //  when :: (Boolean, (a -> a), a) -> a
  function when(bool, f, x) {
    return bool ? f (x) : x;
  }

  //  wrap :: String -> String -> String -> String
  function wrap(prefix) {
    return function(suffix) {
      return function(s) {
        return prefix + s + suffix;
      };
    };
  }

  //  parenthesize :: String -> String
  var parenthesize = wrap ('(') (')');

  //  q :: String -> String
  var q = wrap ('\u2018') ('\u2019');

  //  stripNamespace :: String -> String
  function stripNamespace(s) { return s.slice (s.indexOf ('/') + 1); }

  //  _Type :: ... -> Type
  function _Type(
    type,       // :: String
    name,       // :: String
    url,        // :: String
    format,     // :: (String -> String, String -> String -> String) -> String
    test,       // :: Any -> Boolean
    keys,       // :: Array String
    types       // :: StrMap { extractor :: a -> Array b, type :: Type }
  ) {
    this._test = test;
    this.format = format;
    this.keys = keys;
    this.name = name;
    this.type = type;
    this.types = types;
    this.url = url;
  }

  _Type['@@type'] = 'sanctuary-def/Type';

  //  Type#fantasy-land/equals :: Type ~> Type -> Boolean
  _Type.prototype['fantasy-land/equals'] = function(other) {
    return (
      Z.equals (this.type, other.type) &&
      Z.equals (this.name, other.name) &&
      Z.equals (this.url, other.url) &&
      Z.equals (this.keys, other.keys) &&
      this.keys.every (function(k) {
        return Z.equals (this.types[k].type, other.types[k].type);
      }, this)
    );
  };

  _Type.prototype.validate = function(x) {
    if (!(this._test (x))) return Left ({value: x, propPath: []});
    for (var idx = 0; idx < this.keys.length; idx += 1) {
      var k = this.keys[idx];
      var t = this.types[k];
      for (var idx2 = 0, ys = t.extractor (x); idx2 < ys.length; idx2 += 1) {
        var result = t.type.validate (ys[idx2]);
        if (result.isLeft) {
          var value = result.value.value;
          var propPath = Z.concat ([k], result.value.propPath);
          return Left ({value: value, propPath: propPath});
        }
      }
    }
    return Right (x);
  };

  _Type.prototype['@@show'] = function() {
    return this.format (id, K (id));
  };

  var BINARY        = 'BINARY';
  var FUNCTION      = 'FUNCTION';
  var INCONSISTENT  = 'INCONSISTENT';
  var NO_ARGUMENTS  = 'NO_ARGUMENTS';
  var NULLARY       = 'NULLARY';
  var RECORD        = 'RECORD';
  var UNARY         = 'UNARY';
  var UNKNOWN       = 'UNKNOWN';
  var VARIABLE      = 'VARIABLE';

  //  Inconsistent :: Type
  var Inconsistent =
  new _Type (INCONSISTENT, '', '', always2 ('???'), K (false), [], {});

  //  NoArguments :: Type
  var NoArguments =
  new _Type (NO_ARGUMENTS, '', '', always2 ('()'), K (true), [], {});

  //  typeEq :: String -> a -> Boolean
  function typeEq(name) {
    return function(x) {
      return type (x) === name;
    };
  }

  //  typeofEq :: String -> a -> Boolean
  function typeofEq(typeof_) {
    return function(x) {
      // eslint-disable-next-line valid-typeof
      return typeof x === typeof_;
    };
  }

  //  functionUrl :: String -> String
  function functionUrl(name) {
    var version = '0.18.1';  // updated programmatically
    return 'https://github.com/sanctuary-js/sanctuary-def/tree/v' + version +
           '#' + stripNamespace (name);
  }

  //  NullaryTypeWithUrl :: (String, Any -> Boolean) -> Type
  function NullaryTypeWithUrl(name, test) {
    return NullaryType (name) (functionUrl (name)) (test);
  }

  //  EnumTypeWithUrl :: (String, Array Any) -> Type
  function EnumTypeWithUrl(name, members) {
    return EnumType (name) (functionUrl (name)) (members);
  }

  //  UnaryTypeWithUrl ::
  //    (String, Any -> Boolean, t a -> Array a) -> (Type -> Type)
  function UnaryTypeWithUrl(name, test, _1) {
    return UnaryType (name) (functionUrl (name)) (test) (_1);
  }

  //  BinaryTypeWithUrl ::
  //    (String, Any -> Boolean, t a b -> Array a, t a b -> Array b) ->
  //      ((Type, Type) -> Type)
  function BinaryTypeWithUrl(name, test, _1, _2) {
    return BinaryType (name) (functionUrl (name)) (test) (_1) (_2);
  }

  //. ### Types
  //.
  //. Conceptually, a type is a set of values. One can think of a value of
  //. type `Type` as a function of type `Any -> Boolean` which tests values
  //. for membership in the set (though this is an oversimplification).

  //# Any :: Type
  //.
  //. Type comprising every JavaScript value.
  var Any = NullaryTypeWithUrl ('sanctuary-def/Any', K (true));

  //# AnyFunction :: Type
  //.
  //. Type comprising every Function value.
  var AnyFunction = NullaryTypeWithUrl ('Function', typeofEq ('function'));

  //# Arguments :: Type
  //.
  //. Type comprising every [`arguments`][arguments] object.
  var Arguments = NullaryTypeWithUrl ('Arguments', typeEq ('Arguments'));

  //# Array :: Type -> Type
  //.
  //. Constructor for homogeneous Array types.
  var Array_ = UnaryTypeWithUrl ('Array', typeEq ('Array'), id);

  //# Array0 :: Type
  //.
  //. Type whose sole member is `[]`.
  var Array0 = NullaryTypeWithUrl (
    'sanctuary-def/Array0',
    function(x) { return typeEq ('Array') (x) && x.length === 0; }
  );

  //# Array1 :: Type -> Type
  //.
  //. Constructor for singleton Array types.
  var Array1 = UnaryTypeWithUrl (
    'sanctuary-def/Array1',
    function(x) { return typeEq ('Array') (x) && x.length === 1; },
    id
  );

  //# Array2 :: Type -> Type -> Type
  //.
  //. Constructor for heterogeneous Array types of length 2. `['foo', true]` is
  //. a member of `Array2 String Boolean`.
  var Array2 = BinaryTypeWithUrl (
    'sanctuary-def/Array2',
    function(x) { return typeEq ('Array') (x) && x.length === 2; },
    function(array2) { return [array2[0]]; },
    function(array2) { return [array2[1]]; }
  );

  //# Boolean :: Type
  //.
  //. Type comprising `true` and `false`.
  var Boolean_ = NullaryTypeWithUrl ('Boolean', typeofEq ('boolean'));

  //# Date :: Type
  //.
  //. Type comprising every Date value.
  var Date_ = NullaryTypeWithUrl ('Date', typeEq ('Date'));

  //# Error :: Type
  //.
  //. Type comprising every Error value, including values of more specific
  //. constructors such as [`SyntaxError`][] and [`TypeError`][].
  var Error_ = NullaryTypeWithUrl ('Error', typeEq ('Error'));

  //# FiniteNumber :: Type
  //.
  //. Type comprising every [`ValidNumber`][] value except `Infinity` and
  //. `-Infinity`.
  var FiniteNumber = NullaryTypeWithUrl (
    'sanctuary-def/FiniteNumber',
    function(x) { return ValidNumber._test (x) && isFinite (x); }
  );

  //  augmentThunk :: NonEmpty (Array Type) -> NonEmpty (Array Type)
  function augmentThunk(types) {
    return types.length === 1 ? Z.concat ([NoArguments], types) : types;
  }

  //# Function :: NonEmpty (Array Type) -> Type
  //.
  //. Constructor for Function types.
  //.
  //. Examples:
  //.
  //.   - `$.Function ([$.Date, $.String])` represents the `Date -> String`
  //.     type; and
  //.   - `$.Function ([a, b, a])` represents the `(a, b) -> a` type.
  function Function_(_types) {
    var types = augmentThunk (_types);

    function format(outer, inner) {
      var xs = types.map (function(t, idx) {
        return unless (t.type === RECORD || isEmpty (t.keys),
                       stripOutermostParens,
                       inner ('$' + show (idx + 1)) (show (t)));
      });
      var parenthesize = wrap (outer ('(')) (outer (')'));
      return parenthesize (unless (types.length === 2,
                                   parenthesize,
                                   joinWith (outer (', '), init (xs))) +
                           outer (' -> ') +
                           last (xs));
    }

    var test = AnyFunction._test;

    var $keys = [];
    var $types = {};
    types.forEach (function(t, idx) {
      var k = '$' + show (idx + 1);
      $keys.push (k);
      $types[k] = {extractor: K ([]), type: t};
    });

    return new _Type (FUNCTION, '', '', format, test, $keys, $types);
  }

  //# GlobalRegExp :: Type
  //.
  //. Type comprising every [`RegExp`][] value whose `global` flag is `true`.
  //.
  //. See also [`NonGlobalRegExp`][].
  var GlobalRegExp = NullaryTypeWithUrl (
    'sanctuary-def/GlobalRegExp',
    function(x) { return RegExp_._test (x) && x.global; }
  );

  //# HtmlElement :: Type
  //.
  //. Type comprising every [HTML element][].
  var HtmlElement = NullaryTypeWithUrl (
    'sanctuary-def/HtmlElement',
    function(x) {
      return /^\[object HTML.+Element\]$/.test (toString.call (x));
    }
  );

  //# Integer :: Type
  //.
  //. Type comprising every integer in the range
  //. [[`Number.MIN_SAFE_INTEGER`][min] .. [`Number.MAX_SAFE_INTEGER`][max]].
  var Integer = NullaryTypeWithUrl (
    'sanctuary-def/Integer',
    function(x) {
      return ValidNumber._test (x) &&
             Math.floor (x) === x &&
             x >= MIN_SAFE_INTEGER &&
             x <= MAX_SAFE_INTEGER;
    }
  );

  //# NegativeFiniteNumber :: Type
  //.
  //. Type comprising every [`FiniteNumber`][] value less than zero.
  var NegativeFiniteNumber = NullaryTypeWithUrl (
    'sanctuary-def/NegativeFiniteNumber',
    function(x) { return FiniteNumber._test (x) && x < 0; }
  );

  //# NegativeInteger :: Type
  //.
  //. Type comprising every [`Integer`][] value less than zero.
  var NegativeInteger = NullaryTypeWithUrl (
    'sanctuary-def/NegativeInteger',
    function(x) { return Integer._test (x) && x < 0; }
  );

  //# NegativeNumber :: Type
  //.
  //. Type comprising every [`Number`][] value less than zero.
  var NegativeNumber = NullaryTypeWithUrl (
    'sanctuary-def/NegativeNumber',
    function(x) { return Number_._test (x) && x < 0; }
  );

  //# NonEmpty :: Type -> Type
  //.
  //. Constructor for non-empty types. `$.NonEmpty ($.String)`, for example, is
  //. the type comprising every [`String`][] value except `''`.
  //.
  //. The given type must satisfy the [Monoid][] and [Setoid][] specifications.
  var NonEmpty = UnaryTypeWithUrl (
    'sanctuary-def/NonEmpty',
    function(x) {
      return Z.Monoid.test (x) &&
             Z.Setoid.test (x) &&
             !(Z.equals (x, Z.empty (x.constructor)));
    },
    function(monoid) { return [monoid]; }
  );

  //# NonGlobalRegExp :: Type
  //.
  //. Type comprising every [`RegExp`][] value whose `global` flag is `false`.
  //.
  //. See also [`GlobalRegExp`][].
  var NonGlobalRegExp = NullaryTypeWithUrl (
    'sanctuary-def/NonGlobalRegExp',
    function(x) { return RegExp_._test (x) && !x.global; }
  );

  //# NonNegativeInteger :: Type
  //.
  //. Type comprising every non-negative [`Integer`][] value (including `-0`).
  //. Also known as the set of natural numbers under ISO 80000-2:2009.
  var NonNegativeInteger = NullaryTypeWithUrl (
    'sanctuary-def/NonNegativeInteger',
    function(x) { return Integer._test (x) && x >= 0; }
  );

  //# NonZeroFiniteNumber :: Type
  //.
  //. Type comprising every [`FiniteNumber`][] value except `0` and `-0`.
  var NonZeroFiniteNumber = NullaryTypeWithUrl (
    'sanctuary-def/NonZeroFiniteNumber',
    function(x) { return FiniteNumber._test (x) && x !== 0; }
  );

  //# NonZeroInteger :: Type
  //.
  //. Type comprising every [`Integer`][] value except `0` and `-0`.
  var NonZeroInteger = NullaryTypeWithUrl (
    'sanctuary-def/NonZeroInteger',
    function(x) { return Integer._test (x) && x !== 0; }
  );

  //# NonZeroValidNumber :: Type
  //.
  //. Type comprising every [`ValidNumber`][] value except `0` and `-0`.
  var NonZeroValidNumber = NullaryTypeWithUrl (
    'sanctuary-def/NonZeroValidNumber',
    function(x) { return ValidNumber._test (x) && x !== 0; }
  );

  //# Null :: Type
  //.
  //. Type whose sole member is `null`.
  var Null = NullaryTypeWithUrl ('Null', typeEq ('Null'));

  //# Nullable :: Type -> Type
  //.
  //. Constructor for types which include `null` as a member.
  var Nullable = UnaryTypeWithUrl (
    'sanctuary-def/Nullable',
    K (true),
    function(nullable) {
      // eslint-disable-next-line eqeqeq
      return nullable === null ? [] : [nullable];
    }
  );

  //# Number :: Type
  //.
  //. Type comprising every primitive Number value (including `NaN`).
  var Number_ = NullaryTypeWithUrl ('Number', typeofEq ('number'));

  //# Object :: Type
  //.
  //. Type comprising every "plain" Object value. Specifically, values
  //. created via:
  //.
  //.   - object literal syntax;
  //.   - [`Object.create`][]; or
  //.   - the `new` operator in conjunction with `Object` or a custom
  //.     constructor function.
  var Object_ = NullaryTypeWithUrl ('Object', typeEq ('Object'));

  //# PositiveFiniteNumber :: Type
  //.
  //. Type comprising every [`FiniteNumber`][] value greater than zero.
  var PositiveFiniteNumber = NullaryTypeWithUrl (
    'sanctuary-def/PositiveFiniteNumber',
    function(x) { return FiniteNumber._test (x) && x > 0; }
  );

  //# PositiveInteger :: Type
  //.
  //. Type comprising every [`Integer`][] value greater than zero.
  var PositiveInteger = NullaryTypeWithUrl (
    'sanctuary-def/PositiveInteger',
    function(x) { return Integer._test (x) && x > 0; }
  );

  //# PositiveNumber :: Type
  //.
  //. Type comprising every [`Number`][] value greater than zero.
  var PositiveNumber = NullaryTypeWithUrl (
    'sanctuary-def/PositiveNumber',
    function(x) { return Number_._test (x) && x > 0; }
  );

  //# RegExp :: Type
  //.
  //. Type comprising every RegExp value.
  var RegExp_ = NullaryTypeWithUrl ('RegExp', typeEq ('RegExp'));

  //# RegexFlags :: Type
  //.
  //. Type comprising the canonical RegExp flags:
  //.
  //.   - `''`
  //.   - `'g'`
  //.   - `'i'`
  //.   - `'m'`
  //.   - `'gi'`
  //.   - `'gm'`
  //.   - `'im'`
  //.   - `'gim'`
  var RegexFlags = EnumTypeWithUrl (
    'sanctuary-def/RegexFlags',
    ['', 'g', 'i', 'm', 'gi', 'gm', 'im', 'gim']
  );

  //# StrMap :: Type -> Type
  //.
  //. Constructor for homogeneous Object types.
  //.
  //. `{foo: 1, bar: 2, baz: 3}`, for example, is a member of `StrMap Number`;
  //. `{foo: 1, bar: 2, baz: 'XXX'}` is not.
  var StrMap = UnaryTypeWithUrl (
    'sanctuary-def/StrMap',
    Object_._test,
    function(strMap) {
      return Z.reduce (function(xs, x) { xs.push (x); return xs; },
                       [],
                       strMap);
    }
  );

  //# String :: Type
  //.
  //. Type comprising every primitive String value.
  var String_ = NullaryTypeWithUrl ('String', typeofEq ('string'));

  //# Symbol :: Type
  //.
  //. Type comprising every Symbol value.
  var Symbol_ = NullaryTypeWithUrl ('Symbol', typeofEq ('symbol'));

  //# Type :: Type
  //.
  //. Type comprising every `Type` value.
  var Type = NullaryTypeWithUrl ('Type', typeEq ('sanctuary-def/Type'));

  //# TypeClass :: Type
  //.
  //. Type comprising every [`TypeClass`][] value.
  var TypeClass = NullaryTypeWithUrl (
    'TypeClass',
    typeEq ('sanctuary-type-classes/TypeClass')
  );

  //# Undefined :: Type
  //.
  //. Type whose sole member is `undefined`.
  var Undefined = NullaryTypeWithUrl ('Undefined', typeEq ('Undefined'));

  //# Unknown :: Type
  //.
  //. Type used to represent missing type information. The type of `[]`,
  //. for example, is `Array ???`.
  //.
  //. May be used with type constructors when defining environments. Given a
  //. type constructor `List :: Type -> Type`, one could use `List ($.Unknown)`
  //. to include an infinite number of types in an environment:
  //.
  //.   - `List Number`
  //.   - `List String`
  //.   - `List (List Number)`
  //.   - `List (List String)`
  //.   - `List (List (List Number))`
  //.   - `List (List (List String))`
  //.   - `...`
  var Unknown =
  new _Type (UNKNOWN, '', '', always2 ('Unknown'), K (true), [], {});

  //# ValidDate :: Type
  //.
  //. Type comprising every [`Date`][] value except `new Date (NaN)`.
  var ValidDate = NullaryTypeWithUrl (
    'sanctuary-def/ValidDate',
    function(x) { return Date_._test (x) && !isNaN (x.valueOf ()); }
  );

  //# ValidNumber :: Type
  //.
  //. Type comprising every [`Number`][] value except `NaN`.
  var ValidNumber = NullaryTypeWithUrl (
    'sanctuary-def/ValidNumber',
    function(x) { return Number_._test (x) && !isNaN (x); }
  );

  //# env :: Array Type
  //.
  //. An array of [types][]:
  //.
  //.   - <code>[AnyFunction](#AnyFunction)</code>
  //.   - <code>[Arguments](#Arguments)</code>
  //.   - <code>[Array](#Array) ([Unknown](#Unknown))</code>
  //.   - <code>[Boolean](#Boolean)</code>
  //.   - <code>[Date](#Date)</code>
  //.   - <code>[Error](#Error)</code>
  //.   - <code>[HtmlElement](#HtmlElement)</code>
  //.   - <code>[Null](#Null)</code>
  //.   - <code>[Number](#Number)</code>
  //.   - <code>[Object](#Object)</code>
  //.   - <code>[RegExp](#RegExp)</code>
  //.   - <code>[StrMap](#StrMap) ([Unknown](#Unknown))</code>
  //.   - <code>[String](#String)</code>
  //.   - <code>[Symbol](#Symbol)</code>
  //.   - <code>[Undefined](#Undefined)</code>
  var env = [
    AnyFunction,
    Arguments,
    Array_ (Unknown),
    Boolean_,
    Date_,
    Error_,
    HtmlElement,
    Null,
    Number_,
    Object_,
    RegExp_,
    StrMap (Unknown),
    String_,
    Symbol_,
    Undefined
  ];

  //  Unchecked :: String -> Type
  function Unchecked(s) { return NullaryType (s) ('') (K (true)); }

  //  production :: Boolean
  var production =
    typeof process !== 'undefined' &&
    /* global process:false */
    process != null &&
    process.env != null &&
    "development" === 'production';

  var def = _create ({checkTypes: !production, env: env});

  //  numbers :: Array String
  var numbers = [
    'zero',
    'one',
    'two',
    'three',
    'four',
    'five',
    'six',
    'seven',
    'eight',
    'nine'
  ];

  //  numArgs :: Integer -> String
  function numArgs(n) {
    return (n < numbers.length ? numbers[n] : show (n)) + ' ' +
           (n === 1 ? 'argument' : 'arguments');
  }

  //  expandUnknown :: ... -> Array Type
  function expandUnknown(
    env,            // :: Array Type
    seen,           // :: Array Object
    value,          // :: Any
    r               // :: { extractor :: a -> Array b, type :: Type }
  ) {
    return r.type.type === UNKNOWN ?
      _determineActualTypes (env, seen, r.extractor (value)) :
      [r.type];
  }

  //  _determineActualTypes :: ... -> Array Type
  function _determineActualTypes(
    env,            // :: Array Type
    seen,           // :: Array Object
    values          // :: Array Any
  ) {
    function refine(types, value) {
      var seen$;
      if (typeof value === 'object' && value != null ||
          typeof value === 'function') {
        //  Abort if a circular reference is encountered; add the current
        //  object to the array of seen objects otherwise.
        if (seen.indexOf (value) >= 0) return [];
        seen$ = Z.concat (seen, [value]);
      } else {
        seen$ = seen;
      }
      return Z.chain (function(t) {
        return (
          t.name === 'sanctuary-def/Nullable' || (t.validate (value)).isLeft ?
            [] :
          t.type === UNARY ?
            Z.map (fromUnaryType (t),
                   expandUnknown (env, seen$, value, t.types.$1)) :
          t.type === BINARY ?
            xprod (t,
                   expandUnknown (env, seen$, value, t.types.$1),
                   expandUnknown (env, seen$, value, t.types.$2)) :
          // else
            [t]
        );
      }, types);
    }

    return isEmpty (values) ?
      [Unknown] :
      or (Z.reduce (refine, env, values), [Inconsistent]);
  }

  //  isConsistent :: Type -> Boolean
  function isConsistent(t) {
    return t.type === UNARY   ? isConsistent (t.types.$1.type) :
           t.type === BINARY  ? isConsistent (t.types.$1.type) &&
                                isConsistent (t.types.$2.type) :
           /* else */           t.type !== INCONSISTENT;
  }

  //  determineActualTypesStrict :: (Array Type, Array Any) -> Array Type
  function determineActualTypesStrict(env, values) {
    return Z.filter (isConsistent,
                     _determineActualTypes (env, [], values));
  }

  //  determineActualTypesLoose :: (Array Type, Array Any) -> Array Type
  function determineActualTypesLoose(env, values) {
    return Z.reject (function(t) { return t.type === INCONSISTENT; },
                     _determineActualTypes (env, [], values));
  }

  //  TypeInfo = { name :: String
  //             , constraints :: StrMap (Array TypeClass)
  //             , types :: NonEmpty (Array Type) }
  //
  //  TypeVarMap = StrMap { types :: Array Type
  //                      , valuesByPath :: StrMap (Array Any) }
  //
  //  PropPath = Array (Number | String)

  //  updateTypeVarMap :: ... -> TypeVarMap
  function updateTypeVarMap(
    env,            // :: Array Type
    typeVarMap,     // :: TypeVarMap
    typeVar,        // :: Type
    index,          // :: Integer
    propPath,       // :: PropPath
    values          // :: Array Any
  ) {
    var $typeVarMap = {};
    for (var typeVarName in typeVarMap) {
      var entry = typeVarMap[typeVarName];
      var $entry = {types: entry.types.slice (), valuesByPath: {}};
      for (var k in entry.valuesByPath) {
        $entry.valuesByPath[k] = entry.valuesByPath[k].slice ();
      }
      $typeVarMap[typeVarName] = $entry;
    }
    if (!(hasOwnProperty.call ($typeVarMap, typeVar.name))) {
      $typeVarMap[typeVar.name] = {types: env.slice (), valuesByPath: {}};
    }

    var key = JSON.stringify (Z.concat ([index], propPath));
    if (!(hasOwnProperty.call ($typeVarMap[typeVar.name].valuesByPath, key))) {
      $typeVarMap[typeVar.name].valuesByPath[key] = [];
    }

    var isNullaryTypeVar = isEmpty (typeVar.keys);
    var isValid = test (env);

    function expandUnknownStrict(value, r) {
      return Z.filter (isConsistent, expandUnknown (env, [], value, r));
    }

    values.forEach (function(value) {
      $typeVarMap[typeVar.name].valuesByPath[key].push (value);
      $typeVarMap[typeVar.name].types = Z.chain (function(t) {
        return (
          t.keys.length < typeVar.keys.length || !isValid (t) (value) ?
            [] :
          isNullaryTypeVar && t.type === UNARY ?
            Z.map (fromUnaryType (t),
                   expandUnknownStrict (value, t.types.$1)) :
          isNullaryTypeVar && t.type === BINARY ?
            xprod (t,
                   expandUnknownStrict (value, t.types.$1),
                   expandUnknownStrict (value, t.types.$2)) :
          // else
            [t]
        );
      }, $typeVarMap[typeVar.name].types);
    });

    return $typeVarMap;
  }

  //  underlineTypeVars :: (TypeInfo, StrMap (Array Any)) -> String
  function underlineTypeVars(typeInfo, valuesByPath) {
    //  Note: Sorting these keys lexicographically is not "correct", but it
    //  does the right thing for indexes less than 10.
    var paths = Z.map (JSON.parse, sortedKeys (valuesByPath));
    return underline (
      typeInfo,
      K (K (_)),
      function(index) {
        return function(f) {
          return function(t) {
            return function(propPath) {
              var indexedPropPath = Z.concat ([index], propPath);
              return function(s) {
                if (paths.some (isPrefix (indexedPropPath))) {
                  var key = JSON.stringify (indexedPropPath);
                  if (!(hasOwnProperty.call (valuesByPath, key))) return s;
                  if (!(isEmpty (valuesByPath[key]))) return f (s);
                }
                return _ (s);
              };
            };
          };
        };
      }
    );
  }

  //  satisfactoryTypes :: ... -> Either (() -> Error)
  //                                     { typeVarMap :: TypeVarMap
  //                                     , types :: Array Type }
  function satisfactoryTypes(
    env,            // :: Array Type
    typeInfo,       // :: TypeInfo
    typeVarMap,     // :: TypeVarMap
    expType,        // :: Type
    index,          // :: Integer
    propPath,       // :: PropPath
    values          // :: Array Any
  ) {
    var recur = satisfactoryTypes;

    for (var idx = 0; idx < values.length; idx += 1) {
      var result = expType.validate (values[idx]);
      if (result.isLeft) {
        return Left (function() {
          return invalidValue (env,
                               typeInfo,
                               index,
                               Z.concat (propPath, result.value.propPath),
                               result.value.value);
        });
      }
    }

    switch (expType.type) {

      case VARIABLE:
        var typeVarName = expType.name;
        var constraints = typeInfo.constraints;
        if (hasOwnProperty.call (constraints, typeVarName)) {
          var typeClasses = constraints[typeVarName];
          for (idx = 0; idx < values.length; idx += 1) {
            for (var idx2 = 0; idx2 < typeClasses.length; idx2 += 1) {
              if (!typeClasses[idx2].test (values[idx])) {
                return Left (function() {
                  return typeClassConstraintViolation (
                    env,
                    typeInfo,
                    typeClasses[idx2],
                    index,
                    propPath,
                    values[idx],
                    typeVarMap
                  );
                });
              }
            }
          }
        }

        var typeVarMap$ = updateTypeVarMap (env,
                                            typeVarMap,
                                            expType,
                                            index,
                                            propPath,
                                            values);

        var okTypes = typeVarMap$[typeVarName].types;
        return isEmpty (okTypes) ?
          Left (function() {
            return typeVarConstraintViolation (
              env,
              typeInfo,
              index,
              propPath,
              typeVarMap$[typeVarName].valuesByPath
            );
          }) :
          Z.reduce (function(e, t) {
            return Z.chain (function(r) {
              //  The `a` in `Functor f => f a` corresponds to the `a`
              //  in `Maybe a` but to the `b` in `Either a b`. A type
              //  variable's $1 will correspond to either $1 or $2 of
              //  the actual type depending on the actual type's arity.
              var offset = t.keys.length - expType.keys.length;
              return expType.keys.reduce (function(e, k, idx) {
                var extractor = t.types[t.keys[offset + idx]].extractor;
                return Z.reduce (function(e, x) {
                  return Z.chain (function(r) {
                    return recur (env,
                                  typeInfo,
                                  r.typeVarMap,
                                  expType.types[k].type,
                                  index,
                                  Z.concat (propPath, [k]),
                                  [x]);
                  }, e);
                }, e, Z.chain (extractor, values));
              }, Right (r));
            }, e);
          }, Right ({typeVarMap: typeVarMap$, types: okTypes}), okTypes);

      case UNARY:
        return Z.map (
          function(result) {
            return {
              typeVarMap: result.typeVarMap,
              types: Z.map (fromUnaryType (expType),
                            or (result.types, [expType.types.$1.type]))
            };
          },
          recur (env,
                 typeInfo,
                 typeVarMap,
                 expType.types.$1.type,
                 index,
                 Z.concat (propPath, ['$1']),
                 Z.chain (expType.types.$1.extractor, values))
        );

      case BINARY:
        return Z.chain (
          function(result) {
            var $1s = result.types;
            return Z.map (
              function(result) {
                var $2s = result.types;
                return {
                  typeVarMap: result.typeVarMap,
                  types: xprod (expType,
                                or ($1s, [expType.types.$1.type]),
                                or ($2s, [expType.types.$2.type]))
                };
              },
              recur (env,
                     typeInfo,
                     result.typeVarMap,
                     expType.types.$2.type,
                     index,
                     Z.concat (propPath, ['$2']),
                     Z.chain (expType.types.$2.extractor, values))
            );
          },
          recur (env,
                 typeInfo,
                 typeVarMap,
                 expType.types.$1.type,
                 index,
                 Z.concat (propPath, ['$1']),
                 Z.chain (expType.types.$1.extractor, values))
        );

      case RECORD:
        return Z.reduce (function(e, k) {
          return Z.chain (function(r) {
            return recur (env,
                          typeInfo,
                          r.typeVarMap,
                          expType.types[k].type,
                          index,
                          Z.concat (propPath, [k]),
                          Z.chain (expType.types[k].extractor, values));
          }, e);
        }, Right ({typeVarMap: typeVarMap, types: [expType]}), expType.keys);

      default:
        return Right ({typeVarMap: typeVarMap, types: [expType]});
    }
  }

  //# test :: Array Type -> Type -> a -> Boolean
  //.
  //. Takes an environment, a type, and any value. Returns `true` if the value
  //. is a member of the type; `false` otherwise.
  //.
  //. The environment is only significant if the type contains
  //. [type variables][].
  //.
  //. One may define a more restrictive type in terms of a more general one:
  //.
  //. ```javascript
  //. //    NonNegativeInteger :: Type
  //. const NonNegativeInteger = $.NullaryType
  //.   ('my-package/NonNegativeInteger')
  //.   ('http://example.com/my-package#NonNegativeInteger')
  //.   (x => $.test ([]) ($.Integer) (x) && x >= 0);
  //. ```
  //.
  //. Using types as predicates is useful in other contexts too. One could,
  //. for example, define a [record type][] for each endpoint of a REST API
  //. and validate the bodies of incoming POST requests against these types.
  function test(env) {
    return function(t) {
      return function(x) {
        var typeInfo = {name: 'name', constraints: {}, types: [t]};
        return (satisfactoryTypes (env, typeInfo, {}, t, 0, [], [x])).isRight;
      };
    };
  }

  //. ### Type constructors
  //.
  //. sanctuary-def provides several functions for defining types.

  //# NullaryType :: String -> String -> (Any -> Boolean) -> Type
  //.
  //. Type constructor for types with no type variables (such as [`Number`][]).
  //.
  //. To define a nullary type `t` one must provide:
  //.
  //.   - the name of `t` (exposed as `t.name`);
  //.
  //.   - the documentation URL of `t` (exposed as `t.url`); and
  //.
  //.   - a predicate which accepts any JavaScript value and returns `true` if
  //.     (and only if) the value is a member of `t`.
  //.
  //. For example:
  //.
  //. ```javascript
  //. //    Integer :: Type
  //. const Integer = $.NullaryType
  //.   ('my-package/Integer')
  //.   ('http://example.com/my-package#Integer')
  //.   (x => typeof x === 'number' &&
  //.         Math.floor (x) === x &&
  //.         x >= Number.MIN_SAFE_INTEGER &&
  //.         x <= Number.MAX_SAFE_INTEGER);
  //.
  //. //    NonZeroInteger :: Type
  //. const NonZeroInteger = $.NullaryType
  //.   ('my-package/NonZeroInteger')
  //.   ('http://example.com/my-package#NonZeroInteger')
  //.   (x => $.test ([]) (Integer) (x) && x !== 0);
  //.
  //. //    rem :: Integer -> NonZeroInteger -> Integer
  //. const rem =
  //. def ('rem')
  //.     ({})
  //.     ([Integer, NonZeroInteger, Integer])
  //.     (x => y => x % y);
  //.
  //. rem (42) (5);
  //. // => 2
  //.
  //. rem (0.5);
  //. // ! TypeError: Invalid value
  //. //
  //. //   rem :: Integer -> NonZeroInteger -> Integer
  //. //          ^^^^^^^
  //. //             1
  //. //
  //. //   1)  0.5 :: Number
  //. //
  //. //   The value at position 1 is not a member of ‘Integer’.
  //.
  //. rem (42) (0);
  //. // ! TypeError: Invalid value
  //. //
  //. //   rem :: Integer -> NonZeroInteger -> Integer
  //. //                     ^^^^^^^^^^^^^^
  //. //                           1
  //. //
  //. //   1)  0 :: Number
  //. //
  //. //   The value at position 1 is not a member of ‘NonZeroInteger’.
  //. ```
  function NullaryType(name) {
    function format(outer, inner) {
      return outer (stripNamespace (name));
    }
    return function(url) {
      return function(test) {
        return new _Type (NULLARY, name, url, format, test, [], {});
      };
    };
  }

  var CheckedNullaryType =
  def ('NullaryType')
      ({})
      ([String_, String_, Function_ ([Any, Boolean_]), Type])
      (NullaryType);

  //# UnaryType :: String -> String -> (Any -> Boolean) -> (t a -> Array a) -> Type -> Type
  //.
  //. Type constructor for types with one type variable (such as [`Array`][]).
  //.
  //. To define a unary type `t a` one must provide:
  //.
  //.   - the name of `t` (exposed as `t.name`);
  //.
  //.   - the documentation URL of `t` (exposed as `t.url`);
  //.
  //.   - a predicate which accepts any JavaScript value and returns `true`
  //.     if (and only if) the value is a member of `t x` for some type `x`;
  //.
  //.   - a function which takes any value of type `t a` and returns an array
  //.     of the values of type `a` contained in the `t` (exposed as
  //.     `t.types.$1.extractor`); and
  //.
  //.   - the type of `a` (exposed as `t.types.$1.type`).
  //.
  //. For example:
  //.
  //. ```javascript
  //. const show = require ('sanctuary-show');
  //. const type = require ('sanctuary-type-identifiers');
  //.
  //. //    maybeTypeIdent :: String
  //. const maybeTypeIdent = 'my-package/Maybe';
  //.
  //. //    Maybe :: Type -> Type
  //. const Maybe = $.UnaryType
  //.   (maybeTypeIdent)
  //.   ('http://example.com/my-package#Maybe')
  //.   (x => type (x) === maybeTypeIdent)
  //.   (maybe => maybe.isJust ? [maybe.value] : []);
  //.
  //. //    MaybeTypeRep :: TypeRep Maybe
  //. const MaybeTypeRep = {'@@type': maybeTypeIdent};
  //.
  //. //    Nothing :: Maybe a
  //. const Nothing = {
  //.   'constructor': MaybeTypeRep,
  //.   'isJust': false,
  //.   'isNothing': true,
  //.   '@@show': () => 'Nothing',
  //. };
  //.
  //. //    Just :: a -> Maybe a
  //. const Just = x => ({
  //.   'constructor': MaybeTypeRep,
  //.   'isJust': true,
  //.   'isNothing': false,
  //.   '@@show': () => `Just (${show (x)})`,
  //.   'value': x,
  //. });
  //.
  //. //    fromMaybe :: a -> Maybe a -> a
  //. const fromMaybe =
  //. def ('fromMaybe')
  //.     ({})
  //.     ([a, Maybe (a), a])
  //.     (x => m => m.isJust ? m.value : x);
  //.
  //. fromMaybe (0) (Just (42));
  //. // => 42
  //.
  //. fromMaybe (0) (Nothing);
  //. // => 0
  //.
  //. fromMaybe (0) (Just ('XXX'));
  //. // ! TypeError: Type-variable constraint violation
  //. //
  //. //   fromMaybe :: a -> Maybe a -> a
  //. //                ^          ^
  //. //                1          2
  //. //
  //. //   1)  0 :: Number
  //. //
  //. //   2)  "XXX" :: String
  //. //
  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.
  //. ```
  function UnaryType(name) {
    return function(url) {
      return function(test) {
        return function(_1) {
          return function($1) {
            function format(outer, inner) {
              return outer ('(' + stripNamespace (name) + ' ') +
                     inner ('$1') (show ($1)) +
                     outer (')');
            }
            var types = {$1: {extractor: _1, type: $1}};
            return new _Type (UNARY, name, url, format, test, ['$1'], types);
          };
        };
      };
    };
  }

  var CheckedUnaryType =
  def ('UnaryType')
      ({})
      ([String_,
        String_,
        Function_ ([Any, Boolean_]),
        Function_ ([Unchecked ('t a'), Array_ (Unchecked ('a'))]),
        AnyFunction])
      (function(name) {
         return function(url) {
           return function(test) {
             return compose (def (stripNamespace (name)) ({}) ([Type, Type]),
                             UnaryType (name) (url) (test));
           };
         };
       });

  //  fromUnaryType :: Type -> (Type -> Type)
  function fromUnaryType(t) {
    return UnaryType (t.name) (t.url) (t._test) (t.types.$1.extractor);
  }

  //# BinaryType :: String -> String -> (Any -> Boolean) -> (t a b -> Array a) -> (t a b -> Array b) -> Type -> Type -> Type
  //.
  //. Type constructor for types with two type variables (such as
  //. [`Array2`][]).
  //.
  //. To define a binary type `t a b` one must provide:
  //.
  //.   - the name of `t` (exposed as `t.name`);
  //.
  //.   - the documentation URL of `t` (exposed as `t.url`);
  //.
  //.   - a predicate which accepts any JavaScript value and returns `true`
  //.     if (and only if) the value is a member of `t x y` for some types
  //.     `x` and `y`;
  //.
  //.   - a function which takes any value of type `t a b` and returns an array
  //.     of the values of type `a` contained in the `t` (exposed as
  //.     `t.types.$1.extractor`);
  //.
  //.   - a function which takes any value of type `t a b` and returns an array
  //.     of the values of type `b` contained in the `t` (exposed as
  //.     `t.types.$2.extractor`);
  //.
  //.   - the type of `a` (exposed as `t.types.$1.type`); and
  //.
  //.   - the type of `b` (exposed as `t.types.$2.type`).
  //.
  //. For example:
  //.
  //. ```javascript
  //. const type = require ('sanctuary-type-identifiers');
  //.
  //. //    pairTypeIdent :: String
  //. const pairTypeIdent = 'my-package/Pair';
  //.
  //. //    $Pair :: Type -> Type -> Type
  //. const $Pair = $.BinaryType
  //.   (pairTypeIdent)
  //.   ('http://example.com/my-package#Pair')
  //.   (x => type (x) === pairTypeIdent)
  //.   (({fst}) => [fst])
  //.   (({snd}) => [snd]);
  //.
  //. //    PairTypeRep :: TypeRep Pair
  //. const PairTypeRep = {'@@type': pairTypeIdent};
  //.
  //. //    Pair :: a -> b -> Pair a b
  //. const Pair =
  //. def ('Pair')
  //.     ({})
  //.     ([a, b, $Pair (a) (b)])
  //.     (fst => snd => ({
  //.        'constructor': PairTypeRep,
  //.        'fst': fst,
  //.        'snd': snd,
  //.        '@@show': () => `Pair (${show (fst)}) (${show (snd)})`,
  //.      }));
  //.
  //. //    Rank :: Type
  //. const Rank = $.NullaryType
  //.   ('my-package/Rank')
  //.   ('http://example.com/my-package#Rank')
  //.   (x => typeof x === 'string' &&
  //.         /^(A|2|3|4|5|6|7|8|9|10|J|Q|K)$/.test (x));
  //.
  //. //    Suit :: Type
  //. const Suit = $.NullaryType
  //.   ('my-package/Suit')
  //.   ('http://example.com/my-package#Suit')
  //.   (x => typeof x === 'string' &&
  //.         /^[\u2660\u2663\u2665\u2666]$/.test (x));
  //.
  //. //    Card :: Type
  //. const Card = $Pair (Rank) (Suit);
  //.
  //. //    showCard :: Card -> String
  //. const showCard =
  //. def ('showCard')
  //.     ({})
  //.     ([Card, $.String])
  //.     (card => card.fst + card.snd);
  //.
  //. showCard (Pair ('A') ('♠'));
  //. // => 'A♠'
  //.
  //. showCard (Pair ('X') ('♠'));
  //. // ! TypeError: Invalid value
  //. //
  //. //   showCard :: Pair Rank Suit -> String
  //. //                    ^^^^
  //. //                     1
  //. //
  //. //   1)  "X" :: String
  //. //
  //. //   The value at position 1 is not a member of ‘Rank’.
  //. ```
  function BinaryType(name) {
    return function(url) {
      return function(test) {
        return function(_1) {
          return function(_2) {
            return function($1) {
              return function($2) {
                function format(outer, inner) {
                  return outer ('(' + stripNamespace (name) + ' ') +
                         inner ('$1') (show ($1)) +
                         outer (' ') +
                         inner ('$2') (show ($2)) +
                         outer (')');
                }
                return new _Type (BINARY,
                                  name,
                                  url,
                                  format,
                                  test,
                                  ['$1', '$2'],
                                  {$1: {extractor: _1, type: $1},
                                   $2: {extractor: _2, type: $2}});
              };
            };
          };
        };
      };
    };
  }

  var CheckedBinaryType =
  def ('BinaryType')
      ({})
      ([String_,
        String_,
        Function_ ([Any, Boolean_]),
        Function_ ([Unchecked ('t a b'), Array_ (Unchecked ('a'))]),
        Function_ ([Unchecked ('t a b'), Array_ (Unchecked ('b'))]),
        AnyFunction])
      (function(name) {
         return function(url) {
           return function(test) {
             return function(_1) {
               return function(_2) {
                 return def (stripNamespace (name))
                            ({})
                            ([Type, Type, Type])
                            (BinaryType (name) (url) (test) (_1) (_2));
               };
             };
           };
         };
       });

  //  xprod :: (Type, Array Type, Array Type) -> Array Type
  function xprod(t, $1s, $2s) {
    return Z.chain (
      function(specialize) { return Z.map (specialize, $2s); },
      Z.map (BinaryType (t.name)
                        (t.url)
                        (t._test)
                        (t.types.$1.extractor)
                        (t.types.$2.extractor),
             $1s)
    );
  }

  //# EnumType :: String -> String -> Array Any -> Type
  //.
  //. Type constructor for [enumerated types][] (such as [`RegexFlags`][]).
  //.
  //. To define an enumerated type `t` one must provide:
  //.
  //.   - the name of `t` (exposed as `t.name`);
  //.
  //.   - the documentation URL of `t` (exposed as `t.url`); and
  //.
  //.   - an array of distinct values.
  //.
  //. For example:
  //.
  //. ```javascript
  //. //    Denomination :: Type
  //. const Denomination = $.EnumType
  //.   ('my-package/Denomination')
  //.   ('http://example.com/my-package#Denomination')
  //.   ([10, 20, 50, 100, 200]);
  //. ```
  function EnumType(name) {
    return function(url) {
      return compose (NullaryType (name) (url), memberOf);
    };
  }

  var CheckedEnumType =
  def ('EnumType')
      ({})
      ([String_, String_, Array_ (Any), Type])
      (EnumType);

  //# RecordType :: StrMap Type -> Type
  //.
  //. `RecordType` is used to construct record types. The type definition
  //. specifies the name and type of each required field. A field is an
  //. enumerable property (either an own property or an inherited property).
  //.
  //. To define a record type one must provide:
  //.
  //.   - an object mapping field name to type.
  //.
  //. For example:
  //.
  //. ```javascript
  //. //    Point :: Type
  //. const Point = $.RecordType ({x: $.FiniteNumber, y: $.FiniteNumber});
  //.
  //. //    dist :: Point -> Point -> FiniteNumber
  //. const dist =
  //. def ('dist')
  //.     ({})
  //.     ([Point, Point, $.FiniteNumber])
  //.     (p => q => Math.sqrt (Math.pow (p.x - q.x, 2) +
  //.                           Math.pow (p.y - q.y, 2)));
  //.
  //. dist ({x: 0, y: 0}) ({x: 3, y: 4});
  //. // => 5
  //.
  //. dist ({x: 0, y: 0}) ({x: 3, y: 4, color: 'red'});
  //. // => 5
  //.
  //. dist ({x: 0, y: 0}) ({x: NaN, y: NaN});
  //. // ! TypeError: Invalid value
  //. //
  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber
  //. //                                                              ^^^^^^^^^^^^
  //. //                                                                   1
  //. //
  //. //   1)  NaN :: Number
  //. //
  //. //   The value at position 1 is not a member of ‘FiniteNumber’.
  //.
  //. dist (0);
  //. // ! TypeError: Invalid value
  //. //
  //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber
  //. //           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  //. //                              1
  //. //
  //. //   1)  0 :: Number
  //. //
  //. //   The value at position 1 is not a member of ‘{ x :: FiniteNumber, y :: FiniteNumber }’.
  //. ```
  function RecordType(fields) {
    var keys = sortedKeys (fields);

    function format(outer, inner) {
      if (isEmpty (keys)) return outer ('{}');
      var reprs = Z.map (function(k) {
        var t = fields[k];
        return outer (' ') +
               outer (/^(?!\d)[$\w]+$/.test (k) ? k : show (k)) +
               outer (' :: ') +
               unless (t.type === RECORD || isEmpty (t.keys),
                       stripOutermostParens,
                       inner (k) (show (t)));
      }, keys);
      return wrap (outer ('{')) (outer (' }')) (joinWith (outer (','), reprs));
    }

    function test(x) {
      var missing = {};
      keys.forEach (function(k) { missing[k] = k; });
      for (var k in x) delete missing[k];
      return isEmpty (Object.keys (missing));
    }

    var $types = {};
    keys.forEach (function(k) {
      $types[k] = {extractor: function(x) { return [x[k]]; }, type: fields[k]};
    });

    return new _Type (RECORD, '', '', format, test, keys, $types);
  }

  var CheckedRecordType =
  def ('RecordType') ({}) ([StrMap (Type), Type]) (RecordType);

  //# TypeVariable :: String -> Type
  //.
  //. Polymorphism is powerful. Not being able to define a function for
  //. all types would be very limiting indeed: one couldn't even define the
  //. identity function!
  //.
  //. Before defining a polymorphic function one must define one or more type
  //. variables:
  //.
  //. ```javascript
  //. const a = $.TypeVariable ('a');
  //. const b = $.TypeVariable ('b');
  //.
  //. //    id :: a -> a
  //. const id = def ('id') ({}) ([a, a]) (x => x);
  //.
  //. id (42);
  //. // => 42
  //.
  //. id (null);
  //. // => null
  //. ```
  //.
  //. The same type variable may be used in multiple positions, creating a
  //. constraint:
  //.
  //. ```javascript
  //. //    cmp :: a -> a -> Number
  //. const cmp =
  //. def ('cmp')
  //.     ({})
  //.     ([a, a, $.Number])
  //.     (x => y => x < y ? -1 : x > y ? 1 : 0);
  //.
  //. cmp (42) (42);
  //. // => 0
  //.
  //. cmp ('a') ('z');
  //. // => -1
  //.
  //. cmp ('z') ('a');
  //. // => 1
  //.
  //. cmp (0) ('1');
  //. // ! TypeError: Type-variable constraint violation
  //. //
  //. //   cmp :: a -> a -> Number
  //. //          ^    ^
  //. //          1    2
  //. //
  //. //   1)  0 :: Number
  //. //
  //. //   2)  "1" :: String
  //. //
  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.
  //. ```
  function TypeVariable(name) {
    return new _Type (VARIABLE, name, '', always2 (name), K (true), [], {});
  }

  var CheckedTypeVariable =
  def ('TypeVariable') ({}) ([String_, Type]) (TypeVariable);

  //# UnaryTypeVariable :: String -> Type -> Type
  //.
  //. Combines [`UnaryType`][] and [`TypeVariable`][].
  //.
  //. To define a unary type variable `t a` one must provide:
  //.
  //.   - a name (conventionally matching `^[a-z]$`); and
  //.
  //.   - the type of `a` (exposed as `t.types.$1.type`).
  //.
  //. Consider the type of a generalized `map`:
  //.
  //. ```haskell
  //. map :: Functor f => (a -> b) -> f a -> f b
  //. ```
  //.
  //. `f` is a unary type variable. With two (nullary) type variables, one
  //. unary type variable, and one [type class][] it's possible to define a
  //. fully polymorphic `map` function:
  //.
  //. ```javascript
  //. const $ = require ('sanctuary-def');
  //. const Z = require ('sanctuary-type-classes');
  //.
  //. const a = $.TypeVariable ('a');
  //. const b = $.TypeVariable ('b');
  //. const f = $.UnaryTypeVariable ('f');
  //.
  //. //    map :: Functor f => (a -> b) -> f a -> f b
  //. const map =
  //. def ('map')
  //.     ({f: [Z.Functor]})
  //.     ([$.Function ([a, b]), f (a), f (b)])
  //.     (f => functor => Z.map (f, functor));
  //. ```
  //.
  //. Whereas a regular type variable is fully resolved (`a` might become
  //. `Array (Array String)`, for example), a unary type variable defers to
  //. its type argument, which may itself be a type variable. The type argument
  //. corresponds to the type argument of a unary type or the *second* type
  //. argument of a binary type. The second type argument of `Map k v`, for
  //. example, is `v`. One could replace `Functor => f` with `Map k` or with
  //. `Map Integer`, but not with `Map`.
  //.
  //. This shallow inspection makes it possible to constrain a value's "outer"
  //. and "inner" types independently.
  function UnaryTypeVariable(name) {
    return function($1) {
      function format(outer, inner) {
        return outer ('(' + name + ' ') +
               inner ('$1') (show ($1)) +
               outer (')');
      }
      var types = {$1: {extractor: K ([]), type: $1}};
      return new _Type (VARIABLE, name, '', format, K (true), ['$1'], types);
    };
  }

  var CheckedUnaryTypeVariable =
  def ('UnaryTypeVariable')
      ({})
      ([String_, AnyFunction])
      (function(name) {
         return def (name) ({}) ([Type, Type]) (UnaryTypeVariable (name));
       });

  //# BinaryTypeVariable :: String -> Type -> Type -> Type
  //.
  //. Combines [`BinaryType`][] and [`TypeVariable`][].
  //.
  //. To define a binary type variable `t a b` one must provide:
  //.
  //.   - a name (conventionally matching `^[a-z]$`);
  //.
  //.   - the type of `a` (exposed as `t.types.$1.type`); and
  //.
  //.   - the type of `b` (exposed as `t.types.$2.type`).
  //.
  //. The more detailed explanation of [`UnaryTypeVariable`][] also applies to
  //. `BinaryTypeVariable`.
  function BinaryTypeVariable(name) {
    return function($1) {
      return function($2) {
        function format(outer, inner) {
          return outer ('(' + name + ' ') +
                 inner ('$1') (show ($1)) +
                 outer (' ') +
                 inner ('$2') (show ($2)) +
                 outer (')');
        }
        var keys = ['$1', '$2'];
        var types = {$1: {extractor: K ([]), type: $1},
                     $2: {extractor: K ([]), type: $2}};
        return new _Type (VARIABLE, name, '', format, K (true), keys, types);
      };
    };
  }

  var CheckedBinaryTypeVariable =
  def ('BinaryTypeVariable')
      ({})
      ([String_, AnyFunction])
      (function(name) {
         return def (name)
                    ({})
                    ([Type, Type, Type])
                    (BinaryTypeVariable (name));
       });

  //# Thunk :: Type -> Type
  //.
  //. `$.Thunk (T)` is shorthand for `$.Function ([T])`, the type comprising
  //. every nullary function (thunk) which returns a value of type `T`.
  var Thunk =
  def ('Thunk')
      ({})
      ([Type, Type])
      (function(t) { return Function_ ([t]); });

  //# Predicate :: Type -> Type
  //.
  //. `$.Predicate (T)` is shorthand for `$.Function ([T, $.Boolean])`, the
  //. type comprising every predicate function which takes a value of type `T`.
  var Predicate =
  def ('Predicate')
      ({})
      ([Type, Type])
      (function(t) { return Function_ ([t, Boolean_]); });

  //. ### Type classes
  //.
  //. `concatS`, defined earlier, is a function which concatenates two strings.
  //. This is overly restrictive, since other types support concatenation
  //. (Array, for example).
  //.
  //. One could use a type variable to define a polymorphic "concat" function:
  //.
  //. ```javascript
  //. //    _concat :: a -> a -> a
  //. const _concat =
  //. def ('_concat')
  //.     ({})
  //.     ([a, a, a])
  //.     (x => y => x.concat (y));
  //.
  //. _concat ('fizz') ('buzz');
  //. // => 'fizzbuzz'
  //.
  //. _concat ([1, 2]) ([3, 4]);
  //. // => [1, 2, 3, 4]
  //.
  //. _concat ([1, 2]) ('buzz');
  //. // ! TypeError: Type-variable constraint violation
  //. //
  //. //   _concat :: a -> a -> a
  //. //              ^    ^
  //. //              1    2
  //. //
  //. //   1)  [1, 2] :: Array Number
  //. //
  //. //   2)  "buzz" :: String
  //. //
  //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.
  //. ```
  //.
  //. The type of `_concat` is misleading: it suggests that it can operate on
  //. any two values of *any* one type. In fact there's an implicit constraint,
  //. since the type must support concatenation (in [mathematical][semigroup]
  //. terms, the type must have a [semigroup][FL:Semigroup]). Violating this
  //. implicit constraint results in a run-time error in the implementation:
  //.
  //. ```javascript
  //. _concat (null) (null);
  //. // ! TypeError: Cannot read property 'concat' of null
  //. ```
  //.
  //. The solution is to constrain `a` by first defining a [`TypeClass`][]
  //. value, then specifying the constraint in the definition of the "concat"
  //. function:
  //.
  //. ```javascript
  //. const Z = require ('sanctuary-type-classes');
  //.
  //. //    Semigroup :: TypeClass
  //. const Semigroup = Z.TypeClass (
  //.   'my-package/Semigroup',
  //.   'http://example.com/my-package#Semigroup',
  //.   [],
  //.   x => x != null && typeof x.concat === 'function'
  //. );
  //.
  //. //    concat :: Semigroup a => a -> a -> a
  //. const concat =
  //. def ('concat')
  //.     ({a: [Semigroup]})
  //.     ([a, a, a])
  //.     (x => y => x.concat (y));
  //.
  //. concat ([1, 2]) ([3, 4]);
  //. // => [1, 2, 3, 4]
  //.
  //. concat (null) (null);
  //. // ! TypeError: Type-class constraint violation
  //. //
  //. //   concat :: Semigroup a => a -> a -> a
  //. //             ^^^^^^^^^^^    ^
  //. //                            1
  //. //
  //. //   1)  null :: Null
  //. //
  //. //   ‘concat’ requires ‘a’ to satisfy the Semigroup type-class constraint; the value at position 1 does not.
  //. //
  //. //   See http://example.com/my-package#Semigroup for information about the my-package/Semigroup type class.
  //. ```
  //.
  //. Multiple constraints may be placed on a type variable by including
  //. multiple `TypeClass` values in the array (e.g. `{a: [Foo, Bar, Baz]}`).

  //  invalidArgumentsCount :: (TypeInfo, Integer, Integer, Array Any) -> Error
  //
  //  This function is used in `curry` when a function defined via `def`
  //  is applied to too many arguments.
  function invalidArgumentsCount(typeInfo, index, numArgsExpected, args) {
    return new TypeError (trimTrailingSpaces (
      q (typeInfo.name) + ' applied to the wrong number of arguments\n\n' +
      underline (
        typeInfo,
        K (K (_)),
        function(index_) {
          return function(f) {
            return K (K (index_ === index ? f : _));
          };
        }
      ) + '\n' +
      'Expected ' + numArgs (numArgsExpected) +
      ' but received ' + numArgs (args.length) +
      toMarkdownList ('.\n', ':\n\n', show, args)
    ));
  }

  //  constraintsRepr :: ... -> String
  function constraintsRepr(
    constraints,    // :: StrMap (Array TypeClass)
    outer,          // :: String -> String
    inner           // :: String -> TypeClass -> String -> String
  ) {
    var $reprs = [];
    (sortedKeys (constraints)).forEach (function(k) {
      var f = inner (k);
      constraints[k].forEach (function(typeClass) {
        $reprs.push (
          f (typeClass) (stripNamespace (typeClass.name) + ' ' + k)
        );
      });
    });
    return when ($reprs.length > 0,
                 function(s) { return s + outer (' => '); },
                 when ($reprs.length > 1,
                       wrap (outer ('(')) (outer (')')),
                       joinWith (outer (', '), $reprs)));
  }

  //  label :: String -> String -> String
  function label(label) {
    return function(s) {
      var delta = s.length - label.length;
      return strRepeat (' ', Math.floor (delta / 2)) + label +
             strRepeat (' ', Math.ceil (delta / 2));
    };
  }

  //  typeVarNames :: Type -> Array String
  function typeVarNames(t) {
    return Z.concat (
      t.type === VARIABLE ? [t.name] : [],
      Z.chain (function(k) { return typeVarNames (t.types[k].type); }, t.keys)
    );
  }

  //  showTypeWith :: TypeInfo -> Type -> String
  function showTypeWith(typeInfo) {
    var names = Z.chain (typeVarNames, typeInfo.types);
    return function(t) {
      var code = 'a'.charCodeAt (0);
      return unless (
        t.type === FUNCTION || t.type === RECORD || isEmpty (t.keys),
        stripOutermostParens,
        (show (t)).replace (/\bUnknown\b/g, function() {
          // eslint-disable-next-line no-plusplus
          do var name = String.fromCharCode (code++);
          while (names.indexOf (name) >= 0);
          return name;
        })
      );
    };
  }

  //  showTypeQuoted :: Type -> String
  function showTypeQuoted(t) {
    return q (unless (t.type === RECORD || isEmpty (t.keys),
                      stripOutermostParens,
                      show (t)));
  }

  //  showValuesAndTypes :: ... -> String
  function showValuesAndTypes(
    env,            // :: Array Type
    typeInfo,       // :: TypeInfo
    values,         // :: Array Any
    pos             // :: Integer
  ) {
    var showType = showTypeWith (typeInfo);
    return show (pos) + ')  ' + joinWith ('\n    ', Z.map (function(x) {
      var types = determineActualTypesLoose (env, [x]);
      return show (x) + ' :: ' + joinWith (', ', Z.map (showType, types));
    }, values));
  }

  //  typeSignature :: TypeInfo -> String
  function typeSignature(typeInfo) {
    var reprs = Z.map (showTypeWith (typeInfo), typeInfo.types);
    var arity = reprs.length - 1;
    return typeInfo.name + ' :: ' +
             constraintsRepr (typeInfo.constraints, id, K (K (id))) +
             when (arity === 0,
                   parenthesize,
                   joinWith (' -> ', init (reprs))) +
             ' -> ' + last (reprs);
  }

  //  _underline :: ... -> String
  function _underline(
    t,              // :: Type
    propPath,       // :: PropPath
    formatType3     // :: Type -> Array String -> String -> String
  ) {
    return unless (t.type === RECORD ||
                     isEmpty (t.keys) ||
                     t.type === FUNCTION && isEmpty (propPath) ||
                     !isEmpty (propPath),
                   stripOutermostParens,
                   formatType3 (t) (propPath) (t.format (_, function(k) {
                     return K (_underline (t.types[k].type,
                                           Z.concat (propPath, [k]),
                                           formatType3));
                   })));
  }

  //  underline :: ... -> String
  function underline(
    typeInfo,               // :: TypeInfo
    underlineConstraint,    // :: String -> TypeClass -> String -> String
    formatType5
    // :: Integer -> (String -> String) -> Type -> PropPath -> String -> String
  ) {
    var st = typeInfo.types.reduce (function(st, t, index) {
      var formatType4 = formatType5 (index);
      st.numbers.push (_underline (t, [], formatType4 (function(s) {
        return label (show (st.counter += 1)) (s);
      })));
      st.carets.push (_underline (t, [], W (function(type) {
        var repr = show (type);
        var parenthesized = repr.slice (0, 1) + repr.slice (-1) === '()';
        return formatType4 (function(s) {
          return parenthesized && repr !== '()' && s.length === repr.length ?
            _ ('(') + r ('^') (s.slice (1, -1)) + _ (')') :
            r ('^') (s);
        });
      })));
      return st;
    }, {carets: [], numbers: [], counter: 0});

    return typeSignature (typeInfo) + '\n' +
           _ (typeInfo.name + ' :: ') +
              constraintsRepr (typeInfo.constraints, _, underlineConstraint) +
              joinWith (_ (' -> '), st.carets) + '\n' +
           _ (typeInfo.name + ' :: ') +
              constraintsRepr (typeInfo.constraints, _, K (K (_))) +
              joinWith (_ (' -> '), st.numbers) + '\n';
  }

  //  resolvePropPath :: (Type, Array String) -> Type
  function resolvePropPath(t, propPath) {
    return Z.reduce (function(t, prop) { return t.types[prop].type; },
                     t,
                     propPath);
  }

  //  formatType6 ::
  //    PropPath -> Integer -> (String -> String) ->
  //      Type -> PropPath -> String -> String
  function formatType6(indexedPropPath) {
    return function(index_) {
      return function(f) {
        return function(t) {
          return function(propPath_) {
            var indexedPropPath_ = Z.concat ([index_], propPath_);
            var p = isPrefix (indexedPropPath_) (indexedPropPath);
            var q = isPrefix (indexedPropPath) (indexedPropPath_);
            return p && q ? f : p ? id : _;
          };
        };
      };
    };
  }

  //  see :: (String, { name :: String, url :: String? }) -> String
  function see(label, record) {
    return record.url == null || record.url === '' ?
           '' :
           '\nSee ' + record.url +
           ' for information about the ' + record.name + ' ' + label + '.\n';
  }

  //  typeClassConstraintViolation :: ... -> Error
  function typeClassConstraintViolation(
    env,            // :: Array Type
    typeInfo,       // :: TypeInfo
    typeClass,      // :: TypeClass
    index,          // :: Integer
    propPath,       // :: PropPath
    value,          // :: Any
    typeVarMap      // :: TypeVarMap
  ) {
    var expType = resolvePropPath (typeInfo.types[index], propPath);
    return new TypeError (trimTrailingSpaces (
      'Type-class constraint violation\n\n' +
      underline (typeInfo,
                 function(tvn) {
                   return function(tc) {
                     return (
                       tvn === expType.name && tc.name === typeClass.name ?
                         r ('^') :
                         _
                     );
                   };
                 },
                 formatType6 (Z.concat ([index], propPath))) +
      '\n' +
      showValuesAndTypes (env, typeInfo, [value], 1) + '\n\n' +
      q (typeInfo.name) + ' requires ' +
      q (expType.name) + ' to satisfy the ' +
      stripNamespace (typeClass.name) + ' type-class constraint; ' +
      'the value at position 1 does not.\n' +
      see ('type class', typeClass)
    ));
  }

  //  typeVarConstraintViolation :: ... -> Error
  function typeVarConstraintViolation(
    env,            // :: Array Type
    typeInfo,       // :: TypeInfo
    index,          // :: Integer
    propPath,       // :: PropPath
    valuesByPath    // :: StrMap (Array Any)
  ) {
    //  If we apply an ‘a -> a -> a -> a’ function to Left ('x'), Right (1),
    //  and Right (null) we'd like to avoid underlining the first argument
    //  position, since Left ('x') is compatible with the other ‘a’ values.
    var key = JSON.stringify (Z.concat ([index], propPath));
    var values = valuesByPath[key];

    //  Note: Sorting these keys lexicographically is not "correct", but it
    //  does the right thing for indexes less than 10.
    var keys = Z.filter (function(k) {
      var values_ = valuesByPath[k];
      return (
        //  Keep X, the position at which the violation was observed.
        k === key ||
        //  Keep positions whose values are incompatible with the values at X.
        isEmpty (determineActualTypesStrict (env, Z.concat (values, values_)))
      );
    }, sortedKeys (valuesByPath));

    var underlinedTypeVars =
    underlineTypeVars (typeInfo,
                       Z.reduce (function($valuesByPath, k) {
                         $valuesByPath[k] = valuesByPath[k];
                         return $valuesByPath;
                       }, {}, keys));

    return new TypeError (trimTrailingSpaces (
      values.length === 1 &&
      isEmpty (determineActualTypesLoose (env, values)) ?
        'Unrecognized value\n\n' +
        underlinedTypeVars + '\n' +
        '1)  ' + show (values[0]) + ' :: (no types)\n\n' +
        toMarkdownList (
          'The environment is empty! ' +
          'Polymorphic functions require a non-empty environment.\n',
          'The value at position 1 is not a member of any type in ' +
          'the environment.\n\n' +
          'The environment contains the following types:\n\n',
          showTypeWith (typeInfo),
          env
        ) :
      // else
        'Type-variable constraint violation\n\n' +
        underlinedTypeVars + '\n' +
        (Z.reduce (function(st, k) {
          var values = valuesByPath[k];
          return isEmpty (values) ? st : {
            idx: st.idx + 1,
            s: st.s +
               showValuesAndTypes (env, typeInfo, values, st.idx + 1) +
               '\n\n'
          };
        }, {idx: 0, s: ''}, keys)).s +
        'Since there is no type of which all the above values are ' +
        'members, the type-variable constraint has been violated.\n'
    ));
  }

  //  invalidValue :: ... -> Error
  function invalidValue(
    env,            // :: Array Type
    typeInfo,       // :: TypeInfo
    index,          // :: Integer
    propPath,       // :: PropPath
    value           // :: Any
  ) {
    var t = resolvePropPath (typeInfo.types[index], propPath);
    return new TypeError (trimTrailingSpaces (
      'Invalid value\n\n' +
      underline (typeInfo,
                 K (K (_)),
                 formatType6 (Z.concat ([index], propPath))) +
      '\n' +
      showValuesAndTypes (env, typeInfo, [value], 1) + '\n\n' +
      'The value at position 1 is not a member of ' +
      showTypeQuoted (t) + '.\n' +
      see ('type', t)
    ));
  }

  //  invalidArgumentsLength :: ... -> Error
  //
  //  This function is used in `wrapFunctionCond` to ensure that higher-order
  //  functions defined via `def` only ever apply a function argument to the
  //  correct number of arguments.
  function invalidArgumentsLength(
    typeInfo,           // :: TypeInfo
    index,              // :: Integer
    numArgsExpected,    // :: Integer
    args                // :: Array Any
  ) {
    return new TypeError (trimTrailingSpaces (
      q (typeInfo.name) +
      ' applied ' + showTypeQuoted (typeInfo.types[index]) +
      ' to the wrong number of arguments\n\n' +
      underline (
        typeInfo,
        K (K (_)),
        function(index_) {
          return function(f) {
            return function(t) {
              return function(propPath) {
                return function(s) {
                  return index_ === index ?
                    t.format (_, function(k) { return k === '$1' ? f : _; }) :
                    _ (s);
                };
              };
            };
          };
        }
      ) + '\n' +
      'Expected ' + numArgs (numArgsExpected) +
      ' but received ' + numArgs (args.length) +
      toMarkdownList ('.\n', ':\n\n', show, args)
    ));
  }

  //  assertRight :: Either (() -> Error) a -> a !
  function assertRight(either) {
    if (either.isLeft) throw either.value ();
    return either.value;
  }

  //  withTypeChecking :: ... -> Function
  function withTypeChecking(
    env,            // :: Array Type
    typeInfo,       // :: TypeInfo
    impl            // :: Function
  ) {
    var n = typeInfo.types.length - 1;

    //  wrapFunctionCond :: (TypeVarMap, Integer, a) -> a
    function wrapFunctionCond(_typeVarMap, index, value) {
      if (typeInfo.types[index].type !== FUNCTION) return value;

      var expType = typeInfo.types[index];

      //  checkValue :: (TypeVarMap, Integer, String, a) -> Either (() -> Error) TypeVarMap
      function checkValue(typeVarMap, index, k, x) {
        var propPath = [k];
        var t = expType.types[k].type;
        return (
          t.type === VARIABLE ?
            Z.chain (
              function(typeVarMap) {
                return isEmpty (typeVarMap[t.name].types) ?
                  Left (function() {
                    return typeVarConstraintViolation (
                      env,
                      typeInfo,
                      index,
                      propPath,
                      typeVarMap[t.name].valuesByPath
                    );
                  }) :
                  Right (typeVarMap);
              },
              Right (updateTypeVarMap (env,
                                       typeVarMap,
                                       t,
                                       index,
                                       propPath,
                                       [x]))
            ) :
          // else
            Z.map (
              function(r) { return r.typeVarMap; },
              satisfactoryTypes (env,
                                 typeInfo,
                                 typeVarMap,
                                 t,
                                 index,
                                 propPath,
                                 [x])
            )
        );
      }

      var isThunk = expType.types.$1.type.type === NO_ARGUMENTS;
      var numArgsExpected = isThunk ? 0 : expType.keys.length - 1;
      var typeVarMap = _typeVarMap;
      return function(x) {
        if (arguments.length !== numArgsExpected) {
          throw invalidArgumentsLength (typeInfo,
                                        index,
                                        numArgsExpected,
                                        slice.call (arguments));
        }

        var args = arguments;
        typeVarMap = assertRight (
          (init (expType.keys)).reduce (function(either, k, idx) {
            var arg = args[idx];
            return Z.chain (function(typeVarMap) {
              return checkValue (typeVarMap, index, k, arg);
            }, either);
          }, Right (typeVarMap))
        );

        var output = value.apply (this, arguments);
        var k = last (expType.keys);
        typeVarMap = assertRight (checkValue (typeVarMap, index, k, output));
        return output;
      };
    }

    //  wrapNext :: (TypeVarMap, Array Any, Integer) -> (a -> b)
    function wrapNext(_typeVarMap, _values, index) {
      return function(x) {
        var args = slice.call (arguments);
        if (args.length !== 1) {
          throw invalidArgumentsCount (typeInfo, index, 1, args);
        }
        var typeVarMap = (assertRight (
          satisfactoryTypes (env,
                             typeInfo,
                             _typeVarMap,
                             typeInfo.types[index],
                             index,
                             [],
                             args)
        )).typeVarMap;

        var values = Z.concat (_values, args);
        if (index + 1 === n) {
          var value = values.reduce (function(f, x, idx) {
            return f (wrapFunctionCond (typeVarMap, idx, x));
          }, impl);
          typeVarMap = (assertRight (
            satisfactoryTypes (env,
                               typeInfo,
                               typeVarMap,
                               typeInfo.types[n],
                               n,
                               [],
                               [value])
          )).typeVarMap;
          return wrapFunctionCond (typeVarMap, n, value);
        } else {
          return wrapNext (typeVarMap, values, index + 1);
        }
      };
    }

    var wrapped = typeInfo.types[0].type === NO_ARGUMENTS ?
      function() {
        if (arguments.length !== 0) {
          throw invalidArgumentsCount (typeInfo, 0, 0, slice.call (arguments));
        }
        var value = impl ();
        var typeVarMap = assertRight (
          satisfactoryTypes (env,
                             typeInfo,
                             {},
                             typeInfo.types[n],
                             n,
                             [],
                             [value])
        ).typeVarMap;
        return wrapFunctionCond (typeVarMap, n, value);
      } :
      wrapNext ({}, [], 0);

    wrapped[inspect] = wrapped.toString = always0 (typeSignature (typeInfo));

    return wrapped;
  }

  function _create(opts) {
    function def(name) {
      return function(constraints) {
        return function(expTypes) {
          return function(impl) {
            return opts.checkTypes ?
              withTypeChecking (opts.env,
                                {name: name,
                                 constraints: constraints,
                                 types: augmentThunk (expTypes)},
                                impl) :
              impl;
          };
        };
      };
    }
    return def (def.name)
               ({})
               ([String_,
                 StrMap (Array_ (TypeClass)),
                 NonEmpty (Array_ (Type)),
                 AnyFunction,
                 AnyFunction])
               (def);
  }

  var create =
  def ('create')
      ({})
      ([RecordType ({checkTypes: Boolean_, env: Array_ (Any)}), AnyFunction])
      (_create);

  //  fromUncheckedUnaryType :: (Type -> Type) -> Type -> Type
  function fromUncheckedUnaryType(typeConstructor) {
    var t = typeConstructor (Unknown);
    var _1 = t.types.$1.extractor;
    return CheckedUnaryType (t.name) (t.url) (t._test) (_1);
  }

  //  fromUncheckedBinaryType :: (Type -> Type -> Type) -> Type -> Type -> Type
  function fromUncheckedBinaryType(typeConstructor) {
    var t = typeConstructor (Unknown) (Unknown);
    var _1 = t.types.$1.extractor;
    var _2 = t.types.$2.extractor;
    return CheckedBinaryType (t.name) (t.url) (t._test) (_1) (_2);
  }

  return {
    Any: Any,
    AnyFunction: AnyFunction,
    Arguments: Arguments,
    Array: fromUncheckedUnaryType (Array_),
    Array0: Array0,
    Array1: fromUncheckedUnaryType (Array1),
    Array2: fromUncheckedBinaryType (Array2),
    Boolean: Boolean_,
    Date: Date_,
    Error: Error_,
    FiniteNumber: FiniteNumber,
    Function: def ('Function') ({}) ([Array_ (Type), Type]) (Function_),
    GlobalRegExp: GlobalRegExp,
    HtmlElement: HtmlElement,
    Integer: Integer,
    NegativeFiniteNumber: NegativeFiniteNumber,
    NegativeInteger: NegativeInteger,
    NegativeNumber: NegativeNumber,
    NonEmpty: NonEmpty,
    NonGlobalRegExp: NonGlobalRegExp,
    NonNegativeInteger: NonNegativeInteger,
    NonZeroFiniteNumber: NonZeroFiniteNumber,
    NonZeroInteger: NonZeroInteger,
    NonZeroValidNumber: NonZeroValidNumber,
    Null: Null,
    Nullable: fromUncheckedUnaryType (Nullable),
    Number: Number_,
    Object: Object_,
    PositiveFiniteNumber: PositiveFiniteNumber,
    PositiveInteger: PositiveInteger,
    PositiveNumber: PositiveNumber,
    RegExp: RegExp_,
    RegexFlags: RegexFlags,
    StrMap: fromUncheckedUnaryType (StrMap),
    String: String_,
    Symbol: Symbol_,
    Type: Type,
    TypeClass: TypeClass,
    Undefined: Undefined,
    Unknown: Unknown,
    ValidDate: ValidDate,
    ValidNumber: ValidNumber,
    env: env,
    create: create,
    test: def ('test') ({}) ([Array_ (Type), Type, Any, Boolean_]) (test),
    NullaryType: CheckedNullaryType,
    UnaryType: CheckedUnaryType,
    BinaryType: CheckedBinaryType,
    EnumType: CheckedEnumType,
    RecordType: CheckedRecordType,
    TypeVariable: CheckedTypeVariable,
    UnaryTypeVariable: CheckedUnaryTypeVariable,
    BinaryTypeVariable: CheckedBinaryTypeVariable,
    Thunk: Thunk,
    Predicate: Predicate
  };

}));

//. [FL:Semigroup]:         https://github.com/fantasyland/fantasy-land#semigroup
//. [HTML element]:         https://developer.mozilla.org/en-US/docs/Web/HTML/Element
//. [Monoid]:               https://github.com/fantasyland/fantasy-land#monoid
//. [Setoid]:               https://github.com/fantasyland/fantasy-land#setoid
//. [`Array`]:              #Array
//. [`Array2`]:             #Array2
//. [`BinaryType`]:         #BinaryType
//. [`Date`]:               #Date
//. [`FiniteNumber`]:       #FiniteNumber
//. [`GlobalRegExp`]:       #GlobalRegExp
//. [`Integer`]:            #Integer
//. [`NonGlobalRegExp`]:    #NonGlobalRegExp
//. [`Number`]:             #Number
//. [`Object.create`]:      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
//. [`RegExp`]:             #RegExp
//. [`RegexFlags`]:         #RegexFlags
//. [`String`]:             #String
//. [`SyntaxError`]:        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError
//. [`TypeClass`]:          https://github.com/sanctuary-js/sanctuary-type-classes#TypeClass
//. [`TypeError`]:          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError
//. [`TypeVariable`]:       #TypeVariable
//. [`UnaryType`]:          #UnaryType
//. [`UnaryTypeVariable`]:  #UnaryTypeVariable
//. [`Unknown`]:            #Unknown
//. [`ValidNumber`]:        #ValidNumber
//. [`env`]:                #env
//. [arguments]:            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
//. [enumerated types]:     https://en.wikipedia.org/wiki/Enumerated_type
//. [max]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
//. [min]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER
//. [record type]:          #RecordType
//. [semigroup]:            https://en.wikipedia.org/wiki/Semigroup
//. [type class]:           #type-classes
//. [type variables]:       #TypeVariable
//. [types]:                #types

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/sanctuary-either/index.js":
/*!************************************************!*\
  !*** ./node_modules/sanctuary-either/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
         _______    ___    _________    ___   ___    _______    ______
        /  ____/\  /  /\  /__   ___/\  /  /\ /  /\  /  ____/\  /  __  \
       /  /\___\/ /  / /  \_/  /\__\/ /  /_//  / / /  /\___\/ /  /\/  /\
      /  ____/\  /  / /    /  / /    /  ___   / / /  ____/\  /      _/ /
     /  /\___\/ /  / /    /  / /    /  /\_/  / / /  /\___\/ /  /|  |\\/
    /______/\  /__/ /    /__/ /    /__/ //__/ / /______/\  /__/ |__| |
    \______\/  \__\/     \__\/     \__\/ \__\/  \______\/  \__\/ \__\|
                                                                            */

//. <a href="https://github.com/fantasyland/fantasy-land"><img alt="Fantasy Land" src="https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png" width="75" height="75" align="left"></a>
//.
//. # sanctuary-either
//.
//. The Either type represents values with two possibilities: a value of type
//. `Either a b` is either a Left whose value is of type `a` or a Right whose
//. value is of type `b`.

(function(f) {

  'use strict';

  /* istanbul ignore else */
  if ( true && typeof module.exports === 'object') {
    module.exports = f (__webpack_require__ (/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"),
                        __webpack_require__ (/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"));
  } else if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"), __webpack_require__(/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    self.sanctuaryEither = f (self.sanctuaryShow, self.sanctuaryTypeClasses);
  }

} (function(show, Z) {

  'use strict';

  /* istanbul ignore if */
  if (typeof __doctest !== 'undefined') {
    var $ = __doctest.require ('sanctuary-def');
    var type = __doctest.require ('sanctuary-type-identifiers');
    var S = (function() {
      var S = __doctest.require ('sanctuary');
      var EitherType = $.BinaryType
        ('sanctuary-either/Either')
        ('')
        (function(x) { return type (x) === Either['@@type']; })
        (function(e) { return e.isLeft ? [e.value] : []; })
        (function(e) { return e.isLeft ? [] : [e.value]; });
      var env = Z.concat (S.env,
                          [$.TypeClass, EitherType ($.Unknown) ($.Unknown)]);
      return S.create ({checkTypes: true, env: env});
    } ());
  }

  var Either = {};

  var Left$prototype = {
    /* eslint-disable key-spacing */
    'constructor':            Either,
    'isLeft':                 true,
    'isRight':                false,
    '@@show':                 Left$prototype$show,
    'fantasy-land/map':       Left$prototype$map,
    'fantasy-land/bimap':     Left$prototype$bimap,
    'fantasy-land/ap':        Left$prototype$ap,
    'fantasy-land/chain':     Left$prototype$chain,
    'fantasy-land/alt':       Left$prototype$alt,
    'fantasy-land/reduce':    Left$prototype$reduce,
    'fantasy-land/traverse':  Left$prototype$traverse,
    'fantasy-land/extend':    Left$prototype$extend
    /* eslint-enable key-spacing */
  };

  var Right$prototype = {
    /* eslint-disable key-spacing */
    'constructor':            Either,
    'isLeft':                 false,
    'isRight':                true,
    '@@show':                 Right$prototype$show,
    'fantasy-land/map':       Right$prototype$map,
    'fantasy-land/bimap':     Right$prototype$bimap,
    'fantasy-land/ap':        Right$prototype$ap,
    'fantasy-land/chain':     Right$prototype$chain,
    'fantasy-land/alt':       Right$prototype$alt,
    'fantasy-land/reduce':    Right$prototype$reduce,
    'fantasy-land/traverse':  Right$prototype$traverse,
    'fantasy-land/extend':    Right$prototype$extend
    /* eslint-enable key-spacing */
  };

  var util =
     true && typeof module.exports === 'object' ?
    __webpack_require__ (/*! util */ "./node_modules/util/util.js") :
    /* istanbul ignore next */ {};
  var inspect =
    util.inspect != null && typeof util.inspect.custom === 'symbol' ?
    /* istanbul ignore next */ util.inspect.custom :
    /* istanbul ignore next */ 'inspect';
  Left$prototype[inspect] = Left$prototype$show;
  Right$prototype[inspect] = Right$prototype$show;

  //. `Either a b` satisfies the following [Fantasy Land][] specifications:
  //.
  //. ```javascript
  //. > const Useless = require ('sanctuary-useless')
  //.
  //. > S.map (k => k + ' '.repeat (16 - k.length) +
  //. .             (Z[k].test (Right (Useless)) ? '\u2705   ' :
  //. .              Z[k].test (Right (['foo'])) ? '\u2705 * ' :
  //. .              /* otherwise */               '\u274C   '))
  //. .       (S.keys (Z.filter ($.test ([]) ($.TypeClass), Z)))
  //. [ 'Setoid          ✅ * ',  // if ‘a’ and ‘b’ satisfy Setoid
  //. . 'Ord             ✅ * ',  // if ‘a’ and ‘b’ satisfy Ord
  //. . 'Semigroupoid    ❌   ',
  //. . 'Category        ❌   ',
  //. . 'Semigroup       ✅ * ',  // if ‘a’ and ‘b’ satisfy Semigroup
  //. . 'Monoid          ❌   ',
  //. . 'Group           ❌   ',
  //. . 'Filterable      ❌   ',
  //. . 'Functor         ✅   ',
  //. . 'Bifunctor       ✅   ',
  //. . 'Profunctor      ❌   ',
  //. . 'Apply           ✅   ',
  //. . 'Applicative     ✅   ',
  //. . 'Chain           ✅   ',
  //. . 'ChainRec        ✅   ',
  //. . 'Monad           ✅   ',
  //. . 'Alt             ✅   ',
  //. . 'Plus            ❌   ',
  //. . 'Alternative     ❌   ',
  //. . 'Foldable        ✅   ',
  //. . 'Traversable     ✅   ',
  //. . 'Extend          ✅   ',
  //. . 'Comonad         ❌   ',
  //. . 'Contravariant   ❌   ' ]
  //. ```

  //# Either :: TypeRep Either
  //.
  //. Either [type representative][].

  //# Either.Left :: a -> Either a b
  //.
  //. Constructs a value of type `Either a b` from a value of type `a`.
  //.
  //. ```javascript
  //. > Left ('sqrt undefined for -1')
  //. Left ('sqrt undefined for -1')
  //. ```
  var Left = Either.Left = function(value) {
    var left = Object.create (Left$prototype);
    if (Z.Setoid.test (value)) {
      left['fantasy-land/equals'] = Left$prototype$equals;
      if (Z.Ord.test (value)) {
        left['fantasy-land/lte'] = Left$prototype$lte;
      }
    }
    if (Z.Semigroup.test (value)) {
      left['fantasy-land/concat'] = Left$prototype$concat;
    }
    left.value = value;
    return left;
  };

  //# Either.Right :: b -> Either a b
  //.
  //. Constructs a value of type `Either a b` from a value of type `b`.
  //.
  //. ```javascript
  //. > Right (42)
  //. Right (42)
  //. ```
  var Right = Either.Right = function Right(value) {
    var right = Object.create (Right$prototype);
    if (Z.Setoid.test (value)) {
      right['fantasy-land/equals'] = Right$prototype$equals;
      if (Z.Ord.test (value)) {
        right['fantasy-land/lte'] = Right$prototype$lte;
      }
    }
    if (Z.Semigroup.test (value)) {
      right['fantasy-land/concat'] = Right$prototype$concat;
    }
    right.value = value;
    return right;
  };

  //# Either.@@type :: String
  //.
  //. Either [type identifier][].
  //.
  //. ```javascript
  //. > type (Right (42))
  //. 'sanctuary-either/Either@1'
  //.
  //. > type.parse (type (Right (42)))
  //. {namespace: 'sanctuary-either', name: 'Either', version: 1}
  //. ```
  Either['@@type'] = 'sanctuary-either/Either@1';

  //# Either.fantasy-land/of :: b -> Either a b
  //.
  //.   - `of (Either) (x)` is equivalent to `Right (x)`
  //.
  //. ```javascript
  //. > S.of (Either) (42)
  //. Right (42)
  //. ```
  Either['fantasy-land/of'] = Right;

  function next(x) { return {tag: next, value: x}; }
  function done(x) { return {tag: done, value: x}; }

  //# Either.fantasy-land/chainRec :: ((a -> c, b -> c, a) -> Either d c, a) -> Either d b
  //.
  //. ```javascript
  //. > Z.chainRec (
  //. .   Either,
  //. .   (next, done, x) =>
  //. .     x <= 1 ? Left ('!!') : Right (x >= 1000 ? done (x) : next (x * x)),
  //. .   1
  //. . )
  //. Left ('!!')
  //.
  //. > Z.chainRec (
  //. .   Either,
  //. .   (next, done, x) =>
  //. .     x <= 1 ? Left ('!!') : Right (x >= 1000 ? done (x) : next (x * x)),
  //. .   2
  //. . )
  //. Right (65536)
  //. ```
  Either['fantasy-land/chainRec'] = function(f, x) {
    var r = next (x);
    while (r.tag === next) {
      var either = f (next, done, r.value);
      if (either.isLeft) return either;
      r = either.value;
    }
    return Right (r.value);
  };

  //# Either#@@show :: (Showable a, Showable b) => Either a b ~> () -> String
  //.
  //.   - `show (Left (x))` is equivalent to `'Left (' + show (x) + ')'`
  //.   - `show (Right (x))` is equivalent to `'Right (' + show (x) + ')'`
  //.
  //. ```javascript
  //. > show (Left ('sqrt undefined for -1'))
  //. 'Left ("sqrt undefined for -1")'
  //.
  //. > show (Right ([1, 2, 3]))
  //. 'Right ([1, 2, 3])'
  //. ```
  function Left$prototype$show() {
    return 'Left (' + show (this.value) + ')';
  }
  function Right$prototype$show() {
    return 'Right (' + show (this.value) + ')';
  }

  //# Either#fantasy-land/equals :: (Setoid a, Setoid b) => Either a b ~> Either a b -> Boolean
  //.
  //.   - `Left (x)` is equal to `Left (y)` [iff][] `x` is equal to `y`
  //.     according to [`Z.equals`][]
  //.   - `Right (x)` is equal to `Right (y)` [iff][] `x` is equal to `y`
  //.     according to [`Z.equals`][]
  //.   - `Left (x)` is never equal to `Right (y)`
  //.
  //. ```javascript
  //. > S.equals (Left ([1, 2, 3])) (Left ([1, 2, 3]))
  //. true
  //.
  //. > S.equals (Right ([1, 2, 3])) (Right ([1, 2, 3]))
  //. true
  //.
  //. > S.equals (Left ([1, 2, 3])) (Right ([1, 2, 3]))
  //. false
  //. ```
  function Left$prototype$equals(other) {
    return other.isLeft && Z.equals (this.value, other.value);
  }
  function Right$prototype$equals(other) {
    return other.isRight && Z.equals (this.value, other.value);
  }

  //# Either#fantasy-land/lte :: (Ord a, Ord b) => Either a b ~> Either a b -> Boolean
  //.
  //.   - `Left (x)` is less than or equal to `Left (y)` [iff][] `x` is less
  //.     than or equal to `y` according to [`Z.lte`][]
  //.   - `Right (x)` is less than or equal to `Right (y)` [iff][] `x` is less
  //.     than or equal to `y` according to [`Z.lte`][]
  //.   - `Left (x)` is always less than `Right (y)`
  //.
  //. ```javascript
  //. > S.filter (S.lte (Left (1))) ([Left (0), Left (1), Left (2)])
  //. [Left (0), Left (1)]
  //.
  //. > S.filter (S.lte (Right (1))) ([Right (0), Right (1), Right (2)])
  //. [Right (0), Right (1)]
  //.
  //. > S.filter (S.lte (Left (1))) ([Right (0), Right (1), Right (2)])
  //. []
  //.
  //. > S.filter (S.lte (Right (1))) ([Left (0), Left (1), Left (2)])
  //. [Left (0), Left (1), Left (2)]
  //. ```
  function Left$prototype$lte(other) {
    return other.isRight || Z.lte (this.value, other.value);
  }
  function Right$prototype$lte(other) {
    return other.isRight && Z.lte (this.value, other.value);
  }

  //# Either#fantasy-land/concat :: (Semigroup a, Semigroup b) => Either a b ~> Either a b -> Either a b
  //.
  //.   - `concat (Left (x)) (Left (y))` is equivalent to
  //.     `Left (concat (x) (y))`
  //.   - `concat (Right (x)) (Right (y))` is equivalent to
  //.     `Right (concat (x) (y))`
  //.   - `concat (Left (x)) (Right (y))` is equivalent to `Right (y)`
  //.   - `concat (Right (x)) (Left (y))` is equivalent to `Right (x)`
  //.
  //. ```javascript
  //. > S.concat (Left ('abc')) (Left ('def'))
  //. Left ('abcdef')
  //.
  //. > S.concat (Right ([1, 2, 3])) (Right ([4, 5, 6]))
  //. Right ([1, 2, 3, 4, 5, 6])
  //.
  //. > S.concat (Left ('abc')) (Right ([1, 2, 3]))
  //. Right ([1, 2, 3])
  //.
  //. > S.concat (Right ([1, 2, 3])) (Left ('abc'))
  //. Right ([1, 2, 3])
  //. ```
  function Left$prototype$concat(other) {
    return other.isLeft ? Left (Z.concat (this.value, other.value)) : other;
  }
  function Right$prototype$concat(other) {
    return other.isRight ? Right (Z.concat (this.value, other.value)) : this;
  }

  //# Either#fantasy-land/map :: Either a b ~> (b -> c) -> Either a c
  //.
  //.   - `map (f) (Left (x))` is equivalent to `Left (x)`
  //.   - `map (f) (Right (x))` is equivalent to `Right (f (x))`
  //.
  //. ```javascript
  //. > S.map (S.add (1)) (Left ('sqrt undefined for -1'))
  //. Left ('sqrt undefined for -1')
  //.
  //. > S.map (S.add (1)) (Right (99))
  //. Right (100)
  //. ```
  function Left$prototype$map(f) {
    return this;
  }
  function Right$prototype$map(f) {
    return Right (f (this.value));
  }

  //# Either#fantasy-land/bimap :: Either a c ~> (a -> b, c -> d) -> Either b d
  //.
  //.   - `bimap (f) (g) (Left (x))` is equivalent to `Left (f (x))`
  //.   - `bimap (f) (g) (Right (x))` is equivalent to `Right (g (x))`
  //.
  //. ```javascript
  //. > S.bimap (S.toUpper) (S.add (1)) (Left ('abc'))
  //. Left ('ABC')
  //.
  //. > S.bimap (S.toUpper) (S.add (1)) (Right (99))
  //. Right (100)
  //. ```
  function Left$prototype$bimap(f, g) {
    return Left (f (this.value));
  }
  function Right$prototype$bimap(f, g) {
    return Right (g (this.value));
  }

  //# Either#fantasy-land/ap :: Either a b ~> Either a (b -> c) -> Either a c
  //.
  //.   - `ap (Left (x)) (Left (y))` is equivalent to `Left (x)`
  //.   - `ap (Left (x)) (Right (y))` is equivalent to `Left (x)`
  //.   - `ap (Right (f)) (Left (x))` is equivalent to `Left (x)`
  //.   - `ap (Right (f)) (Right (x))` is equivalent to `Right (f (x))`
  //.
  //. ```javascript
  //. > S.ap (Left ('div undefined for 0')) (Left ('sqrt undefined for -1'))
  //. Left ('div undefined for 0')
  //.
  //. > S.ap (Left ('div undefined for 0')) (Right (99))
  //. Left ('div undefined for 0')
  //.
  //. > S.ap (Right (S.add (1))) (Left ('sqrt undefined for -1'))
  //. Left ('sqrt undefined for -1')
  //.
  //. > S.ap (Right (S.add (1))) (Right (99))
  //. Right (100)
  //. ```
  function Left$prototype$ap(other) {
    return other.isLeft ? other : this;
  }
  function Right$prototype$ap(other) {
    return other.isLeft ? other : Right (other.value (this.value));
  }

  //# Either#fantasy-land/chain :: Either a b ~> (b -> Either a c) -> Either a c
  //.
  //.   - `chain (f) (Left (x))` is equivalent to `Left (x)`
  //.   - `chain (f) (Right (x))` is equivalent to `f (x)`
  //.
  //. ```javascript
  //. > const sqrt = n => n < 0 ? Left ('sqrt undefined for ' + show (n))
  //. .                         : Right (Math.sqrt (n))
  //.
  //. > S.chain (sqrt) (Left ('div undefined for 0'))
  //. Left ('div undefined for 0')
  //.
  //. > S.chain (sqrt) (Right (-1))
  //. Left ('sqrt undefined for -1')
  //.
  //. > S.chain (sqrt) (Right (25))
  //. Right (5)
  //. ```
  function Left$prototype$chain(f) {
    return this;
  }
  function Right$prototype$chain(f) {
    return f (this.value);
  }

  //# Either#fantasy-land/alt :: Either a b ~> Either a b -> Either a b
  //.
  //.   - `alt (Left (x)) (Left (y))` is equivalent to `Left (y)`
  //.   - `alt (Left (x)) (Right (y))` is equivalent to `Right (y)`
  //.   - `alt (Right (x)) (Left (y))` is equivalent to `Right (x)`
  //.   - `alt (Right (x)) (Right (y))` is equivalent to `Right (x)`
  //.
  //. ```javascript
  //. > S.alt (Left ('A')) (Left ('B'))
  //. Left ('B')
  //.
  //. > S.alt (Left ('C')) (Right (1))
  //. Right (1)
  //.
  //. > S.alt (Right (2)) (Left ('D'))
  //. Right (2)
  //.
  //. > S.alt (Right (3)) (Right (4))
  //. Right (3)
  //. ```
  function Left$prototype$alt(other) {
    return other;
  }
  function Right$prototype$alt(other) {
    return this;
  }

  //# Either#fantasy-land/reduce :: Either a b ~> ((c, b) -> c, c) -> c
  //.
  //.   - `reduce (f) (x) (Left (y))` is equivalent to `x`
  //.   - `reduce (f) (x) (Right (y))` is equivalent to `f (x) (y)`
  //.
  //. ```javascript
  //. > S.reduce (S.concat) ([1]) (Left ('sqrt undefined for -1'))
  //. [1]
  //.
  //. > S.reduce (S.concat) ([1]) (Right ([2]))
  //. [1, 2]
  //. ```
  function Left$prototype$reduce(f, x) {
    return x;
  }
  function Right$prototype$reduce(f, x) {
    return f (x, this.value);
  }

  //# Either#fantasy-land/traverse :: Applicative f => Either a b ~> (TypeRep f, b -> f c) -> f (Either a c)
  //.
  //.   - `traverse (A) (f) (Left (x))` is equivalent to `of (A) (Left (x))`
  //.   - `traverse (A) (f) (Right (x))` is equivalent to `map (Right) (f (x))`
  //.
  //. ```javascript
  //. > S.traverse (Array) (S.words) (Left ('sqrt undefined for -1'))
  //. [Left ('sqrt undefined for -1')]
  //.
  //. > S.traverse (Array) (S.words) (Right ('foo bar baz'))
  //. [Right ('foo'), Right ('bar'), Right ('baz')]
  //. ```
  function Left$prototype$traverse(typeRep, f) {
    return Z.of (typeRep, this);
  }
  function Right$prototype$traverse(typeRep, f) {
    return Z.map (Right, f (this.value));
  }

  //# Either#fantasy-land/extend :: Either a b ~> (Either a b -> c) -> Either a c
  //.
  //.   - `extend (f) (Left (x))` is equivalent to `Left (x)`
  //.   - `extend (f) (Right (x))` is equivalent to `Right (f (Right (x)))`
  //.
  //. ```javascript
  //. > S.extend (S.reduce (S.add) (1)) (Left ('sqrt undefined for -1'))
  //. Left ('sqrt undefined for -1')
  //.
  //. > S.extend (S.reduce (S.add) (1)) (Right (99))
  //. Right (100)
  //. ```
  function Left$prototype$extend(f) {
    return this;
  }
  function Right$prototype$extend(f) {
    return Right (f (this));
  }

  return Either;

}));

//. [Fantasy Land]:             v:fantasyland/fantasy-land
//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals
//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte
//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if
//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers
//. [type representative]:      v:fantasyland/fantasy-land#type-representatives


/***/ }),

/***/ "./node_modules/sanctuary-maybe/index.js":
/*!***********************************************!*\
  !*** ./node_modules/sanctuary-maybe/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
    ,______  ______,  ,________,,_____,,_____,,__________  ,__________,
    |      \/      |  |        ||     ||     ||          \ |          |
    |_,          ,_|  |_      _||_    ||    _||_,   __    ||_,   _____|
      |   \  /   |     /      \   \   \/   /    |        /   |      |
    ,_|    ||    |_,,_/   /\   \_, \      /   ,_|   __   \ ,_|   ___|_,
    |      ||      ||     ||     |  |    |    |           ||          |
    |______||______||_____||_____|  |____|    |__________/ |__________|
                                                                         */

//. <a href="https://github.com/fantasyland/fantasy-land"><img alt="Fantasy Land" src="https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png" width="75" height="75" align="left"></a>
//.
//. # sanctuary-maybe
//.
//. The Maybe type represents optional values: a value of type `Maybe a` is
//. either Nothing (the empty value) or a Just whose value is of type `a`.

(function(f) {

  'use strict';

  /* istanbul ignore else */
  if ( true && typeof module.exports === 'object') {
    module.exports = f (__webpack_require__ (/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"),
                        __webpack_require__ (/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"));
  } else if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"), __webpack_require__(/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    self.sanctuaryMaybe = f (self.sanctuaryShow, self.sanctuaryTypeClasses);
  }

} (function(show, Z) {

  'use strict';

  /* istanbul ignore if */
  if (typeof __doctest !== 'undefined') {
    var $ = __doctest.require ('sanctuary-def');
    var type = __doctest.require ('sanctuary-type-identifiers');
    var S = (function() {
      var S = __doctest.require ('sanctuary');
      var MaybeType = $.UnaryType
        ('sanctuary-maybe/Maybe')
        ('')
        (function(x) { return type (x) === Maybe['@@type']; })
        (function(m) { return m.isJust ? [m.value] : []; });
      var env = Z.concat (S.env, [$.TypeClass, MaybeType ($.Unknown)]);
      return S.create ({checkTypes: true, env: env});
    } ());
  }

  var Maybe = {};

  var Nothing$prototype = {
    /* eslint-disable key-spacing */
    'constructor':            Maybe,
    'isNothing':              true,
    'isJust':                 false,
    '@@show':                 Nothing$prototype$show,
    'fantasy-land/equals':    Nothing$prototype$equals,
    'fantasy-land/lte':       Nothing$prototype$lte,
    'fantasy-land/concat':    Nothing$prototype$concat,
    'fantasy-land/filter':    Nothing$prototype$filter,
    'fantasy-land/map':       Nothing$prototype$map,
    'fantasy-land/ap':        Nothing$prototype$ap,
    'fantasy-land/chain':     Nothing$prototype$chain,
    'fantasy-land/alt':       Nothing$prototype$alt,
    'fantasy-land/reduce':    Nothing$prototype$reduce,
    'fantasy-land/traverse':  Nothing$prototype$traverse,
    'fantasy-land/extend':    Nothing$prototype$extend
    /* eslint-enable key-spacing */
  };

  var Just$prototype = {
    /* eslint-disable key-spacing */
    'constructor':            Maybe,
    'isNothing':              false,
    'isJust':                 true,
    '@@show':                 Just$prototype$show,
    'fantasy-land/filter':    Just$prototype$filter,
    'fantasy-land/map':       Just$prototype$map,
    'fantasy-land/ap':        Just$prototype$ap,
    'fantasy-land/chain':     Just$prototype$chain,
    'fantasy-land/alt':       Just$prototype$alt,
    'fantasy-land/reduce':    Just$prototype$reduce,
    'fantasy-land/traverse':  Just$prototype$traverse,
    'fantasy-land/extend':    Just$prototype$extend
    /* eslint-enable key-spacing */
  };

  var util =
     true && typeof module.exports === 'object' ?
    __webpack_require__ (/*! util */ "./node_modules/util/util.js") :
    /* istanbul ignore next */ {};
  var inspect =
    util.inspect != null && typeof util.inspect.custom === 'symbol' ?
    /* istanbul ignore next */ util.inspect.custom :
    /* istanbul ignore next */ 'inspect';
  Nothing$prototype[inspect] = Nothing$prototype$show;
  Just$prototype[inspect] = Just$prototype$show;

  //. `Maybe a` satisfies the following [Fantasy Land][] specifications:
  //.
  //. ```javascript
  //. > const Useless = require ('sanctuary-useless')
  //.
  //. > S.map (k => k + ' '.repeat (16 - k.length) +
  //. .             (Z[k].test (Just (Useless)) ? '\u2705   ' :
  //. .              Z[k].test (Nothing)        ? '\u2705 * ' :
  //. .              /* otherwise */              '\u274C   '))
  //. .       (S.keys (Z.filter ($.test ([]) ($.TypeClass), Z)))
  //. [ 'Setoid          ✅ * ',  // if ‘a’ satisfies Setoid
  //. . 'Ord             ✅ * ',  // if ‘a’ satisfies Ord
  //. . 'Semigroupoid    ❌   ',
  //. . 'Category        ❌   ',
  //. . 'Semigroup       ✅ * ',  // if ‘a’ satisfies Semigroup
  //. . 'Monoid          ✅ * ',  // if ‘a’ satisfies Semigroup
  //. . 'Group           ❌   ',
  //. . 'Filterable      ✅   ',
  //. . 'Functor         ✅   ',
  //. . 'Bifunctor       ❌   ',
  //. . 'Profunctor      ❌   ',
  //. . 'Apply           ✅   ',
  //. . 'Applicative     ✅   ',
  //. . 'Chain           ✅   ',
  //. . 'ChainRec        ✅   ',
  //. . 'Monad           ✅   ',
  //. . 'Alt             ✅   ',
  //. . 'Plus            ✅   ',
  //. . 'Alternative     ✅   ',
  //. . 'Foldable        ✅   ',
  //. . 'Traversable     ✅   ',
  //. . 'Extend          ✅   ',
  //. . 'Comonad         ❌   ',
  //. . 'Contravariant   ❌   ' ]
  //. ```

  //# Maybe :: TypeRep Maybe
  //.
  //. Maybe [type representative][].

  //# Maybe.Nothing :: Maybe a
  //.
  //. The empty value of type `Maybe a`.
  //.
  //. ```javascript
  //. > Nothing
  //. Nothing
  //. ```
  var Nothing = Maybe.Nothing = Object.create (Nothing$prototype);

  //# Maybe.Just :: a -> Maybe a
  //.
  //. Constructs a value of type `Maybe a` from a value of type `a`.
  //.
  //. ```javascript
  //. > Just (42)
  //. Just (42)
  //. ```
  var Just = Maybe.Just = function(value) {
    var just = Object.create (Just$prototype);
    if (Z.Setoid.test (value)) {
      just['fantasy-land/equals'] = Just$prototype$equals;
      if (Z.Ord.test (value)) {
        just['fantasy-land/lte'] = Just$prototype$lte;
      }
    }
    if (Z.Semigroup.test (value)) {
      just['fantasy-land/concat'] = Just$prototype$concat;
    }
    just.value = value;
    return just;
  };

  //# Maybe.@@type :: String
  //.
  //. Maybe [type identifier][].
  //.
  //. ```javascript
  //. > type (Just (42))
  //. 'sanctuary-maybe/Maybe@1'
  //.
  //. > type.parse (type (Just (42)))
  //. {namespace: 'sanctuary-maybe', name: 'Maybe', version: 1}
  //. ```
  Maybe['@@type'] = 'sanctuary-maybe/Maybe@1';

  //# Maybe.fantasy-land/empty :: () -> Maybe a
  //.
  //.   - `empty (Maybe)` is equivalent to `Nothing`
  //.
  //. ```javascript
  //. > S.empty (Maybe)
  //. Nothing
  //. ```
  Maybe['fantasy-land/empty'] = function() { return Nothing; };

  //# Maybe.fantasy-land/of :: a -> Maybe a
  //.
  //.   - `of (Maybe) (x)` is equivalent to `Just (x)`
  //.
  //. ```javascript
  //. > S.of (Maybe) (42)
  //. Just (42)
  //. ```
  Maybe['fantasy-land/of'] = Just;

  function next(x) { return {tag: next, value: x}; }
  function done(x) { return {tag: done, value: x}; }

  //# Maybe.fantasy-land/chainRec :: ((a -> c, b -> c, a) -> Maybe c, a) -> Maybe b
  //.
  //. ```javascript
  //. > Z.chainRec (
  //. .   Maybe,
  //. .   (next, done, x) =>
  //. .     x <= 1 ? Nothing : Just (x >= 1000 ? done (x) : next (x * x)),
  //. .   1
  //. . )
  //. Nothing
  //.
  //. > Z.chainRec (
  //. .   Maybe,
  //. .   (next, done, x) =>
  //. .     x <= 1 ? Nothing : Just (x >= 1000 ? done (x) : next (x * x)),
  //. .   2
  //. . )
  //. Just (65536)
  //. ```
  Maybe['fantasy-land/chainRec'] = function(f, x) {
    var r = next (x);
    while (r.tag === next) {
      var maybe = f (next, done, r.value);
      if (maybe.isNothing) return maybe;
      r = maybe.value;
    }
    return Just (r.value);
  };

  //# Maybe.fantasy-land/zero :: () -> Maybe a
  //.
  //.   - `zero (Maybe)` is equivalent to `Nothing`
  //.
  //. ```javascript
  //. > S.zero (Maybe)
  //. Nothing
  //. ```
  Maybe['fantasy-land/zero'] = function() { return Nothing; };

  //# Maybe#@@show :: Showable a => Maybe a ~> () -> String
  //.
  //.   - `show (Nothing)` is equivalent to `'Nothing'`
  //.   - `show (Just (x))` is equivalent to `'Just (' + show (x) + ')'`
  //.
  //. ```javascript
  //. > show (Nothing)
  //. 'Nothing'
  //.
  //. > show (Just (['foo', 'bar', 'baz']))
  //. 'Just (["foo", "bar", "baz"])'
  //. ```
  function Nothing$prototype$show() {
    return 'Nothing';
  }
  function Just$prototype$show() {
    return 'Just (' + show (this.value) + ')';
  }

  //# Maybe#fantasy-land/equals :: Setoid a => Maybe a ~> Maybe a -> Boolean
  //.
  //.   - `Nothing` is equal to `Nothing`
  //.   - `Just (x)` is equal to `Just (y)` [iff][] `x` is equal to `y`
  //.     according to [`Z.equals`][]
  //.   - `Nothing` is never equal to `Just (x)`
  //.
  //. ```javascript
  //. > S.equals (Nothing) (Nothing)
  //. true
  //.
  //. > S.equals (Just ([1, 2, 3])) (Just ([1, 2, 3]))
  //. true
  //.
  //. > S.equals (Just ([1, 2, 3])) (Just ([3, 2, 1]))
  //. false
  //.
  //. > S.equals (Just ([1, 2, 3])) (Nothing)
  //. false
  //. ```
  function Nothing$prototype$equals(other) {
    return other.isNothing;
  }
  function Just$prototype$equals(other) {
    return other.isJust && Z.equals (this.value, other.value);
  }

  //# Maybe#fantasy-land/lte :: Ord a => Maybe a ~> Maybe a -> Boolean
  //.
  //.   - `Nothing` is (less than or) equal to `Nothing`
  //.   - `Just (x)` is less than or equal to `Just (y)` [iff][] `x` is less
  //.     than or equal to `y` according to [`Z.lte`][]
  //.   - `Nothing` is always less than `Just (x)`
  //.
  //. ```javascript
  //. > S.filter (S.lte (Nothing)) ([Nothing, Just (0), Just (1), Just (2)])
  //. [Nothing]
  //.
  //. > S.filter (S.lte (Just (1))) ([Nothing, Just (0), Just (1), Just (2)])
  //. [Nothing, Just (0), Just (1)]
  //. ```
  function Nothing$prototype$lte(other) {
    return true;
  }
  function Just$prototype$lte(other) {
    return other.isJust && Z.lte (this.value, other.value);
  }

  //# Maybe#fantasy-land/concat :: Semigroup a => Maybe a ~> Maybe a -> Maybe a
  //.
  //.   - `concat (Nothing) (Nothing)` is equivalent to `Nothing`
  //.   - `concat (Just (x)) (Just (y))` is equivalent to
  //.     `Just (concat (x) (y))`
  //.   - `concat (Nothing) (Just (x))` is equivalent to `Just (x)`
  //.   - `concat (Just (x)) (Nothing)` is equivalent to `Just (x)`
  //.
  //. ```javascript
  //. > S.concat (Nothing) (Nothing)
  //. Nothing
  //.
  //. > S.concat (Just ([1, 2, 3])) (Just ([4, 5, 6]))
  //. Just ([1, 2, 3, 4, 5, 6])
  //.
  //. > S.concat (Nothing) (Just ([1, 2, 3]))
  //. Just ([1, 2, 3])
  //.
  //. > S.concat (Just ([1, 2, 3])) (Nothing)
  //. Just ([1, 2, 3])
  //. ```
  function Nothing$prototype$concat(other) {
    return other;
  }
  function Just$prototype$concat(other) {
    return other.isJust ? Just (Z.concat (this.value, other.value)) : this;
  }

  //# Maybe#fantasy-land/filter :: Maybe a ~> (a -> Boolean) -> Maybe a
  //.
  //.   - `filterM (p) (Nothing)` is equivalent to `Nothing`
  //.   - `filterM (p) (Just (x))` is equivalent to
  //.     `p (x) ? Just (x) : Nothing`
  //.
  //. ```javascript
  //. > S.filterM (isFinite) (Nothing)
  //. Nothing
  //.
  //. > S.filterM (isFinite) (Just (Infinity))
  //. Nothing
  //.
  //. > S.filterM (isFinite) (Just (Number.MAX_SAFE_INTEGER))
  //. Just (9007199254740991)
  //. ```
  function Nothing$prototype$filter(pred) {
    return this;
  }
  function Just$prototype$filter(pred) {
    return pred (this.value) ? this : Nothing;
  }

  //# Maybe#fantasy-land/map :: Maybe a ~> (a -> b) -> Maybe b
  //.
  //.   - `map (f) (Nothing)` is equivalent to `Nothing`
  //.   - `map (f) (Just (x))` is equivalent to `Just (f (x))`
  //.
  //. ```javascript
  //. > S.map (Math.sqrt) (Nothing)
  //. Nothing
  //.
  //. > S.map (Math.sqrt) (Just (9))
  //. Just (3)
  //. ```
  function Nothing$prototype$map(f) {
    return this;
  }
  function Just$prototype$map(f) {
    return Just (f (this.value));
  }

  //# Maybe#fantasy-land/ap :: Maybe a ~> Maybe (a -> b) -> Maybe b
  //.
  //.   - `ap (Nothing) (Nothing)` is equivalent to `Nothing`
  //.   - `ap (Nothing) (Just (x))` is equivalent to `Nothing`
  //.   - `ap (Just (f)) (Nothing)` is equivalent to `Nothing`
  //.   - `ap (Just (f)) (Just (x))` is equivalent to `Just (f (x))`
  //.
  //. ```javascript
  //. > S.ap (Nothing) (Nothing)
  //. Nothing
  //.
  //. > S.ap (Nothing) (Just (9))
  //. Nothing
  //.
  //. > S.ap (Just (Math.sqrt)) (Nothing)
  //. Nothing
  //.
  //. > S.ap (Just (Math.sqrt)) (Just (9))
  //. Just (3)
  //. ```
  function Nothing$prototype$ap(other) {
    return this;
  }
  function Just$prototype$ap(other) {
    return other.isJust ? Just (other.value (this.value)) : other;
  }

  //# Maybe#fantasy-land/chain :: Maybe a ~> (a -> Maybe b) -> Maybe b
  //.
  //.   - `chain (f) (Nothing)` is equivalent to `Nothing`
  //.   - `chain (f) (Just (x))` is equivalent to `f (x)`
  //.
  //. ```javascript
  //. > const head = xs => xs.length === 0 ? Nothing : Just (xs[0])
  //.
  //. > S.chain (head) (Nothing)
  //. Nothing
  //.
  //. > S.chain (head) (Just ([]))
  //. Nothing
  //.
  //. > S.chain (head) (Just (['foo', 'bar', 'baz']))
  //. Just ('foo')
  //. ```
  function Nothing$prototype$chain(f) {
    return this;
  }
  function Just$prototype$chain(f) {
    return f (this.value);
  }

  //# Maybe#fantasy-land/alt :: Maybe a ~> Maybe a -> Maybe a
  //.
  //.   - `alt (Nothing) (Nothing)` is equivalent to `Nothing`
  //.   - `alt (Nothing) (Just (x))` is equivalent to `Just (x)`
  //.   - `alt (Just (x)) (Nothing)` is equivalent to `Just (x)`
  //.   - `alt (Just (x)) (Just (y))` is equivalent to `Just (x)`
  //.
  //. ```javascript
  //. > S.alt (Nothing) (Nothing)
  //. Nothing
  //.
  //. > S.alt (Nothing) (Just (1))
  //. Just (1)
  //.
  //. > S.alt (Just (2)) (Nothing)
  //. Just (2)
  //.
  //. > S.alt (Just (3)) (Just (4))
  //. Just (3)
  //. ```
  function Nothing$prototype$alt(other) {
    return other;
  }
  function Just$prototype$alt(other) {
    return this;
  }

  //# Maybe#fantasy-land/reduce :: Maybe a ~> ((b, a) -> b, b) -> b
  //.
  //.   - `reduce (f) (x) (Nothing)` is equivalent to `x`
  //.   - `reduce (f) (x) (Just (y))` is equivalent to `f (x) (y)`
  //.
  //. ```javascript
  //. > S.reduce (S.concat) ('abc') (Nothing)
  //. 'abc'
  //.
  //. > S.reduce (S.concat) ('abc') (Just ('xyz'))
  //. 'abcxyz'
  //. ```
  function Nothing$prototype$reduce(f, x) {
    return x;
  }
  function Just$prototype$reduce(f, x) {
    return f (x, this.value);
  }

  //# Maybe#fantasy-land/traverse :: Applicative f => Maybe a ~> (TypeRep f, a -> f b) -> f (Maybe b)
  //.
  //.   - `traverse (A) (f) (Nothing)` is equivalent to `of (A) (Nothing)`
  //.   - `traverse (A) (f) (Just (x))` is equivalent to `map (Just) (f (x))`
  //.
  //. ```javascript
  //. > S.traverse (Array) (S.words) (Nothing)
  //. [Nothing]
  //.
  //. > S.traverse (Array) (S.words) (Just ('foo bar baz'))
  //. [Just ('foo'), Just ('bar'), Just ('baz')]
  //. ```
  function Nothing$prototype$traverse(typeRep, f) {
    return Z.of (typeRep, this);
  }
  function Just$prototype$traverse(typeRep, f) {
    return Z.map (Just, f (this.value));
  }

  //# Maybe#fantasy-land/extend :: Maybe a ~> (Maybe a -> b) -> Maybe b
  //.
  //.   - `extend (f) (Nothing)` is equivalent to `Nothing`
  //.   - `extend (f) (Just (x))` is equivalent to `Just (f (Just (x)))`
  //.
  //. ```javascript
  //. > S.extend (S.reduce (S.add) (1)) (Nothing)
  //. Nothing
  //.
  //. > S.extend (S.reduce (S.add) (1)) (Just (99))
  //. Just (100)
  //. ```
  function Nothing$prototype$extend(f) {
    return this;
  }
  function Just$prototype$extend(f) {
    return Just (f (this));
  }

  return Maybe;

}));

//. [Fantasy Land]:             v:fantasyland/fantasy-land
//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals
//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte
//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if
//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers
//. [type representative]:      v:fantasyland/fantasy-land#type-representatives


/***/ }),

/***/ "./node_modules/sanctuary-pair/index.js":
/*!**********************************************!*\
  !*** ./node_modules/sanctuary-pair/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;       /*                   *\
      //                     \\
     //   @@  @@     @@  @@   \\
    //      @@       @@  @@    \\
    \\      @@       @@  @@    //
     \\   @@  @@  @    @@ @   //
      \\          /       @  //
       \*             @@@@  */

//. <a href="https://github.com/fantasyland/fantasy-land"><img alt="Fantasy Land" src="https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png" width="75" height="75" align="left"></a>
//.
//. # sanctuary-pair
//.
//. Pair is the canonical product type: a value of type `Pair a b` always
//. contains exactly two values: one of type `a`; one of type `b`.

(function(f) {

  'use strict';

  /* istanbul ignore else */
  if ( true && typeof module.exports === 'object') {
    module.exports = f (__webpack_require__ (/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"),
                        __webpack_require__ (/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"));
  } else if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"), __webpack_require__(/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    self.sanctuaryPair = f (self.sanctuaryShow, self.sanctuaryTypeClasses);
  }

} (function(show, Z) {

  'use strict';

  /* istanbul ignore if */
  if (typeof __doctest !== 'undefined') {
    var $ = __doctest.require ('sanctuary-def');
    var type = __doctest.require ('sanctuary-type-identifiers');
    var S = (function() {
      var S = __doctest.require ('sanctuary');
      var PairType = $.BinaryType
        ('sanctuary-pair/Pair')
        ('')
        (function(x) { return type (x) === Pair['@@type']; })
        (function(p) { return [p.fst]; })
        (function(p) { return [p.snd]; });
      var env = Z.concat (S.env,
                          [$.TypeClass, PairType ($.Unknown) ($.Unknown)]);
      return S.create ({checkTypes: true, env: env});
    } ());
  }

  var prototype = {
    /* eslint-disable key-spacing */
    'constructor':            Pair,
    '@@show':                 Pair$prototype$show,
    'fantasy-land/compose':   Pair$prototype$compose,
    'fantasy-land/map':       Pair$prototype$map,
    'fantasy-land/bimap':     Pair$prototype$bimap,
    'fantasy-land/reduce':    Pair$prototype$reduce,
    'fantasy-land/traverse':  Pair$prototype$traverse,
    'fantasy-land/extend':    Pair$prototype$extend,
    'fantasy-land/extract':   Pair$prototype$extract
    /* eslint-enable key-spacing */
  };

  var util =
     true && typeof module.exports === 'object' ?
    __webpack_require__ (/*! util */ "./node_modules/util/util.js") :
    /* istanbul ignore next */ {};
  prototype[
    util.inspect != null && typeof util.inspect.custom === 'symbol' ?
    /* istanbul ignore next */ util.inspect.custom :
    /* istanbul ignore next */ 'inspect'
  ] = Pair$prototype$show;

  /* istanbul ignore else */
  if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
    prototype[Symbol.iterator] = function() {
      return [this.fst, this.snd][Symbol.iterator] ();
    };
  }

  //. `Pair a b` satisfies the following [Fantasy Land][] specifications:
  //.
  //. ```javascript
  //. > const Useless = require ('sanctuary-useless')
  //.
  //. > S.map (k => k + ' '.repeat (16 - k.length) +
  //. .             (Z[k].test (Pair (Useless) (Useless)) ? '\u2705   ' :
  //. .              Z[k].test (Pair (['foo']) (['bar'])) ? '\u2705 * ' :
  //. .              /* otherwise */                        '\u274C   '))
  //. .       (S.keys (Z.filter ($.test ([]) ($.TypeClass), Z)))
  //. [ 'Setoid          ✅ * ',  // if ‘a’ and ‘b’ satisfy Setoid
  //. . 'Ord             ✅ * ',  // if ‘a’ and ‘b’ satisfy Ord
  //. . 'Semigroupoid    ✅   ',
  //. . 'Category        ❌   ',
  //. . 'Semigroup       ✅ * ',  // if ‘a’ and ‘b’ satisfy Semigroup
  //. . 'Monoid          ❌   ',
  //. . 'Group           ❌   ',
  //. . 'Filterable      ❌   ',
  //. . 'Functor         ✅   ',
  //. . 'Bifunctor       ✅   ',
  //. . 'Profunctor      ❌   ',
  //. . 'Apply           ✅ * ',  // if ‘a’ satisfies Semigroup
  //. . 'Applicative     ❌   ',
  //. . 'Chain           ✅ * ',  // if ‘a’ satisfies Semigroup
  //. . 'ChainRec        ❌   ',
  //. . 'Monad           ❌   ',
  //. . 'Alt             ❌   ',
  //. . 'Plus            ❌   ',
  //. . 'Alternative     ❌   ',
  //. . 'Foldable        ✅   ',
  //. . 'Traversable     ✅   ',
  //. . 'Extend          ✅   ',
  //. . 'Comonad         ✅   ',
  //. . 'Contravariant   ❌   ' ]
  //. ```

  //# Pair :: a -> b -> Pair a b
  //.
  //. Pair's sole data constructor. Additionally, it serves as the
  //. Pair [type representative][].
  //.
  //. ```javascript
  //. > Pair (1) (2)
  //. Pair (1) (2)
  //. ```
  function Pair(fst) {
    return function(snd) {
      var pair = Object.create (prototype);
      if (Z.Setoid.test (fst) && Z.Setoid.test (snd)) {
        pair['fantasy-land/equals'] = Pair$prototype$equals;
        if (Z.Ord.test (fst) && Z.Ord.test (snd)) {
          pair['fantasy-land/lte'] = Pair$prototype$lte;
        }
      }
      if (Z.Semigroup.test (fst)) {
        if (Z.Semigroup.test (snd)) {
          pair['fantasy-land/concat'] = Pair$prototype$concat;
        }
        pair['fantasy-land/ap'] = Pair$prototype$ap;
        pair['fantasy-land/chain'] = Pair$prototype$chain;
      }
      pair.fst = fst;
      pair.snd = snd;
      return pair;
    };
  }

  //# Pair.fst :: Pair a b -> a
  //.
  //. `fst (Pair (x) (y))` is equivalent to `x`.
  //.
  //. ```javascript
  //. > Pair.fst (Pair ('abc') ([1, 2, 3]))
  //. 'abc'
  //. ```
  Pair.fst = function(p) { return p.fst; };

  //# Pair.snd :: Pair a b -> b
  //.
  //. `snd (Pair (x) (y))` is equivalent to `y`.
  //.
  //. ```javascript
  //. > Pair.snd (Pair ('abc') ([1, 2, 3]))
  //. [1, 2, 3]
  //. ```
  Pair.snd = function(p) { return p.snd; };

  //# Pair.swap :: Pair a b -> Pair b a
  //.
  //. `swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.
  //.
  //. ```javascript
  //. > Pair.swap (Pair ('abc') ([1, 2, 3]))
  //. Pair ([1, 2, 3]) ('abc')
  //. ```
  Pair.swap = function(p) { return Pair (p.snd) (p.fst); };

  //# Pair.@@type :: String
  //.
  //. Pair [type identifier][].
  //.
  //. ```javascript
  //. > type (Pair ('abc') ([1, 2, 3]))
  //. 'sanctuary-pair/Pair@1'
  //.
  //. > type.parse (type (Pair ('abc') ([1, 2, 3])))
  //. {namespace: 'sanctuary-pair', name: 'Pair', version: 1}
  //. ```
  Pair['@@type'] = 'sanctuary-pair/Pair@1';

  //# Pair#@@show :: (Showable a, Showable b) => Pair a b ~> () -> String
  //.
  //. `show (Pair (x) (y))` is equivalent to
  //. `'Pair (' + show (x) + ') (' + show (y) + ')'`.
  //.
  //. ```javascript
  //. > show (Pair ('abc') ([1, 2, 3]))
  //. 'Pair ("abc") ([1, 2, 3])'
  //. ```
  function Pair$prototype$show() {
    return 'Pair (' + show (this.fst) + ') (' + show (this.snd) + ')';
  }

  //# Pair#fantasy-land/equals :: (Setoid a, Setoid b) => Pair a b ~> Pair a b -> Boolean
  //.
  //. `Pair (x) (y)` is equal to `Pair (v) (w)` [iff][] `x` is equal to `v`
  //. and `y` is equal to `w` according to [`Z.equals`][].
  //.
  //. ```javascript
  //. > S.equals (Pair ('abc') ([1, 2, 3])) (Pair ('abc') ([1, 2, 3]))
  //. true
  //.
  //. > S.equals (Pair ('abc') ([1, 2, 3])) (Pair ('abc') ([3, 2, 1]))
  //. false
  //. ```
  function Pair$prototype$equals(other) {
    return Z.equals (this.fst, other.fst) && Z.equals (this.snd, other.snd);
  }

  //# Pair#fantasy-land/lte :: (Ord a, Ord b) => Pair a b ~> Pair a b -> Boolean
  //.
  //. `Pair (x) (y)` is less than or equal to `Pair (v) (w)` [iff][] `x` is
  //. less than `v` or `x` is equal to `v` and `y` is less than or equal to
  //. `w` according to [`Z.lte`][].
  //.
  //. ```javascript
  //. > S.filter (S.lte (Pair ('b') (2)))
  //. .          ([Pair ('a') (1), Pair ('a') (2), Pair ('a') (3),
  //. .            Pair ('b') (1), Pair ('b') (2), Pair ('b') (3),
  //. .            Pair ('c') (1), Pair ('c') (2), Pair ('c') (3)])
  //. [ Pair ('a') (1),
  //. . Pair ('a') (2),
  //. . Pair ('a') (3),
  //. . Pair ('b') (1),
  //. . Pair ('b') (2) ]
  //. ```
  function Pair$prototype$lte(other) {
    return Z.equals (this.fst, other.fst) ? Z.lte (this.snd, other.snd)
                                          : Z.lte (this.fst, other.fst);
  }

  //# Pair#fantasy-land/compose :: Pair a b ~> Pair b c -> Pair a c
  //.
  //. `compose (Pair (x) (y)) (Pair (v) (w))` is equivalent to `Pair (v) (y)`.
  //.
  //. ```javascript
  //. > S.compose (Pair ('a') (0)) (Pair ([1, 2, 3]) ('b'))
  //. Pair ([1, 2, 3]) (0)
  //. ```
  function Pair$prototype$compose(other) {
    return Pair (this.fst) (other.snd);
  }

  //# Pair#fantasy-land/concat :: (Semigroup a, Semigroup b) => Pair a b ~> Pair a b -> Pair a b
  //.
  //. `concat (Pair (x) (y)) (Pair (v) (w))` is equivalent to
  //. `Pair (concat (x) (v)) (concat (y) (w))`.
  //.
  //. ```javascript
  //. > S.concat (Pair ('abc') ([1, 2, 3])) (Pair ('xyz') ([4, 5, 6]))
  //. Pair ('abcxyz') ([1, 2, 3, 4, 5, 6])
  //. ```
  function Pair$prototype$concat(other) {
    return Pair (Z.concat (this.fst, other.fst))
                (Z.concat (this.snd, other.snd));
  }

  //# Pair#fantasy-land/map :: Pair a b ~> (b -> c) -> Pair a c
  //.
  //. `map (f) (Pair (x) (y))` is equivalent to `Pair (x) (f (y))`.
  //.
  //. ```javascript
  //. > S.map (Math.sqrt) (Pair ('abc') (256))
  //. Pair ('abc') (16)
  //. ```
  function Pair$prototype$map(f) {
    return Pair (this.fst) (f (this.snd));
  }

  //# Pair#fantasy-land/bimap :: Pair a c ~> (a -> b, c -> d) -> Pair b d
  //.
  //. `bimap (f) (g) (Pair (x) (y))` is equivalent to `Pair (f (x)) (g (y))`.
  //.
  //. ```javascript
  //. > S.bimap (S.toUpper) (Math.sqrt) (Pair ('abc') (256))
  //. Pair ('ABC') (16)
  //. ```
  function Pair$prototype$bimap(f, g) {
    return Pair (f (this.fst)) (g (this.snd));
  }

  //# Pair#fantasy-land/ap :: Semigroup a => Pair a b ~> Pair a (b -> c) -> Pair a c
  //.
  //. `ap (Pair (v) (f)) (Pair (x) (y))` is equivalent to
  //. `Pair (concat (v) (x)) (f (y))`.
  //.
  //. ```javascript
  //. > S.ap (Pair ('abc') (Math.sqrt)) (Pair ('xyz') (256))
  //. Pair ('abcxyz') (16)
  //. ```
  function Pair$prototype$ap(other) {
    return Pair (Z.concat (other.fst, this.fst)) (other.snd (this.snd));
  }

  //# Pair#fantasy-land/chain :: Semigroup a => Pair a b ~> (b -> Pair a c) -> Pair a c
  //.
  //. `chain (f) (Pair (x) (y))` is equivalent to
  //. `Pair (concat (x) (fst (f (y)))) (snd (f (y)))`.
  //.
  //. ```javascript
  //. > S.chain (n => Pair (show (n)) (Math.sqrt (n))) (Pair ('abc') (256))
  //. Pair ('abc256') (16)
  //. ```
  function Pair$prototype$chain(f) {
    var other = f (this.snd);
    return Pair (Z.concat (this.fst, other.fst)) (other.snd);
  }

  //# Pair#fantasy-land/reduce :: Pair a b ~> ((c, b) -> c, c) -> c
  //.
  //. `reduce (f) (x) (Pair (v) (w))` is equivalent to `f (x) (w)`.
  //.
  //. ```javascript
  //. > S.reduce (S.concat) ([1, 2, 3]) (Pair ('abc') ([4, 5, 6]))
  //. [1, 2, 3, 4, 5, 6]
  //. ```
  function Pair$prototype$reduce(f, x) {
    return f (x, this.snd);
  }

  //# Pair#fantasy-land/traverse :: Applicative f => Pair a b ~> (TypeRep f, b -> f c) -> f (Pair a c)
  //.
  //. `traverse (_) (f) (Pair (x) (y))` is equivalent to
  //. `map (Pair (x)) (f (y))`.
  //.
  //. ```javascript
  //. > S.traverse (Array) (S.words) (Pair (123) ('foo bar baz'))
  //. [Pair (123) ('foo'), Pair (123) ('bar'), Pair (123) ('baz')]
  //. ```
  function Pair$prototype$traverse(typeRep, f) {
    return Z.map (Pair (this.fst), f (this.snd));
  }

  //# Pair#fantasy-land/extend :: Pair a b ~> (Pair a b -> c) -> Pair a c
  //.
  //. `extend (f) (Pair (x) (y))` is equivalent to
  //. `Pair (x) (f (Pair (x) (y)))`.
  //.
  //. ```javascript
  //. > S.extend (S.reduce (S.add) (1)) (Pair ('abc') (99))
  //. Pair ('abc') (100)
  //. ```
  function Pair$prototype$extend(f) {
    return Pair (this.fst) (f (this));
  }

  //# Pair#fantasy-land/extract :: Pair a b ~> () -> b
  //.
  //. `extract (Pair (x) (y))` is equivalent to `y`.
  //.
  //. ```javascript
  //. > S.extract (Pair ('abc') ([1, 2, 3]))
  //. [1, 2, 3]
  //. ```
  function Pair$prototype$extract() {
    return this.snd;
  }

  return Pair;

}));

//. [Fantasy Land]:             v:fantasyland/fantasy-land
//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals
//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte
//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if
//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers
//. [type representative]:      v:fantasyland/fantasy-land#type-representatives


/***/ }),

/***/ "./node_modules/sanctuary-show/index.js":
/*!**********************************************!*\
  !*** ./node_modules/sanctuary-show/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//. # sanctuary-show
//.
//. Haskell has a `show` function which can be applied to a compatible value to
//. produce a descriptive string representation of that value. The idea is that
//. the string representation should, if possible, be an expression which would
//. produce the original value if evaluated.
//.
//. This library provides a similar [`show`](#show) function.
//.
//. In general, this property should hold: `eval (show (x)) = x`. In some cases
//. parens are necessary to ensure correct interpretation (`{}`, for example,
//. is an empty block rather than an empty object in some contexts). Thus the
//. property is more accurately stated `eval ('(' + show (x) + ')') = x`.
//.
//. One can make values of a custom type compatible with [`show`](#show) by
//. defining a `@@show` method. For example:
//.
//. ```javascript
//. //# Maybe#@@show :: Maybe a ~> () -> String
//. //.
//. //. ```javascript
//. //. > show (Nothing)
//. //. 'Nothing'
//. //.
//. //. > show (Just (['foo', 'bar', 'baz']))
//. //. 'Just (["foo", "bar", "baz"])'
//. //. ```
//. Maybe.prototype['@@show'] = function() {
//.   return this.isNothing ? 'Nothing' : 'Just (' + show (this.value) + ')';
//. };
//. ```

(function(f) {

  'use strict';

  /* istanbul ignore else */
  if ( true && typeof module.exports === 'object') {
    module.exports = f();
  } else if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    self.sanctuaryShow = f();
  }

}(function() {

  'use strict';

  //  $$show :: String
  var $$show = '@@show';

  //  seen :: Array Any
  var seen = [];

  //  entry :: Object -> String -> String
  function entry(o) {
    return function(k) {
      return show(k) + ': ' + show(o[k]);
    };
  }

  //# show :: Showable a => a -> String
  //.
  //. Returns a useful string representation of the given value.
  //.
  //. Dispatches to the value's `@@show` method if present.
  //.
  //. Where practical, `show (eval ('(' + show (x) + ')')) = show (x)`.
  //.
  //. ```javascript
  //. > show (null)
  //. 'null'
  //.
  //. > show (undefined)
  //. 'undefined'
  //.
  //. > show (true)
  //. 'true'
  //.
  //. > show (new Boolean (false))
  //. 'new Boolean (false)'
  //.
  //. > show (-0)
  //. '-0'
  //.
  //. > show (NaN)
  //. 'NaN'
  //.
  //. > show (new Number (Infinity))
  //. 'new Number (Infinity)'
  //.
  //. > show ('foo\n"bar"\nbaz\n')
  //. '"foo\\n\\"bar\\"\\nbaz\\n"'
  //.
  //. > show (new String (''))
  //. 'new String ("")'
  //.
  //. > show (['foo', 'bar', 'baz'])
  //. '["foo", "bar", "baz"]'
  //.
  //. > show ([[[[[0]]]]])
  //. '[[[[[0]]]]]'
  //.
  //. > show ({x: [1, 2], y: [3, 4], z: [5, 6]})
  //. '{"x": [1, 2], "y": [3, 4], "z": [5, 6]}'
  //. ```
  function show(x) {
    if (seen.indexOf(x) >= 0) return '<Circular>';

    switch (Object.prototype.toString.call(x)) {

      case '[object Boolean]':
        return typeof x === 'object' ?
          'new Boolean (' + show(x.valueOf()) + ')' :
          x.toString();

      case '[object Number]':
        return typeof x === 'object' ?
          'new Number (' + show(x.valueOf()) + ')' :
          1 / x === -Infinity ? '-0' : x.toString(10);

      case '[object String]':
        return typeof x === 'object' ?
          'new String (' + show(x.valueOf()) + ')' :
          JSON.stringify(x);

      case '[object Date]':
        return 'new Date (' +
               show(isNaN(x.valueOf()) ? NaN : x.toISOString()) +
               ')';

      case '[object Error]':
        return 'new ' + x.name + ' (' + show(x.message) + ')';

      case '[object Arguments]':
        return 'function () { return arguments; } (' +
               Array.prototype.map.call(x, show).join(', ') +
               ')';

      case '[object Array]':
        seen.push(x);
        try {
          return '[' + x.map(show).concat(
            Object.keys(x)
            .sort()
            .filter(function(k) { return !/^\d+$/.test(k); })
            .map(entry(x))
          ).join(', ') + ']';
        } finally {
          seen.pop();
        }

      case '[object Object]':
        seen.push(x);
        try {
          return (
            $$show in x &&
            (x.constructor == null || x.constructor.prototype !== x) ?
              x[$$show]() :
              '{' + Object.keys(x).sort().map(entry(x)).join(', ') + '}'
          );
        } finally {
          seen.pop();
        }

      default:
        return String(x);

    }
  }

  return show;

}));


/***/ }),

/***/ "./node_modules/sanctuary-type-classes/index.js":
/*!******************************************************!*\
  !*** ./node_modules/sanctuary-type-classes/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
             ############                  #
            ############                  ###
                  #####                  #####
                #####      ####################
              #####       ######################
            #####                     ###########
          #####         ######################
        #####          ####################
      #####                        #####
     ############                 ###
    ############                 */

//. # sanctuary-type-classes
//.
//. The [Fantasy Land Specification][FL] "specifies interoperability of common
//. algebraic structures" by defining a number of type classes. For each type
//. class, it states laws which every member of a type must obey in order for
//. the type to be a member of the type class. In order for the Maybe type to
//. be considered a [Functor][], for example, every `Maybe a` value must have
//. a `fantasy-land/map` method which obeys the identity and composition laws.
//.
//. This project provides:
//.
//.   - [`TypeClass`](#TypeClass), a function for defining type classes;
//.   - one `TypeClass` value for each Fantasy Land type class;
//.   - lawful Fantasy Land methods for JavaScript's built-in types;
//.   - one function for each Fantasy Land method; and
//.   - several functions derived from these functions.
//.
//. ## Type-class hierarchy
//.
/* eslint-disable max-len */
//. <pre>
//.  Setoid   Semigroupoid  Semigroup   Foldable        Functor      Contravariant  Filterable
//. (equals)    (compose)    (concat)   (reduce)         (map)        (contramap)    (filter)
//.     |           |           |           \         / | | | | \
//.     |           |           |            \       /  | | | |  \
//.     |           |           |             \     /   | | | |   \
//.     |           |           |              \   /    | | | |    \
//.     |           |           |               \ /     | | | |     \
//.    Ord      Category     Monoid         Traversable | | | |      \
//.   (lte)       (id)       (empty)        (traverse)  / | | \       \
//.                             |                      /  | |  \       \
//.                             |                     /   / \   \       \
//.                             |             Profunctor /   \ Bifunctor \
//.                             |              (promap) /     \ (bimap)   \
//.                             |                      /       \           \
//.                           Group                   /         \           \
//.                          (invert)               Alt        Apply      Extend
//.                                                (alt)        (ap)     (extend)
//.                                                 /           / \           \
//.                                                /           /   \           \
//.                                               /           /     \           \
//.                                              /           /       \           \
//.                                             /           /         \           \
//.                                           Plus    Applicative    Chain      Comonad
//.                                          (zero)       (of)      (chain)    (extract)
//.                                             \         / \         / \
//.                                              \       /   \       /   \
//.                                               \     /     \     /     \
//.                                                \   /       \   /       \
//.                                                 \ /         \ /         \
//.                                             Alternative    Monad     ChainRec
//.                                                                     (chainRec)
//. </pre>
/* eslint-enable max-len */
//.
//. ## API

(function(f) {

  'use strict';

  /* istanbul ignore else */
  if ( true && typeof module.exports === 'object') {
    module.exports = f(__webpack_require__(/*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-classes/node_modules/sanctuary-type-identifiers/index.js"));
  } else if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-classes/node_modules/sanctuary-type-identifiers/index.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    self.sanctuaryTypeClasses = f(self.sanctuaryTypeIdentifiers);
  }

}(function(type) {

  'use strict';

  /* istanbul ignore if */
  if (typeof __doctest !== 'undefined') {
    /* global __doctest:false */
    /* eslint-disable no-unused-vars */
    var Identity = __doctest.require('./test/Identity');
    var List = __doctest.require('./test/List');
    var Maybe = __doctest.require('./test/Maybe');
    var Sum = __doctest.require('./test/Sum');
    var Tuple = __doctest.require('./test/Tuple');

    var Nil = List.Nil, Cons = List.Cons;
    var Nothing = Maybe.Nothing, Just = Maybe.Just;
    /* eslint-enable no-unused-vars */
  }

  //  concat_ :: Array a -> Array a -> Array a
  function concat_(xs) {
    return function(ys) {
      return xs.concat(ys);
    };
  }

  //  constant :: a -> b -> a
  function constant(x) {
    return function(y) {
      return x;
    };
  }

  //  forEachKey :: (StrMap a, StrMap a ~> String -> Undefined) -> Undefined
  function forEachKey(strMap, f) {
    Object.keys(strMap).forEach(f, strMap);
  }

  //  has :: (String, Object) -> Boolean
  function has(k, o) {
    return Object.prototype.hasOwnProperty.call(o, k);
  }

  //  identity :: a -> a
  function identity(x) { return x; }

  //  pair :: a -> b -> Array2 a b
  function pair(x) {
    return function(y) {
      return [x, y];
    };
  }

  //  sameType :: (a, b) -> Boolean
  function sameType(x, y) {
    return typeof x === typeof y && type(x) === type(y);
  }

  //  thrush :: a -> (a -> b) -> b
  function thrush(x) {
    return function(f) {
      return f(x);
    };
  }

  //  type Iteration a = { value :: a, done :: Boolean }

  //  iterationNext :: a -> Iteration a
  function iterationNext(x) { return {value: x, done: false}; }

  //  iterationDone :: a -> Iteration a
  function iterationDone(x) { return {value: x, done: true}; }

  //# TypeClass :: (String, String, Array TypeClass, a -> Boolean) -> TypeClass
  //.
  //. The arguments are:
  //.
  //.   - the name of the type class, prefixed by its npm package name;
  //.   - the documentation URL of the type class;
  //.   - an array of dependencies; and
  //.   - a predicate which accepts any JavaScript value and returns `true`
  //.     if the value satisfies the requirements of the type class; `false`
  //.     otherwise.
  //.
  //. Example:
  //.
  //. ```javascript
  //. //    hasMethod :: String -> a -> Boolean
  //. const hasMethod = name => x => x != null && typeof x[name] == 'function';
  //.
  //. //    Foo :: TypeClass
  //. const Foo = Z.TypeClass(
  //.   'my-package/Foo',
  //.   'http://example.com/my-package#Foo',
  //.   [],
  //.   hasMethod('foo')
  //. );
  //.
  //. //    Bar :: TypeClass
  //. const Bar = Z.TypeClass(
  //.   'my-package/Bar',
  //.   'http://example.com/my-package#Bar',
  //.   [Foo],
  //.   hasMethod('bar')
  //. );
  //. ```
  //.
  //. Types whose values have a `foo` method are members of the Foo type class.
  //. Members of the Foo type class whose values have a `bar` method are also
  //. members of the Bar type class.
  //.
  //. Each `TypeClass` value has a `test` field: a function which accepts
  //. any JavaScript value and returns `true` if the value satisfies the
  //. type class's predicate and the predicates of all the type class's
  //. dependencies; `false` otherwise.
  //.
  //. `TypeClass` values may be used with [sanctuary-def][type-classes]
  //. to define parametrically polymorphic functions which verify their
  //. type-class constraints at run time.
  function TypeClass(name, url, dependencies, test) {
    if (!(this instanceof TypeClass)) {
      return new TypeClass(name, url, dependencies, test);
    }
    this.name = name;
    this.url = url;
    this.test = function(x) {
      return dependencies.every(function(d) { return d.test(x); }) && test(x);
    };
  }

  TypeClass['@@type'] = 'sanctuary-type-classes/TypeClass';

  //  data Location = Constructor | Value

  //  Constructor :: Location
  var Constructor = 'Constructor';

  //  Value :: Location
  var Value = 'Value';

  //  _funcPath :: (Boolean, Array String, a) -> Nullable Function
  function _funcPath(allowInheritedProps, path, _x) {
    var x = _x;
    for (var idx = 0; idx < path.length; idx += 1) {
      var k = path[idx];
      if (x == null || !(allowInheritedProps || has(k, x))) return null;
      x = x[k];
    }
    return typeof x === 'function' ? x : null;
  }

  //  funcPath :: (Array String, a) -> Nullable Function
  function funcPath(path, x) {
    return _funcPath(true, path, x);
  }

  //  implPath :: Array String -> Nullable Function
  function implPath(path) {
    return _funcPath(false, path, implementations);
  }

  //  functionName :: Function -> String
  var functionName = has('name', function f() {}) ?
    function functionName(f) { return f.name; } :
    /* istanbul ignore next */
    function functionName(f) {
      var match = /function (\w*)/.exec(f);
      return match == null ? '' : match[1];
    };

  //  $ :: (String, Array TypeClass, StrMap (Array Location)) -> TypeClass
  function $(_name, dependencies, requirements) {
    function getBoundMethod(_name) {
      var name = 'fantasy-land/' + _name;
      return requirements[_name] === Constructor ?
        function(typeRep) {
          var f = funcPath([name], typeRep);
          return f == null && typeof typeRep === 'function' ?
            implPath([functionName(typeRep), name]) :
            f;
        } :
        function(x) {
          var isPrototype = x != null &&
                            x.constructor != null &&
                            x.constructor.prototype === x;
          var m = null;
          if (!isPrototype) m = funcPath([name], x);
          if (m == null)    m = implPath([type(x), 'prototype', name]);
          return m && m.bind(x);
        };
    }

    var version = '9.0.0';  // updated programmatically
    var keys = Object.keys(requirements);

    var typeClass = TypeClass(
      'sanctuary-type-classes/' + _name,
      'https://github.com/sanctuary-js/sanctuary-type-classes/tree/v' + version
        + '#' + _name,
      dependencies,
      function(x) {
        return keys.every(function(_name) {
          var arg = requirements[_name] === Constructor ? x.constructor : x;
          return getBoundMethod(_name)(arg) != null;
        });
      }
    );

    typeClass.methods = keys.reduce(function(methods, _name) {
      methods[_name] = getBoundMethod(_name);
      return methods;
    }, {});

    return typeClass;
  }

  //# Setoid :: TypeClass
  //.
  //. `TypeClass` value for [Setoid][].
  //.
  //. ```javascript
  //. > Setoid.test(null)
  //. true
  //. ```
  var Setoid = $('Setoid', [], {equals: Value});

  //# Ord :: TypeClass
  //.
  //. `TypeClass` value for [Ord][].
  //.
  //. ```javascript
  //. > Ord.test(0)
  //. true
  //.
  //. > Ord.test(Math.sqrt)
  //. false
  //. ```
  var Ord = $('Ord', [Setoid], {lte: Value});

  //# Semigroupoid :: TypeClass
  //.
  //. `TypeClass` value for [Semigroupoid][].
  //.
  //. ```javascript
  //. > Semigroupoid.test(Math.sqrt)
  //. true
  //.
  //. > Semigroupoid.test(0)
  //. false
  //. ```
  var Semigroupoid = $('Semigroupoid', [], {compose: Value});

  //# Category :: TypeClass
  //.
  //. `TypeClass` value for [Category][].
  //.
  //. ```javascript
  //. > Category.test(Math.sqrt)
  //. true
  //.
  //. > Category.test(0)
  //. false
  //. ```
  var Category = $('Category', [Semigroupoid], {id: Constructor});

  //# Semigroup :: TypeClass
  //.
  //. `TypeClass` value for [Semigroup][].
  //.
  //. ```javascript
  //. > Semigroup.test('')
  //. true
  //.
  //. > Semigroup.test(0)
  //. false
  //. ```
  var Semigroup = $('Semigroup', [], {concat: Value});

  //# Monoid :: TypeClass
  //.
  //. `TypeClass` value for [Monoid][].
  //.
  //. ```javascript
  //. > Monoid.test('')
  //. true
  //.
  //. > Monoid.test(0)
  //. false
  //. ```
  var Monoid = $('Monoid', [Semigroup], {empty: Constructor});

  //# Group :: TypeClass
  //.
  //. `TypeClass` value for [Group][].
  //.
  //. ```javascript
  //. > Group.test(Sum(0))
  //. true
  //.
  //. > Group.test('')
  //. false
  //. ```
  var Group = $('Group', [Monoid], {invert: Value});

  //# Filterable :: TypeClass
  //.
  //. `TypeClass` value for [Filterable][].
  //.
  //. ```javascript
  //. > Filterable.test({})
  //. true
  //.
  //. > Filterable.test('')
  //. false
  //. ```
  var Filterable = $('Filterable', [], {filter: Value});

  //# Functor :: TypeClass
  //.
  //. `TypeClass` value for [Functor][].
  //.
  //. ```javascript
  //. > Functor.test([])
  //. true
  //.
  //. > Functor.test('')
  //. false
  //. ```
  var Functor = $('Functor', [], {map: Value});

  //# Bifunctor :: TypeClass
  //.
  //. `TypeClass` value for [Bifunctor][].
  //.
  //. ```javascript
  //. > Bifunctor.test(Tuple('foo', 64))
  //. true
  //.
  //. > Bifunctor.test([])
  //. false
  //. ```
  var Bifunctor = $('Bifunctor', [Functor], {bimap: Value});

  //# Profunctor :: TypeClass
  //.
  //. `TypeClass` value for [Profunctor][].
  //.
  //. ```javascript
  //. > Profunctor.test(Math.sqrt)
  //. true
  //.
  //. > Profunctor.test([])
  //. false
  //. ```
  var Profunctor = $('Profunctor', [Functor], {promap: Value});

  //# Apply :: TypeClass
  //.
  //. `TypeClass` value for [Apply][].
  //.
  //. ```javascript
  //. > Apply.test([])
  //. true
  //.
  //. > Apply.test('')
  //. false
  //. ```
  var Apply = $('Apply', [Functor], {ap: Value});

  //# Applicative :: TypeClass
  //.
  //. `TypeClass` value for [Applicative][].
  //.
  //. ```javascript
  //. > Applicative.test([])
  //. true
  //.
  //. > Applicative.test({})
  //. false
  //. ```
  var Applicative = $('Applicative', [Apply], {of: Constructor});

  //# Chain :: TypeClass
  //.
  //. `TypeClass` value for [Chain][].
  //.
  //. ```javascript
  //. > Chain.test([])
  //. true
  //.
  //. > Chain.test({})
  //. false
  //. ```
  var Chain = $('Chain', [Apply], {chain: Value});

  //# ChainRec :: TypeClass
  //.
  //. `TypeClass` value for [ChainRec][].
  //.
  //. ```javascript
  //. > ChainRec.test([])
  //. true
  //.
  //. > ChainRec.test({})
  //. false
  //. ```
  var ChainRec = $('ChainRec', [Chain], {chainRec: Constructor});

  //# Monad :: TypeClass
  //.
  //. `TypeClass` value for [Monad][].
  //.
  //. ```javascript
  //. > Monad.test([])
  //. true
  //.
  //. > Monad.test({})
  //. false
  //. ```
  var Monad = $('Monad', [Applicative, Chain], {});

  //# Alt :: TypeClass
  //.
  //. `TypeClass` value for [Alt][].
  //.
  //. ```javascript
  //. > Alt.test({})
  //. true
  //.
  //. > Alt.test('')
  //. false
  //. ```
  var Alt = $('Alt', [Functor], {alt: Value});

  //# Plus :: TypeClass
  //.
  //. `TypeClass` value for [Plus][].
  //.
  //. ```javascript
  //. > Plus.test({})
  //. true
  //.
  //. > Plus.test('')
  //. false
  //. ```
  var Plus = $('Plus', [Alt], {zero: Constructor});

  //# Alternative :: TypeClass
  //.
  //. `TypeClass` value for [Alternative][].
  //.
  //. ```javascript
  //. > Alternative.test([])
  //. true
  //.
  //. > Alternative.test({})
  //. false
  //. ```
  var Alternative = $('Alternative', [Applicative, Plus], {});

  //# Foldable :: TypeClass
  //.
  //. `TypeClass` value for [Foldable][].
  //.
  //. ```javascript
  //. > Foldable.test({})
  //. true
  //.
  //. > Foldable.test('')
  //. false
  //. ```
  var Foldable = $('Foldable', [], {reduce: Value});

  //# Traversable :: TypeClass
  //.
  //. `TypeClass` value for [Traversable][].
  //.
  //. ```javascript
  //. > Traversable.test([])
  //. true
  //.
  //. > Traversable.test('')
  //. false
  //. ```
  var Traversable = $('Traversable', [Functor, Foldable], {traverse: Value});

  //# Extend :: TypeClass
  //.
  //. `TypeClass` value for [Extend][].
  //.
  //. ```javascript
  //. > Extend.test([])
  //. true
  //.
  //. > Extend.test({})
  //. false
  //. ```
  var Extend = $('Extend', [Functor], {extend: Value});

  //# Comonad :: TypeClass
  //.
  //. `TypeClass` value for [Comonad][].
  //.
  //. ```javascript
  //. > Comonad.test(Identity(0))
  //. true
  //.
  //. > Comonad.test([])
  //. false
  //. ```
  var Comonad = $('Comonad', [Extend], {extract: Value});

  //# Contravariant :: TypeClass
  //.
  //. `TypeClass` value for [Contravariant][].
  //.
  //. ```javascript
  //. > Contravariant.test(Math.sqrt)
  //. true
  //.
  //. > Contravariant.test([])
  //. false
  //. ```
  var Contravariant = $('Contravariant', [], {contramap: Value});

  //  Null$prototype$equals :: Null ~> Null -> Boolean
  function Null$prototype$equals(other) {
    return true;
  }

  //  Null$prototype$lte :: Null ~> Null -> Boolean
  function Null$prototype$lte(other) {
    return true;
  }

  //  Undefined$prototype$equals :: Undefined ~> Undefined -> Boolean
  function Undefined$prototype$equals(other) {
    return true;
  }

  //  Undefined$prototype$lte :: Undefined ~> Undefined -> Boolean
  function Undefined$prototype$lte(other) {
    return true;
  }

  //  Boolean$prototype$equals :: Boolean ~> Boolean -> Boolean
  function Boolean$prototype$equals(other) {
    return typeof this === 'object' ?
      equals(this.valueOf(), other.valueOf()) :
      this === other;
  }

  //  Boolean$prototype$lte :: Boolean ~> Boolean -> Boolean
  function Boolean$prototype$lte(other) {
    return typeof this === 'object' ?
      lte(this.valueOf(), other.valueOf()) :
      this === false || other === true;
  }

  //  Number$prototype$equals :: Number ~> Number -> Boolean
  function Number$prototype$equals(other) {
    return typeof this === 'object' ?
      equals(this.valueOf(), other.valueOf()) :
      isNaN(this) && isNaN(other) || this === other;
  }

  //  Number$prototype$lte :: Number ~> Number -> Boolean
  function Number$prototype$lte(other) {
    return typeof this === 'object' ?
      lte(this.valueOf(), other.valueOf()) :
      isNaN(this) || this <= other;
  }

  //  Date$prototype$equals :: Date ~> Date -> Boolean
  function Date$prototype$equals(other) {
    return equals(this.valueOf(), other.valueOf());
  }

  //  Date$prototype$lte :: Date ~> Date -> Boolean
  function Date$prototype$lte(other) {
    return lte(this.valueOf(), other.valueOf());
  }

  //  RegExp$prototype$equals :: RegExp ~> RegExp -> Boolean
  function RegExp$prototype$equals(other) {
    return other.source === this.source &&
           other.global === this.global &&
           other.ignoreCase === this.ignoreCase &&
           other.multiline === this.multiline &&
           other.sticky === this.sticky &&
           other.unicode === this.unicode;
  }

  //  String$empty :: () -> String
  function String$empty() {
    return '';
  }

  //  String$prototype$equals :: String ~> String -> Boolean
  function String$prototype$equals(other) {
    return typeof this === 'object' ?
      equals(this.valueOf(), other.valueOf()) :
      this === other;
  }

  //  String$prototype$lte :: String ~> String -> Boolean
  function String$prototype$lte(other) {
    return typeof this === 'object' ?
      lte(this.valueOf(), other.valueOf()) :
      this <= other;
  }

  //  String$prototype$concat :: String ~> String -> String
  function String$prototype$concat(other) {
    return this + other;
  }

  //  Array$empty :: () -> Array a
  function Array$empty() {
    return [];
  }

  //  Array$of :: a -> Array a
  function Array$of(x) {
    return [x];
  }

  //  Array$chainRec :: ((a -> c, b -> c, a) -> Array c, a) -> Array b
  function Array$chainRec(f, x) {
    var result = [];
    var nil = {};
    var todo = {head: x, tail: nil};
    while (todo !== nil) {
      var more = nil;
      var steps = f(iterationNext, iterationDone, todo.head);
      for (var idx = 0; idx < steps.length; idx += 1) {
        var step = steps[idx];
        if (step.done) {
          result.push(step.value);
        } else {
          more = {head: step.value, tail: more};
        }
      }
      todo = todo.tail;
      while (more !== nil) {
        todo = {head: more.head, tail: todo};
        more = more.tail;
      }
    }
    return result;
  }

  //  Array$zero :: () -> Array a
  function Array$zero() {
    return [];
  }

  //  Array$prototype$equals :: Array a ~> Array a -> Boolean
  function Array$prototype$equals(other) {
    if (other.length !== this.length) return false;
    for (var idx = 0; idx < this.length; idx += 1) {
      if (!equals(this[idx], other[idx])) return false;
    }
    return true;
  }

  //  Array$prototype$lte :: Array a ~> Array a -> Boolean
  function Array$prototype$lte(other) {
    for (var idx = 0; true; idx += 1) {
      if (idx === this.length) return true;
      if (idx === other.length) return false;
      if (!equals(this[idx], other[idx])) return lte(this[idx], other[idx]);
    }
  }

  //  Array$prototype$concat :: Array a ~> Array a -> Array a
  function Array$prototype$concat(other) {
    return this.concat(other);
  }

  //  Array$prototype$filter :: Array a ~> (a -> Boolean) -> Array a
  function Array$prototype$filter(pred) {
    return this.filter(function(x) { return pred(x); });
  }

  //  Array$prototype$map :: Array a ~> (a -> b) -> Array b
  function Array$prototype$map(f) {
    return this.map(function(x) { return f(x); });
  }

  //  Array$prototype$ap :: Array a ~> Array (a -> b) -> Array b
  function Array$prototype$ap(fs) {
    var result = [];
    for (var idx = 0; idx < fs.length; idx += 1) {
      for (var idx2 = 0; idx2 < this.length; idx2 += 1) {
        result.push(fs[idx](this[idx2]));
      }
    }
    return result;
  }

  //  Array$prototype$chain :: Array a ~> (a -> Array b) -> Array b
  function Array$prototype$chain(f) {
    var result = [];
    for (var idx = 0; idx < this.length; idx += 1) {
      for (var idx2 = 0, xs = f(this[idx]); idx2 < xs.length; idx2 += 1) {
        result.push(xs[idx2]);
      }
    }
    return result;
  }

  //  Array$prototype$alt :: Array a ~> Array a -> Array a
  var Array$prototype$alt = Array$prototype$concat;

  //  Array$prototype$reduce :: Array a ~> ((b, a) -> b, b) -> b
  function Array$prototype$reduce(f, initial) {
    var acc = initial;
    for (var idx = 0; idx < this.length; idx += 1) acc = f(acc, this[idx]);
    return acc;
  }

  //  Array$prototype$traverse :: Applicative f => Array a ~> (TypeRep f, a -> f b) -> f (Array b)
  function Array$prototype$traverse(typeRep, f) {
    var xs = this;
    function go(idx, n) {
      switch (n) {
        case 0: return of(typeRep, []);
        case 2: return lift2(pair, f(xs[idx]), f(xs[idx + 1]));
        default:
          var m = Math.floor(n / 4) * 2;
          return lift2(concat_, go(idx, m), go(idx + m, n - m));
      }
    }
    return this.length % 2 === 1 ?
      lift2(concat_, map(Array$of, f(this[0])), go(1, this.length - 1)) :
      go(0, this.length);
  }

  //  Array$prototype$extend :: Array a ~> (Array a -> b) -> Array b
  function Array$prototype$extend(f) {
    return this.map(function(_, idx, xs) { return f(xs.slice(idx)); });
  }

  //  Arguments$prototype$equals :: Arguments ~> Arguments -> Boolean
  function Arguments$prototype$equals(other) {
    return Array$prototype$equals.call(this, other);
  }

  //  Arguments$prototype$lte :: Arguments ~> Arguments -> Boolean
  function Arguments$prototype$lte(other) {
    return Array$prototype$lte.call(this, other);
  }

  //  Error$prototype$equals :: Error ~> Error -> Boolean
  function Error$prototype$equals(other) {
    return equals(this.name, other.name) &&
           equals(this.message, other.message);
  }

  //  Object$empty :: () -> StrMap a
  function Object$empty() {
    return {};
  }

  //  Object$zero :: () -> StrMap a
  function Object$zero() {
    return {};
  }

  //  Object$prototype$equals :: StrMap a ~> StrMap a -> Boolean
  function Object$prototype$equals(other) {
    var self = this;
    var keys = Object.keys(this).sort();
    return equals(keys, Object.keys(other).sort()) &&
           keys.every(function(k) { return equals(self[k], other[k]); });
  }

  //  Object$prototype$lte :: StrMap a ~> StrMap a -> Boolean
  function Object$prototype$lte(other) {
    var theseKeys = Object.keys(this).sort();
    var otherKeys = Object.keys(other).sort();
    while (true) {
      if (theseKeys.length === 0) return true;
      if (otherKeys.length === 0) return false;
      var k = theseKeys.shift();
      var z = otherKeys.shift();
      if (k < z) return true;
      if (k > z) return false;
      if (!equals(this[k], other[k])) return lte(this[k], other[k]);
    }
  }

  //  Object$prototype$concat :: StrMap a ~> StrMap a -> StrMap a
  function Object$prototype$concat(other) {
    var result = {};
    function assign(k) { result[k] = this[k]; }
    forEachKey(this, assign);
    forEachKey(other, assign);
    return result;
  }

  //  Object$prototype$filter :: StrMap a ~> (a -> Boolean) -> StrMap a
  function Object$prototype$filter(pred) {
    var result = {};
    forEachKey(this, function(k) { if (pred(this[k])) result[k] = this[k]; });
    return result;
  }

  //  Object$prototype$map :: StrMap a ~> (a -> b) -> StrMap b
  function Object$prototype$map(f) {
    var result = {};
    forEachKey(this, function(k) { result[k] = f(this[k]); });
    return result;
  }

  //  Object$prototype$ap :: StrMap a ~> StrMap (a -> b) -> StrMap b
  function Object$prototype$ap(other) {
    var result = {};
    forEachKey(this, function(k) {
      if (has(k, other)) result[k] = other[k](this[k]);
    });
    return result;
  }

  //  Object$prototype$alt :: StrMap a ~> StrMap a -> StrMap a
  var Object$prototype$alt = Object$prototype$concat;

  //  Object$prototype$reduce :: StrMap a ~> ((b, a) -> b, b) -> b
  function Object$prototype$reduce(f, initial) {
    var self = this;
    function reducer(acc, k) { return f(acc, self[k]); }
    return Object.keys(this).sort().reduce(reducer, initial);
  }

  //  Object$prototype$traverse :: Applicative f => StrMap a ~> (TypeRep f, a -> f b) -> f (StrMap b)
  function Object$prototype$traverse(typeRep, f) {
    var self = this;
    return Object.keys(this).reduce(function(applicative, k) {
      function set(o) {
        return function(v) {
          var singleton = {}; singleton[k] = v;
          return Object$prototype$concat.call(o, singleton);
        };
      }
      return lift2(set, applicative, f(self[k]));
    }, of(typeRep, {}));
  }

  //  Function$id :: () -> a -> a
  function Function$id() {
    return identity;
  }

  //  Function$of :: b -> (a -> b)
  function Function$of(x) {
    return function(_) { return x; };
  }

  //  Function$chainRec :: ((a -> c, b -> c, a) -> (z -> c), a) -> (z -> b)
  function Function$chainRec(f, x) {
    return function(a) {
      var step = iterationNext(x);
      while (!step.done) {
        step = f(iterationNext, iterationDone, step.value)(a);
      }
      return step.value;
    };
  }

  //  Function$prototype$equals :: Function ~> Function -> Boolean
  function Function$prototype$equals(other) {
    return other === this;
  }

  //  Function$prototype$compose :: (a -> b) ~> (b -> c) -> (a -> c)
  function Function$prototype$compose(other) {
    var semigroupoid = this;
    return function(x) { return other(semigroupoid(x)); };
  }

  //  Function$prototype$map :: (a -> b) ~> (b -> c) -> (a -> c)
  function Function$prototype$map(f) {
    var functor = this;
    return function(x) { return f(functor(x)); };
  }

  //  Function$prototype$promap :: (b -> c) ~> (a -> b, c -> d) -> (a -> d)
  function Function$prototype$promap(f, g) {
    var profunctor = this;
    return function(x) { return g(profunctor(f(x))); };
  }

  //  Function$prototype$ap :: (a -> b) ~> (a -> b -> c) -> (a -> c)
  function Function$prototype$ap(f) {
    var apply = this;
    return function(x) { return f(x)(apply(x)); };
  }

  //  Function$prototype$chain :: (a -> b) ~> (b -> a -> c) -> (a -> c)
  function Function$prototype$chain(f) {
    var chain = this;
    return function(x) { return f(chain(x))(x); };
  }

  //  Function$prototype$extend :: Semigroup a => (a -> b) ~> ((a -> b) -> c) -> (a -> c)
  function Function$prototype$extend(f) {
    var extend = this;
    return function(x) {
      return f(function(y) { return extend(concat(x, y)); });
    };
  }

  //  Function$prototype$contramap :: (b -> c) ~> (a -> b) -> (a -> c)
  function Function$prototype$contramap(f) {
    var contravariant = this;
    return function(x) { return contravariant(f(x)); };
  }

  /* eslint-disable key-spacing */
  var implementations = {
    Null: {
      'prototype': {
        'fantasy-land/equals':      Null$prototype$equals,
        'fantasy-land/lte':         Null$prototype$lte
      }
    },
    Undefined: {
      'prototype': {
        'fantasy-land/equals':      Undefined$prototype$equals,
        'fantasy-land/lte':         Undefined$prototype$lte
      }
    },
    Boolean: {
      'prototype': {
        'fantasy-land/equals':      Boolean$prototype$equals,
        'fantasy-land/lte':         Boolean$prototype$lte
      }
    },
    Number: {
      'prototype': {
        'fantasy-land/equals':      Number$prototype$equals,
        'fantasy-land/lte':         Number$prototype$lte
      }
    },
    Date: {
      'prototype': {
        'fantasy-land/equals':      Date$prototype$equals,
        'fantasy-land/lte':         Date$prototype$lte
      }
    },
    RegExp: {
      'prototype': {
        'fantasy-land/equals':      RegExp$prototype$equals
      }
    },
    String: {
      'fantasy-land/empty':         String$empty,
      'prototype': {
        'fantasy-land/equals':      String$prototype$equals,
        'fantasy-land/lte':         String$prototype$lte,
        'fantasy-land/concat':      String$prototype$concat
      }
    },
    Array: {
      'fantasy-land/empty':         Array$empty,
      'fantasy-land/of':            Array$of,
      'fantasy-land/chainRec':      Array$chainRec,
      'fantasy-land/zero':          Array$zero,
      'prototype': {
        'fantasy-land/equals':      Array$prototype$equals,
        'fantasy-land/lte':         Array$prototype$lte,
        'fantasy-land/concat':      Array$prototype$concat,
        'fantasy-land/filter':      Array$prototype$filter,
        'fantasy-land/map':         Array$prototype$map,
        'fantasy-land/ap':          Array$prototype$ap,
        'fantasy-land/chain':       Array$prototype$chain,
        'fantasy-land/alt':         Array$prototype$alt,
        'fantasy-land/reduce':      Array$prototype$reduce,
        'fantasy-land/traverse':    Array$prototype$traverse,
        'fantasy-land/extend':      Array$prototype$extend
      }
    },
    Arguments: {
      'prototype': {
        'fantasy-land/equals':      Arguments$prototype$equals,
        'fantasy-land/lte':         Arguments$prototype$lte
      }
    },
    Error: {
      'prototype': {
        'fantasy-land/equals':      Error$prototype$equals
      }
    },
    Object: {
      'fantasy-land/empty':         Object$empty,
      'fantasy-land/zero':          Object$zero,
      'prototype': {
        'fantasy-land/equals':      Object$prototype$equals,
        'fantasy-land/lte':         Object$prototype$lte,
        'fantasy-land/concat':      Object$prototype$concat,
        'fantasy-land/filter':      Object$prototype$filter,
        'fantasy-land/map':         Object$prototype$map,
        'fantasy-land/ap':          Object$prototype$ap,
        'fantasy-land/alt':         Object$prototype$alt,
        'fantasy-land/reduce':      Object$prototype$reduce,
        'fantasy-land/traverse':    Object$prototype$traverse
      }
    },
    Function: {
      'fantasy-land/id':            Function$id,
      'fantasy-land/of':            Function$of,
      'fantasy-land/chainRec':      Function$chainRec,
      'prototype': {
        'fantasy-land/equals':      Function$prototype$equals,
        'fantasy-land/compose':     Function$prototype$compose,
        'fantasy-land/map':         Function$prototype$map,
        'fantasy-land/promap':      Function$prototype$promap,
        'fantasy-land/ap':          Function$prototype$ap,
        'fantasy-land/chain':       Function$prototype$chain,
        'fantasy-land/extend':      Function$prototype$extend,
        'fantasy-land/contramap':   Function$prototype$contramap
      }
    }
  };
  /* eslint-enable key-spacing */

  //# equals :: (a, b) -> Boolean
  //.
  //. Returns `true` if its arguments are of the same type and equal according
  //. to the type's [`fantasy-land/equals`][] method; `false` otherwise.
  //.
  //. `fantasy-land/equals` implementations are provided for the following
  //. built-in types: Null, Undefined, Boolean, Number, Date, RegExp, String,
  //. Array, Arguments, Error, Object, and Function.
  //.
  //. The algorithm supports circular data structures. Two arrays are equal
  //. if they have the same index paths and for each path have equal values.
  //. Two arrays which represent `[1, [1, [1, [1, [1, ...]]]]]`, for example,
  //. are equal even if their internal structures differ. Two objects are equal
  //. if they have the same property paths and for each path have equal values.
  //.
  //. ```javascript
  //. > equals(0, -0)
  //. true
  //.
  //. > equals(NaN, NaN)
  //. true
  //.
  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('foo', Cons('bar', Nil)))
  //. true
  //.
  //. > equals(Cons('foo', Cons('bar', Nil)), Cons('bar', Cons('foo', Nil)))
  //. false
  //. ```
  var equals = (function() {
    //  $pairs :: Array (Array2 Any Any)
    var $pairs = [];

    return function equals(x, y) {
      if (!sameType(x, y)) return false;

      //  This algorithm for comparing circular data structures was
      //  suggested in <http://stackoverflow.com/a/40622794/312785>.
      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {
        return true;
      }

      $pairs.push([x, y]);
      try {
        return Setoid.test(x) && Setoid.test(y) && Setoid.methods.equals(x)(y);
      } finally {
        $pairs.pop();
      }
    };
  }());

  //# lt :: (a, b) -> Boolean
  //.
  //. Returns `true` if its arguments are of the same type and the first is
  //. less than the second according to the type's [`fantasy-land/lte`][]
  //. method; `false` otherwise.
  //.
  //. This function is derived from [`lte`](#lte).
  //.
  //. See also [`gt`](#gt) and [`gte`](#gte).
  //.
  //. ```javascript
  //. > lt(0, 0)
  //. false
  //.
  //. > lt(0, 1)
  //. true
  //.
  //. > lt(1, 0)
  //. false
  //. ```
  function lt(x, y) {
    return sameType(x, y) && !lte(y, x);
  }

  //# lte :: (a, b) -> Boolean
  //.
  //. Returns `true` if its arguments are of the same type and the first
  //. is less than or equal to the second according to the type's
  //. [`fantasy-land/lte`][] method; `false` otherwise.
  //.
  //. `fantasy-land/lte` implementations are provided for the following
  //. built-in types: Null, Undefined, Boolean, Number, Date, String, Array,
  //. Arguments, and Object.
  //.
  //. The algorithm supports circular data structures in the same manner as
  //. [`equals`](#equals).
  //.
  //. See also [`lt`](#lt), [`gt`](#gt), and [`gte`](#gte).
  //.
  //. ```javascript
  //. > lte(0, 0)
  //. true
  //.
  //. > lte(0, 1)
  //. true
  //.
  //. > lte(1, 0)
  //. false
  //. ```
  var lte = (function() {
    //  $pairs :: Array (Array2 Any Any)
    var $pairs = [];

    return function lte(x, y) {
      if (!sameType(x, y)) return false;

      //  This algorithm for comparing circular data structures was
      //  suggested in <http://stackoverflow.com/a/40622794/312785>.
      if ($pairs.some(function(p) { return p[0] === x && p[1] === y; })) {
        return equals(x, y);
      }

      $pairs.push([x, y]);
      try {
        return Ord.test(x) && Ord.test(y) && Ord.methods.lte(x)(y);
      } finally {
        $pairs.pop();
      }
    };
  }());

  //# gt :: (a, b) -> Boolean
  //.
  //. Returns `true` if its arguments are of the same type and the first is
  //. greater than the second according to the type's [`fantasy-land/lte`][]
  //. method; `false` otherwise.
  //.
  //. This function is derived from [`lte`](#lte).
  //.
  //. See also [`lt`](#lt) and [`gte`](#gte).
  //.
  //. ```javascript
  //. > gt(0, 0)
  //. false
  //.
  //. > gt(0, 1)
  //. false
  //.
  //. > gt(1, 0)
  //. true
  //. ```
  function gt(x, y) {
    return lt(y, x);
  }

  //# gte :: (a, b) -> Boolean
  //.
  //. Returns `true` if its arguments are of the same type and the first
  //. is greater than or equal to the second according to the type's
  //. [`fantasy-land/lte`][] method; `false` otherwise.
  //.
  //. This function is derived from [`lte`](#lte).
  //.
  //. See also [`lt`](#lt) and [`gt`](#gt).
  //.
  //. ```javascript
  //. > gte(0, 0)
  //. true
  //.
  //. > gte(0, 1)
  //. false
  //.
  //. > gte(1, 0)
  //. true
  //. ```
  function gte(x, y) {
    return lte(y, x);
  }

  //# min :: Ord a => (a, a) -> a
  //.
  //. Returns the smaller of its two arguments.
  //.
  //. This function is derived from [`lte`](#lte).
  //.
  //. See also [`max`](#max).
  //.
  //. ```javascript
  //. > min(10, 2)
  //. 2
  //.
  //. > min(new Date('1999-12-31'), new Date('2000-01-01'))
  //. new Date('1999-12-31')
  //.
  //. > min('10', '2')
  //. '10'
  //. ```
  function min(x, y) {
    return lte(x, y) ? x : y;
  }

  //# max :: Ord a => (a, a) -> a
  //.
  //. Returns the larger of its two arguments.
  //.
  //. This function is derived from [`lte`](#lte).
  //.
  //. See also [`min`](#min).
  //.
  //. ```javascript
  //. > max(10, 2)
  //. 10
  //.
  //. > max(new Date('1999-12-31'), new Date('2000-01-01'))
  //. new Date('2000-01-01')
  //.
  //. > max('10', '2')
  //. '2'
  //. ```
  function max(x, y) {
    return lte(x, y) ? y : x;
  }

  //# compose :: Semigroupoid c => (c j k, c i j) -> c i k
  //.
  //. Function wrapper for [`fantasy-land/compose`][].
  //.
  //. `fantasy-land/compose` implementations are provided for the following
  //. built-in types: Function.
  //.
  //. ```javascript
  //. > compose(Math.sqrt, x => x + 1)(99)
  //. 10
  //. ```
  function compose(x, y) {
    return Semigroupoid.methods.compose(y)(x);
  }

  //# id :: Category c => TypeRep c -> c
  //.
  //. Function wrapper for [`fantasy-land/id`][].
  //.
  //. `fantasy-land/id` implementations are provided for the following
  //. built-in types: Function.
  //.
  //. ```javascript
  //. > id(Function)('foo')
  //. 'foo'
  //. ```
  function id(typeRep) {
    return Category.methods.id(typeRep)();
  }

  //# concat :: Semigroup a => (a, a) -> a
  //.
  //. Function wrapper for [`fantasy-land/concat`][].
  //.
  //. `fantasy-land/concat` implementations are provided for the following
  //. built-in types: String, Array, and Object.
  //.
  //. ```javascript
  //. > concat('abc', 'def')
  //. 'abcdef'
  //.
  //. > concat([1, 2, 3], [4, 5, 6])
  //. [1, 2, 3, 4, 5, 6]
  //.
  //. > concat({x: 1, y: 2}, {y: 3, z: 4})
  //. {x: 1, y: 3, z: 4}
  //.
  //. > concat(Cons('foo', Cons('bar', Cons('baz', Nil))), Cons('quux', Nil))
  //. Cons('foo', Cons('bar', Cons('baz', Cons('quux', Nil))))
  //. ```
  function concat(x, y) {
    return Semigroup.methods.concat(x)(y);
  }

  //# empty :: Monoid m => TypeRep m -> m
  //.
  //. Function wrapper for [`fantasy-land/empty`][].
  //.
  //. `fantasy-land/empty` implementations are provided for the following
  //. built-in types: String, Array, and Object.
  //.
  //. ```javascript
  //. > empty(String)
  //. ''
  //.
  //. > empty(Array)
  //. []
  //.
  //. > empty(Object)
  //. {}
  //.
  //. > empty(List)
  //. Nil
  //. ```
  function empty(typeRep) {
    return Monoid.methods.empty(typeRep)();
  }

  //# invert :: Group g => g -> g
  //.
  //. Function wrapper for [`fantasy-land/invert`][].
  //.
  //. ```javascript
  //. > invert(Sum(5))
  //. Sum(-5)
  //. ```
  function invert(group) {
    return Group.methods.invert(group)();
  }

  //# filter :: Filterable f => (a -> Boolean, f a) -> f a
  //.
  //. Function wrapper for [`fantasy-land/filter`][]. Discards every element
  //. which does not satisfy the predicate.
  //.
  //. `fantasy-land/filter` implementations are provided for the following
  //. built-in types: Array and Object.
  //.
  //. See also [`reject`](#reject).
  //.
  //. ```javascript
  //. > filter(x => x % 2 == 1, [1, 2, 3])
  //. [1, 3]
  //.
  //. > filter(x => x % 2 == 1, {x: 1, y: 2, z: 3})
  //. {x: 1, z: 3}
  //.
  //. > filter(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))
  //. Cons(1, Cons(3, Nil))
  //.
  //. > filter(x => x % 2 == 1, Nothing)
  //. Nothing
  //.
  //. > filter(x => x % 2 == 1, Just(0))
  //. Nothing
  //.
  //. > filter(x => x % 2 == 1, Just(1))
  //. Just(1)
  //. ```
  function filter(pred, filterable) {
    return Filterable.methods.filter(filterable)(pred);
  }

  //# reject :: Filterable f => (a -> Boolean, f a) -> f a
  //.
  //. Discards every element which satisfies the predicate.
  //.
  //. This function is derived from [`filter`](#filter).
  //.
  //. ```javascript
  //. > reject(x => x % 2 == 1, [1, 2, 3])
  //. [2]
  //.
  //. > reject(x => x % 2 == 1, {x: 1, y: 2, z: 3})
  //. {y: 2}
  //.
  //. > reject(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))
  //. Cons(2, Nil)
  //.
  //. > reject(x => x % 2 == 1, Nothing)
  //. Nothing
  //.
  //. > reject(x => x % 2 == 1, Just(0))
  //. Just(0)
  //.
  //. > reject(x => x % 2 == 1, Just(1))
  //. Nothing
  //. ```
  function reject(pred, filterable) {
    return filter(function(x) { return !pred(x); }, filterable);
  }

  //# takeWhile :: Filterable f => (a -> Boolean, f a) -> f a
  //.
  //. Discards the first element which does not satisfy the predicate, and all
  //. subsequent elements.
  //.
  //. This function is derived from [`filter`](#filter).
  //.
  //. See also [`dropWhile`](#dropWhile).
  //.
  //. ```javascript
  //. > takeWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
  //. ['xy', 'xz', 'yx']
  //.
  //. > takeWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
  //. ['xy']
  //.
  //. > takeWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
  //. []
  //. ```
  function takeWhile(pred, filterable) {
    var take = true;
    return filter(function(x) { return take = take && pred(x); }, filterable);
  }

  //# dropWhile :: Filterable f => (a -> Boolean, f a) -> f a
  //.
  //. Retains the first element which does not satisfy the predicate, and all
  //. subsequent elements.
  //.
  //. This function is derived from [`filter`](#filter).
  //.
  //. See also [`takeWhile`](#takeWhile).
  //.
  //. ```javascript
  //. > dropWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
  //. ['yz', 'zx', 'zy']
  //.
  //. > dropWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
  //. ['xz', 'yx', 'yz', 'zx', 'zy']
  //.
  //. > dropWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
  //. ['xy', 'xz', 'yx', 'yz', 'zx', 'zy']
  //. ```
  function dropWhile(pred, filterable) {
    var take = false;
    return filter(function(x) { return take = take || !pred(x); }, filterable);
  }

  //# map :: Functor f => (a -> b, f a) -> f b
  //.
  //. Function wrapper for [`fantasy-land/map`][].
  //.
  //. `fantasy-land/map` implementations are provided for the following
  //. built-in types: Array, Object, and Function.
  //.
  //. ```javascript
  //. > map(Math.sqrt, [1, 4, 9])
  //. [1, 2, 3]
  //.
  //. > map(Math.sqrt, {x: 1, y: 4, z: 9})
  //. {x: 1, y: 2, z: 3}
  //.
  //. > map(Math.sqrt, s => s.length)('Sanctuary')
  //. 3
  //.
  //. > map(Math.sqrt, Tuple('foo', 64))
  //. Tuple('foo', 8)
  //.
  //. > map(Math.sqrt, Nil)
  //. Nil
  //.
  //. > map(Math.sqrt, Cons(1, Cons(4, Cons(9, Nil))))
  //. Cons(1, Cons(2, Cons(3, Nil)))
  //. ```
  function map(f, functor) {
    return Functor.methods.map(functor)(f);
  }

  //# flip :: Functor f => (f (a -> b), a) -> f b
  //.
  //. Maps over the given functions, applying each to the given value.
  //.
  //. This function is derived from [`map`](#map).
  //.
  //. ```javascript
  //. > flip(x => y => x + y, '!')('foo')
  //. 'foo!'
  //.
  //. > flip([Math.floor, Math.ceil], 1.5)
  //. [1, 2]
  //.
  //. > flip({floor: Math.floor, ceil: Math.ceil}, 1.5)
  //. {floor: 1, ceil: 2}
  //.
  //. > flip(Cons(Math.floor, Cons(Math.ceil, Nil)), 1.5)
  //. Cons(1, Cons(2, Nil))
  //. ```
  function flip(functor, x) {
    return Functor.methods.map(functor)(thrush(x));
  }

  //# bimap :: Bifunctor f => (a -> b, c -> d, f a c) -> f b d
  //.
  //. Function wrapper for [`fantasy-land/bimap`][].
  //.
  //. ```javascript
  //. > bimap(s => s.toUpperCase(), Math.sqrt, Tuple('foo', 64))
  //. Tuple('FOO', 8)
  //. ```
  function bimap(f, g, bifunctor) {
    return Bifunctor.methods.bimap(bifunctor)(f, g);
  }

  //# mapLeft :: Bifunctor f => (a -> b, f a c) -> f b c
  //.
  //. Maps the given function over the left side of a Bifunctor.
  //.
  //. ```javascript
  //. > mapLeft(Math.sqrt, Tuple(64, 9))
  //. Tuple(8, 9)
  //. ```
  function mapLeft(f, bifunctor) {
    return bimap(f, identity, bifunctor);
  }

  //# promap :: Profunctor p => (a -> b, c -> d, p b c) -> p a d
  //.
  //. Function wrapper for [`fantasy-land/promap`][].
  //.
  //. `fantasy-land/promap` implementations are provided for the following
  //. built-in types: Function.
  //.
  //. ```javascript
  //. > promap(Math.abs, x => x + 1, Math.sqrt)(-100)
  //. 11
  //. ```
  function promap(f, g, profunctor) {
    return Profunctor.methods.promap(profunctor)(f, g);
  }

  //# ap :: Apply f => (f (a -> b), f a) -> f b
  //.
  //. Function wrapper for [`fantasy-land/ap`][].
  //.
  //. `fantasy-land/ap` implementations are provided for the following
  //. built-in types: Array, Object, and Function.
  //.
  //. ```javascript
  //. > ap([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])
  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]
  //.
  //. > ap({a: Math.sqrt, b: x => x * x}, {a: 16, b: 10, c: 1})
  //. {a: 4, b: 100}
  //.
  //. > ap(s => n => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')
  //. 'Hask'
  //.
  //. > ap(Identity(Math.sqrt), Identity(64))
  //. Identity(8)
  //.
  //. > ap(Cons(Math.sqrt, Cons(x => x * x, Nil)), Cons(16, Cons(100, Nil)))
  //. Cons(4, Cons(10, Cons(256, Cons(10000, Nil))))
  //. ```
  function ap(applyF, applyX) {
    return Apply.methods.ap(applyX)(applyF);
  }

  //# lift2 :: Apply f => (a -> b -> c, f a, f b) -> f c
  //.
  //. Lifts `a -> b -> c` to `Apply f => f a -> f b -> f c` and returns the
  //. result of applying this to the given arguments.
  //.
  //. This function is derived from [`map`](#map) and [`ap`](#ap).
  //.
  //. See also [`lift3`](#lift3).
  //.
  //. ```javascript
  //. > lift2(x => y => Math.pow(x, y), [10], [1, 2, 3])
  //. [10, 100, 1000]
  //.
  //. > lift2(x => y => Math.pow(x, y), Identity(10), Identity(3))
  //. Identity(1000)
  //. ```
  function lift2(f, x, y) {
    return ap(map(f, x), y);
  }

  //# lift3 :: Apply f => (a -> b -> c -> d, f a, f b, f c) -> f d
  //.
  //. Lifts `a -> b -> c -> d` to `Apply f => f a -> f b -> f c -> f d` and
  //. returns the result of applying this to the given arguments.
  //.
  //. This function is derived from [`map`](#map) and [`ap`](#ap).
  //.
  //. See also [`lift2`](#lift2).
  //.
  //. ```javascript
  //. > lift3(x => y => z => x + z + y, ['<'], ['>'], ['foo', 'bar', 'baz'])
  //. ['<foo>', '<bar>', '<baz>']
  //.
  //. > lift3(x => y => z => x + z + y, Identity('<'), Identity('>'), Identity('baz'))
  //. Identity('<baz>')
  //. ```
  function lift3(f, x, y, z) {
    return ap(ap(map(f, x), y), z);
  }

  //# apFirst :: Apply f => (f a, f b) -> f a
  //.
  //. Combines two effectful actions, keeping only the result of the first.
  //. Equivalent to Haskell's `(<*)` function.
  //.
  //. This function is derived from [`lift2`](#lift2).
  //.
  //. See also [`apSecond`](#apSecond).
  //.
  //. ```javascript
  //. > apFirst([1, 2], [3, 4])
  //. [1, 1, 2, 2]
  //.
  //. > apFirst(Identity(1), Identity(2))
  //. Identity(1)
  //. ```
  function apFirst(x, y) {
    return lift2(constant, x, y);
  }

  //# apSecond :: Apply f => (f a, f b) -> f b
  //.
  //. Combines two effectful actions, keeping only the result of the second.
  //. Equivalent to Haskell's `(*>)` function.
  //.
  //. This function is derived from [`lift2`](#lift2).
  //.
  //. See also [`apFirst`](#apFirst).
  //.
  //. ```javascript
  //. > apSecond([1, 2], [3, 4])
  //. [3, 4, 3, 4]
  //.
  //. > apSecond(Identity(1), Identity(2))
  //. Identity(2)
  //. ```
  function apSecond(x, y) {
    return lift2(constant(identity), x, y);
  }

  //# of :: Applicative f => (TypeRep f, a) -> f a
  //.
  //. Function wrapper for [`fantasy-land/of`][].
  //.
  //. `fantasy-land/of` implementations are provided for the following
  //. built-in types: Array and Function.
  //.
  //. ```javascript
  //. > of(Array, 42)
  //. [42]
  //.
  //. > of(Function, 42)(null)
  //. 42
  //.
  //. > of(List, 42)
  //. Cons(42, Nil)
  //. ```
  function of(typeRep, x) {
    return Applicative.methods.of(typeRep)(x);
  }

  //# append :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a
  //.
  //. Returns the result of appending the first argument to the second.
  //.
  //. This function is derived from [`concat`](#concat) and [`of`](#of).
  //.
  //. See also [`prepend`](#prepend).
  //.
  //. ```javascript
  //. > append(3, [1, 2])
  //. [1, 2, 3]
  //.
  //. > append(3, Cons(1, Cons(2, Nil)))
  //. Cons(1, Cons(2, Cons(3, Nil)))
  //. ```
  function append(x, xs) {
    return concat(xs, of(xs.constructor, x));
  }

  //# prepend :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a
  //.
  //. Returns the result of prepending the first argument to the second.
  //.
  //. This function is derived from [`concat`](#concat) and [`of`](#of).
  //.
  //. See also [`append`](#append).
  //.
  //. ```javascript
  //. > prepend(1, [2, 3])
  //. [1, 2, 3]
  //.
  //. > prepend(1, Cons(2, Cons(3, Nil)))
  //. Cons(1, Cons(2, Cons(3, Nil)))
  //. ```
  function prepend(x, xs) {
    return concat(of(xs.constructor, x), xs);
  }

  //# chain :: Chain m => (a -> m b, m a) -> m b
  //.
  //. Function wrapper for [`fantasy-land/chain`][].
  //.
  //. `fantasy-land/chain` implementations are provided for the following
  //. built-in types: Array and Function.
  //.
  //. ```javascript
  //. > chain(x => [x, x], [1, 2, 3])
  //. [1, 1, 2, 2, 3, 3]
  //.
  //. > chain(x => x % 2 == 1 ? of(List, x) : Nil, Cons(1, Cons(2, Cons(3, Nil))))
  //. Cons(1, Cons(3, Nil))
  //.
  //. > chain(n => s => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')
  //. 'Hask'
  //. ```
  function chain(f, chain_) {
    return Chain.methods.chain(chain_)(f);
  }

  //# join :: Chain m => m (m a) -> m a
  //.
  //. Removes one level of nesting from a nested monadic structure.
  //.
  //. This function is derived from [`chain`](#chain).
  //.
  //. ```javascript
  //. > join([[1], [2], [3]])
  //. [1, 2, 3]
  //.
  //. > join([[[1, 2, 3]]])
  //. [[1, 2, 3]]
  //.
  //. > join(Identity(Identity(1)))
  //. Identity(1)
  //. ```
  function join(chain_) {
    return chain(identity, chain_);
  }

  //# chainRec :: ChainRec m => (TypeRep m, (a -> c, b -> c, a) -> m c, a) -> m b
  //.
  //. Function wrapper for [`fantasy-land/chainRec`][].
  //.
  //. `fantasy-land/chainRec` implementations are provided for the following
  //. built-in types: Array.
  //.
  //. ```javascript
  //. > chainRec(
  //. .   Array,
  //. .   (next, done, s) => s.length == 2 ? [s + '!', s + '?'].map(done)
  //. .                                    : [s + 'o', s + 'n'].map(next),
  //. .   ''
  //. . )
  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']
  //. ```
  function chainRec(typeRep, f, x) {
    return ChainRec.methods.chainRec(typeRep)(f, x);
  }

  //# alt :: Alt f => (f a, f a) -> f a
  //.
  //. Function wrapper for [`fantasy-land/alt`][].
  //.
  //. `fantasy-land/alt` implementations are provided for the following
  //. built-in types: Array and Object.
  //.
  //. ```javascript
  //. > alt([1, 2, 3], [4, 5, 6])
  //. [1, 2, 3, 4, 5, 6]
  //.
  //. > alt(Nothing, Nothing)
  //. Nothing
  //.
  //. > alt(Nothing, Just(1))
  //. Just(1)
  //.
  //. > alt(Just(2), Just(3))
  //. Just(2)
  //. ```
  function alt(x, y) {
    return Alt.methods.alt(x)(y);
  }

  //# zero :: Plus f => TypeRep f -> f a
  //.
  //. Function wrapper for [`fantasy-land/zero`][].
  //.
  //. `fantasy-land/zero` implementations are provided for the following
  //. built-in types: Array and Object.
  //.
  //. ```javascript
  //. > zero(Array)
  //. []
  //.
  //. > zero(Object)
  //. {}
  //.
  //. > zero(Maybe)
  //. Nothing
  //. ```
  function zero(typeRep) {
    return Plus.methods.zero(typeRep)();
  }

  //# reduce :: Foldable f => ((b, a) -> b, b, f a) -> b
  //.
  //. Function wrapper for [`fantasy-land/reduce`][].
  //.
  //. `fantasy-land/reduce` implementations are provided for the following
  //. built-in types: Array and Object.
  //.
  //. ```javascript
  //. > reduce((xs, x) => [x].concat(xs), [], [1, 2, 3])
  //. [3, 2, 1]
  //.
  //. > reduce(concat, '', Cons('foo', Cons('bar', Cons('baz', Nil))))
  //. 'foobarbaz'
  //. ```
  function reduce(f, x, foldable) {
    return Foldable.methods.reduce(foldable)(f, x);
  }

  //# size :: Foldable f => f a -> Integer
  //.
  //. Returns the number of elements of the given structure.
  //.
  //. This function is derived from [`reduce`](#reduce).
  //.
  //. ```javascript
  //. > size([])
  //. 0
  //.
  //. > size(['foo', 'bar', 'baz'])
  //. 3
  //.
  //. > size(Nil)
  //. 0
  //.
  //. > size(Cons('foo', Cons('bar', Cons('baz', Nil))))
  //. 3
  //. ```
  function size(foldable) {
    //  Fast path for arrays.
    if (Array.isArray(foldable)) return foldable.length;
    return reduce(function(n, _) { return n + 1; }, 0, foldable);
  }

  //# elem :: (Setoid a, Foldable f) => (a, f a) -> Boolean
  //.
  //. Takes a value and a structure and returns `true` if the
  //. value is an element of the structure; `false` otherwise.
  //.
  //. This function is derived from [`equals`](#equals) and
  //. [`reduce`](#reduce).
  //.
  //. ```javascript
  //. > elem('c', ['a', 'b', 'c'])
  //. true
  //.
  //. > elem('x', ['a', 'b', 'c'])
  //. false
  //.
  //. > elem(3, {x: 1, y: 2, z: 3})
  //. true
  //.
  //. > elem(8, {x: 1, y: 2, z: 3})
  //. false
  //.
  //. > elem(0, Just(0))
  //. true
  //.
  //. > elem(0, Just(1))
  //. false
  //.
  //. > elem(0, Nothing)
  //. false
  //. ```
  function elem(x, foldable) {
    return reduce(function(b, y) { return b || equals(x, y); },
                  false,
                  foldable);
  }

  //# foldMap :: (Monoid m, Foldable f) => (TypeRep m, a -> m, f a) -> m
  //.
  //. Deconstructs a foldable by mapping every element to a monoid and
  //. concatenating the results.
  //.
  //. This function is derived from [`concat`](#concat), [`empty`](#empty),
  //. and [`reduce`](#reduce).
  //.
  //. ```javascript
  //. > foldMap(String, f => f.name, [Math.sin, Math.cos, Math.tan])
  //. 'sincostan'
  //. ```
  function foldMap(typeRep, f, foldable) {
    return reduce(function(monoid, x) { return concat(monoid, f(x)); },
                  empty(typeRep),
                  foldable);
  }

  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a
  //.
  //. Reverses the elements of the given structure.
  //.
  //. This function is derived from [`concat`](#concat), [`empty`](#empty),
  //. [`of`](#of), and [`reduce`](#reduce).
  //.
  //. ```javascript
  //. > reverse([1, 2, 3])
  //. [3, 2, 1]
  //.
  //. > reverse(Cons(1, Cons(2, Cons(3, Nil))))
  //. Cons(3, Cons(2, Cons(1, Nil)))
  //. ```
  function reverse(foldable) {
    //  Fast path for arrays.
    if (Array.isArray(foldable)) return foldable.slice().reverse();
    var F = foldable.constructor;
    return reduce(function(xs, x) { return concat(of(F, x), xs); },
                  empty(F),
                  foldable);
  }

  //# sort :: (Ord a, Applicative f, Foldable f, Monoid (f a)) => f a -> f a
  //.
  //. Performs a [stable sort][] of the elements of the given structure,
  //. using [`lte`](#lte) for comparisons.
  //.
  //. This function is derived from [`lte`](#lte), [`concat`](#concat),
  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).
  //.
  //. See also [`sortBy`](#sortBy).
  //.
  //. ```javascript
  //. > sort(['foo', 'bar', 'baz'])
  //. ['bar', 'baz', 'foo']
  //.
  //. > sort([Just(2), Nothing, Just(1)])
  //. [Nothing, Just(1), Just(2)]
  //.
  //. > sort(Cons('foo', Cons('bar', Cons('baz', Nil))))
  //. Cons('bar', Cons('baz', Cons('foo', Nil)))
  //. ```
  function sort(foldable) {
    return sortBy(identity, foldable);
  }

  //# sortBy :: (Ord b, Applicative f, Foldable f, Monoid (f a)) => (a -> b, f a) -> f a
  //.
  //. Performs a [stable sort][] of the elements of the given structure,
  //. using [`lte`](#lte) to compare the values produced by applying the
  //. given function to each element of the structure.
  //.
  //. This function is derived from [`lte`](#lte), [`concat`](#concat),
  //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).
  //.
  //. See also [`sort`](#sort).
  //.
  //. ```javascript
  //. > sortBy(s => s.length, ['red', 'green', 'blue'])
  //. ['red', 'blue', 'green']
  //.
  //. > sortBy(s => s.length, ['black', 'white'])
  //. ['black', 'white']
  //.
  //. > sortBy(s => s.length, ['white', 'black'])
  //. ['white', 'black']
  //.
  //. > sortBy(s => s.length, Cons('red', Cons('green', Cons('blue', Nil))))
  //. Cons('red', Cons('blue', Cons('green', Nil)))
  //. ```
  function sortBy(f, foldable) {
    var rs = reduce(function(rs, x) {
      rs.push({idx: rs.length, x: x, fx: f(x)});
      return rs;
    }, [], foldable);

    var lte_ = (function(r) {
      switch (typeof (r && r.fx)) {
        case 'number':  return function(x, y) { return x <= y || x !== x; };
        case 'string':  return function(x, y) { return x <= y; };
        default:        return lte;
      }
    }(rs[0]));

    rs.sort(function(a, b) {
      return lte_(a.fx, b.fx) ? lte_(b.fx, a.fx) ? a.idx - b.idx : -1 : 1;
    });

    if (Array.isArray(foldable)) {
      for (var idx = 0; idx < rs.length; idx += 1) rs[idx] = rs[idx].x;
      return rs;
    }

    var F = foldable.constructor;
    var result = empty(F);
    for (idx = 0; idx < rs.length; idx += 1) {
      result = concat(result, of(F, rs[idx].x));
    }
    return result;
  }

  //# traverse :: (Applicative f, Traversable t) => (TypeRep f, a -> f b, t a) -> f (t b)
  //.
  //. Function wrapper for [`fantasy-land/traverse`][].
  //.
  //. `fantasy-land/traverse` implementations are provided for the following
  //. built-in types: Array and Object.
  //.
  //. See also [`sequence`](#sequence).
  //.
  //. ```javascript
  //. > traverse(Array, x => x, [[1, 2, 3], [4, 5]])
  //. [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
  //.
  //. > traverse(Identity, x => Identity(x + 1), [1, 2, 3])
  //. Identity([2, 3, 4])
  //. ```
  function traverse(typeRep, f, traversable) {
    return Traversable.methods.traverse(traversable)(typeRep, f);
  }

  //# sequence :: (Applicative f, Traversable t) => (TypeRep f, t (f a)) -> f (t a)
  //.
  //. Inverts the given `t (f a)` to produce an `f (t a)`.
  //.
  //. This function is derived from [`traverse`](#traverse).
  //.
  //. ```javascript
  //. > sequence(Array, Identity([1, 2, 3]))
  //. [Identity(1), Identity(2), Identity(3)]
  //.
  //. > sequence(Identity, [Identity(1), Identity(2), Identity(3)])
  //. Identity([1, 2, 3])
  //. ```
  function sequence(typeRep, traversable) {
    return traverse(typeRep, identity, traversable);
  }

  //# extend :: Extend w => (w a -> b, w a) -> w b
  //.
  //. Function wrapper for [`fantasy-land/extend`][].
  //.
  //. `fantasy-land/extend` implementations are provided for the following
  //. built-in types: Array and Function.
  //.
  //. ```javascript
  //. > extend(ss => ss.join(''), ['x', 'y', 'z'])
  //. ['xyz', 'yz', 'z']
  //.
  //. > extend(f => f([3, 4]), reverse)([1, 2])
  //. [4, 3, 2, 1]
  //. ```
  function extend(f, extend_) {
    return Extend.methods.extend(extend_)(f);
  }

  //# duplicate :: Extend w => w a -> w (w a)
  //.
  //. Adds one level of nesting to a comonadic structure.
  //.
  //. This function is derived from [`extend`](#extend).
  //.
  //. ```javascript
  //. > duplicate(Identity(1))
  //. Identity(Identity(1))
  //.
  //. > duplicate([1])
  //. [[1]]
  //.
  //. > duplicate([1, 2, 3])
  //. [[1, 2, 3], [2, 3], [3]]
  //.
  //. > duplicate(reverse)([1, 2])([3, 4])
  //. [4, 3, 2, 1]
  //. ```
  function duplicate(extend_) {
    return extend(identity, extend_);
  }

  //# extract :: Comonad w => w a -> a
  //.
  //. Function wrapper for [`fantasy-land/extract`][].
  //.
  //. ```javascript
  //. > extract(Identity(42))
  //. 42
  //. ```
  function extract(comonad) {
    return Comonad.methods.extract(comonad)();
  }

  //# contramap :: Contravariant f => (b -> a, f a) -> f b
  //.
  //. Function wrapper for [`fantasy-land/contramap`][].
  //.
  //. `fantasy-land/contramap` implementations are provided for the following
  //. built-in types: Function.
  //.
  //. ```javascript
  //. > contramap(s => s.length, Math.sqrt)('Sanctuary')
  //. 3
  //. ```
  function contramap(f, contravariant) {
    return Contravariant.methods.contramap(contravariant)(f);
  }

  return {
    TypeClass: TypeClass,
    Setoid: Setoid,
    Ord: Ord,
    Semigroupoid: Semigroupoid,
    Category: Category,
    Semigroup: Semigroup,
    Monoid: Monoid,
    Group: Group,
    Filterable: Filterable,
    Functor: Functor,
    Bifunctor: Bifunctor,
    Profunctor: Profunctor,
    Apply: Apply,
    Applicative: Applicative,
    Chain: Chain,
    ChainRec: ChainRec,
    Monad: Monad,
    Alt: Alt,
    Plus: Plus,
    Alternative: Alternative,
    Foldable: Foldable,
    Traversable: Traversable,
    Extend: Extend,
    Comonad: Comonad,
    Contravariant: Contravariant,
    equals: equals,
    lt: lt,
    lte: lte,
    gt: gt,
    gte: gte,
    min: min,
    max: max,
    compose: compose,
    id: id,
    concat: concat,
    empty: empty,
    invert: invert,
    filter: filter,
    reject: reject,
    map: map,
    flip: flip,
    bimap: bimap,
    mapLeft: mapLeft,
    promap: promap,
    ap: ap,
    lift2: lift2,
    lift3: lift3,
    apFirst: apFirst,
    apSecond: apSecond,
    of: of,
    append: append,
    prepend: prepend,
    chain: chain,
    join: join,
    chainRec: chainRec,
    alt: alt,
    zero: zero,
    reduce: reduce,
    size: size,
    elem: elem,
    foldMap: foldMap,
    reverse: reverse,
    sort: sort,
    sortBy: sortBy,
    takeWhile: takeWhile,
    dropWhile: dropWhile,
    traverse: traverse,
    sequence: sequence,
    extend: extend,
    duplicate: duplicate,
    extract: extract,
    contramap: contramap
  };

}));

//. [Alt]:                      v:fantasyland/fantasy-land#alt
//. [Alternative]:              v:fantasyland/fantasy-land#alternative
//. [Applicative]:              v:fantasyland/fantasy-land#applicative
//. [Apply]:                    v:fantasyland/fantasy-land#apply
//. [Bifunctor]:                v:fantasyland/fantasy-land#bifunctor
//. [Category]:                 v:fantasyland/fantasy-land#category
//. [Chain]:                    v:fantasyland/fantasy-land#chain
//. [ChainRec]:                 v:fantasyland/fantasy-land#chainrec
//. [Comonad]:                  v:fantasyland/fantasy-land#comonad
//. [Contravariant]:            v:fantasyland/fantasy-land#contravariant
//. [Extend]:                   v:fantasyland/fantasy-land#extend
//. [FL]:                       v:fantasyland/fantasy-land
//. [Filterable]:               v:fantasyland/fantasy-land#filterable
//. [Foldable]:                 v:fantasyland/fantasy-land#foldable
//. [Functor]:                  v:fantasyland/fantasy-land#functor
//. [Group]:                    v:fantasyland/fantasy-land#group
//. [Monad]:                    v:fantasyland/fantasy-land#monad
//. [Monoid]:                   v:fantasyland/fantasy-land#monoid
//. [Ord]:                      v:fantasyland/fantasy-land#ord
//. [Plus]:                     v:fantasyland/fantasy-land#plus
//. [Profunctor]:               v:fantasyland/fantasy-land#profunctor
//. [Semigroup]:                v:fantasyland/fantasy-land#semigroup
//. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid
//. [Setoid]:                   v:fantasyland/fantasy-land#setoid
//. [Traversable]:              v:fantasyland/fantasy-land#traversable
//. [`fantasy-land/alt`]:       v:fantasyland/fantasy-land#alt-method
//. [`fantasy-land/ap`]:        v:fantasyland/fantasy-land#ap-method
//. [`fantasy-land/bimap`]:     v:fantasyland/fantasy-land#bimap-method
//. [`fantasy-land/chain`]:     v:fantasyland/fantasy-land#chain-method
//. [`fantasy-land/chainRec`]:  v:fantasyland/fantasy-land#chainrec-method
//. [`fantasy-land/compose`]:   v:fantasyland/fantasy-land#compose-method
//. [`fantasy-land/concat`]:    v:fantasyland/fantasy-land#concat-method
//. [`fantasy-land/contramap`]: v:fantasyland/fantasy-land#contramap-method
//. [`fantasy-land/empty`]:     v:fantasyland/fantasy-land#empty-method
//. [`fantasy-land/equals`]:    v:fantasyland/fantasy-land#equals-method
//. [`fantasy-land/extend`]:    v:fantasyland/fantasy-land#extend-method
//. [`fantasy-land/extract`]:   v:fantasyland/fantasy-land#extract-method
//. [`fantasy-land/filter`]:    v:fantasyland/fantasy-land#filter-method
//. [`fantasy-land/id`]:        v:fantasyland/fantasy-land#id-method
//. [`fantasy-land/invert`]:    v:fantasyland/fantasy-land#invert-method
//. [`fantasy-land/lte`]:       v:fantasyland/fantasy-land#lte-method
//. [`fantasy-land/map`]:       v:fantasyland/fantasy-land#map-method
//. [`fantasy-land/of`]:        v:fantasyland/fantasy-land#of-method
//. [`fantasy-land/promap`]:    v:fantasyland/fantasy-land#promap-method
//. [`fantasy-land/reduce`]:    v:fantasyland/fantasy-land#reduce-method
//. [`fantasy-land/traverse`]:  v:fantasyland/fantasy-land#traverse-method
//. [`fantasy-land/zero`]:      v:fantasyland/fantasy-land#zero-method
//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
//. [type-classes]:             https://github.com/sanctuary-js/sanctuary-def#type-classes


/***/ }),

/***/ "./node_modules/sanctuary-type-classes/node_modules/sanctuary-type-identifiers/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/sanctuary-type-classes/node_modules/sanctuary-type-identifiers/index.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
        @@@@@@@            @@@@@@@         @@
      @@       @@        @@       @@      @@@
    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@
   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@
   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@
   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@
    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@
      @@                 @@                           @@  @@
        @@@@@@@            @@@@@@@               @@@@@    @@
                                                          */
//. # sanctuary-type-identifiers
//.
//. A type is a set of values. Boolean, for example, is the type comprising
//. `true` and `false`. A value may be a member of multiple types (`42` is a
//. member of Number, PositiveNumber, Integer, and many other types).
//.
//. In certain situations it is useful to divide JavaScript values into
//. non-overlapping types. The language provides two constructs for this
//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].
//. Each has pros and cons, but neither supports user-defined types.
//.
//. This package specifies an [algorithm][3] for deriving a _type identifier_
//. from any JavaScript value, and exports an implementation of the algorithm.
//. Authors of algebraic data types may follow this specification in order to
//. make their data types compatible with the algorithm.
//.
//. ### Algorithm
//.
//. 1.  Take any JavaScript value `x`.
//.
//. 2.  If `x` is `null` or `undefined`, go to step 6.
//.
//. 3.  If `x.constructor` evaluates to `null` or `undefined`, go to step 6.
//.
//. 4.  If `x.constructor.prototype === x`, go to step 6. This check prevents a
//.     prototype object from being considered a member of its associated type.
//.
//. 5.  If `typeof x.constructor['@@type']` evaluates to `'string'`, return
//.     the value of `x.constructor['@@type']`.
//.
//. 6.  Return the [`Object.prototype.toString`][2] representation of `x`
//.     without the leading `'[object '` and trailing `']'`.
//.
//. ### Compatibility
//.
//. For an algebraic data type to be compatible with the [algorithm][3]:
//.
//.   - every member of the type must have a `constructor` property pointing
//.     to an object known as the _type representative_;
//.
//.   - the type representative must have a `@@type` property; and
//.
//.   - the type representative's `@@type` property (the _type identifier_)
//.     must be a string primitive, ideally `'<npm-package-name>/<type-name>'`.
//.
//. For example:
//.
//. ```javascript
//. //  Identity :: a -> Identity a
//. function Identity(x) {
//.   if (!(this instanceof Identity)) return new Identity(x);
//.   this.value = x;
//. }
//.
//. Identity['@@type'] = 'my-package/Identity';
//. ```
//.
//. Note that by using a constructor function the `constructor` property is set
//. implicitly for each value created. Constructor functions are convenient for
//. this reason, but are not required. This definition is also valid:
//.
//. ```javascript
//. //  IdentityTypeRep :: TypeRep Identity
//. var IdentityTypeRep = {
//.   '@@type': 'my-package/Identity'
//. };
//.
//. //  Identity :: a -> Identity a
//. function Identity(x) {
//.   return {constructor: IdentityTypeRep, value: x};
//. }
//. ```
//.
//. ### Usage
//.
//. ```javascript
//. var Identity = require('my-package').Identity;
//. var type = require('sanctuary-type-identifiers');
//.
//. type(null);         // => 'Null'
//. type(true);         // => 'Boolean'
//. type([1, 2, 3]);    // => 'Array'
//. type(Identity);     // => 'Function'
//. type(Identity(0));  // => 'my-package/Identity'
//. ```
//.
//.
//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
//. [3]: #algorithm

(function(f) {

  'use strict';

  if ( true && typeof module.exports === 'object') {
    module.exports = f();
  } else if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    self.sanctuaryTypeIdentifiers = f();
  }

}(function() {

  'use strict';

  //  $$type :: String
  var $$type = '@@type';

  //  type :: Any -> String
  function type(x) {
    return x != null &&
           x.constructor != null &&
           x.constructor.prototype !== x &&
           typeof x.constructor[$$type] === 'string' ?
      x.constructor[$$type] :
      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);
  }

  return type;

}));


/***/ }),

/***/ "./node_modules/sanctuary-type-identifiers/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/sanctuary-type-identifiers/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
        @@@@@@@            @@@@@@@         @@
      @@       @@        @@       @@      @@@
    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@
   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@
   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@
   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@
    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@
      @@                 @@                           @@  @@
        @@@@@@@            @@@@@@@               @@@@@    @@
                                                          */
//. # sanctuary-type-identifiers
//.
//. A type is a set of values. Boolean, for example, is the type comprising
//. `true` and `false`. A value may be a member of multiple types (`42` is a
//. member of Number, PositiveNumber, Integer, and many other types).
//.
//. In certain situations it is useful to divide JavaScript values into
//. non-overlapping types. The language provides two constructs for this
//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].
//. Each has pros and cons, but neither supports user-defined types.
//.
//. sanctuary-type-identifiers comprises:
//.
//.   - an npm and browser -compatible package for deriving the
//.     _type identifier_ of a JavaScript value; and
//.   - a specification which authors may follow to specify type
//.     identifiers for their types.
//.
//. ### Specification
//.
//. For a type to be compatible with the algorithm:
//.
//.   - every member of the type MUST have a `constructor` property
//.     pointing to an object known as the _type representative_;
//.
//.   - the type representative MUST have a `@@type` property
//.     (the _type identifier_); and
//.
//.   - the type identifier MUST be a string primitive and SHOULD have
//.     format `'<namespace>/<name>[@<version>]'`, where:
//.
//.       - `<namespace>` MUST consist of one or more characters, and
//.         SHOULD equal the name of the npm package which defines the
//.         type (including [scope][3] where appropriate);
//.
//.       - `<name>` MUST consist of one or more characters, and SHOULD
//.         be the unique name of the type; and
//.
//.       - `<version>` MUST consist of one or more digits, and SHOULD
//.         represent the version of the type.
//.
//. If the type identifier does not conform to the format specified above,
//. it is assumed that the entire string represents the _name_ of the type;
//. _namespace_ will be `null` and _version_ will be `0`.
//.
//. If the _version_ is not given, it is assumed to be `0`.
//.
//. For example:
//.
//. ```javascript
//. //  Identity :: a -> Identity a
//. function Identity(x) {
//.   if (!(this instanceof Identity)) return new Identity(x);
//.   this.value = x;
//. }
//.
//. Identity['@@type'] = 'my-package/Identity';
//. ```
//.
//. Note that by using a constructor function the `constructor` property is set
//. implicitly for each value created. Constructor functions are convenient for
//. this reason, but are not required. This definition is also valid:
//.
//. ```javascript
//. //  IdentityTypeRep :: TypeRep Identity
//. var IdentityTypeRep = {
//.   '@@type': 'my-package/Identity'
//. };
//.
//. //  Identity :: a -> Identity a
//. function Identity(x) {
//.   return {constructor: IdentityTypeRep, value: x};
//. }
//. ```

(function(f) {

  'use strict';

  if ( true && typeof module.exports === 'object') {
    module.exports = f();
  } else if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    self.sanctuaryTypeIdentifiers = f();
  }

}(function() {

  'use strict';

  //  $$type :: String
  var $$type = '@@type';

  //  pattern :: RegExp
  var pattern = new RegExp(
    '^'
  + '([\\s\\S]+)'   //  <namespace>
  + '/'             //  SOLIDUS (U+002F)
  + '([\\s\\S]+?)'  //  <name>
  + '(?:'           //  optional non-capturing group {
  +   '@'           //    COMMERCIAL AT (U+0040)
  +   '([0-9]+)'    //    <version>
  + ')?'            //  }
  + '$'
  );

  //. ### Usage
  //.
  //. ```javascript
  //. const type = require('sanctuary-type-identifiers');
  //. ```
  //.
  //. ```javascript
  //. > function Identity(x) {
  //. .   if (!(this instanceof Identity)) return new Identity(x);
  //. .   this.value = x;
  //. . }
  //. . Identity['@@type'] = 'my-package/Identity@1';
  //.
  //. > type.parse(type(Identity(0)))
  //. {namespace: 'my-package', name: 'Identity', version: 1}
  //. ```
  //.
  //. ### API
  //.
  //# type :: Any -> String
  //.
  //. Takes any value and returns a string which identifies its type. If the
  //. value conforms to the [specification][4], the custom type identifier is
  //. returned.
  //.
  //. ```javascript
  //. > type(null)
  //. 'Null'
  //.
  //. > type(true)
  //. 'Boolean'
  //.
  //. > type(Identity(0))
  //. 'my-package/Identity@1'
  //. ```
  function type(x) {
    return x != null &&
           x.constructor != null &&
           x.constructor.prototype !== x &&
           typeof x.constructor[$$type] === 'string' ?
      x.constructor[$$type] :
      Object.prototype.toString.call(x).slice('[object '.length, -']'.length);
  }

  //# type.parse :: String -> { namespace :: Nullable String, name :: String, version :: Number }
  //.
  //. Takes any string and parses it according to the [specification][4],
  //. returning an object with `namespace`, `name`, and `version` fields.
  //.
  //. ```javascript
  //. > type.parse('my-package/List@2')
  //. {namespace: 'my-package', name: 'List', version: 2}
  //.
  //. > type.parse('nonsense!')
  //. {namespace: null, name: 'nonsense!', version: 0}
  //.
  //. > type.parse(Identity['@@type'])
  //. {namespace: 'my-package', name: 'Identity', version: 1}
  //. ```
  type.parse = function parse(s) {
    var groups = pattern.exec(s);
    return {
      namespace: groups == null || groups[1] == null ? null : groups[1],
      name:      groups == null                      ? s    : groups[2],
      version:   groups == null || groups[3] == null ? 0    : Number(groups[3])
    };
  };

  return type;

}));

//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
//. [3]: https://docs.npmjs.com/misc/scope
//. [4]: #specification


/***/ }),

/***/ "./node_modules/sanctuary/index.js":
/*!*****************************************!*\
  !*** ./node_modules/sanctuary/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*    #######
   ####     ####
 ####   ###   ####
#####   ###########   sanctuary
########   ########   noun
###########   #####   1 [ mass noun ] refuge from unsafe JavaScript
 ####   ###   ####
   ####     ####
      #######    */

//. # Sanctuary
//.
//. [![npm](https://img.shields.io/npm/v/sanctuary.svg)](https://www.npmjs.com/package/sanctuary)
//. [![CircleCI](https://img.shields.io/circleci/project/github/sanctuary-js/sanctuary/master.svg)](https://circleci.com/gh/sanctuary-js/sanctuary/tree/master)
//. [![Gitter](https://img.shields.io/gitter/room/badges/shields.svg)](https://gitter.im/sanctuary-js/sanctuary)
//.
//. Sanctuary is a JavaScript functional programming library inspired by
//. [Haskell][] and [PureScript][]. It's stricter than [Ramda][], and
//. provides a similar suite of functions.
//.
//. Sanctuary promotes programs composed of simple, pure functions. Such
//. programs are easier to comprehend, test, and maintain &ndash; they are
//. also a pleasure to write.
//.
//. Sanctuary provides two data types, [Maybe][] and [Either][], both of
//. which are compatible with [Fantasy Land][]. Thanks to these data types
//. even Sanctuary functions which may fail, such as [`head`](#head), are
//. composable.
//.
//. Sanctuary makes it possible to write safe code without null checks.
//. In JavaScript it's trivial to introduce a possible run-time type error:
//.
//.     words[0].toUpperCase()
//.
//. If `words` is `[]` we'll get a familiar error at run-time:
//.
//.     TypeError: Cannot read property 'toUpperCase' of undefined
//.
//. Sanctuary gives us a fighting chance of avoiding such errors. We might
//. write:
//.
//.     S.map (S.toUpper) (S.head (words))
//.
//. Sanctuary is designed to work in Node.js and in ES5-compatible browsers.
//.
//. ## Ramda
//.
//. [Ramda][] provides several functions which return problematic values
//. such as `undefined`, `Infinity`, or `NaN` when applied to unsuitable
//. inputs. These are known as [partial functions][]. Partial functions
//. necessitate the use of guards or null checks. In order to safely use
//. `R.head`, for example, one must ensure that the array is non-empty:
//.
//.     if (R.isEmpty (xs)) {
//.       // ...
//.     } else {
//.       return f (R.head (xs));
//.     }
//.
//. Using the Maybe type renders such guards (and null checks) unnecessary.
//. Changing functions such as `R.head` to return Maybe values was proposed
//. in [ramda/ramda#683][], but was considered too much of a stretch for
//. JavaScript programmers. Sanctuary was released the following month,
//. in January 2015, as a companion library to Ramda.
//.
//. In addition to broadening in scope in the years since its release,
//. Sanctuary's philosophy has diverged from Ramda's in several respects.
//.
//. ### Totality
//.
//. Every Sanctuary function is defined for every value which is a member of
//. the function's input type. Such functions are known as [total functions][].
//. Ramda, on the other hand, contains a number of [partial functions][].
//.
//. ### Information preservation
//.
//. Certain Sanctuary functions preserve more information than their Ramda
//. counterparts. Examples:
//.
//.     |> R.tail ([])                      |> S.tail ([])
//.     []                                  Nothing
//.
//.     |> R.tail (['foo'])                 |> S.tail (['foo'])
//.     []                                  Just ([])
//.
//.     |> R.replace (/^x/) ('') ('abc')    |> S.stripPrefix ('x') ('abc')
//.     'abc'                               Nothing
//.
//.     |> R.replace (/^x/) ('') ('xabc')   |> S.stripPrefix ('x') ('xabc')
//.     'abc'                               Just ('abc')
//.
//. ### Invariants
//.
//. Sanctuary performs rigorous [type checking][] of inputs and outputs, and
//. throws a descriptive error if a type error is encountered. This allows bugs
//. to be caught and fixed early in the development cycle.
//.
//. Ramda operates on the [garbage in, garbage out][GIGO] principal. Functions
//. are documented to take arguments of particular types, but these invariants
//. are not enforced. The problem with this approach in a language as
//. permissive as JavaScript is that there's no guarantee that garbage input
//. will produce garbage output ([ramda/ramda#1413][]). Ramda performs ad hoc
//. type checking in some such cases ([ramda/ramda#1419][]).
//.
//. Sanctuary can be configured to operate in garbage in, garbage out mode.
//. Ramda cannot be configured to enforce its invariants.
//.
//. ### Currying
//.
//. Sanctuary functions are curried. There is, for example, exactly one way to
//. apply `S.reduce` to `S.add`, `0`, and `xs`:
//.
//.   - `S.reduce (S.add) (0) (xs)`
//.
//. Ramda functions are also curried, but in a complex manner. There are four
//. ways to apply `R.reduce` to `R.add`, `0`, and `xs`:
//.
//.   - `R.reduce (R.add) (0) (xs)`
//.   - `R.reduce (R.add) (0, xs)`
//.   - `R.reduce (R.add, 0) (xs)`
//.   - `R.reduce (R.add, 0, xs)`
//.
//. Ramda supports all these forms because curried functions enable partial
//. application, one of the library's tenets, but `f(x)(y)(z)` is considered
//. too unfamiliar and too unattractive to appeal to JavaScript programmers.
//.
//. Sanctuary's developers prefer a simple, unfamiliar construct to a complex,
//. familiar one. Familiarity can be acquired; complexity is intrinsic.
//.
//. The lack of breathing room in `f(x)(y)(z)` impairs readability. The simple
//. solution to this problem, proposed in [#438][], is to include a space when
//. applying a function: `f (x) (y) (z)`.
//.
//. Ramda also provides a special placeholder value, [`R.__`][], which removes
//. the restriction that a function must be applied to its arguments in order.
//. The following expressions are equivalent:
//.
//.   - `R.reduce (R.__, 0, xs) (R.add)`
//.   - `R.reduce (R.add, R.__, xs) (0)`
//.   - `R.reduce (R.__, 0) (R.add) (xs)`
//.   - `R.reduce (R.__, 0) (R.add, xs)`
//.   - `R.reduce (R.__, R.__, xs) (R.add) (0)`
//.   - `R.reduce (R.__, R.__, xs) (R.add, 0)`
//.
//. ### Variadic functions
//.
//. Ramda provides several functions which take any number of arguments. These
//. are known as [variadic functions][]. Additionally, Ramda provides several
//. functions which take variadic functions as arguments. Although natural in
//. a dynamically typed language, variadic functions are at odds with the type
//. notation Ramda and Sanctuary both use, leading to some indecipherable type
//. signatures such as this one:
//.
//.     R.lift :: (*... -> *...) -> ([*]... -> [*])
//.
//. Sanctuary has no variadic functions, nor any functions which take variadic
//. functions as arguments. Sanctuary provides two "lift" functions, each with
//. a helpful type signature:
//.
//.     S.lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
//.     S.lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
//.
//. ### Implicit context
//.
//. Ramda provides [`R.bind`][] and [`R.invoker`][] for working with methods.
//. Additionally, many Ramda functions use `Function#call` or `Function#apply`
//. to preserve context. Sanctuary makes no allowances for `this`.
//.
//. ### Transducers
//.
//. Several Ramda functions act as transducers. Sanctuary provides no support
//. for transducers.
//.
//. ### Modularity
//.
//. Whereas Ramda has no dependencies, Sanctuary has a modular design:
//. [sanctuary-def][] provides type checking, [sanctuary-type-classes][]
//. provides Fantasy Land functions and type classes, [sanctuary-show][]
//. provides string representations, and algebraic data types are provided
//. by [sanctuary-either][], [sanctuary-maybe][], and [sanctuary-pair][].
//. Not only does this approach reduce the complexity of Sanctuary itself,
//. but it allows these components to be reused in other contexts.
//.
//. ## Types
//.
//. Sanctuary uses Haskell-like type signatures to describe the types of
//. values, including functions. `'foo'`, for example, is a member of `String`;
//. `[1, 2, 3]` is a member of `Array Number`. The double colon (`::`) is used
//. to mean "is a member of", so one could write:
//.
//.     'foo' :: String
//.     [1, 2, 3] :: Array Number
//.
//. An identifier may appear to the left of the double colon:
//.
//.     Math.PI :: Number
//.
//. The arrow (`->`) is used to express a function's type:
//.
//.     Math.abs :: Number -> Number
//.
//. That states that `Math.abs` is a unary function which takes an argument
//. of type `Number` and returns a value of type `Number`.
//.
//. Some functions are parametrically polymorphic: their types are not fixed.
//. Type variables are used in the representations of such functions:
//.
//.     S.I :: a -> a
//.
//. `a` is a type variable. Type variables are not capitalized, so they
//. are differentiable from type identifiers (which are always capitalized).
//. By convention type variables have single-character names. The signature
//. above states that `S.I` takes a value of any type and returns a value of
//. the same type. Some signatures feature multiple type variables:
//.
//.     S.K :: a -> b -> a
//.
//. It must be possible to replace all occurrences of `a` with a concrete type.
//. The same applies for each other type variable. For the function above, the
//. types with which `a` and `b` are replaced may be different, but needn't be.
//.
//. Since all Sanctuary functions are curried (they accept their arguments
//. one at a time), a binary function is represented as a unary function which
//. returns a unary function: `* -> * -> *`. This aligns neatly with Haskell,
//. which uses curried functions exclusively. In JavaScript, though, we may
//. wish to represent the types of functions with arities less than or greater
//. than one. The general form is `(<input-types>) -> <output-type>`, where
//. `<input-types>` comprises zero or more comma–space (<code>, </code>)
//. -separated type representations:
//.
//.   - `() -> String`
//.   - `(a, b) -> a`
//.   - `(a, b, c) -> d`
//.
//. `Number -> Number` can thus be seen as shorthand for `(Number) -> Number`.
//.
//. The question mark (`?`) is used to represent types which include `null`
//. and `undefined` as members. `String?`, for example, represents the type
//. comprising `null`, `undefined`, and all strings.
//.
//. Sanctuary embraces types. JavaScript doesn't support algebraic data types,
//. but these can be simulated by providing a group of data constructors which
//. return values with the same set of methods. A value of the Either type, for
//. example, is created via the Left constructor or the Right constructor.
//.
//. It's necessary to extend Haskell's notation to describe implicit arguments
//. to the *methods* provided by Sanctuary's types. In `x.map(y)`, for example,
//. the `map` method takes an implicit argument `x` in addition to the explicit
//. argument `y`. The type of the value upon which a method is invoked appears
//. at the beginning of the signature, separated from the arguments and return
//. value by a squiggly arrow (`~>`). The type of the `fantasy-land/map` method
//. of the Maybe type is written `Maybe a ~> (a -> b) -> Maybe b`. One could
//. read this as:
//.
//. _When the `fantasy-land/map` method is invoked on a value of type `Maybe a`
//. (for any type `a`) with an argument of type `a -> b` (for any type `b`),
//. it returns a value of type `Maybe b`._
//.
//. The squiggly arrow is also used when representing non-function properties.
//. `Maybe a ~> Boolean`, for example, represents a Boolean property of a value
//. of type `Maybe a`.
//.
//. Sanctuary supports type classes: constraints on type variables. Whereas
//. `a -> a` implicitly supports every type, `Functor f => (a -> b) -> f a ->
//. f b` requires that `f` be a type which satisfies the requirements of the
//. Functor type class. Type-class constraints appear at the beginning of a
//. type signature, separated from the rest of the signature by a fat arrow
//. (`=>`).
//.
//. ## Type checking
//.
//. Sanctuary functions are defined via [sanctuary-def][] to provide run-time
//. type checking. This is tremendously useful during development: type errors
//. are reported immediately, avoiding circuitous stack traces (at best) and
//. silent failures due to type coercion (at worst). For example:
//.
//. ```javascript
//. S.add (2) (true);
//. // ! TypeError: Invalid value
//. //
//. //   add :: FiniteNumber -> FiniteNumber -> FiniteNumber
//. //                          ^^^^^^^^^^^^
//. //                               1
//. //
//. //   1)  true :: Boolean
//. //
//. //   The value at position 1 is not a member of ‘FiniteNumber’.
//. //
//. //   See v:sanctuary-js/sanctuary-def#FiniteNumber for information about the sanctuary-def/FiniteNumber type.
//. ```
//.
//. Compare this to the behaviour of Ramda's unchecked equivalent:
//.
//. ```javascript
//. R.add (2) (true);
//. // => 3
//. ```
//.
//. There is a performance cost to run-time type checking. Type checking is
//. disabled by default if `process.env.NODE_ENV` is `'production'`. If this
//. rule is unsuitable for a given program, one may use [`create`](#create)
//. to create a Sanctuary module based on a different rule. For example:
//.
//. ```javascript
//. const S = sanctuary.create ({
//.   checkTypes: localStorage.getItem ('SANCTUARY_CHECK_TYPES') === 'true',
//.   env: sanctuary.env,
//. });
//. ```
//.
//. Occasionally one may wish to perform an operation which is not type safe,
//. such as mapping over an object with heterogeneous values. This is possible
//. via selective use of [`unchecked`](#unchecked) functions.
//.
//. ## Installation
//.
//. `npm install sanctuary` will install Sanctuary for use in Node.js.
//.
//. Running Sanctuary in the browser is more involved. One must include a
//. `<script>` for each dependency in addition to one for Sanctuary itself:
//.
//. ```html
//. <script src="vendor/sanctuary-show.js"></script>
//. <script src="vendor/sanctuary-type-identifiers.js"></script>
//. <script src="vendor/sanctuary-type-classes.js"></script>
//. <script src="vendor/sanctuary-either.js"></script>
//. <script src="vendor/sanctuary-maybe.js"></script>
//. <script src="vendor/sanctuary-pair.js"></script>
//. <script src="vendor/sanctuary-def.js"></script>
//. <script src="vendor/sanctuary.js"></script>
//. ```
//.
//. To ensure compatibility one should use the dependency versions specified
//. in __package.json__.
//.
//. For convenience one could define aliases for various modules:
//.
//. ```javascript
//. const S = window.sanctuary;
//. const $ = window.sanctuaryDef;
//. // ...
//. ```
//.
//. ## API

(function(f) {

  'use strict';

  /* istanbul ignore else */
  if ( true && typeof module.exports === 'object') {
    module.exports = f (__webpack_require__ (/*! sanctuary-def */ "./node_modules/sanctuary-def/index.js"),
                        __webpack_require__ (/*! sanctuary-either */ "./node_modules/sanctuary-either/index.js"),
                        __webpack_require__ (/*! sanctuary-maybe */ "./node_modules/sanctuary-maybe/index.js"),
                        __webpack_require__ (/*! sanctuary-pair */ "./node_modules/sanctuary-pair/index.js"),
                        __webpack_require__ (/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"),
                        __webpack_require__ (/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"),
                        __webpack_require__ (/*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-identifiers/index.js"));
  } else if ( true && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js") != null) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! sanctuary-def */ "./node_modules/sanctuary-def/index.js"),
             __webpack_require__(/*! sanctuary-either */ "./node_modules/sanctuary-either/index.js"),
             __webpack_require__(/*! sanctuary-maybe */ "./node_modules/sanctuary-maybe/index.js"),
             __webpack_require__(/*! sanctuary-pair */ "./node_modules/sanctuary-pair/index.js"),
             __webpack_require__(/*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"),
             __webpack_require__(/*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"),
             __webpack_require__(/*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-identifiers/index.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (f),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {
    self.sanctuary = f (self.sanctuaryDef,
                        self.sanctuaryEither,
                        self.sanctuaryMaybe,
                        self.sanctuaryPair,
                        self.sanctuaryShow,
                        self.sanctuaryTypeClasses,
                        self.sanctuaryTypeIdentifiers);
  }

} (function($, Either, Maybe, Pair, show, Z, type) {

  'use strict';

  /* istanbul ignore if */
  if (typeof __doctest !== 'undefined') {
    /* eslint-disable no-unused-vars */
    var Descending = __doctest.require ('sanctuary-descending');
    var Nil = (__doctest.require ('./test/internal/List')).Nil;
    var Cons = (__doctest.require ('./test/internal/List')).Cons;
    var Sum = __doctest.require ('./test/internal/Sum');
    var S = (function(S) {
      //  DescendingType :: Type -> Type
      var DescendingType = $.UnaryType
        ('sanctuary/Descending')
        ('')
        (typeEq (Descending['@@type']))
        (B (of (Array)) (Z.extract));

      var S_ = S.create ({
        checkTypes: true,
        env: S.env.concat ([
          DescendingType ($.Unknown),
          (__doctest.require ('./test/internal/List')).Type ($.Unknown),
          Sum.Type
        ])
      });
      S_.env = S.env;  // see S.env doctest
      return S_;
    } (__webpack_require__ (/*! . */ "./node_modules/sanctuary/index.js")));
    /* eslint-enable no-unused-vars */
  }

  //  Left :: a -> Either a b
  var Left = Either.Left;

  //  Right :: b -> Either a b
  var Right = Either.Right;

  //  Nothing :: Maybe a
  var Nothing = Maybe.Nothing;

  //  Just :: a -> Maybe a
  var Just = Maybe.Just;

  //  B :: (b -> c) -> (a -> b) -> a -> c
  function B(f) {
    return function(g) {
      return function(x) {
        return f (g (x));
      };
    };
  }

  //  C :: (a -> b -> c) -> b -> a -> c
  function C(f) {
    return function(y) {
      return function(x) {
        return f (x) (y);
      };
    };
  }

  //  Fn :: Type -> Type -> Type
  function Fn(x) {
    return function(y) {
      return $.Function ([x, y]);
    };
  }

  //  get_ :: String -> a -> Maybe b
  function get_(key) {
    return B (function(obj) { return key in obj ? Just (obj[key]) : Nothing; })
             (toObject);
  }

  //  invoke0 :: String -> a -> b
  function invoke0(name) {
    return function(target) {
      return target[name] ();
    };
  }

  //  invoke1 :: String -> a -> b -> c
  function invoke1(name) {
    return function(x) {
      return function(target) {
        return target[name] (x);
      };
    };
  }

  //  toObject :: a -> Object
  function toObject(x) {
    return x == null ? Object.create (null) : Object (x);
  }

  //  typeEq :: String -> a -> Boolean
  function typeEq(typeIdent) {
    return function(x) {
      return type (x) === typeIdent;
    };
  }

  //  value :: { value :: a } -> a
  function value(r) {
    return r.value;
  }

  //  :: Type
  var a = $.TypeVariable ('a');
  var b = $.TypeVariable ('b');
  var c = $.TypeVariable ('c');
  var d = $.TypeVariable ('d');
  var e = $.TypeVariable ('e');
  var g = $.TypeVariable ('g');
  var l = $.TypeVariable ('l');
  var r = $.TypeVariable ('r');

  //  :: Type -> Type
  var f = $.UnaryTypeVariable ('f');
  var m = $.UnaryTypeVariable ('m');
  var t = $.UnaryTypeVariable ('t');
  var w = $.UnaryTypeVariable ('w');

  //  :: Type -> Type -> Type
  var p = $.BinaryTypeVariable ('p');
  var s = $.BinaryTypeVariable ('s');

  //  $Either :: Type -> Type -> Type
  var $Either = $.BinaryType
    ('sanctuary/Either')
    ('https://github.com/sanctuary-js/sanctuary-either')
    (typeEq ('sanctuary-either/Either@1'))
    (either (of (Array)) (K ([])))
    (either (K ([])) (of (Array)));

  //  $Maybe :: Type -> Type
  var $Maybe = $.UnaryType
    ('sanctuary/Maybe')
    ('https://github.com/sanctuary-js/sanctuary-maybe')
    (typeEq ('sanctuary-maybe/Maybe@1'))
    (maybe ([]) (of (Array)));

  //  $Pair :: Type -> Type -> Type
  var $Pair = $.BinaryType
    ('sanctuary/Pair')
    ('https://github.com/sanctuary-js/sanctuary-pair')
    (typeEq ('sanctuary-pair/Pair@1'))
    (function(pair) { return [pair.fst]; })
    (function(pair) { return [pair.snd]; });

  //  TypeRep :: Type -> Type
  var TypeRep = $.UnaryType
    ('sanctuary/TypeRep')
    ('https://github.com/fantasyland/fantasy-land#type-representatives')
    (function(x) {
       return $.AnyFunction._test (x) ||
              x != null && $.String._test (x['@@type']);
     })
    (K ([]));

  //  Options :: Type
  var Options = $.RecordType ({checkTypes: $.Boolean, env: $.Array ($.Any)});

  var _ = {};

  //. ### Configure

  //# create :: { checkTypes :: Boolean, env :: Array Type } -> Module
  //.
  //. Takes an options record and returns a Sanctuary module. `checkTypes`
  //. specifies whether to enable type checking. The module's polymorphic
  //. functions (such as [`I`](#I)) require each value associated with a
  //. type variable to be a member of at least one type in the environment.
  //.
  //. A well-typed application of a Sanctuary function will produce the same
  //. result regardless of whether type checking is enabled. If type checking
  //. is enabled, a badly typed application will produce an exception with a
  //. descriptive error message.
  //.
  //. The following snippet demonstrates defining a custom type and using
  //. `create` to produce a Sanctuary module which is aware of that type:
  //.
  //. ```javascript
  //. const {create, env} = require ('sanctuary');
  //. const $ = require ('sanctuary-def');
  //. const type = require ('sanctuary-type-identifiers');
  //.
  //. //    Identity :: a -> Identity a
  //. const Identity = x => {
  //.   const identity = Object.create (Identity$prototype);
  //.   identity.value = x;
  //.   return identity;
  //. };
  //.
  //. Identity['@@type'] = 'my-package/Identity@1';
  //.
  //. const Identity$prototype = {
  //.   'constructor': Identity,
  //.   '@@show': function() { return `Identity (${S.show (this.value)})`; },
  //.   'fantasy-land/map': function(f) { return Identity (f (this.value)); },
  //. };
  //.
  //. //    IdentityType :: Type -> Type
  //. const IdentityType = $.UnaryType
  //.   (Identity['@@type'])
  //.   ('http://example.com/my-package#Identity')
  //.   (x => type (x) === Identity['@@type'])
  //.   (identity => [identity.value]);
  //.
  //. const S = create ({
  //.   checkTypes: process.env.NODE_ENV !== 'production',
  //.   env: env.concat ([IdentityType ($.Unknown)]),
  //. });
  //.
  //. S.map (S.sub (1)) (Identity (43));
  //. // => Identity (42)
  //. ```
  //.
  //. See also [`env`](#env).
  function create(opts) {
    var def = $.create (opts);
    var S = {
      env: opts.env,
      is: def ('is') ({}) ([$.Type, $.Any, $.Boolean]) ($.test (opts.env)),
      MaybeType: $Maybe,
      Maybe: Maybe,
      Nothing: Nothing,
      EitherType: $Either,
      Either: Either,
      PairType: $Pair
    };
    (Object.keys (_)).forEach (function(name) {
      S[name] = def (name) (_[name].consts) (_[name].types) (_[name].impl);
    });
    S.unchecked = opts.checkTypes ? create ({checkTypes: false, env: opts.env})
                                  : S;
    return S;
  }
  _.create = {
    consts: {},
    types: [Options, $.Object],
    impl: create
  };

  //# env :: Array Type
  //.
  //. The Sanctuary module's environment (`(S.create ({checkTypes, env})).env`
  //. is a reference to `env`). Useful in conjunction with [`create`](#create).
  //.
  //. ```javascript
  //. > S.env
  //. [ $.AnyFunction,
  //. . $.Arguments,
  //. . $.Array ($.Unknown),
  //. . $.Boolean,
  //. . $.Date,
  //. . $.Error,
  //. . $.HtmlElement,
  //. . $.Null,
  //. . $.Number,
  //. . $.Object,
  //. . $.RegExp,
  //. . $.StrMap ($.Unknown),
  //. . $.String,
  //. . $.Symbol,
  //. . $.Undefined,
  //. . $.FiniteNumber,
  //. . $.NonZeroFiniteNumber,
  //. . S.EitherType ($.Unknown) ($.Unknown),
  //. . $.Function ([$.Unknown, $.Unknown]),
  //. . $.GlobalRegExp,
  //. . $.NonGlobalRegExp,
  //. . $.Integer,
  //. . $.NonNegativeInteger,
  //. . S.MaybeType ($.Unknown),
  //. . $.Array2 ($.Unknown) ($.Unknown),
  //. . S.PairType ($.Unknown) ($.Unknown),
  //. . $.RegexFlags,
  //. . $.Type,
  //. . $.TypeClass,
  //. . $.ValidDate,
  //. . $.ValidNumber ]
  //. ```

  //# unchecked :: Module
  //.
  //. A complete Sanctuary module which performs no type checking. This is
  //. useful as it permits operations which Sanctuary's type checking would
  //. disallow, such as mapping over an object with heterogeneous values.
  //.
  //. See also [`create`](#create).
  //.
  //. ```javascript
  //. > S.unchecked.map (S.show) ({x: 'foo', y: true, z: 42})
  //. {x: '"foo"', y: 'true', z: '42'}
  //. ```
  //.
  //. Opting out of type checking may cause type errors to go unnoticed.
  //.
  //. ```javascript
  //. > S.unchecked.add (2) ('2')
  //. '22'
  //. ```

  //. ### Classify

  //# type :: Any -> { namespace :: Maybe String, name :: String, version :: NonNegativeInteger }
  //.
  //. Returns the result of parsing the [type identifier][] of the given value.
  //.
  //. ```javascript
  //. > S.type (S.Just (42))
  //. {namespace: Just ('sanctuary-maybe'), name: 'Maybe', version: 1}
  //.
  //. > S.type ([1, 2, 3])
  //. {namespace: Nothing, name: 'Array', version: 0}
  //. ```
  function type_(x) {
    var r = type.parse (type (x));
    r.namespace = toMaybe (r.namespace);
    return r;
  }
  _.type = {
    consts: {},
    types: [$.Any,
            $.RecordType ({namespace: $Maybe ($.String),
                           name: $.String,
                           version: $.NonNegativeInteger})],
    impl: type_
  };

  //# is :: Type -> Any -> Boolean
  //.
  //. Returns `true` [iff][] the given value is a member of the specified type.
  //. See [`$.test`][] for details.
  //.
  //. ```javascript
  //. > S.is ($.Array ($.Integer)) ([1, 2, 3])
  //. true
  //.
  //. > S.is ($.Array ($.Integer)) ([1, 2, 3.14])
  //. false
  //. ```

  //. ### Showable

  //# show :: Any -> String
  //.
  //. Alias of [`show`][].
  //.
  //. ```javascript
  //. > S.show (-0)
  //. '-0'
  //.
  //. > S.show (['foo', 'bar', 'baz'])
  //. '["foo", "bar", "baz"]'
  //.
  //. > S.show ({x: 1, y: 2, z: 3})
  //. '{"x": 1, "y": 2, "z": 3}'
  //.
  //. > S.show (S.Left (S.Right (S.Just (S.Nothing))))
  //. 'Left (Right (Just (Nothing)))'
  //. ```
  _.show = {
    consts: {},
    types: [$.Any, $.String],
    impl: show
  };

  //. ### Fantasy Land
  //.
  //. Sanctuary is compatible with the [Fantasy Land][] specification.

  //# equals :: Setoid a => a -> a -> Boolean
  //.
  //. Curried version of [`Z.equals`][] which requires two arguments of the
  //. same type.
  //.
  //. To compare values of different types first use [`create`](#create) to
  //. create a Sanctuary module with type checking disabled, then use that
  //. module's `equals` function.
  //.
  //. ```javascript
  //. > S.equals (0) (-0)
  //. true
  //.
  //. > S.equals (NaN) (NaN)
  //. true
  //.
  //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 3]))
  //. true
  //.
  //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 4]))
  //. false
  //. ```
  _.equals = {
    consts: {a: [Z.Setoid]},
    types: [a, a, $.Boolean],
    impl: curry2 (Z.equals)
  };

  //# lt :: Ord a => a -> a -> Boolean
  //.
  //. Returns `true` [iff][] the *second* argument is less than the first
  //. according to [`Z.lt`][].
  //.
  //. ```javascript
  //. > S.filter (S.lt (3)) ([1, 2, 3, 4, 5])
  //. [1, 2]
  //. ```
  function lt(y) {
    return function(x) {
      return Z.lt (x, y);
    };
  }
  _.lt = {
    consts: {a: [Z.Ord]},
    types: [a, a, $.Boolean],
    impl: lt
  };

  //# lte :: Ord a => a -> a -> Boolean
  //.
  //. Returns `true` [iff][] the *second* argument is less than or equal to
  //. the first according to [`Z.lte`][].
  //.
  //. ```javascript
  //. > S.filter (S.lte (3)) ([1, 2, 3, 4, 5])
  //. [1, 2, 3]
  //. ```
  function lte(y) {
    return function(x) {
      return Z.lte (x, y);
    };
  }
  _.lte = {
    consts: {a: [Z.Ord]},
    types: [a, a, $.Boolean],
    impl: lte
  };

  //# gt :: Ord a => a -> a -> Boolean
  //.
  //. Returns `true` [iff][] the *second* argument is greater than the first
  //. according to [`Z.gt`][].
  //.
  //. ```javascript
  //. > S.filter (S.gt (3)) ([1, 2, 3, 4, 5])
  //. [4, 5]
  //. ```
  function gt(y) {
    return function(x) {
      return Z.gt (x, y);
    };
  }
  _.gt = {
    consts: {a: [Z.Ord]},
    types: [a, a, $.Boolean],
    impl: gt
  };

  //# gte :: Ord a => a -> a -> Boolean
  //.
  //. Returns `true` [iff][] the *second* argument is greater than or equal
  //. to the first according to [`Z.gte`][].
  //.
  //. ```javascript
  //. > S.filter (S.gte (3)) ([1, 2, 3, 4, 5])
  //. [3, 4, 5]
  //. ```
  function gte(y) {
    return function(x) {
      return Z.gte (x, y);
    };
  }
  _.gte = {
    consts: {a: [Z.Ord]},
    types: [a, a, $.Boolean],
    impl: gte
  };

  //# min :: Ord a => a -> a -> a
  //.
  //. Returns the smaller of its two arguments (according to [`Z.lte`][]).
  //.
  //. See also [`max`](#max).
  //.
  //. ```javascript
  //. > S.min (10) (2)
  //. 2
  //.
  //. > S.min (new Date ('1999-12-31')) (new Date ('2000-01-01'))
  //. new Date ('1999-12-31')
  //.
  //. > S.min ('10') ('2')
  //. '10'
  //. ```
  _.min = {
    consts: {a: [Z.Ord]},
    types: [a, a, a],
    impl: curry2 (Z.min)
  };

  //# max :: Ord a => a -> a -> a
  //.
  //. Returns the larger of its two arguments (according to [`Z.lte`][]).
  //.
  //. See also [`min`](#min).
  //.
  //. ```javascript
  //. > S.max (10) (2)
  //. 10
  //.
  //. > S.max (new Date ('1999-12-31')) (new Date ('2000-01-01'))
  //. new Date ('2000-01-01')
  //.
  //. > S.max ('10') ('2')
  //. '2'
  //. ```
  _.max = {
    consts: {a: [Z.Ord]},
    types: [a, a, a],
    impl: curry2 (Z.max)
  };

  //# id :: Category c => TypeRep c -> c
  //.
  //. [Type-safe][sanctuary-def] version of [`Z.id`][].
  //.
  //. ```javascript
  //. > S.id (Function) (42)
  //. 42
  //. ```
  _.id = {
    consts: {c: [Z.Category]},
    types: [TypeRep (c), c],
    impl: Z.id
  };

  //# concat :: Semigroup a => a -> a -> a
  //.
  //. Curried version of [`Z.concat`][].
  //.
  //. ```javascript
  //. > S.concat ('abc') ('def')
  //. 'abcdef'
  //.
  //. > S.concat ([1, 2, 3]) ([4, 5, 6])
  //. [1, 2, 3, 4, 5, 6]
  //.
  //. > S.concat ({x: 1, y: 2}) ({y: 3, z: 4})
  //. {x: 1, y: 3, z: 4}
  //.
  //. > S.concat (S.Just ([1, 2, 3])) (S.Just ([4, 5, 6]))
  //. Just ([1, 2, 3, 4, 5, 6])
  //.
  //. > S.concat (Sum (18)) (Sum (24))
  //. Sum (42)
  //. ```
  _.concat = {
    consts: {a: [Z.Semigroup]},
    types: [a, a, a],
    impl: curry2 (Z.concat)
  };

  //# empty :: Monoid a => TypeRep a -> a
  //.
  //. [Type-safe][sanctuary-def] version of [`Z.empty`][].
  //.
  //. ```javascript
  //. > S.empty (String)
  //. ''
  //.
  //. > S.empty (Array)
  //. []
  //.
  //. > S.empty (Object)
  //. {}
  //.
  //. > S.empty (Sum)
  //. Sum (0)
  //. ```
  _.empty = {
    consts: {a: [Z.Monoid]},
    types: [TypeRep (a), a],
    impl: Z.empty
  };

  //# invert :: Group g => g -> g
  //.
  //. [Type-safe][sanctuary-def] version of [`Z.invert`][].
  //.
  //. ```javascript
  //. > S.invert (Sum (5))
  //. Sum (-5)
  //. ```
  _.invert = {
    consts: {g: [Z.Group]},
    types: [g, g],
    impl: Z.invert
  };

  //# filter :: Filterable f => (a -> Boolean) -> f a -> f a
  //.
  //. Curried version of [`Z.filter`][]. Discards every element which does not
  //. satisfy the predicate.
  //.
  //. See also [`reject`](#reject).
  //.
  //. ```javascript
  //. > S.filter (S.odd) ([1, 2, 3])
  //. [1, 3]
  //.
  //. > S.filter (S.odd) ({x: 1, y: 2, z: 3})
  //. {x: 1, z: 3}
  //.
  //. > S.filter (S.odd) (S.Nothing)
  //. Nothing
  //.
  //. > S.filter (S.odd) (S.Just (0))
  //. Nothing
  //.
  //. > S.filter (S.odd) (S.Just (1))
  //. Just (1)
  //. ```
  function filter(pred) {
    return function(filterable) {
      return Z.filter (pred, filterable);
    };
  }
  _.filter = {
    consts: {f: [Z.Filterable]},
    types: [$.Predicate (a), f (a), f (a)],
    impl: filter
  };

  //# reject :: Filterable f => (a -> Boolean) -> f a -> f a
  //.
  //. Curried version of [`Z.reject`][]. Discards every element which satisfies
  //. the predicate.
  //.
  //. See also [`filter`](#filter).
  //.
  //. ```javascript
  //. > S.reject (S.odd) ([1, 2, 3])
  //. [2]
  //.
  //. > S.reject (S.odd) ({x: 1, y: 2, z: 3})
  //. {y: 2}
  //.
  //. > S.reject (S.odd) (S.Nothing)
  //. Nothing
  //.
  //. > S.reject (S.odd) (S.Just (0))
  //. Just (0)
  //.
  //. > S.reject (S.odd) (S.Just (1))
  //. Nothing
  //. ```
  _.reject = {
    consts: {f: [Z.Filterable]},
    types: [$.Predicate (a), f (a), f (a)],
    impl: curry2 (Z.reject)
  };

  //# takeWhile :: Filterable f => (a -> Boolean) -> f a -> f a
  //.
  //. Curried version of [`Z.takeWhile`][]. Discards the first element which
  //. does not satisfy the predicate, and all subsequent elements.
  //.
  //. See also [`dropWhile`](#dropWhile).
  //.
  //. ```javascript
  //. > S.takeWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])
  //. [3, 3, 3, 7]
  //.
  //. > S.takeWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])
  //. []
  //. ```
  _.takeWhile = {
    consts: {f: [Z.Filterable]},
    types: [$.Predicate (a), f (a), f (a)],
    impl: curry2 (Z.takeWhile)
  };

  //# dropWhile :: Filterable f => (a -> Boolean) -> f a -> f a
  //.
  //. Curried version of [`Z.dropWhile`][]. Retains the first element which
  //. does not satisfy the predicate, and all subsequent elements.
  //.
  //. See also [`takeWhile`](#takeWhile).
  //.
  //. ```javascript
  //. > S.dropWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])
  //. [6, 3, 5, 4]
  //.
  //. > S.dropWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])
  //. [3, 3, 3, 7, 6, 3, 5, 4]
  //. ```
  _.dropWhile = {
    consts: {f: [Z.Filterable]},
    types: [$.Predicate (a), f (a), f (a)],
    impl: curry2 (Z.dropWhile)
  };

  //# map :: Functor f => (a -> b) -> f a -> f b
  //.
  //. Curried version of [`Z.map`][].
  //.
  //. ```javascript
  //. > S.map (Math.sqrt) ([1, 4, 9])
  //. [1, 2, 3]
  //.
  //. > S.map (Math.sqrt) ({x: 1, y: 4, z: 9})
  //. {x: 1, y: 2, z: 3}
  //.
  //. > S.map (Math.sqrt) (S.Just (9))
  //. Just (3)
  //.
  //. > S.map (Math.sqrt) (S.Right (9))
  //. Right (3)
  //.
  //. > S.map (Math.sqrt) (S.Pair (99980001) (99980001))
  //. Pair (99980001) (9999)
  //. ```
  //.
  //. Replacing `Functor f => f` with `Function x` produces the B combinator
  //. from combinatory logic (i.e. [`compose`](#compose)):
  //.
  //.     Functor f => (a -> b) -> f a -> f b
  //.     (a -> b) -> Function x a -> Function x b
  //.     (a -> c) -> Function x a -> Function x c
  //.     (b -> c) -> Function x b -> Function x c
  //.     (b -> c) -> Function a b -> Function a c
  //.     (b -> c) -> (a -> b) -> (a -> c)
  //.
  //. ```javascript
  //. > S.map (Math.sqrt) (S.add (1)) (99)
  //. 10
  //. ```
  function map(f) {
    return function(functor) {
      return Z.map (f, functor);
    };
  }
  _.map = {
    consts: {f: [Z.Functor]},
    types: [Fn (a) (b), f (a), f (b)],
    impl: map
  };

  //# flip :: Functor f => f (a -> b) -> a -> f b
  //.
  //. Curried version of [`Z.flip`][]. Maps over the given functions, applying
  //. each to the given value.
  //.
  //. Replacing `Functor f => f` with `Function x` produces the C combinator
  //. from combinatory logic:
  //.
  //.     Functor f => f (a -> b) -> a -> f b
  //.     Function x (a -> b) -> a -> Function x b
  //.     Function x (a -> c) -> a -> Function x c
  //.     Function x (b -> c) -> b -> Function x c
  //.     Function a (b -> c) -> b -> Function a c
  //.     (a -> b -> c) -> b -> a -> c
  //.
  //. ```javascript
  //. > S.flip (S.concat) ('!') ('foo')
  //. 'foo!'
  //.
  //. > S.flip ([Math.floor, Math.ceil]) (1.5)
  //. [1, 2]
  //.
  //. > S.flip ({floor: Math.floor, ceil: Math.ceil}) (1.5)
  //. {floor: 1, ceil: 2}
  //.
  //. > S.flip (Cons (Math.floor) (Cons (Math.ceil) (Nil))) (1.5)
  //. Cons (1) (Cons (2) (Nil))
  //. ```
  _.flip = {
    consts: {f: [Z.Functor]},
    types: [f (Fn (a) (b)), a, f (b)],
    impl: curry2 (Z.flip)
  };

  //# bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a c -> f b d
  //.
  //. Curried version of [`Z.bimap`][].
  //.
  //. ```javascript
  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Pair ('foo') (64))
  //. Pair ('FOO') (8)
  //.
  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Left ('foo'))
  //. Left ('FOO')
  //.
  //. > S.bimap (S.toUpper) (Math.sqrt) (S.Right (64))
  //. Right (8)
  //. ```
  _.bimap = {
    consts: {p: [Z.Bifunctor]},
    types: [Fn (a) (b), Fn (c) (d), p (a) (c), p (b) (d)],
    impl: curry3 (Z.bimap)
  };

  //# mapLeft :: Bifunctor f => (a -> b) -> f a c -> f b c
  //.
  //. Curried version of [`Z.mapLeft`][]. Maps the given function over the left
  //. side of a Bifunctor.
  //.
  //. ```javascript
  //. > S.mapLeft (S.toUpper) (S.Pair ('foo') (64))
  //. Pair ('FOO') (64)
  //.
  //. > S.mapLeft (S.toUpper) (S.Left ('foo'))
  //. Left ('FOO')
  //.
  //. > S.mapLeft (S.toUpper) (S.Right (64))
  //. Right (64)
  //. ```
  _.mapLeft = {
    consts: {p: [Z.Bifunctor]},
    types: [Fn (a) (b), p (a) (c), p (b) (c)],
    impl: curry2 (Z.mapLeft)
  };

  //# promap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
  //.
  //. Curried version of [`Z.promap`][].
  //.
  //. ```javascript
  //. > S.promap (Math.abs) (S.add (1)) (Math.sqrt) (-100)
  //. 11
  //. ```
  _.promap = {
    consts: {p: [Z.Profunctor]},
    types: [Fn (a) (b), Fn (c) (d), p (b) (c), p (a) (d)],
    impl: curry3 (Z.promap)
  };

  //# alt :: Alt f => f a -> f a -> f a
  //.
  //. Curried version of [`Z.alt`][].
  //.
  //. ```javascript
  //. > S.alt (S.Nothing) (S.Just (1))
  //. Just (1)
  //.
  //. > S.alt (S.Just (2)) (S.Just (3))
  //. Just (2)
  //.
  //. > S.alt (S.Left ('X')) (S.Right (1))
  //. Right (1)
  //.
  //. > S.alt (S.Right (2)) (S.Right (3))
  //. Right (2)
  //. ```
  _.alt = {
    consts: {f: [Z.Alt]},
    types: [f (a), f (a), f (a)],
    impl: curry2 (Z.alt)
  };

  //# zero :: Plus f => TypeRep f -> f a
  //.
  //. [Type-safe][sanctuary-def] version of [`Z.zero`][].
  //.
  //. ```javascript
  //. > S.zero (Array)
  //. []
  //.
  //. > S.zero (Object)
  //. {}
  //.
  //. > S.zero (S.Maybe)
  //. Nothing
  //. ```
  _.zero = {
    consts: {f: [Z.Plus]},
    types: [TypeRep ($.TypeVariable ('f')), f (a)],
    impl: Z.zero
  };

  //# reduce :: Foldable f => (b -> a -> b) -> b -> f a -> b
  //.
  //. Takes a curried binary function, an initial value, and a [Foldable][],
  //. and applies the function to the initial value and the Foldable's first
  //. value, then applies the function to the result of the previous
  //. application and the Foldable's second value. Repeats this process
  //. until each of the Foldable's values has been used. Returns the initial
  //. value if the Foldable is empty; the result of the final application
  //. otherwise.
  //.
  //. ```javascript
  //. > S.reduce (S.add) (0) ([1, 2, 3, 4, 5])
  //. 15
  //.
  //. > S.reduce (xs => x => S.prepend (x) (xs)) ([]) ([1, 2, 3, 4, 5])
  //. [5, 4, 3, 2, 1]
  //. ```
  function reduce(f) {
    return function(initial) {
      return function(foldable) {
        return Z.reduce (function(y, x) { return f (y) (x); },
                         initial,
                         foldable);
      };
    };
  }
  _.reduce = {
    consts: {f: [Z.Foldable]},
    types: [Fn (a) (Fn (b) (a)), a, f (b), a],
    impl: reduce
  };

  //# traverse :: (Applicative f, Traversable t) => TypeRep f -> (a -> f b) -> t a -> f (t b)
  //.
  //. Curried version of [`Z.traverse`][].
  //.
  //. ```javascript
  //. > S.traverse (Array) (S.words) (S.Just ('foo bar baz'))
  //. [Just ('foo'), Just ('bar'), Just ('baz')]
  //.
  //. > S.traverse (Array) (S.words) (S.Nothing)
  //. [Nothing]
  //.
  //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C'])
  //. Just ([10, 11, 12])
  //.
  //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C', 'X'])
  //. Nothing
  //.
  //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C'})
  //. Just ({a: 10, b: 11, c: 12})
  //.
  //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C', x: 'X'})
  //. Nothing
  //. ```
  _.traverse = {
    consts: {f: [Z.Applicative], t: [Z.Traversable]},
    types: [TypeRep ($.TypeVariable ('f')), Fn (a) (f (b)), t (a), f (t (b))],
    impl: curry3 (Z.traverse)
  };

  //# sequence :: (Applicative f, Traversable t) => TypeRep f -> t (f a) -> f (t a)
  //.
  //. Curried version of [`Z.sequence`][]. Inverts the given `t (f a)`
  //. to produce an `f (t a)`.
  //.
  //. ```javascript
  //. > S.sequence (Array) (S.Just ([1, 2, 3]))
  //. [Just (1), Just (2), Just (3)]
  //.
  //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Just (3)])
  //. Just ([1, 2, 3])
  //.
  //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Nothing])
  //. Nothing
  //.
  //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Just (3)})
  //. Just ({a: 1, b: 2, c: 3})
  //.
  //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Nothing})
  //. Nothing
  //. ```
  _.sequence = {
    consts: {f: [Z.Applicative], t: [Z.Traversable]},
    types: [TypeRep ($.TypeVariable ('f')), t (f (a)), f (t (a))],
    impl: curry2 (Z.sequence)
  };

  //# ap :: Apply f => f (a -> b) -> f a -> f b
  //.
  //. Curried version of [`Z.ap`][].
  //.
  //. ```javascript
  //. > S.ap ([Math.sqrt, x => x * x]) ([1, 4, 9, 16, 25])
  //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]
  //.
  //. > S.ap ({x: Math.sqrt, y: S.add (1), z: S.sub (1)}) ({w: 4, x: 4, y: 4})
  //. {x: 2, y: 5}
  //.
  //. > S.ap (S.Just (Math.sqrt)) (S.Just (64))
  //. Just (8)
  //. ```
  //.
  //. Replacing `Apply f => f` with `Function x` produces the S combinator
  //. from combinatory logic:
  //.
  //.     Apply f => f (a -> b) -> f a -> f b
  //.     Function x (a -> b) -> Function x a -> Function x b
  //.     Function x (a -> c) -> Function x a -> Function x c
  //.     Function x (b -> c) -> Function x b -> Function x c
  //.     Function a (b -> c) -> Function a b -> Function a c
  //.     (a -> b -> c) -> (a -> b) -> (a -> c)
  //.
  //. ```javascript
  //. > S.ap (s => n => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('Haskell')
  //. 'Hask'
  //. ```
  _.ap = {
    consts: {f: [Z.Apply]},
    types: [f (Fn (a) (b)), f (a), f (b)],
    impl: curry2 (Z.ap)
  };

  //# lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
  //.
  //. Promotes a curried binary function to a function which operates on two
  //. [Apply][]s.
  //.
  //. ```javascript
  //. > S.lift2 (S.add) (S.Just (2)) (S.Just (3))
  //. Just (5)
  //.
  //. > S.lift2 (S.add) (S.Just (2)) (S.Nothing)
  //. Nothing
  //.
  //. > S.lift2 (S.and) (S.Just (true)) (S.Just (true))
  //. Just (true)
  //.
  //. > S.lift2 (S.and) (S.Just (true)) (S.Just (false))
  //. Just (false)
  //. ```
  _.lift2 = {
    consts: {f: [Z.Apply]},
    types: [Fn (a) (Fn (b) (c)), f (a), f (b), f (c)],
    impl: curry3 (Z.lift2)
  };

  //# lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
  //.
  //. Promotes a curried ternary function to a function which operates on three
  //. [Apply][]s.
  //.
  //. ```javascript
  //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Just ([1, 2, 3]))
  //. Just (6)
  //.
  //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Nothing)
  //. Nothing
  //. ```
  _.lift3 = {
    consts: {f: [Z.Apply]},
    types: [Fn (a) (Fn (b) (Fn (c) (d))), f (a), f (b), f (c), f (d)],
    impl: curry4 (Z.lift3)
  };

  //# apFirst :: Apply f => f a -> f b -> f a
  //.
  //. Curried version of [`Z.apFirst`][]. Combines two effectful actions,
  //. keeping only the result of the first. Equivalent to Haskell's `(<*)`
  //. function.
  //.
  //. See also [`apSecond`](#apSecond).
  //.
  //. ```javascript
  //. > S.apFirst ([1, 2]) ([3, 4])
  //. [1, 1, 2, 2]
  //.
  //. > S.apFirst (S.Just (1)) (S.Just (2))
  //. Just (1)
  //. ```
  _.apFirst = {
    consts: {f: [Z.Apply]},
    types: [f (a), f (b), f (a)],
    impl: curry2 (Z.apFirst)
  };

  //# apSecond :: Apply f => f a -> f b -> f b
  //.
  //. Curried version of [`Z.apSecond`][]. Combines two effectful actions,
  //. keeping only the result of the second. Equivalent to Haskell's `(*>)`
  //. function.
  //.
  //. See also [`apFirst`](#apFirst).
  //.
  //. ```javascript
  //. > S.apSecond ([1, 2]) ([3, 4])
  //. [3, 4, 3, 4]
  //.
  //. > S.apSecond (S.Just (1)) (S.Just (2))
  //. Just (2)
  //. ```
  _.apSecond = {
    consts: {f: [Z.Apply]},
    types: [f (a), f (b), f (b)],
    impl: curry2 (Z.apSecond)
  };

  //# of :: Applicative f => TypeRep f -> a -> f a
  //.
  //. Curried version of [`Z.of`][].
  //.
  //. ```javascript
  //. > S.of (Array) (42)
  //. [42]
  //.
  //. > S.of (Function) (42) (null)
  //. 42
  //.
  //. > S.of (S.Maybe) (42)
  //. Just (42)
  //.
  //. > S.of (S.Either) (42)
  //. Right (42)
  //. ```
  function of(typeRep) {
    return function(x) {
      return Z.of (typeRep, x);
    };
  }
  _.of = {
    consts: {f: [Z.Applicative]},
    types: [TypeRep ($.TypeVariable ('f')), a, f (a)],
    impl: of
  };

  //# chain :: Chain m => (a -> m b) -> m a -> m b
  //.
  //. Curried version of [`Z.chain`][].
  //.
  //. ```javascript
  //. > S.chain (x => [x, x]) ([1, 2, 3])
  //. [1, 1, 2, 2, 3, 3]
  //.
  //. > S.chain (n => s => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('slice')
  //. 'sli'
  //.
  //. > S.chain (S.parseInt (10)) (S.Just ('123'))
  //. Just (123)
  //.
  //. > S.chain (S.parseInt (10)) (S.Just ('XXX'))
  //. Nothing
  //. ```
  _.chain = {
    consts: {m: [Z.Chain]},
    types: [Fn (a) (m (b)), m (a), m (b)],
    impl: curry2 (Z.chain)
  };

  //# join :: Chain m => m (m a) -> m a
  //.
  //. [Type-safe][sanctuary-def] version of [`Z.join`][].
  //. Removes one level of nesting from a nested monadic structure.
  //.
  //. ```javascript
  //. > S.join ([[1], [2], [3]])
  //. [1, 2, 3]
  //.
  //. > S.join ([[[1, 2, 3]]])
  //. [[1, 2, 3]]
  //.
  //. > S.join (S.Just (S.Just (1)))
  //. Just (1)
  //.
  //. > S.join (S.Pair ('foo') (S.Pair ('bar') ('baz')))
  //. Pair ('foobar') ('baz')
  //. ```
  //.
  //. Replacing `Chain m => m` with `Function x` produces the W combinator
  //. from combinatory logic:
  //.
  //.     Chain m => m (m a) -> m a
  //.     Function x (Function x a) -> Function x a
  //.     (x -> x -> a) -> (x -> a)
  //.
  //. ```javascript
  //. > S.join (S.concat) ('abc')
  //. 'abcabc'
  //. ```
  _.join = {
    consts: {m: [Z.Chain]},
    types: [m (m (a)), m (a)],
    impl: Z.join
  };

  //# chainRec :: ChainRec m => TypeRep m -> (a -> m (Either a b)) -> a -> m b
  //.
  //. Performs a [`chain`](#chain)-like computation with constant stack usage.
  //. Similar to [`Z.chainRec`][], but curried and more convenient due to the
  //. use of the Either type to indicate completion (via a Right).
  //.
  //. ```javascript
  //. > S.chainRec (Array)
  //. .            (s => s.length === 2 ? S.map (S.Right) ([s + '!', s + '?'])
  //. .                                 : S.map (S.Left) ([s + 'o', s + 'n']))
  //. .            ('')
  //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']
  //. ```
  function chainRec(typeRep) {
    return function(f) {
      return function(x) {
        return Z.chainRec (typeRep, step, x);
      };
      function step(next, done, x) {
        return Z.map (either (next) (done), f (x));
      }
    };
  }
  _.chainRec = {
    consts: {m: [Z.ChainRec]},
    types: [TypeRep ($.TypeVariable ('m')),
            Fn (a) (m ($Either (a) (b))),
            a,
            m (b)],
    impl: chainRec
  };

  //# extend :: Extend w => (w a -> b) -> w a -> w b
  //.
  //. Curried version of [`Z.extend`][].
  //.
  //. ```javascript
  //. > S.extend (S.joinWith ('')) (['x', 'y', 'z'])
  //. ['xyz', 'yz', 'z']
  //.
  //. > S.extend (f => f ([3, 4])) (S.reverse) ([1, 2])
  //. [4, 3, 2, 1]
  //. ```
  _.extend = {
    consts: {w: [Z.Extend]},
    types: [Fn (w (a)) (b), w (a), w (b)],
    impl: curry2 (Z.extend)
  };

  //# duplicate :: Extend w => w a -> w (w a)
  //.
  //. [Type-safe][sanctuary-def] version of [`Z.duplicate`][].
  //. Adds one level of nesting to a comonadic structure.
  //.
  //. ```javascript
  //. > S.duplicate (S.Just (1))
  //. Just (Just (1))
  //.
  //. > S.duplicate ([1])
  //. [[1]]
  //.
  //. > S.duplicate ([1, 2, 3])
  //. [[1, 2, 3], [2, 3], [3]]
  //.
  //. > S.duplicate (S.reverse) ([1, 2]) ([3, 4])
  //. [4, 3, 2, 1]
  //. ```
  _.duplicate = {
    consts: {w: [Z.Extend]},
    types: [w (a), w (w (a))],
    impl: Z.duplicate
  };

  //# extract :: Comonad w => w a -> a
  //.
  //. [Type-safe][sanctuary-def] version of [`Z.extract`][].
  //.
  //. ```javascript
  //. > S.extract (S.Pair ('foo') ('bar'))
  //. 'bar'
  //. ```
  _.extract = {
    consts: {w: [Z.Comonad]},
    types: [w (a), a],
    impl: Z.extract
  };

  //# contramap :: Contravariant f => (b -> a) -> f a -> f b
  //.
  //. [Type-safe][sanctuary-def] version of [`Z.contramap`][].
  //.
  //. ```javascript
  //. > S.contramap (s => s.length) (Math.sqrt) ('Sanctuary')
  //. 3
  //. ```
  _.contramap = {
    consts: {f: [Z.Contravariant]},
    types: [Fn (b) (a), f (a), f (b)],
    impl: curry2 (Z.contramap)
  };

  //. ### Combinator

  //# I :: a -> a
  //.
  //. The I combinator. Returns its argument. Equivalent to Haskell's `id`
  //. function.
  //.
  //. ```javascript
  //. > S.I ('foo')
  //. 'foo'
  //. ```
  function I(x) {
    return x;
  }
  _.I = {
    consts: {},
    types: [a, a],
    impl: I
  };

  //# K :: a -> b -> a
  //.
  //. The K combinator. Takes two values and returns the first. Equivalent to
  //. Haskell's `const` function.
  //.
  //. ```javascript
  //. > S.K ('foo') ('bar')
  //. 'foo'
  //.
  //. > S.map (S.K (42)) (S.range (0) (5))
  //. [42, 42, 42, 42, 42]
  //. ```
  function K(x) {
    return function(y) {
      return x;
    };
  }
  _.K = {
    consts: {},
    types: [a, b, a],
    impl: K
  };

  //# T :: a -> (a -> b) -> b
  //.
  //. The T ([thrush][]) combinator. Takes a value and a function, and returns
  //. the result of applying the function to the value. Equivalent to Haskell's
  //. `(&)` function.
  //.
  //. ```javascript
  //. > S.T (42) (S.add (1))
  //. 43
  //.
  //. > S.map (S.T (100)) ([S.add (1), Math.sqrt])
  //. [101, 10]
  //. ```
  function T(x) {
    return function(f) {
      return f (x);
    };
  }
  _.T = {
    consts: {},
    types: [a, Fn (a) (b), b],
    impl: T
  };

  //. ### Function

  //# curry2 :: ((a, b) -> c) -> a -> b -> c
  //.
  //. Curries the given binary function.
  //.
  //. ```javascript
  //. > S.map (S.curry2 (Math.pow) (10)) ([1, 2, 3])
  //. [10, 100, 1000]
  //. ```
  function curry2(f) {
    return function(x) {
      return function(y) {
        return f (x, y);
      };
    };
  }
  _.curry2 = {
    consts: {},
    types: [$.Function ([a, b, c]), a, b, c],
    impl: curry2
  };

  //# curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
  //.
  //. Curries the given ternary function.
  //.
  //. ```javascript
  //. > const replaceString = S.curry3 ((what, replacement, string) =>
  //. .   string.replace (what, replacement)
  //. . )
  //.
  //. > replaceString ('banana') ('orange') ('banana icecream')
  //. 'orange icecream'
  //. ```
  function curry3(f) {
    return function(x) {
      return function(y) {
        return function(z) {
          return f (x, y, z);
        };
      };
    };
  }
  _.curry3 = {
    consts: {},
    types: [$.Function ([a, b, c, d]), a, b, c, d],
    impl: curry3
  };

  //# curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e
  //.
  //. Curries the given quaternary function.
  //.
  //. ```javascript
  //. > const createRect = S.curry4 ((x, y, width, height) =>
  //. .   ({x, y, width, height})
  //. . )
  //.
  //. > createRect (0) (0) (10) (10)
  //. {x: 0, y: 0, width: 10, height: 10}
  //. ```
  function curry4(f) {
    return function(w) {
      return function(x) {
        return function(y) {
          return function(z) {
            return f (w, x, y, z);
          };
        };
      };
    };
  }
  _.curry4 = {
    consts: {},
    types: [$.Function ([a, b, c, d, e]), a, b, c, d, e],
    impl: curry4
  };

  //# curry5 :: ((a, b, c, d, e) -> f) -> a -> b -> c -> d -> e -> f
  //.
  //. Curries the given quinary function.
  //.
  //. ```javascript
  //. > const toUrl = S.curry5 ((protocol, creds, hostname, port, pathname) =>
  //. .   protocol + '//' +
  //. .   S.maybe ('') (S.flip (S.concat) ('@')) (creds) +
  //. .   hostname +
  //. .   S.maybe ('') (S.concat (':')) (port) +
  //. .   pathname
  //. . )
  //.
  //. > toUrl ('https:') (S.Nothing) ('example.com') (S.Just ('443')) ('/foo/bar')
  //. 'https://example.com:443/foo/bar'
  //. ```
  function curry5(f) {
    return function(v) {
      return function(w) {
        return function(x) {
          return function(y) {
            return function(z) {
              return f (v, w, x, y, z);
            };
          };
        };
      };
    };
  }
  _.curry5 = {
    consts: {},
    types: [$.Function ([a, b, c, d, e, r]), a, b, c, d, e, r],
    impl: curry5
  };

  //. ### Composition

  //# compose :: Semigroupoid s => s b c -> s a b -> s a c
  //.
  //. Curried version of [`Z.compose`][].
  //.
  //. When specialized to Function, `compose` composes two unary functions,
  //. from right to left (this is the B combinator from combinatory logic).
  //.
  //. The generalized type signature indicates that `compose` is compatible
  //. with any [Semigroupoid][].
  //.
  //. See also [`pipe`](#pipe).
  //.
  //. ```javascript
  //. > S.compose (Math.sqrt) (S.add (1)) (99)
  //. 10
  //. ```
  _.compose = {
    consts: {s: [Z.Semigroupoid]},
    types: [s (b) (c), s (a) (b), s (a) (c)],
    impl: curry2 (Z.compose)
  };

  //# pipe :: Foldable f => f (Any -> Any) -> a -> b
  //.
  //. Takes a sequence of functions assumed to be unary and a value of any
  //. type, and returns the result of applying the sequence of transformations
  //. to the initial value.
  //.
  //. In general terms, `pipe` performs left-to-right composition of a sequence
  //. of functions. `pipe ([f, g, h]) (x)` is equivalent to `h (g (f (x)))`.
  //.
  //. ```javascript
  //. > S.pipe ([S.add (1), Math.sqrt, S.sub (1)]) (99)
  //. 9
  //. ```
  function pipe(fs) {
    return function(x) {
      return reduce (T) (x) (fs);
    };
  }
  _.pipe = {
    consts: {f: [Z.Foldable]},
    types: [f (Fn ($.Any) ($.Any)), a, b],
    impl: pipe
  };

  //# pipeK :: (Foldable f, Chain m) => f (Any -> m Any) -> m a -> m b
  //.
  //. Takes a sequence of functions assumed to be unary which return values
  //. with a [Chain][], and a value of that Chain, and returns the result
  //. of applying the sequence of transformations to the initial value.
  //.
  //. In general terms, `pipeK` performs left-to-right [Kleisli][] composition
  //. of an sequence of functions. `pipeK ([f, g, h]) (x)` is equivalent to
  //. `chain (h) (chain (g) (chain (f) (x)))`.
  //.
  //. ```javascript
  //. > S.pipeK ([S.tail, S.tail, S.head]) (S.Just ([1, 2, 3, 4]))
  //. Just (3)
  //. ```
  function pipeK(fs) {
    return function(x) {
      return Z.reduce (function(x, f) { return Z.chain (f, x); }, x, fs);
    };
  }
  _.pipeK = {
    consts: {f: [Z.Foldable], m: [Z.Chain]},
    types: [f (Fn ($.Any) (m ($.Any))), m (a), m (b)],
    impl: pipeK
  };

  //# on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
  //.
  //. Takes a binary function `f`, a unary function `g`, and two
  //. values `x` and `y`. Returns `f (g (x)) (g (y))`.
  //.
  //. This is the P combinator from combinatory logic.
  //.
  //. ```javascript
  //. > S.on (S.concat) (S.reverse) ([1, 2, 3]) ([4, 5, 6])
  //. [3, 2, 1, 6, 5, 4]
  //. ```
  function on(f) {
    return function(g) {
      return function(x) {
        return function(y) {
          return f (g (x)) (g (y));
        };
      };
    };
  }
  _.on = {
    consts: {},
    types: [Fn (b) (Fn (b) (c)), Fn (a) (b), a, a, c],
    impl: on
  };

  //. ### Pair type
  //.
  //. Pair is the canonical product type: a value of type `Pair a b` always
  //. contains exactly two values: one of type `a`; one of type `b`.
  //.
  //. The implementation is provided by [sanctuary-pair][].

  //# PairType :: Type -> Type -> Type
  //.
  //. A [`BinaryType`][BinaryType] for use with [sanctuary-def][].

  //# Pair :: a -> b -> Pair a b
  //.
  //. Pair's sole data constructor. Additionally, it serves as the
  //. Pair [type representative][].
  //.
  //. ```javascript
  //. > S.Pair ('foo') (42)
  //. Pair ('foo') (42)
  //. ```
  _.Pair = {
    consts: {},
    types: [a, b, $Pair (a) (b)],
    impl: Pair
  };

  //# fst :: Pair a b -> a
  //.
  //. `fst (Pair (x) (y))` is equivalent to `x`.
  //.
  //. ```javascript
  //. > S.fst (S.Pair ('foo') (42))
  //. 'foo'
  //. ```
  _.fst = {
    consts: {},
    types: [$Pair (a) (b), a],
    impl: Pair.fst
  };

  //# snd :: Pair a b -> b
  //.
  //. `snd (Pair (x) (y))` is equivalent to `y`.
  //.
  //. ```javascript
  //. > S.snd (S.Pair ('foo') (42))
  //. 42
  //. ```
  _.snd = {
    consts: {},
    types: [$Pair (a) (b), b],
    impl: Pair.snd
  };

  //# swap :: Pair a b -> Pair b a
  //.
  //. `swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.
  //.
  //. ```javascript
  //. > S.swap (S.Pair ('foo') (42))
  //. Pair (42) ('foo')
  //. ```
  _.swap = {
    consts: {},
    types: [$Pair (a) (b), $Pair (b) (a)],
    impl: Pair.swap
  };

  //. ### Maybe type
  //.
  //. The Maybe type represents optional values: a value of type `Maybe a` is
  //. either Nothing (the empty value) or a Just whose value is of type `a`.
  //.
  //. The implementation is provided by [sanctuary-maybe][].

  //# MaybeType :: Type -> Type
  //.
  //. A [`UnaryType`][UnaryType] for use with [sanctuary-def][].

  //# Maybe :: TypeRep Maybe
  //.
  //. Maybe [type representative][].

  //# Nothing :: Maybe a
  //.
  //. The empty value of type `Maybe a`.
  //.
  //. ```javascript
  //. > S.Nothing
  //. Nothing
  //. ```

  //# Just :: a -> Maybe a
  //.
  //. Constructs a value of type `Maybe a` from a value of type `a`.
  //.
  //. ```javascript
  //. > S.Just (42)
  //. Just (42)
  //. ```
  _.Just = {
    consts: {},
    types: [a, $Maybe (a)],
    impl: Just
  };

  //# isNothing :: Maybe a -> Boolean
  //.
  //. Returns `true` if the given Maybe is Nothing; `false` if it is a Just.
  //.
  //. ```javascript
  //. > S.isNothing (S.Nothing)
  //. true
  //.
  //. > S.isNothing (S.Just (42))
  //. false
  //. ```
  function isNothing(maybe) {
    return maybe.isNothing;
  }
  _.isNothing = {
    consts: {},
    types: [$Maybe (a), $.Boolean],
    impl: isNothing
  };

  //# isJust :: Maybe a -> Boolean
  //.
  //. Returns `true` if the given Maybe is a Just; `false` if it is Nothing.
  //.
  //. ```javascript
  //. > S.isJust (S.Just (42))
  //. true
  //.
  //. > S.isJust (S.Nothing)
  //. false
  //. ```
  function isJust(maybe) {
    return maybe.isJust;
  }
  _.isJust = {
    consts: {},
    types: [$Maybe (a), $.Boolean],
    impl: isJust
  };

  //# fromMaybe :: a -> Maybe a -> a
  //.
  //. Takes a default value and a Maybe, and returns the Maybe's value
  //. if the Maybe is a Just; the default value otherwise.
  //.
  //. See also [`fromMaybe_`](#fromMaybe_) and
  //. [`maybeToNullable`](#maybeToNullable).
  //.
  //. ```javascript
  //. > S.fromMaybe (0) (S.Just (42))
  //. 42
  //.
  //. > S.fromMaybe (0) (S.Nothing)
  //. 0
  //. ```
  _.fromMaybe = {
    consts: {},
    types: [a, $Maybe (a), a],
    impl: C (maybe) (I)
  };

  //# fromMaybe_ :: (() -> a) -> Maybe a -> a
  //.
  //. Variant of [`fromMaybe`](#fromMaybe) which takes a thunk so the default
  //. value is only computed if required.
  //.
  //. ```javascript
  //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }
  //.
  //. > S.fromMaybe_ (() => fib (30)) (S.Just (1000000))
  //. 1000000
  //.
  //. > S.fromMaybe_ (() => fib (30)) (S.Nothing)
  //. 832040
  //. ```
  _.fromMaybe_ = {
    consts: {},
    types: [$.Thunk (a), $Maybe (a), a],
    impl: C (maybe_) (I)
  };

  //# maybeToNullable :: Maybe a -> Nullable a
  //.
  //. Returns the given Maybe's value if the Maybe is a Just; `null` otherwise.
  //. [Nullable][] is defined in [sanctuary-def][].
  //.
  //. See also [`fromMaybe`](#fromMaybe).
  //.
  //. ```javascript
  //. > S.maybeToNullable (S.Just (42))
  //. 42
  //.
  //. > S.maybeToNullable (S.Nothing)
  //. null
  //. ```
  function maybeToNullable(maybe) {
    return maybe.isJust ? maybe.value : null;
  }
  _.maybeToNullable = {
    consts: {},
    types: [$Maybe (a), $.Nullable (a)],
    impl: maybeToNullable
  };

  //# toMaybe :: a? -> Maybe a
  //.
  //. Takes a value and returns Nothing if the value is `null` or `undefined`;
  //. Just the value otherwise.
  //.
  //. ```javascript
  //. > S.toMaybe (null)
  //. Nothing
  //.
  //. > S.toMaybe (42)
  //. Just (42)
  //. ```
  function toMaybe(x) {
    return x == null ? Nothing : Just (x);
  }
  _.toMaybe = {
    consts: {},
    types: [a, $Maybe (a)],
    impl: toMaybe
  };

  //# maybe :: b -> (a -> b) -> Maybe a -> b
  //.
  //. Takes a value of any type, a function, and a Maybe. If the Maybe is
  //. a Just, the return value is the result of applying the function to
  //. the Just's value. Otherwise, the first argument is returned.
  //.
  //. See also [`maybe_`](#maybe_).
  //.
  //. ```javascript
  //. > S.maybe (0) (S.prop ('length')) (S.Just ('refuge'))
  //. 6
  //.
  //. > S.maybe (0) (S.prop ('length')) (S.Nothing)
  //. 0
  //. ```
  function maybe(x) {
    return function(f) {
      return function(maybe) {
        return maybe.isJust ? f (maybe.value) : x;
      };
    };
  }
  _.maybe = {
    consts: {},
    types: [b, Fn (a) (b), $Maybe (a), b],
    impl: maybe
  };

  //# maybe_ :: (() -> b) -> (a -> b) -> Maybe a -> b
  //.
  //. Variant of [`maybe`](#maybe) which takes a thunk so the default value
  //. is only computed if required.
  //.
  //. ```javascript
  //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }
  //.
  //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Just (1000000))
  //. 1000
  //.
  //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Nothing)
  //. 832040
  //. ```
  function maybe_(thunk) {
    return function(f) {
      return function(maybe) {
        return maybe.isJust ? f (maybe.value) : thunk ();
      };
    };
  }
  _.maybe_ = {
    consts: {},
    types: [$.Thunk (b), Fn (a) (b), $Maybe (a), b],
    impl: maybe_
  };

  //# justs :: (Filterable f, Functor f) => f (Maybe a) -> f a
  //.
  //. Discards each element which is Nothing, and unwraps each element which is
  //. a Just. Related to Haskell's `catMaybes` function.
  //.
  //. See also [`lefts`](#lefts) and [`rights`](#rights).
  //.
  //. ```javascript
  //. > S.justs ([S.Just ('foo'), S.Nothing, S.Just ('baz')])
  //. ['foo', 'baz']
  //. ```
  function justs(maybes) {
    return map (value) (filter (isJust) (maybes));
  }
  _.justs = {
    consts: {f: [Z.Filterable, Z.Functor]},
    types: [f ($Maybe (a)), f (a)],
    impl: justs
  };

  //# mapMaybe :: (Filterable f, Functor f) => (a -> Maybe b) -> f a -> f b
  //.
  //. Takes a function and a structure, applies the function to each element
  //. of the structure, and returns the "successful" results. If the result of
  //. applying the function to an element is Nothing, the result is discarded;
  //. if the result is a Just, the Just's value is included.
  //.
  //. ```javascript
  //. > S.mapMaybe (S.head) ([[], [1, 2, 3], [], [4, 5, 6], []])
  //. [1, 4]
  //.
  //. > S.mapMaybe (S.head) ({x: [1, 2, 3], y: [], z: [4, 5, 6]})
  //. {x: 1, z: 4}
  //. ```
  _.mapMaybe = {
    consts: {f: [Z.Filterable, Z.Functor]},
    types: [Fn (a) ($Maybe (b)), f (a), f (b)],
    impl: B (B (justs)) (map)
  };

  //# encase :: (a -> b) -> a -> Maybe b
  //.
  //. Takes a unary function `f` which may throw and a value `x` of any type,
  //. and applies `f` to `x` inside a `try` block. If an exception is caught,
  //. the return value is Nothing; otherwise the return value is Just the
  //. result of applying `f` to `x`.
  //.
  //. See also [`encaseEither`](#encaseEither).
  //.
  //. ```javascript
  //. > S.encase (eval) ('1 + 1')
  //. Just (2)
  //.
  //. > S.encase (eval) ('1 +')
  //. Nothing
  //. ```
  function encase(f) {
    return B (eitherToMaybe) (encaseEither (I) (f));
  }
  _.encase = {
    consts: {},
    types: [Fn (a) (b), a, $Maybe (b)],
    impl: encase
  };

  //# encase2 :: (a -> b -> c) -> a -> b -> Maybe c
  //.
  //. Binary version of [`encase`](#encase).
  _.encase2 = {
    consts: {},
    types: [Fn (a) (Fn (b) (c)), a, b, $Maybe (c)],
    impl: B (B (B (eitherToMaybe))) (encaseEither2 (I))
  };

  //# encase3 :: (a -> b -> c -> d) -> a -> b -> c -> Maybe d
  //.
  //. Ternary version of [`encase`](#encase).
  _.encase3 = {
    consts: {},
    types: [Fn (a) (Fn (b) (Fn (c) (d))), a, b, c, $Maybe (d)],
    impl: B (B (B (B (eitherToMaybe)))) (encaseEither3 (I))
  };

  //# maybeToEither :: a -> Maybe b -> Either a b
  //.
  //. Converts a Maybe to an Either. Nothing becomes a Left (containing the
  //. first argument); a Just becomes a Right.
  //.
  //. See also [`eitherToMaybe`](#eitherToMaybe).
  //.
  //. ```javascript
  //. > S.maybeToEither ('Expecting an integer') (S.parseInt (10) ('xyz'))
  //. Left ('Expecting an integer')
  //.
  //. > S.maybeToEither ('Expecting an integer') (S.parseInt (10) ('42'))
  //. Right (42)
  //. ```
  function maybeToEither(x) {
    return maybe (Left (x)) (Right);
  }
  _.maybeToEither = {
    consts: {},
    types: [a, $Maybe (b), $Either (a) (b)],
    impl: maybeToEither
  };

  //. ### Either type
  //.
  //. The Either type represents values with two possibilities: a value of type
  //. `Either a b` is either a Left whose value is of type `a` or a Right whose
  //. value is of type `b`.
  //.
  //. The implementation is provided by [sanctuary-either][].

  //# EitherType :: Type -> Type -> Type
  //.
  //. A [`BinaryType`][BinaryType] for use with [sanctuary-def][].

  //# Either :: TypeRep Either
  //.
  //. Either [type representative][].

  //# Left :: a -> Either a b
  //.
  //. Constructs a value of type `Either a b` from a value of type `a`.
  //.
  //. ```javascript
  //. > S.Left ('Cannot divide by zero')
  //. Left ('Cannot divide by zero')
  //. ```
  _.Left = {
    consts: {},
    types: [a, $Either (a) (b)],
    impl: Left
  };

  //# Right :: b -> Either a b
  //.
  //. Constructs a value of type `Either a b` from a value of type `b`.
  //.
  //. ```javascript
  //. > S.Right (42)
  //. Right (42)
  //. ```
  _.Right = {
    consts: {},
    types: [b, $Either (a) (b)],
    impl: Right
  };

  //# isLeft :: Either a b -> Boolean
  //.
  //. Returns `true` if the given Either is a Left; `false` if it is a Right.
  //.
  //. ```javascript
  //. > S.isLeft (S.Left ('Cannot divide by zero'))
  //. true
  //.
  //. > S.isLeft (S.Right (42))
  //. false
  //. ```
  function isLeft(either) {
    return either.isLeft;
  }
  _.isLeft = {
    consts: {},
    types: [$Either (a) (b), $.Boolean],
    impl: isLeft
  };

  //# isRight :: Either a b -> Boolean
  //.
  //. Returns `true` if the given Either is a Right; `false` if it is a Left.
  //.
  //. ```javascript
  //. > S.isRight (S.Right (42))
  //. true
  //.
  //. > S.isRight (S.Left ('Cannot divide by zero'))
  //. false
  //. ```
  function isRight(either) {
    return either.isRight;
  }
  _.isRight = {
    consts: {},
    types: [$Either (a) (b), $.Boolean],
    impl: isRight
  };

  //# fromEither :: b -> Either a b -> b
  //.
  //. Takes a default value and an Either, and returns the Right value
  //. if the Either is a Right; the default value otherwise.
  //.
  //. ```javascript
  //. > S.fromEither (0) (S.Right (42))
  //. 42
  //.
  //. > S.fromEither (0) (S.Left (42))
  //. 0
  //. ```
  function fromEither(x) {
    return either (K (x)) (I);
  }
  _.fromEither = {
    consts: {},
    types: [b, $Either (a) (b), b],
    impl: fromEither
  };

  //# toEither :: a -> b? -> Either a b
  //.
  //. Converts an arbitrary value to an Either: a Left if the value is `null`
  //. or `undefined`; a Right otherwise. The first argument specifies the
  //. value of the Left in the "failure" case.
  //.
  //. ```javascript
  //. > S.toEither ('XYZ') (null)
  //. Left ('XYZ')
  //.
  //. > S.toEither ('XYZ') ('ABC')
  //. Right ('ABC')
  //.
  //. > S.map (S.prop ('0'))
  //. .       (S.toEither ('Invalid protocol')
  //. .                   ('ftp://example.com/'.match (/^https?:/)))
  //. Left ('Invalid protocol')
  //.
  //. > S.map (S.prop ('0'))
  //. .       (S.toEither ('Invalid protocol')
  //. .                   ('https://example.com/'.match (/^https?:/)))
  //. Right ('https:')
  //. ```
  function toEither(x) {
    return function(y) {
      return y == null ? Left (x) : Right (y);
    };
  }
  _.toEither = {
    consts: {},
    types: [a, b, $Either (a) (b)],
    impl: toEither
  };

  //# either :: (a -> c) -> (b -> c) -> Either a b -> c
  //.
  //. Takes two functions and an Either, and returns the result of
  //. applying the first function to the Left's value, if the Either
  //. is a Left, or the result of applying the second function to the
  //. Right's value, if the Either is a Right.
  //.
  //. ```javascript
  //. > S.either (S.toUpper) (S.show) (S.Left ('Cannot divide by zero'))
  //. 'CANNOT DIVIDE BY ZERO'
  //.
  //. > S.either (S.toUpper) (S.show) (S.Right (42))
  //. '42'
  //. ```
  function either(l) {
    return function(r) {
      return function(either) {
        return (either.isLeft ? l : r) (either.value);
      };
    };
  }
  _.either = {
    consts: {},
    types: [Fn (a) (c), Fn (b) (c), $Either (a) (b), c],
    impl: either
  };

  //# lefts :: (Filterable f, Functor f) => f (Either a b) -> f a
  //.
  //. Discards each element which is a Right, and unwraps each element which is
  //. a Left.
  //.
  //. See also [`rights`](#rights).
  //.
  //. ```javascript
  //. > S.lefts ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])
  //. ['foo', 'bar']
  //. ```
  _.lefts = {
    consts: {f: [Z.Filterable, Z.Functor]},
    types: [f ($Either (a) (b)), f (a)],
    impl: B (map (value)) (filter (isLeft))
  };

  //# rights :: (Filterable f, Functor f) => f (Either a b) -> f b
  //.
  //. Discards each element which is a Left, and unwraps each element which is
  //. a Right.
  //.
  //. See also [`lefts`](#lefts).
  //.
  //. ```javascript
  //. > S.rights ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])
  //. [20, 10]
  //. ```
  _.rights = {
    consts: {f: [Z.Filterable, Z.Functor]},
    types: [f ($Either (a) (b)), f (b)],
    impl: B (map (value)) (filter (isRight))
  };

  //# tagBy :: (a -> Boolean) -> a -> Either a a
  //.
  //. Takes a predicate and a value, and returns a Right of the value if it
  //. satisfies the predicate; a Left of the value otherwise.
  //.
  //. ```javascript
  //. > S.tagBy (S.odd) (0)
  //. Left (0)
  //
  //. > S.tagBy (S.odd) (1)
  //. Right (1)
  //. ```
  function tagBy(pred) {
    return ifElse (pred) (Right) (Left);
  }
  _.tagBy = {
    consts: {},
    types: [$.Predicate (a), a, $Either (a) (a)],
    impl: tagBy
  };

  //# encaseEither :: (Error -> l) -> (a -> r) -> a -> Either l r
  //.
  //. Takes two unary functions, `f` and `g`, the second of which may throw,
  //. and a value `x` of any type. Applies `g` to `x` inside a `try` block.
  //. If an exception is caught, the return value is a Left containing the
  //. result of applying `f` to the caught Error object; otherwise the return
  //. value is a Right containing the result of applying `g` to `x`.
  //.
  //. See also [`encase`](#encase).
  //.
  //. ```javascript
  //. > S.encaseEither (S.I) (JSON.parse) ('["foo","bar","baz"]')
  //. Right (['foo', 'bar', 'baz'])
  //.
  //. > S.encaseEither (S.I) (JSON.parse) ('[')
  //. Left (new SyntaxError ('Unexpected end of JSON input'))
  //.
  //. > S.encaseEither (S.prop ('message')) (JSON.parse) ('[')
  //. Left ('Unexpected end of JSON input')
  //. ```
  function encaseEither(f) {
    return function(g) {
      return function(x) {
        try {
          return Right (g (x));
        } catch (err) {
          return Left (f (err));
        }
      };
    };
  }
  _.encaseEither = {
    consts: {},
    types: [Fn ($.Error) (l), Fn (a) (r), a, $Either (l) (r)],
    impl: encaseEither
  };

  //# encaseEither2 :: (Error -> l) -> (a -> b -> r) -> a -> b -> Either l r
  //.
  //. Binary version of [`encaseEither`](#encaseEither).
  function encaseEither2(f) {
    return function(g) {
      return function(x) {
        return function(y) {
          try {
            return Right (g (x) (y));
          } catch (err) {
            return Left (f (err));
          }
        };
      };
    };
  }
  _.encaseEither2 = {
    consts: {},
    types: [Fn ($.Error) (l), Fn (a) (Fn (b) (r)), a, b, $Either (l) (r)],
    impl: encaseEither2
  };

  //# encaseEither3 :: (Error -> l) -> (a -> b -> c -> r) -> a -> b -> c -> Either l r
  //.
  //. Ternary version of [`encaseEither`](#encaseEither).
  function encaseEither3(f) {
    return function(g) {
      return function(x) {
        return function(y) {
          return function(z) {
            try {
              return Right (g (x) (y) (z));
            } catch (err) {
              return Left (f (err));
            }
          };
        };
      };
    };
  }
  _.encaseEither3 = {
    consts: {},
    types: [Fn ($.Error) (l),
            Fn (a) (Fn (b) (Fn (c) (r))),
            a,
            b,
            c,
            $Either (l) (r)],
    impl: encaseEither3
  };

  //# eitherToMaybe :: Either a b -> Maybe b
  //.
  //. Converts an Either to a Maybe. A Left becomes Nothing; a Right becomes
  //. a Just.
  //.
  //. See also [`maybeToEither`](#maybeToEither).
  //.
  //. ```javascript
  //. > S.eitherToMaybe (S.Left ('Cannot divide by zero'))
  //. Nothing
  //.
  //. > S.eitherToMaybe (S.Right (42))
  //. Just (42)
  //. ```
  function eitherToMaybe(either) {
    return either.isLeft ? Nothing : Just (either.value);
  }
  _.eitherToMaybe = {
    consts: {},
    types: [$Either (a) (b), $Maybe (b)],
    impl: eitherToMaybe
  };

  //. ### Logic

  //# and :: Boolean -> Boolean -> Boolean
  //.
  //. Boolean "and".
  //.
  //. ```javascript
  //. > S.and (false) (false)
  //. false
  //.
  //. > S.and (false) (true)
  //. false
  //.
  //. > S.and (true) (false)
  //. false
  //.
  //. > S.and (true) (true)
  //. true
  //. ```
  function and(x) {
    return function(y) {
      return x && y;
    };
  }
  _.and = {
    consts: {},
    types: [$.Boolean, $.Boolean, $.Boolean],
    impl: and
  };

  //# or :: Boolean -> Boolean -> Boolean
  //.
  //. Boolean "or".
  //.
  //. ```javascript
  //. > S.or (false) (false)
  //. false
  //.
  //. > S.or (false) (true)
  //. true
  //.
  //. > S.or (true) (false)
  //. true
  //.
  //. > S.or (true) (true)
  //. true
  //. ```
  function or(x) {
    return function(y) {
      return x || y;
    };
  }
  _.or = {
    consts: {},
    types: [$.Boolean, $.Boolean, $.Boolean],
    impl: or
  };

  //# not :: Boolean -> Boolean
  //.
  //. Boolean "not".
  //.
  //. See also [`complement`](#complement).
  //.
  //. ```javascript
  //. > S.not (false)
  //. true
  //.
  //. > S.not (true)
  //. false
  //. ```
  function not(x) {
    return !x;
  }
  _.not = {
    consts: {},
    types: [$.Boolean, $.Boolean],
    impl: not
  };

  //# complement :: (a -> Boolean) -> a -> Boolean
  //.
  //. Takes a unary predicate and a value of any type, and returns the logical
  //. negation of applying the predicate to the value.
  //.
  //. See also [`not`](#not).
  //.
  //. ```javascript
  //. > Number.isInteger (42)
  //. true
  //.
  //. > S.complement (Number.isInteger) (42)
  //. false
  //. ```
  _.complement = {
    consts: {},
    types: [$.Predicate (a), a, $.Boolean],
    impl: B (not)
  };

  //# ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b
  //.
  //. Takes a unary predicate, a unary "if" function, a unary "else"
  //. function, and a value of any type, and returns the result of
  //. applying the "if" function to the value if the value satisfies
  //. the predicate; the result of applying the "else" function to the
  //. value otherwise.
  //.
  //. See also [`when`](#when) and [`unless`](#unless).
  //.
  //. ```javascript
  //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (-1)
  //. 1
  //.
  //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (16)
  //. 4
  //. ```
  function ifElse(pred) {
    return function(f) {
      return function(g) {
        return function(x) {
          return (pred (x) ? f : g) (x);
        };
      };
    };
  }
  _.ifElse = {
    consts: {},
    types: [$.Predicate (a), Fn (a) (b), Fn (a) (b), a, b],
    impl: ifElse
  };

  //# when :: (a -> Boolean) -> (a -> a) -> a -> a
  //.
  //. Takes a unary predicate, a unary function, and a value of any type, and
  //. returns the result of applying the function to the value if the value
  //. satisfies the predicate; the value otherwise.
  //.
  //. See also [`unless`](#unless) and [`ifElse`](#ifElse).
  //.
  //. ```javascript
  //. > S.when (x => x >= 0) (Math.sqrt) (16)
  //. 4
  //.
  //. > S.when (x => x >= 0) (Math.sqrt) (-1)
  //. -1
  //. ```
  function when(pred) {
    return C (ifElse (pred)) (I);
  }
  _.when = {
    consts: {},
    types: [$.Predicate (a), Fn (a) (a), a, a],
    impl: when
  };

  //# unless :: (a -> Boolean) -> (a -> a) -> a -> a
  //.
  //. Takes a unary predicate, a unary function, and a value of any type, and
  //. returns the result of applying the function to the value if the value
  //. does not satisfy the predicate; the value otherwise.
  //.
  //. See also [`when`](#when) and [`ifElse`](#ifElse).
  //.
  //. ```javascript
  //. > S.unless (x => x < 0) (Math.sqrt) (16)
  //. 4
  //.
  //. > S.unless (x => x < 0) (Math.sqrt) (-1)
  //. -1
  //. ```
  function unless(pred) {
    return ifElse (pred) (I);
  }
  _.unless = {
    consts: {},
    types: [$.Predicate (a), Fn (a) (a), a, a],
    impl: unless
  };

  //# allPass :: Foldable f => f (a -> Boolean) -> a -> Boolean
  //.
  //. Takes a structure containing zero or more predicates, and a value
  //. of any type. Returns `true` [iff][] the value satisfies all of the
  //. predicates. None of the subsequent predicates will be applied after
  //. the first predicate not satisfied.
  //.
  //. ```javascript
  //. > S.allPass ([S.test (/q/), S.test (/u/), S.test (/i/)]) ('quiessence')
  //. true
  //.
  //. > S.allPass ([S.test (/q/), S.test (/u/), S.test (/i/)]) ('fissiparous')
  //. false
  //. ```
  function allPass(preds) {
    return function(x) {
      return Z.reduce (function(b, p) { return b && p (x); }, true, preds);
    };
  }
  _.allPass = {
    consts: {f: [Z.Foldable]},
    types: [f ($.Predicate (a)), a, $.Boolean],
    impl: allPass
  };

  //# anyPass :: Foldable f => f (a -> Boolean) -> a -> Boolean
  //.
  //. Takes a structure containing zero or more predicates, and a value
  //. of any type. Returns `true` [iff][] the value satisfies any of the
  //. predicates. None of the subsequent predicates will be applied after
  //. the first predicate satisfied.
  //.
  //. ```javascript
  //. > S.anyPass ([S.test (/q/), S.test (/u/), S.test (/i/)]) ('incandescent')
  //. true
  //.
  //. > S.anyPass ([S.test (/q/), S.test (/u/), S.test (/i/)]) ('empathy')
  //. false
  //. ```
  function anyPass(preds) {
    return function(x) {
      return Z.reduce (function(b, p) { return b || p (x); }, false, preds);
    };
  }
  _.anyPass = {
    consts: {f: [Z.Foldable]},
    types: [f ($.Predicate (a)), a, $.Boolean],
    impl: anyPass
  };

  //. ### Array

  //# slice :: Integer -> Integer -> Array a -> Maybe (Array a)
  //.
  //. Takes a start index `i`, an end index `j`, and an array, and returns
  //. Just the `[i,j)` slice of the array if possible; Nothing otherwise.
  //. A negative index represents an offset from the length of the array.
  //.
  //. See also [`take`](#take), [`drop`](#drop), [`takeLast`](#takeLast),
  //. and [`dropLast`](#dropLast).
  //.
  //. ```javascript
  //. > S.slice (1) (3) (['a', 'b', 'c', 'd', 'e'])
  //. Just (['b', 'c'])
  //.
  //. > S.slice (-3) (-1) (['a', 'b', 'c', 'd', 'e'])
  //. Just (['c', 'd'])
  //.
  //. > S.slice (1) (6) (['a', 'b', 'c', 'd', 'e'])
  //. Nothing
  //. ```
  function slice(start) {
    return function(end) {
      return function(xs) {
        var fromIdx = start < 0 ? start + xs.length : start;
        var toIdx = end < 0 ? end + xs.length : end;

        return Math.abs (start) <= xs.length &&
               Math.abs (end) <= xs.length &&
               fromIdx <= toIdx ?
                 Just (xs.slice (fromIdx, toIdx)) :
                 Nothing;
      };
    };
  }
  _.slice = {
    consts: {},
    types: [$.Integer, $.Integer, $.Array (a), $Maybe ($.Array (a))],
    impl: slice
  };

  //# at :: Integer -> Array a -> Maybe a
  //.
  //. Returns Just the element of the given array at the specified index if
  //. the index is within the array's bounds; Nothing otherwise. A negative
  //. index represents an offset from the length of the array.
  //.
  //. ```javascript
  //. > S.at (2) (['a', 'b', 'c', 'd', 'e'])
  //. Just ('c')
  //.
  //. > S.at (5) (['a', 'b', 'c', 'd', 'e'])
  //. Nothing
  //.
  //. > S.at (-2) (['a', 'b', 'c', 'd', 'e'])
  //. Just ('d')
  //. ```
  function at(n) {
    return function(xs) {
      var idx = n < 0 ? xs.length + n : n;
      return idx < 0 || idx >= xs.length ? Nothing : Just (xs[idx]);
    };
  }
  _.at = {
    consts: {},
    types: [$.Integer, $.Array (a), $Maybe (a)],
    impl: at
  };

  //# head :: Array a -> Maybe a
  //.
  //. Returns Just the first element of the given array if the array contains
  //. at least one element; Nothing otherwise.
  //.
  //. ```javascript
  //. > S.head ([1, 2, 3])
  //. Just (1)
  //.
  //. > S.head ([])
  //. Nothing
  //. ```
  function head(xs) {
    return xs.length > 0 ? Just (xs[0]) : Nothing;
  }
  _.head = {
    consts: {},
    types: [$.Array (a), $Maybe (a)],
    impl: head
  };

  //# last :: Array a -> Maybe a
  //.
  //. Returns Just the last element of the given array if the array contains
  //. at least one element; Nothing otherwise.
  //.
  //. ```javascript
  //. > S.last ([1, 2, 3])
  //. Just (3)
  //.
  //. > S.last ([])
  //. Nothing
  //. ```
  function last(xs) {
    return xs.length > 0 ? Just (xs[xs.length - 1]) : Nothing;
  }
  _.last = {
    consts: {},
    types: [$.Array (a), $Maybe (a)],
    impl: last
  };

  //# tail :: Array a -> Maybe (Array a)
  //.
  //. Returns Just all but the first of the given array's elements if the
  //. array contains at least one element; Nothing otherwise.
  //.
  //. ```javascript
  //. > S.tail ([1, 2, 3])
  //. Just ([2, 3])
  //.
  //. > S.tail ([])
  //. Nothing
  //. ```
  function tail(xs) {
    return xs.length > 0 ? Just (xs.slice (1)) : Nothing;
  }
  _.tail = {
    consts: {},
    types: [$.Array (a), $Maybe ($.Array (a))],
    impl: tail
  };

  //# init :: Array a -> Maybe (Array a)
  //.
  //. Returns Just all but the last of the given array's elements if the
  //. array contains at least one element; Nothing otherwise.
  //.
  //. ```javascript
  //. > S.init ([1, 2, 3])
  //. Just ([1, 2])
  //.
  //. > S.init ([])
  //. Nothing
  //. ```
  function init(xs) {
    return xs.length > 0 ? Just (xs.slice (0, -1)) : Nothing;
  }
  _.init = {
    consts: {},
    types: [$.Array (a), $Maybe ($.Array (a))],
    impl: init
  };

  //# take :: Integer -> Array a -> Maybe (Array a)
  //.
  //. Returns Just the first N elements of the given array if N is greater
  //. than or equal to zero and less than or equal to the length of the array;
  //. Nothing otherwise.
  //.
  //. ```javascript
  //. > S.take (2) (['a', 'b', 'c', 'd', 'e'])
  //. Just (['a', 'b'])
  //.
  //. > S.take (5) (['a', 'b', 'c', 'd', 'e'])
  //. Just (['a', 'b', 'c', 'd', 'e'])
  //.
  //. > S.take (6) (['a', 'b', 'c', 'd', 'e'])
  //. Nothing
  //. ```
  function take(n) {
    return function(xs) {
      return n >= 0 && n <= xs.length ? Just (xs.slice (0, n)) : Nothing;
    };
  }
  _.take = {
    consts: {},
    types: [$.Integer, $.Array (a), $Maybe ($.Array (a))],
    impl: take
  };

  //# takeLast :: Integer -> Array a -> Maybe (Array a)
  //.
  //. Returns Just the last N elements of the given array if N is greater
  //. than or equal to zero and less than or equal to the length of the array;
  //. Nothing otherwise.
  //.
  //. ```javascript
  //. > S.takeLast (2) (['a', 'b', 'c', 'd', 'e'])
  //. Just (['d', 'e'])
  //.
  //. > S.takeLast (5) (['a', 'b', 'c', 'd', 'e'])
  //. Just (['a', 'b', 'c', 'd', 'e'])
  //.
  //. > S.takeLast (6) (['a', 'b', 'c', 'd', 'e'])
  //. Nothing
  //. ```
  function takeLast(n) {
    return function(xs) {
      return n >= 0 && n <= xs.length ? Just (xs.slice (xs.length - n))
                                      : Nothing;
    };
  }
  _.takeLast = {
    consts: {},
    types: [$.Integer, $.Array (a), $Maybe ($.Array (a))],
    impl: takeLast
  };

  //# drop :: Integer -> Array a -> Maybe (Array a)
  //.
  //. Returns Just all but the first N elements of the given array if N is
  //. greater than or equal to zero and less than or equal to the length of
  //. the array; Nothing otherwise.
  //.
  //. ```javascript
  //. > S.drop (2) (['a', 'b', 'c', 'd', 'e'])
  //. Just (['c', 'd', 'e'])
  //.
  //. > S.drop (5) (['a', 'b', 'c', 'd', 'e'])
  //. Just ([])
  //.
  //. > S.drop (6) (['a', 'b', 'c', 'd', 'e'])
  //. Nothing
  //. ```
  function drop(n) {
    return function(xs) {
      return n >= 0 && n <= xs.length ? Just (xs.slice (n)) : Nothing;
    };
  }
  _.drop = {
    consts: {},
    types: [$.Integer, $.Array (a), $Maybe ($.Array (a))],
    impl: drop
  };

  //# dropLast :: Integer -> Array a -> Maybe (Array a)
  //.
  //. Returns Just all but the last N elements of the given array if N is
  //. greater than or equal to zero and less than or equal to the length of
  //. the array; Nothing otherwise.
  //.
  //. ```javascript
  //. > S.dropLast (2) (['a', 'b', 'c', 'd', 'e'])
  //. Just (['a', 'b', 'c'])
  //.
  //. > S.dropLast (5) (['a', 'b', 'c', 'd', 'e'])
  //. Just ([])
  //.
  //. > S.dropLast (6) (['a', 'b', 'c', 'd', 'e'])
  //. Nothing
  //. ```
  function dropLast(n) {
    return function(xs) {
      return n >= 0 && n <= xs.length ? Just (xs.slice (0, xs.length - n))
                                      : Nothing;
    };
  }
  _.dropLast = {
    consts: {},
    types: [$.Integer, $.Array (a), $Maybe ($.Array (a))],
    impl: dropLast
  };

  //# size :: Foldable f => f a -> Integer
  //.
  //. Returns the number of elements of the given structure.
  //.
  //. ```javascript
  //. > S.size ([])
  //. 0
  //.
  //. > S.size (['foo', 'bar', 'baz'])
  //. 3
  //.
  //. > S.size (Nil)
  //. 0
  //.
  //. > S.size (Cons ('foo') (Cons ('bar') (Cons ('baz') (Nil))))
  //. 3
  //.
  //. > S.size (S.Nothing)
  //. 0
  //.
  //. > S.size (S.Just ('quux'))
  //. 1
  //.
  //. > S.size (S.Pair ('ignored!') ('counted!'))
  //. 1
  //. ```
  _.size = {
    consts: {f: [Z.Foldable]},
    types: [f (a), $.Integer],
    impl: Z.size
  };

  //# append :: (Applicative f, Semigroup (f a)) => a -> f a -> f a
  //.
  //. Returns the result of appending the first argument to the second.
  //.
  //. See also [`prepend`](#prepend).
  //.
  //. ```javascript
  //. > S.append (3) ([1, 2])
  //. [1, 2, 3]
  //.
  //. > S.append (3) (Cons (1) (Cons (2) (Nil)))
  //. Cons (1) (Cons (2) (Cons (3) (Nil)))
  //.
  //. > S.append ([1]) (S.Nothing)
  //. Just ([1])
  //.
  //. > S.append ([3]) (S.Just ([1, 2]))
  //. Just ([1, 2, 3])
  //. ```
  _.append = {
    consts: {f: [Z.Applicative, Z.Semigroup]},
    types: [a, f (a), f (a)],
    impl: curry2 (Z.append)
  };

  //# prepend :: (Applicative f, Semigroup (f a)) => a -> f a -> f a
  //.
  //. Returns the result of prepending the first argument to the second.
  //.
  //. See also [`append`](#append).
  //.
  //. ```javascript
  //. > S.prepend (1) ([2, 3])
  //. [1, 2, 3]
  //.
  //. > S.prepend (1) (Cons (2) (Cons (3) (Nil)))
  //. Cons (1) (Cons (2) (Cons (3) (Nil)))
  //.
  //. > S.prepend ([1]) (S.Nothing)
  //. Just ([1])
  //.
  //. > S.prepend ([1]) (S.Just ([2, 3]))
  //. Just ([1, 2, 3])
  //. ```
  _.prepend = {
    consts: {f: [Z.Applicative, Z.Semigroup]},
    types: [a, f (a), f (a)],
    impl: curry2 (Z.prepend)
  };

  //# joinWith :: String -> Array String -> String
  //.
  //. Joins the strings of the second argument separated by the first argument.
  //.
  //. Properties:
  //.
  //.   - `forall s :: String, t :: String.
  //.      S.joinWith (s) (S.splitOn (s) (t)) = t`
  //.
  //. See also [`splitOn`](#splitOn).
  //.
  //. ```javascript
  //. > S.joinWith (':') (['foo', 'bar', 'baz'])
  //. 'foo:bar:baz'
  //. ```
  _.joinWith = {
    consts: {},
    types: [$.String, $.Array ($.String), $.String],
    impl: invoke1 ('join')
  };

  //# elem :: (Setoid a, Foldable f) => a -> f a -> Boolean
  //.
  //. Takes a value and a structure and returns `true` [iff][] the value is an
  //. element of the structure.
  //.
  //. See also [`find`](#find).
  //.
  //. ```javascript
  //. > S.elem ('c') (['a', 'b', 'c'])
  //. true
  //.
  //. > S.elem ('x') (['a', 'b', 'c'])
  //. false
  //.
  //. > S.elem (3) ({x: 1, y: 2, z: 3})
  //. true
  //.
  //. > S.elem (8) ({x: 1, y: 2, z: 3})
  //. false
  //.
  //. > S.elem (0) (S.Just (0))
  //. true
  //.
  //. > S.elem (0) (S.Just (1))
  //. false
  //.
  //. > S.elem (0) (S.Nothing)
  //. false
  //. ```
  _.elem = {
    consts: {a: [Z.Setoid], f: [Z.Foldable]},
    types: [a, f (a), $.Boolean],
    impl: curry2 (Z.elem)
  };

  //# find :: Foldable f => (a -> Boolean) -> f a -> Maybe a
  //.
  //. Takes a predicate and a structure and returns Just the leftmost element
  //. of the structure which satisfies the predicate; Nothing if there is no
  //. such element.
  //.
  //. See also [`elem`](#elem).
  //.
  //. ```javascript
  //. > S.find (S.lt (0)) ([1, -2, 3, -4, 5])
  //. Just (-2)
  //.
  //. > S.find (S.lt (0)) ([1, 2, 3, 4, 5])
  //. Nothing
  //. ```
  function find(pred) {
    return function(xs) {
      return Z.reduce (
        function(m, x) {
          return m.isJust ? m : pred (x) ? Just (x) : Nothing;
        },
        Nothing,
        xs
      );
    };
  }
  _.find = {
    consts: {f: [Z.Foldable]},
    types: [$.Predicate (a), f (a), $Maybe (a)],
    impl: find
  };

  //# foldMap :: (Monoid m, Foldable f) => TypeRep m -> (a -> m) -> f a -> m
  //.
  //. Curried version of [`Z.foldMap`][]. Deconstructs a foldable by mapping
  //. every element to a monoid and concatenating the results.
  //.
  //. ```javascript
  //. > S.foldMap (String) (f => f.name) ([Math.sin, Math.cos, Math.tan])
  //. 'sincostan'
  //. ```
  _.foldMap = {
    consts: {b: [Z.Monoid], f: [Z.Foldable]},
    types: [TypeRep (b), Fn (a) (b), f (a), b],
    impl: curry3 (Z.foldMap)
  };

  //# unfoldr :: (b -> Maybe (Pair a b)) -> b -> Array a
  //.
  //. Takes a function and a seed value, and returns an array generated by
  //. applying the function repeatedly. The array is initially empty. The
  //. function is initially applied to the seed value. Each application
  //. of the function should result in either:
  //.
  //.   - Nothing, in which case the array is returned; or
  //.
  //.   - Just a pair, in which case the first element is appended to
  //.     the array and the function is applied to the second element.
  //.
  //. ```javascript
  //. > S.unfoldr (n => n < 5 ? S.Just (S.Pair (n) (n + 1)) : S.Nothing) (1)
  //. [1, 2, 3, 4]
  //. ```
  function unfoldr(f) {
    return function(x) {
      var result = [];
      for (var m = f (x); m.isJust; m = f (m.value.snd)) {
        result.push (m.value.fst);
      }
      return result;
    };
  }
  _.unfoldr = {
    consts: {},
    types: [Fn (b) ($Maybe ($Pair (a) (b))), b, $.Array (a)],
    impl: unfoldr
  };

  //# range :: Integer -> Integer -> Array Integer
  //.
  //. Returns an array of consecutive integers starting with the first argument
  //. and ending with the second argument minus one. Returns `[]` if the second
  //. argument is less than or equal to the first argument.
  //.
  //. ```javascript
  //. > S.range (0) (10)
  //. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  //.
  //. > S.range (-5) (0)
  //. [-5, -4, -3, -2, -1]
  //.
  //. > S.range (0) (-5)
  //. []
  //. ```
  function range(from) {
    return function(to) {
      var result = [];
      for (var n = from; n < to; n += 1) result.push (n);
      return result;
    };
  }
  _.range = {
    consts: {},
    types: [$.Integer, $.Integer, $.Array ($.Integer)],
    impl: range
  };

  //# groupBy :: (a -> a -> Boolean) -> Array a -> Array (Array a)
  //.
  //. Splits its array argument into an array of arrays of equal,
  //. adjacent elements. Equality is determined by the function
  //. provided as the first argument. Its behaviour can be surprising
  //. for functions that aren't reflexive, transitive, and symmetric
  //. (see [equivalence][] relation).
  //.
  //. Properties:
  //.
  //.   - `forall f :: a -> a -> Boolean, xs :: Array a.
  //.      S.join (S.groupBy (f) (xs)) = xs`
  //.
  //. ```javascript
  //. > S.groupBy (S.equals) ([1, 1, 2, 1, 1])
  //. [[1, 1], [2], [1, 1]]
  //.
  //. > S.groupBy (x => y => x + y === 0) ([2, -3, 3, 3, 3, 4, -4, 4])
  //. [[2], [-3, 3, 3, 3], [4, -4], [4]]
  //. ```
  function groupBy(f) {
    return function(xs) {
      if (xs.length === 0) return [];
      var x0 = xs[0];         // :: a
      var active = [x0];      // :: Array a
      var result = [active];  // :: Array (Array a)
      for (var idx = 1; idx < xs.length; idx += 1) {
        var x = xs[idx];
        if (f (x0) (x)) active.push (x); else result.push (active = [x0 = x]);
      }
      return result;
    };
  }
  _.groupBy = {
    consts: {},
    types: [Fn (a) ($.Predicate (a)), $.Array (a), $.Array ($.Array (a))],
    impl: groupBy
  };

  //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a
  //.
  //. Reverses the elements of the given structure.
  //.
  //. ```javascript
  //. > S.reverse ([1, 2, 3])
  //. [3, 2, 1]
  //.
  //. > S.reverse (Cons (1) (Cons (2) (Cons (3) (Nil))))
  //. Cons (3) (Cons (2) (Cons (1) (Nil)))
  //.
  //. > S.pipe ([S.splitOn (''), S.reverse, S.joinWith ('')]) ('abc')
  //. 'cba'
  //. ```
  _.reverse = {
    consts: {f: [Z.Applicative, Z.Foldable, Z.Monoid]},
    types: [f (a), f (a)],
    impl: Z.reverse
  };

  //# sort :: (Ord a, Applicative m, Foldable m, Monoid (m a)) => m a -> m a
  //.
  //. Performs a [stable sort][] of the elements of the given structure, using
  //. [`Z.lte`][] for comparisons.
  //.
  //. Properties:
  //.
  //.   - `S.sort (S.sort (m)) = S.sort (m)` (idempotence)
  //.
  //. See also [`sortBy`](#sortBy).
  //.
  //. ```javascript
  //. > S.sort (['foo', 'bar', 'baz'])
  //. ['bar', 'baz', 'foo']
  //.
  //. > S.sort ([S.Left (4), S.Right (3), S.Left (2), S.Right (1)])
  //. [Left (2), Left (4), Right (1), Right (3)]
  //. ```
  _.sort = {
    consts: {a: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},
    types: [m (a), m (a)],
    impl: Z.sort
  };

  //# sortBy :: (Ord b, Applicative m, Foldable m, Monoid (m a)) => (a -> b) -> m a -> m a
  //.
  //. Performs a [stable sort][] of the elements of the given structure, using
  //. [`Z.lte`][] to compare the values produced by applying the given function
  //. to each element of the structure.
  //.
  //. Properties:
  //.
  //.   - `S.sortBy (f) (S.sortBy (f) (m)) = S.sortBy (f) (m)` (idempotence)
  //.
  //. See also [`sort`](#sort).
  //.
  //. ```javascript
  //. > S.sortBy (S.prop ('rank')) ([
  //. .   {rank: 7, suit: 'spades'},
  //. .   {rank: 5, suit: 'hearts'},
  //. .   {rank: 2, suit: 'hearts'},
  //. .   {rank: 5, suit: 'spades'},
  //. . ])
  //. [ {rank: 2, suit: 'hearts'},
  //. . {rank: 5, suit: 'hearts'},
  //. . {rank: 5, suit: 'spades'},
  //. . {rank: 7, suit: 'spades'} ]
  //.
  //. > S.sortBy (S.prop ('suit')) ([
  //. .   {rank: 7, suit: 'spades'},
  //. .   {rank: 5, suit: 'hearts'},
  //. .   {rank: 2, suit: 'hearts'},
  //. .   {rank: 5, suit: 'spades'},
  //. . ])
  //. [ {rank: 5, suit: 'hearts'},
  //. . {rank: 2, suit: 'hearts'},
  //. . {rank: 7, suit: 'spades'},
  //. . {rank: 5, suit: 'spades'} ]
  //. ```
  //.
  //. If descending order is desired, one may use [`Descending`][]:
  //.
  //. ```javascript
  //. > S.sortBy (Descending) ([83, 97, 110, 99, 116, 117, 97, 114, 121])
  //. [121, 117, 116, 114, 110, 99, 97, 97, 83]
  //. ```
  _.sortBy = {
    consts: {b: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid]},
    types: [Fn (a) (b), m (a), m (a)],
    impl: curry2 (Z.sortBy)
  };

  //# zip :: Array a -> Array b -> Array (Pair a b)
  //.
  //. Returns an array of pairs of corresponding elements from the given
  //. arrays. The length of the resulting array is equal to the length of
  //. the shorter input array.
  //.
  //. See also [`zipWith`](#zipWith).
  //.
  //. ```javascript
  //. > S.zip (['a', 'b']) (['x', 'y', 'z'])
  //. [Pair ('a') ('x'), Pair ('b') ('y')]
  //.
  //. > S.zip ([1, 3, 5]) ([2, 4])
  //. [Pair (1) (2), Pair (3) (4)]
  //. ```
  _.zip = {
    consts: {},
    types: [$.Array (a), $.Array (b), $.Array ($Pair (a) (b))],
    impl: zipWith (Pair)
  };

  //# zipWith :: (a -> b -> c) -> Array a -> Array b -> Array c
  //.
  //. Returns the result of combining, pairwise, the given arrays using the
  //. given binary function. The length of the resulting array is equal to the
  //. length of the shorter input array.
  //.
  //. See also [`zip`](#zip).
  //.
  //. ```javascript
  //. > S.zipWith (a => b => a + b) (['a', 'b']) (['x', 'y', 'z'])
  //. ['ax', 'by']
  //.
  //. > S.zipWith (a => b => [a, b]) ([1, 3, 5]) ([2, 4])
  //. [[1, 2], [3, 4]]
  //. ```
  function zipWith(f) {
    return function(xs) {
      return function(ys) {
        var result = [];
        var len = Math.min (xs.length, ys.length);
        for (var idx = 0; idx < len; idx += 1) {
          result.push (f (xs[idx]) (ys[idx]));
        }
        return result;
      };
    };
  }
  _.zipWith = {
    consts: {},
    types: [Fn (a) (Fn (b) (c)), $.Array (a), $.Array (b), $.Array (c)],
    impl: zipWith
  };

  //. ### Object

  //# prop :: String -> a -> b
  //.
  //. Takes a property name and an object with known properties and returns
  //. the value of the specified property. If for some reason the object
  //. lacks the specified property, a type error is thrown.
  //.
  //. For accessing properties of uncertain objects, use [`get`](#get) instead.
  //.
  //. ```javascript
  //. > S.prop ('a') ({a: 1, b: 2})
  //. 1
  //. ```
  function prop(key) {
    return function(x) {
      var obj = toObject (x);
      if (key in obj) return obj[key];
      throw new TypeError ('‘prop’ expected object to have a property named ' +
                           '‘' + key + '’; ' + show (x) + ' does not');
    };
  }
  _.prop = {
    consts: {},
    types: [$.String, a, b],
    impl: prop
  };

  //# props :: Array String -> a -> b
  //.
  //. Takes a property path (an array of property names) and an object with
  //. known structure and returns the value at the given path. If for some
  //. reason the path does not exist, a type error is thrown.
  //.
  //. For accessing property paths of uncertain objects, use [`gets`](#gets)
  //. instead.
  //.
  //. ```javascript
  //. > S.props (['a', 'b', 'c']) ({a: {b: {c: 1}}})
  //. 1
  //. ```
  function props(path) {
    return function(x) {
      return path.reduce (function(x, key) {
        var obj = toObject (x);
        if (key in obj) return obj[key];
        throw new TypeError ('‘props’ expected object to have a property at ' +
                             show (path) + '; ' + show (x) + ' does not');
      }, x);
    };
  }
  _.props = {
    consts: {},
    types: [$.Array ($.String), a, b],
    impl: props
  };

  //# get :: (Any -> Boolean) -> String -> a -> Maybe b
  //.
  //. Takes a predicate, a property name, and an object and returns Just the
  //. value of the specified object property if it exists and the value
  //. satisfies the given predicate; Nothing otherwise.
  //.
  //. See also [`gets`](#gets) and [`prop`](#prop).
  //.
  //. ```javascript
  //. > S.get (S.is ($.Number)) ('x') ({x: 1, y: 2})
  //. Just (1)
  //.
  //. > S.get (S.is ($.Number)) ('x') ({x: '1', y: '2'})
  //. Nothing
  //.
  //. > S.get (S.is ($.Number)) ('x') ({})
  //. Nothing
  //.
  //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3]})
  //. Just ([1, 2, 3])
  //.
  //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3, null]})
  //. Nothing
  //. ```
  function get(pred) {
    return B (B (filter (pred))) (get_);
  }
  _.get = {
    consts: {},
    types: [$.Predicate ($.Any), $.String, a, $Maybe (b)],
    impl: get
  };

  //# gets :: (Any -> Boolean) -> Array String -> a -> Maybe b
  //.
  //. Takes a predicate, a property path (an array of property names), and
  //. an object and returns Just the value at the given path if such a path
  //. exists and the value satisfies the given predicate; Nothing otherwise.
  //.
  //. See also [`get`](#get).
  //.
  //. ```javascript
  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: 42}}})
  //. Just (42)
  //.
  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: '42'}}})
  //. Nothing
  //.
  //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({})
  //. Nothing
  //. ```
  function gets(pred) {
    return function(keys) {
      return function(x) {
        return Z.filter (pred, keys.reduce (function(maybe, key) {
          return Z.chain (get_ (key), maybe);
        }, Just (x)));
      };
    };
  }
  _.gets = {
    consts: {},
    types: [$.Predicate ($.Any), $.Array ($.String), a, $Maybe (b)],
    impl: gets
  };

  //. ### StrMap
  //.
  //. StrMap is an abbreviation of _string map_. A string map is an object,
  //. such as `{foo: 1, bar: 2, baz: 3}`, whose values are all members of
  //. the same type. Formally, a value is a member of type `StrMap a` if its
  //. [type identifier][] is `'Object'` and the values of its enumerable own
  //. properties are all members of type `a`.

  //# singleton :: String -> a -> StrMap a
  //.
  //. Takes a string and a value of any type, and returns a string map with
  //. a single entry (mapping the key to the value).
  //.
  //. ```javascript
  //. > S.singleton ('foo') (42)
  //. {foo: 42}
  //. ```
  function singleton(key) {
    return function(val) {
      var strMap = {};
      strMap[key] = val;
      return strMap;
    };
  }
  _.singleton = {
    consts: {},
    types: [$.String, a, $.StrMap (a)],
    impl: singleton
  };

  //# insert :: String -> a -> StrMap a -> StrMap a
  //.
  //. Takes a string, a value of any type, and a string map, and returns a
  //. string map comprising all the entries of the given string map plus the
  //. entry specified by the first two arguments (which takes precedence).
  //.
  //. Equivalent to Haskell's `insert` function. Similar to Clojure's `assoc`
  //. function.
  //.
  //. ```javascript
  //. > S.insert ('c') (3) ({a: 1, b: 2})
  //. {a: 1, b: 2, c: 3}
  //.
  //. > S.insert ('a') (4) ({a: 1, b: 2})
  //. {a: 4, b: 2}
  //. ```
  function insert(key) {
    return function(val) {
      return function(strMap) {
        return Z.concat (strMap, singleton (key) (val));
      };
    };
  }
  _.insert = {
    consts: {},
    types: [$.String, a, $.StrMap (a), $.StrMap (a)],
    impl: insert
  };

  //# remove :: String -> StrMap a -> StrMap a
  //.
  //. Takes a string and a string map, and returns a string map comprising all
  //. the entries of the given string map except the one whose key matches the
  //. given string (if such a key exists).
  //.
  //. Equivalent to Haskell's `delete` function. Similar to Clojure's `dissoc`
  //. function.
  //.
  //. ```javascript
  //. > S.remove ('c') ({a: 1, b: 2, c: 3})
  //. {a: 1, b: 2}
  //.
  //. > S.remove ('c') ({})
  //. {}
  //. ```
  function remove(key) {
    return function(strMap) {
      var result = Z.concat (strMap, {});
      delete result[key];
      return result;
    };
  }
  _.remove = {
    consts: {},
    types: [$.String, $.StrMap (a), $.StrMap (a)],
    impl: remove
  };

  //# keys :: StrMap a -> Array String
  //.
  //. Returns the keys of the given string map, in arbitrary order.
  //.
  //. ```javascript
  //. > S.sort (S.keys ({b: 2, c: 3, a: 1}))
  //. ['a', 'b', 'c']
  //. ```
  _.keys = {
    consts: {},
    types: [$.StrMap (a), $.Array ($.String)],
    impl: Object.keys
  };

  //# values :: StrMap a -> Array a
  //.
  //. Returns the values of the given string map, in arbitrary order.
  //.
  //. ```javascript
  //. > S.sort (S.values ({a: 1, c: 3, b: 2}))
  //. [1, 2, 3]
  //. ```
  function values(strMap) {
    return Z.map (function(k) { return strMap[k]; }, Object.keys (strMap));
  }
  _.values = {
    consts: {},
    types: [$.StrMap (a), $.Array (a)],
    impl: values
  };

  //# pairs :: StrMap a -> Array (Pair String a)
  //.
  //. Returns the key–value pairs of the given string map, in arbitrary order.
  //.
  //. ```javascript
  //. > S.sort (S.pairs ({b: 2, a: 1, c: 3}))
  //. [Pair ('a') (1), Pair ('b') (2), Pair ('c') (3)]
  //. ```
  function pairs(strMap) {
    return Z.map (function(k) { return Pair (k) (strMap[k]); },
                  Object.keys (strMap));
  }
  _.pairs = {
    consts: {},
    types: [$.StrMap (a), $.Array ($Pair ($.String) (a))],
    impl: pairs
  };

  //# fromPairs :: Foldable f => f (Pair String a) -> StrMap a
  //.
  //. Returns a string map containing the key–value pairs specified by the
  //. given [Foldable][]. If a key appears in multiple pairs, the rightmost
  //. pair takes precedence.
  //.
  //. ```javascript
  //. > S.fromPairs ([S.Pair ('a') (1), S.Pair ('b') (2), S.Pair ('c') (3)])
  //. {a: 1, b: 2, c: 3}
  //.
  //. > S.fromPairs ([S.Pair ('x') (1), S.Pair ('x') (2)])
  //. {x: 2}
  //. ```
  function fromPairs(pairs) {
    return Z.reduce (function(strMap, pair) {
      strMap[pair.fst] = pair.snd;
      return strMap;
    }, {}, pairs);
  }
  _.fromPairs = {
    consts: {f: [Z.Foldable]},
    types: [f ($Pair ($.String) (a)), $.StrMap (a)],
    impl: fromPairs
  };

  //. ### Number

  //# negate :: ValidNumber -> ValidNumber
  //.
  //. Negates its argument.
  //.
  //. ```javascript
  //. > S.negate (12.5)
  //. -12.5
  //.
  //. > S.negate (-42)
  //. 42
  //. ```
  function negate(n) {
    return -n;
  }
  _.negate = {
    consts: {},
    types: [$.ValidNumber, $.ValidNumber],
    impl: negate
  };

  //# add :: FiniteNumber -> FiniteNumber -> FiniteNumber
  //.
  //. Returns the sum of two (finite) numbers.
  //.
  //. ```javascript
  //. > S.add (1) (1)
  //. 2
  //. ```
  function add(x) {
    return function(y) {
      return x + y;
    };
  }
  _.add = {
    consts: {},
    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],
    impl: add
  };

  //# sum :: Foldable f => f FiniteNumber -> FiniteNumber
  //.
  //. Returns the sum of the given array of (finite) numbers.
  //.
  //. ```javascript
  //. > S.sum ([1, 2, 3, 4, 5])
  //. 15
  //.
  //. > S.sum ([])
  //. 0
  //.
  //. > S.sum (S.Just (42))
  //. 42
  //.
  //. > S.sum (S.Nothing)
  //. 0
  //. ```
  _.sum = {
    consts: {f: [Z.Foldable]},
    types: [f ($.FiniteNumber), $.FiniteNumber],
    impl: reduce (add) (0)
  };

  //# sub :: FiniteNumber -> FiniteNumber -> FiniteNumber
  //.
  //. Takes a finite number `n` and returns the _subtract `n`_ function.
  //.
  //. ```javascript
  //. > S.map (S.sub (1)) ([1, 2, 3])
  //. [0, 1, 2]
  //. ```
  function sub(y) {
    return function(x) {
      return x - y;
    };
  }
  _.sub = {
    consts: {},
    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],
    impl: sub
  };

  //# mult :: FiniteNumber -> FiniteNumber -> FiniteNumber
  //.
  //. Returns the product of two (finite) numbers.
  //.
  //. ```javascript
  //. > S.mult (4) (2)
  //. 8
  //. ```
  function mult(x) {
    return function(y) {
      return x * y;
    };
  }
  _.mult = {
    consts: {},
    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],
    impl: mult
  };

  //# product :: Foldable f => f FiniteNumber -> FiniteNumber
  //.
  //. Returns the product of the given array of (finite) numbers.
  //.
  //. ```javascript
  //. > S.product ([1, 2, 3, 4, 5])
  //. 120
  //.
  //. > S.product ([])
  //. 1
  //.
  //. > S.product (S.Just (42))
  //. 42
  //.
  //. > S.product (S.Nothing)
  //. 1
  //. ```
  _.product = {
    consts: {f: [Z.Foldable]},
    types: [f ($.FiniteNumber), $.FiniteNumber],
    impl: reduce (mult) (1)
  };

  //# div :: NonZeroFiniteNumber -> FiniteNumber -> FiniteNumber
  //.
  //. Takes a non-zero finite number `n` and returns the _divide by `n`_
  //. function.
  //.
  //. ```javascript
  //. > S.map (S.div (2)) ([0, 1, 2, 3])
  //. [0, 0.5, 1, 1.5]
  //. ```
  function div(y) {
    return function(x) {
      return x / y;
    };
  }
  _.div = {
    consts: {},
    types: [$.NonZeroFiniteNumber, $.FiniteNumber, $.FiniteNumber],
    impl: div
  };

  //# pow :: FiniteNumber -> FiniteNumber -> FiniteNumber
  //.
  //. Takes a finite number `n` and returns the _power of `n`_ function.
  //.
  //. ```javascript
  //. > S.map (S.pow (2)) ([-3, -2, -1, 0, 1, 2, 3])
  //. [9, 4, 1, 0, 1, 4, 9]
  //.
  //. > S.map (S.pow (0.5)) ([1, 4, 9, 16, 25])
  //. [1, 2, 3, 4, 5]
  //. ```
  function pow(exp) {
    return function(base) {
      return Math.pow (base, exp);
    };
  }
  _.pow = {
    consts: {},
    types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],
    impl: pow
  };

  //# mean :: Foldable f => f FiniteNumber -> Maybe FiniteNumber
  //.
  //. Returns the mean of the given array of (finite) numbers.
  //.
  //. ```javascript
  //. > S.mean ([1, 2, 3, 4, 5])
  //. Just (3)
  //.
  //. > S.mean ([])
  //. Nothing
  //.
  //. > S.mean (S.Just (42))
  //. Just (42)
  //.
  //. > S.mean (S.Nothing)
  //. Nothing
  //. ```
  function mean(foldable) {
    var result = Z.reduce (
      function(acc, n) {
        acc.total += n;
        acc.count += 1;
        return acc;
      },
      {total: 0, count: 0},
      foldable
    );
    return result.count > 0 ? Just (result.total / result.count) : Nothing;
  }
  _.mean = {
    consts: {f: [Z.Foldable]},
    types: [f ($.FiniteNumber), $Maybe ($.FiniteNumber)],
    impl: mean
  };

  //. ### Integer

  //# even :: Integer -> Boolean
  //.
  //. Returns `true` if the given integer is even; `false` if it is odd.
  //.
  //. ```javascript
  //. > S.even (42)
  //. true
  //.
  //. > S.even (99)
  //. false
  //. ```
  function even(n) {
    return n % 2 === 0;
  }
  _.even = {
    consts: {},
    types: [$.Integer, $.Boolean],
    impl: even
  };

  //# odd :: Integer -> Boolean
  //.
  //. Returns `true` if the given integer is odd; `false` if it is even.
  //.
  //. ```javascript
  //. > S.odd (99)
  //. true
  //.
  //. > S.odd (42)
  //. false
  //. ```
  function odd(n) {
    return n % 2 !== 0;
  }
  _.odd = {
    consts: {},
    types: [$.Integer, $.Boolean],
    impl: odd
  };

  //. ### Parse

  //# parseDate :: String -> Maybe ValidDate
  //.
  //. Takes a string and returns Just the date represented by the string
  //. if it does in fact represent a date; Nothing otherwise.
  //.
  //. ```javascript
  //. > S.parseDate ('2011-01-19T17:40:00Z')
  //. Just (new Date ('2011-01-19T17:40:00.000Z'))
  //.
  //. > S.parseDate ('today')
  //. Nothing
  //. ```
  function parseDate(s) {
    var date = new Date (s);
    return isNaN (date.valueOf ()) ? Nothing : Just (date);
  }
  _.parseDate = {
    consts: {},
    types: [$.String, $Maybe ($.ValidDate)],
    impl: parseDate
  };

  //  requiredNonCapturingGroup :: Array String -> String
  function requiredNonCapturingGroup(xs) {
    return '(?:' + xs.join ('|') + ')';
  }

  //  optionalNonCapturingGroup :: Array String -> String
  function optionalNonCapturingGroup(xs) {
    return requiredNonCapturingGroup (xs) + '?';
  }

  //  validFloatRepr :: RegExp
  var validFloatRepr = new RegExp (
    '^' +                     // start-of-string anchor
    '\\s*' +                  // any number of leading whitespace characters
    '[+-]?' +                 // optional sign
    requiredNonCapturingGroup ([
      'Infinity',             // "Infinity"
      'NaN',                  // "NaN"
      requiredNonCapturingGroup ([
        '[0-9]+',             // number
        '[0-9]+[.][0-9]+',    // number with interior decimal point
        '[0-9]+[.]',          // number with trailing decimal point
        '[.][0-9]+'           // number with leading decimal point
      ]) +
      optionalNonCapturingGroup ([
        '[Ee]' +              // "E" or "e"
        '[+-]?' +             // optional sign
        '[0-9]+'              // exponent
      ])
    ]) +
    '\\s*' +                  // any number of trailing whitespace characters
    '$'                       // end-of-string anchor
  );

  //# parseFloat :: String -> Maybe Number
  //.
  //. Takes a string and returns Just the number represented by the string
  //. if it does in fact represent a number; Nothing otherwise.
  //.
  //. ```javascript
  //. > S.parseFloat ('-123.45')
  //. Just (-123.45)
  //.
  //. > S.parseFloat ('foo.bar')
  //. Nothing
  //. ```
  function parseFloat_(s) {
    return validFloatRepr.test (s) ? Just (parseFloat (s)) : Nothing;
  }
  _.parseFloat = {
    consts: {},
    types: [$.String, $Maybe ($.Number)],
    impl: parseFloat_
  };

  //  Radix :: Type
  var Radix = $.NullaryType
    ('sanctuary/Radix')
    ('')
    (function(x) { return $.Integer._test (x) && x >= 2 && x <= 36; });

  //# parseInt :: Radix -> String -> Maybe Integer
  //.
  //. Takes a radix (an integer between 2 and 36 inclusive) and a string,
  //. and returns Just the number represented by the string if it does in
  //. fact represent a number in the base specified by the radix; Nothing
  //. otherwise.
  //.
  //. This function is stricter than [`parseInt`][parseInt]: a string
  //. is considered to represent an integer only if all its non-prefix
  //. characters are members of the character set specified by the radix.
  //.
  //. ```javascript
  //. > S.parseInt (10) ('-42')
  //. Just (-42)
  //.
  //. > S.parseInt (16) ('0xFF')
  //. Just (255)
  //.
  //. > S.parseInt (16) ('0xGG')
  //. Nothing
  //. ```
  function parseInt_(radix) {
    return function(s) {
      var charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.slice (0, radix);
      var pattern = new RegExp ('^[' + charset + ']+$', 'i');

      var t = s.replace (/^[+-]/, '');
      if (pattern.test (radix === 16 ? t.replace (/^0x/i, '') : t)) {
        var n = parseInt (s, radix);
        if ($.Integer._test (n)) return Just (n);
      }
      return Nothing;
    };
  }
  _.parseInt = {
    consts: {},
    types: [Radix, $.String, $Maybe ($.Integer)],
    impl: parseInt_
  };

  //# parseJson :: (Any -> Boolean) -> String -> Maybe a
  //.
  //. Takes a predicate and a string which may or may not be valid JSON, and
  //. returns Just the result of applying `JSON.parse` to the string *if* the
  //. result satisfies the predicate; Nothing otherwise.
  //.
  //. ```javascript
  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[')
  //. Nothing
  //.
  //. > S.parseJson (S.is ($.Array ($.Integer))) ('["1","2","3"]')
  //. Nothing
  //.
  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[0,1.5,3,4.5]')
  //. Nothing
  //.
  //. > S.parseJson (S.is ($.Array ($.Integer))) ('[1,2,3]')
  //. Just ([1, 2, 3])
  //. ```
  function parseJson(pred) {
    return B (filter (pred)) (encase (JSON.parse));
  }
  _.parseJson = {
    consts: {},
    types: [$.Predicate ($.Any), $.String, $Maybe (a)],
    impl: parseJson
  };

  //. ### RegExp

  //  Match :: Type
  var Match = $.RecordType ({
    match: $.String,
    groups: $.Array ($Maybe ($.String))
  });

  //  toMatch :: Array String? -> Match
  function toMatch(ss) {
    return {match: ss[0], groups: Z.map (toMaybe, ss.slice (1))};
  }

  //  withRegex :: (RegExp, () -> a) -> a
  function withRegex(pattern, thunk) {
    var lastIndex = pattern.lastIndex;
    var result = thunk ();
    pattern.lastIndex = lastIndex;
    return result;
  }

  //# regex :: RegexFlags -> String -> RegExp
  //.
  //. Takes a [RegexFlags][] and a pattern, and returns a RegExp.
  //.
  //. ```javascript
  //. > S.regex ('g') (':\\d+:')
  //. /:\d+:/g
  //. ```
  function regex(flags) {
    return function(source) {
      return new RegExp (source, flags);
    };
  }
  _.regex = {
    consts: {},
    types: [$.RegexFlags, $.String, $.RegExp],
    impl: regex
  };

  //# regexEscape :: String -> String
  //.
  //. Takes a string which may contain regular expression metacharacters,
  //. and returns a string with those metacharacters escaped.
  //.
  //. Properties:
  //.
  //.   - `forall s :: String.
  //.      S.test (S.regex ('') (S.regexEscape (s))) (s) = true`
  //.
  //. ```javascript
  //. > S.regexEscape ('-=*{XYZ}*=-')
  //. '\\-=\\*\\{XYZ\\}\\*=\\-'
  //. ```
  function regexEscape(s) {
    return s.replace (/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
  }
  _.regexEscape = {
    consts: {},
    types: [$.String, $.String],
    impl: regexEscape
  };

  //# test :: RegExp -> String -> Boolean
  //.
  //. Takes a pattern and a string, and returns `true` [iff][] the pattern
  //. matches the string.
  //.
  //. ```javascript
  //. > S.test (/^a/) ('abacus')
  //. true
  //.
  //. > S.test (/^a/) ('banana')
  //. false
  //. ```
  function test(pattern) {
    return function(s) {
      return withRegex (pattern, function() { return pattern.test (s); });
    };
  }
  _.test = {
    consts: {},
    types: [$.RegExp, $.String, $.Boolean],
    impl: test
  };

  //# match :: NonGlobalRegExp -> String -> Maybe { match :: String, groups :: Array (Maybe String) }
  //.
  //. Takes a pattern and a string, and returns Just a match record if the
  //. pattern matches the string; Nothing otherwise.
  //.
  //. `groups :: Array (Maybe String)` acknowledges the existence of optional
  //. capturing groups.
  //.
  //. Properties:
  //.
  //.   - `forall p :: Pattern, s :: String.
  //.      S.head (S.matchAll (S.regex ('g') (p)) (s))
  //.      = S.match (S.regex ('') (p)) (s)`
  //.
  //. See also [`matchAll`](#matchAll).
  //.
  //. ```javascript
  //. > S.match (/(good)?bye/) ('goodbye')
  //. Just ({match: 'goodbye', groups: [Just ('good')]})
  //.
  //. > S.match (/(good)?bye/) ('bye')
  //. Just ({match: 'bye', groups: [Nothing]})
  //. ```
  function match(pattern) {
    return function(s) {
      return Z.map (toMatch, toMaybe (s.match (pattern)));
    };
  }
  _.match = {
    consts: {},
    types: [$.NonGlobalRegExp, $.String, $Maybe (Match)],
    impl: match
  };

  //# matchAll :: GlobalRegExp -> String -> Array { match :: String, groups :: Array (Maybe String) }
  //.
  //. Takes a pattern and a string, and returns an array of match records.
  //.
  //. `groups :: Array (Maybe String)` acknowledges the existence of optional
  //. capturing groups.
  //.
  //. See also [`match`](#match).
  //.
  //. ```javascript
  //. > S.matchAll (/@([a-z]+)/g) ('Hello, world!')
  //. []
  //.
  //. > S.matchAll (/@([a-z]+)/g) ('Hello, @foo! Hello, @bar! Hello, @baz!')
  //. [ {match: '@foo', groups: [Just ('foo')]},
  //. . {match: '@bar', groups: [Just ('bar')]},
  //. . {match: '@baz', groups: [Just ('baz')]} ]
  //. ```
  function matchAll(pattern) {
    return function(s) {
      return withRegex (pattern, function() {
        return unfoldr (function(_) {
          return Z.map (function(ss) {
            return Pair (toMatch (ss)) (null);
          }, toMaybe (pattern.exec (s)));
        }) ([]);
      });
    };
  }
  _.matchAll = {
    consts: {},
    types: [$.GlobalRegExp, $.String, $.Array (Match)],
    impl: matchAll
  };

  //. ### String

  //# toUpper :: String -> String
  //.
  //. Returns the upper-case equivalent of its argument.
  //.
  //. See also [`toLower`](#toLower).
  //.
  //. ```javascript
  //. > S.toUpper ('ABC def 123')
  //. 'ABC DEF 123'
  //. ```
  _.toUpper = {
    consts: {},
    types: [$.String, $.String],
    impl: invoke0 ('toUpperCase')
  };

  //# toLower :: String -> String
  //.
  //. Returns the lower-case equivalent of its argument.
  //.
  //. See also [`toUpper`](#toUpper).
  //.
  //. ```javascript
  //. > S.toLower ('ABC def 123')
  //. 'abc def 123'
  //. ```
  _.toLower = {
    consts: {},
    types: [$.String, $.String],
    impl: invoke0 ('toLowerCase')
  };

  //# trim :: String -> String
  //.
  //. Strips leading and trailing whitespace characters.
  //.
  //. ```javascript
  //. > S.trim ('\t\t foo bar \n')
  //. 'foo bar'
  //. ```
  _.trim = {
    consts: {},
    types: [$.String, $.String],
    impl: invoke0 ('trim')
  };

  //# stripPrefix :: String -> String -> Maybe String
  //.
  //. Returns Just the portion of the given string (the second argument) left
  //. after removing the given prefix (the first argument) if the string starts
  //. with the prefix; Nothing otherwise.
  //.
  //. See also [`stripSuffix`](#stripSuffix).
  //.
  //. ```javascript
  //. > S.stripPrefix ('https://') ('https://sanctuary.js.org')
  //. Just ('sanctuary.js.org')
  //.
  //. > S.stripPrefix ('https://') ('http://sanctuary.js.org')
  //. Nothing
  //. ```
  function stripPrefix(prefix) {
    return function(s) {
      var idx = prefix.length;
      return s.slice (0, idx) === prefix ? Just (s.slice (idx)) : Nothing;
    };
  }
  _.stripPrefix = {
    consts: {},
    types: [$.String, $.String, $Maybe ($.String)],
    impl: stripPrefix
  };

  //# stripSuffix :: String -> String -> Maybe String
  //.
  //. Returns Just the portion of the given string (the second argument) left
  //. after removing the given suffix (the first argument) if the string ends
  //. with the suffix; Nothing otherwise.
  //.
  //. See also [`stripPrefix`](#stripPrefix).
  //.
  //. ```javascript
  //. > S.stripSuffix ('.md') ('README.md')
  //. Just ('README')
  //.
  //. > S.stripSuffix ('.md') ('README')
  //. Nothing
  //. ```
  function stripSuffix(suffix) {
    return function(s) {
      var idx = s.length - suffix.length;  // value may be negative
      return s.slice (idx) === suffix ? Just (s.slice (0, idx)) : Nothing;
    };
  }
  _.stripSuffix = {
    consts: {},
    types: [$.String, $.String, $Maybe ($.String)],
    impl: stripSuffix
  };

  //# words :: String -> Array String
  //.
  //. Takes a string and returns the array of words the string contains
  //. (words are delimited by whitespace characters).
  //.
  //. See also [`unwords`](#unwords).
  //.
  //. ```javascript
  //. > S.words (' foo bar baz ')
  //. ['foo', 'bar', 'baz']
  //. ```
  function words(s) {
    var words = s.split (/\s+/);
    var len = words.length;
    return words.slice (words[0] === '' ? 1 : 0,
                        words[len - 1] === '' ? len - 1 : len);
  }
  _.words = {
    consts: {},
    types: [$.String, $.Array ($.String)],
    impl: words
  };

  //# unwords :: Array String -> String
  //.
  //. Takes an array of words and returns the result of joining the words
  //. with separating spaces.
  //.
  //. See also [`words`](#words).
  //.
  //. ```javascript
  //. > S.unwords (['foo', 'bar', 'baz'])
  //. 'foo bar baz'
  //. ```
  _.unwords = {
    consts: {},
    types: [$.Array ($.String), $.String],
    impl: invoke1 ('join') (' ')
  };

  //# lines :: String -> Array String
  //.
  //. Takes a string and returns the array of lines the string contains
  //. (lines are delimited by newlines: `'\n'` or `'\r\n'` or `'\r'`).
  //. The resulting strings do not contain newlines.
  //.
  //. See also [`unlines`](#unlines).
  //.
  //. ```javascript
  //. > S.lines ('foo\nbar\nbaz\n')
  //. ['foo', 'bar', 'baz']
  //. ```
  function lines(s) {
    return s === '' ? []
                    : (s.replace (/\r\n?/g, '\n')).match (/^(?=[\s\S]).*/gm);
  }
  _.lines = {
    consts: {},
    types: [$.String, $.Array ($.String)],
    impl: lines
  };

  //# unlines :: Array String -> String
  //.
  //. Takes an array of lines and returns the result of joining the lines
  //. after appending a terminating line feed (`'\n'`) to each.
  //.
  //. See also [`lines`](#lines).
  //.
  //. ```javascript
  //. > S.unlines (['foo', 'bar', 'baz'])
  //. 'foo\nbar\nbaz\n'
  //. ```
  function unlines(xs) {
    return xs.reduce (function(s, x) { return s + x + '\n'; }, '');
  }
  _.unlines = {
    consts: {},
    types: [$.Array ($.String), $.String],
    impl: unlines
  };

  //# splitOn :: String -> String -> Array String
  //.
  //. Returns the substrings of its second argument separated by occurrences
  //. of its first argument.
  //.
  //. See also [`joinWith`](#joinWith) and [`splitOnRegex`](#splitOnRegex).
  //.
  //. ```javascript
  //. > S.splitOn ('::') ('foo::bar::baz')
  //. ['foo', 'bar', 'baz']
  //. ```
  _.splitOn = {
    consts: {},
    types: [$.String, $.String, $.Array ($.String)],
    impl: invoke1 ('split')
  };

  //# splitOnRegex :: GlobalRegExp -> String -> Array String
  //.
  //. Takes a pattern and a string, and returns the result of splitting the
  //. string at every non-overlapping occurrence of the pattern.
  //.
  //. Properties:
  //.
  //.   - `forall s :: String, t :: String.
  //.      S.joinWith (s)
  //.                 (S.splitOnRegex (S.regex ('g') (S.regexEscape (s))) (t))
  //.      = t`
  //.
  //. See also [`splitOn`](#splitOn).
  //.
  //. ```javascript
  //. > S.splitOnRegex (/[,;][ ]*/g) ('foo, bar, baz')
  //. ['foo', 'bar', 'baz']
  //.
  //. > S.splitOnRegex (/[,;][ ]*/g) ('foo;bar;baz')
  //. ['foo', 'bar', 'baz']
  //. ```
  function splitOnRegex(pattern) {
    return function(s) {
      return withRegex (pattern, function() {
        var result = [];
        var lastIndex = 0;
        var match;
        while ((match = pattern.exec (s)) != null) {
          if (pattern.lastIndex === lastIndex && match[0] === '') {
            if (pattern.lastIndex === s.length) return result;
            pattern.lastIndex += 1;
          } else {
            result.push (s.slice (lastIndex, match.index));
            lastIndex = match.index + match[0].length;
          }
        }
        result.push (s.slice (lastIndex));
        return result;
      });
    };
  }
  _.splitOnRegex = {
    consts: {},
    types: [$.GlobalRegExp, $.String, $.Array ($.String)],
    impl: splitOnRegex
  };

  return create ({
    checkTypes: (
      /* global process:false */
      typeof process === 'undefined'
      || process == null
      || process.env == null
      || "development" !== 'production'
    ),
    env: Z.concat ($.env, [
      $.FiniteNumber,
      $.NonZeroFiniteNumber,
      $Either ($.Unknown) ($.Unknown),
      Fn ($.Unknown) ($.Unknown),
      $.GlobalRegExp,
      $.NonGlobalRegExp,
      $.Integer,
      $.NonNegativeInteger,
      $Maybe ($.Unknown),
      $.Array2 ($.Unknown) ($.Unknown),
      $Pair ($.Unknown) ($.Unknown),
      $.RegexFlags,
      $.Type,
      $.TypeClass,
      $.ValidDate,
      $.ValidNumber
    ])
  });

}));

//. [#438]:                     https://github.com/sanctuary-js/sanctuary/issues/438
//. [Apply]:                    v:fantasyland/fantasy-land#apply
//. [BinaryType]:               v:sanctuary-js/sanctuary-def#BinaryType
//. [Chain]:                    v:fantasyland/fantasy-land#chain
//. [Either]:                   #either-type
//. [Fantasy Land]:             v:fantasyland/fantasy-land
//. [Foldable]:                 v:fantasyland/fantasy-land#foldable
//. [GIGO]:                     https://en.wikipedia.org/wiki/Garbage_in,_garbage_out
//. [Haskell]:                  https://www.haskell.org/
//. [Kleisli]:                  https://en.wikipedia.org/wiki/Kleisli_category
//. [Maybe]:                    #maybe-type
//. [Nullable]:                 v:sanctuary-js/sanctuary-def#Nullable
//. [PureScript]:               http://www.purescript.org/
//. [Ramda]:                    http://ramdajs.com/
//. [RegexFlags]:               v:sanctuary-js/sanctuary-def#RegexFlags
//. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid
//. [UnaryType]:                v:sanctuary-js/sanctuary-def#UnaryType
//. [`$.test`]:                 v:sanctuary-js/sanctuary-def#test
//. [`Descending`]:             v:sanctuary-js/sanctuary-descending#Descending
//. [`R.__`]:                   http://ramdajs.com/docs/#__
//. [`R.bind`]:                 http://ramdajs.com/docs/#bind
//. [`R.invoker`]:              http://ramdajs.com/docs/#invoker
//. [`Z.alt`]:                  v:sanctuary-js/sanctuary-type-classes#alt
//. [`Z.ap`]:                   v:sanctuary-js/sanctuary-type-classes#ap
//. [`Z.apFirst`]:              v:sanctuary-js/sanctuary-type-classes#apFirst
//. [`Z.apSecond`]:             v:sanctuary-js/sanctuary-type-classes#apSecond
//. [`Z.bimap`]:                v:sanctuary-js/sanctuary-type-classes#bimap
//. [`Z.chain`]:                v:sanctuary-js/sanctuary-type-classes#chain
//. [`Z.chainRec`]:             v:sanctuary-js/sanctuary-type-classes#chainRec
//. [`Z.compose`]:              v:sanctuary-js/sanctuary-type-classes#compose
//. [`Z.concat`]:               v:sanctuary-js/sanctuary-type-classes#concat
//. [`Z.contramap`]:            v:sanctuary-js/sanctuary-type-classes#contramap
//. [`Z.dropWhile`]:            v:sanctuary-js/sanctuary-type-classes#dropWhile
//. [`Z.duplicate`]:            v:sanctuary-js/sanctuary-type-classes#duplicate
//. [`Z.empty`]:                v:sanctuary-js/sanctuary-type-classes#empty
//. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals
//. [`Z.extend`]:               v:sanctuary-js/sanctuary-type-classes#extend
//. [`Z.extract`]:              v:sanctuary-js/sanctuary-type-classes#extract
//. [`Z.filter`]:               v:sanctuary-js/sanctuary-type-classes#filter
//. [`Z.flip`]:                 v:sanctuary-js/sanctuary-type-classes#flip
//. [`Z.foldMap`]:              v:sanctuary-js/sanctuary-type-classes#foldMap
//. [`Z.gt`]:                   v:sanctuary-js/sanctuary-type-classes#gt
//. [`Z.gte`]:                  v:sanctuary-js/sanctuary-type-classes#gte
//. [`Z.id`]:                   v:sanctuary-js/sanctuary-type-classes#id
//. [`Z.invert`]:               v:sanctuary-js/sanctuary-type-classes#invert
//. [`Z.join`]:                 v:sanctuary-js/sanctuary-type-classes#join
//. [`Z.lt`]:                   v:sanctuary-js/sanctuary-type-classes#lt
//. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte
//. [`Z.map`]:                  v:sanctuary-js/sanctuary-type-classes#map
//. [`Z.mapLeft`]:              v:sanctuary-js/sanctuary-type-classes#mapLeft
//. [`Z.of`]:                   v:sanctuary-js/sanctuary-type-classes#of
//. [`Z.promap`]:               v:sanctuary-js/sanctuary-type-classes#promap
//. [`Z.reject`]:               v:sanctuary-js/sanctuary-type-classes#reject
//. [`Z.sequence`]:             v:sanctuary-js/sanctuary-type-classes#sequence
//. [`Z.takeWhile`]:            v:sanctuary-js/sanctuary-type-classes#takeWhile
//. [`Z.traverse`]:             v:sanctuary-js/sanctuary-type-classes#traverse
//. [`Z.zero`]:                 v:sanctuary-js/sanctuary-type-classes#zero
//. [`show`]:                   v:sanctuary-js/sanctuary-show#show
//. [equivalence]:              https://en.wikipedia.org/wiki/Equivalence_relation
//. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if
//. [parseInt]:                 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
//. [partial functions]:        https://en.wikipedia.org/wiki/Partial_function
//. [ramda/ramda#683]:          https://github.com/ramda/ramda/issues/683
//. [ramda/ramda#1413]:         https://github.com/ramda/ramda/issues/1413
//. [ramda/ramda#1419]:         https://github.com/ramda/ramda/pull/1419
//. [sanctuary-def]:            v:sanctuary-js/sanctuary-def
//. [sanctuary-either]:         v:sanctuary-js/sanctuary-either
//. [sanctuary-maybe]:          v:sanctuary-js/sanctuary-maybe
//. [sanctuary-pair]:           v:sanctuary-js/sanctuary-pair
//. [sanctuary-show]:           v:sanctuary-js/sanctuary-show
//. [sanctuary-type-classes]:   v:sanctuary-js/sanctuary-type-classes
//. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
//. [thrush]:                   https://github.com/raganwald-deprecated/homoiconic/blob/master/2008-10-30/thrush.markdown
//. [total functions]:          https://en.wikipedia.org/wiki/Partial_function#Total_function
//. [type checking]:            #type-checking
//. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers
//. [type representative]:      v:fantasyland/fantasy-land#type-representatives
//. [variadic functions]:       https://en.wikipedia.org/wiki/Variadic_function

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _print_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print.js */ "./src/print.js");
/* eslint-env node */


const {reduce, concat, map} = __webpack_require__ (/*! sanctuary */ "./node_modules/sanctuary/index.js")

function join(list, separator) {
  return reduce (concat) ('') (map (x => concat (x) (separator)) (list))
}

function component() {
  const element = document.createElement ('div')
  const btn = document.createElement ('button')

  element.innerHTML = join (['Hello', 'Webpack'], ' ')

  btn.innerHTML = 'Click me and check the console'
  btn.onclick = _print_js__WEBPACK_IMPORTED_MODULE_0__["default"]
  element.appendChild (btn)


  return element
}

document.body.appendChild (component ())


/***/ }),

/***/ "./src/print.js":
/*!**********************!*\
  !*** ./src/print.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return printMe; });
/* eslint-env node */

function printMe() {
  console.log ('I get called from print.js!');
}


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LWRlZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LWVpdGhlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LW1heWJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktcGFpci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXNob3cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9wcmludC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7QUN2THRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTLHFCQUFxQjtBQUNsRCxvQkFBb0IsU0FBUyxxQkFBcUI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsTUFBTSxLQUEwQjtBQUNoQyx3QkFBd0IsbUJBQU8sRUFBRSw4REFBZ0I7QUFDakQsd0JBQXdCLG1CQUFPLEVBQUUsOEVBQXdCO0FBQ3pELEdBQUcsVUFBVSxLQUE0QixJQUFJLGdHQUFVO0FBQ3ZELElBQUksaUNBQVEsQ0FBQyxtRkFBZ0IsRUFBRSxtR0FBd0IsQ0FBQyxvQ0FBRSxDQUFDO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzVELEdBQUc7QUFDSDtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQyxFQUFFO0FBQzdELHNCQUFzQixrQ0FBa0MsRUFBRTtBQUMxRDtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUEwQjtBQUM5QixJQUFJLG1CQUFPLEVBQUUseUNBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVMscUJBQXFCO0FBQ2xELG9CQUFvQixTQUFTLHFCQUFxQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxnQkFBZ0I7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0EsTUFBTSxLQUEwQjtBQUNoQyx3QkFBd0IsbUJBQU8sRUFBRSw4REFBZ0I7QUFDakQsd0JBQXdCLG1CQUFPLEVBQUUsOEVBQXdCO0FBQ3pELEdBQUcsVUFBVSxLQUE0QixJQUFJLGdHQUFVO0FBQ3ZELElBQUksaUNBQVEsQ0FBQyxtRkFBZ0IsRUFBRSxtR0FBd0IsQ0FBQyxvQ0FBRSxDQUFDO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzVELEdBQUc7QUFDSDtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9DQUFvQyxFQUFFO0FBQzVELHNCQUFzQixnQkFBZ0IsRUFBRTtBQUN4QyxzQkFBc0IsZ0JBQWdCLEVBQUU7QUFDeEM7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUEwQjtBQUM5QixJQUFJLG1CQUFPLEVBQUUseUNBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxNQUFNLEtBQTBCO0FBQ2hDO0FBQ0EsR0FBRyxVQUFVLEtBQTRCLElBQUksZ0dBQVU7QUFDdkQsSUFBSSxpQ0FBTyxFQUFFLG9DQUFFLENBQUM7QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDakIsR0FBRztBQUNIO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDLEVBQUU7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDLEVBQUU7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYyxFQUFFO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCLEVBQUU7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZCQUE2QixFQUFFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkJBQTZCLEVBQUU7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsK0NBQStDLDBCQUEwQjtBQUN6RSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzV3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEUsT0FBTztBQUNQO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUIsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CLEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTyxtQkFBbUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBaUQsRUFBRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4cUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsMEVBQW9COztBQUUvQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkRBQVU7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6a0JBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUFBOztBQUVnQztBQUNoQyxPQUFPLG9CQUFvQixHQUFHLG1CQUFPLEVBQUUsb0RBQVc7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsaURBQU87QUFDdkI7OztBQUdBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUN2QkE7QUFBQTtBQUFBOztBQUVlO0FBQ2Y7QUFDQSIsImZpbGUiOiJhcHAuYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXguanNcIik7XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiAgICAgICAgICAgICAgX19fICAgICAgICAgICAgICAgICBfX19fX19cbiAgICAgICAgICAgICAgIC8gIC9cXCAgICAgICAgICAgICAgIC8gIF9fXy9cXFxuICAgICAgICBfX19fX18vICAvIC8gX19fX19fXyAgICBfXy8gIC9fX19cXC9cbiAgICAgICAvICBfX18gICAvIC8gLyAgX19fICBcXCAgL18gICBfXy9cXFxuICAgICAgLyAgL1xcXy8gIC8gLyAvICAvX18vICAvXFwgXFwvICAvXFxfXFwvXG4gICAgIC8gIC8gLy8gIC8gLyAvICBfX19fX18vIC8gLyAgLyAvXG4gICAgLyAgL18vLyAgLyAvIC8gIC9fX19fX19cXC8gLyAgLyAvXG4gICAgXFxfX19fX19fLyAvICBcXF9fX19fX18vXFwgIC9fXy8gL1xuICAgICBcXF9fX19fX1xcLyAgICBcXF9fX19fX1xcLyAgXFxfXyovXG5cbi8vLiAjIHNhbmN0dWFyeS1kZWZcbi8vLlxuLy8uIHNhbmN0dWFyeS1kZWYgaXMgYSBydW4tdGltZSB0eXBlIHN5c3RlbSBmb3IgSmF2YVNjcmlwdC4gSXQgZmFjaWxpdGF0ZXNcbi8vLiB0aGUgZGVmaW5pdGlvbiBvZiBjdXJyaWVkIEphdmFTY3JpcHQgZnVuY3Rpb25zIHdoaWNoIGFyZSBleHBsaWNpdCBhYm91dFxuLy8uIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHdoaWNoIHRoZXkgbWF5IGJlIGFwcGxpZWQgYW5kIHRoZSB0eXBlcyBvZlxuLy8uIHRob3NlIGFyZ3VtZW50cy5cbi8vLlxuLy8uIEl0IGlzIGNvbnZlbnRpb25hbCB0byBpbXBvcnQgdGhlIHBhY2thZ2UgYXMgYCRgOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIGNvbnN0ICQgPSByZXF1aXJlICgnc2FuY3R1YXJ5LWRlZicpO1xuLy8uIGBgYFxuLy8uXG4vLy4gVGhlIG5leHQgc3RlcCBpcyB0byBkZWZpbmUgYW4gZW52aXJvbm1lbnQuIEFuIGVudmlyb25tZW50IGlzIGFuIGFycmF5XG4vLy4gb2YgW3R5cGVzXVtdLiBbYGVudmBdW10gaXMgYW4gZW52aXJvbm1lbnQgY29udGFpbmluZyBhbGwgdGhlIGJ1aWx0LWluXG4vLy4gSmF2YVNjcmlwdCB0eXBlcy4gSXQgbWF5IGJlIHVzZWQgYXMgdGhlIGJhc2lzIGZvciBlbnZpcm9ubWVudHMgd2hpY2hcbi8vLiBpbmNsdWRlIGN1c3RvbSB0eXBlcyBpbiBhZGRpdGlvbiB0byB0aGUgYnVpbHQtaW4gdHlwZXM6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gICAgSW50ZWdlciA6OiBUeXBlXG4vLy4gY29uc3QgSW50ZWdlciA9ICcuLi4nO1xuLy8uXG4vLy4gLy8gICAgTm9uWmVyb0ludGVnZXIgOjogVHlwZVxuLy8uIGNvbnN0IE5vblplcm9JbnRlZ2VyID0gJy4uLic7XG4vLy5cbi8vLiAvLyAgICBlbnYgOjogQXJyYXkgVHlwZVxuLy8uIGNvbnN0IGVudiA9ICQuZW52LmNvbmNhdCAoW0ludGVnZXIsIE5vblplcm9JbnRlZ2VyXSk7XG4vLy4gYGBgXG4vLy5cbi8vLiBUeXBlIGNvbnN0cnVjdG9ycyBzdWNoIGFzIGBMaXN0IDo6IFR5cGUgLT4gVHlwZWAgY2Fubm90IGJlIGluY2x1ZGVkIGluXG4vLy4gYW4gZW52aXJvbm1lbnQgYXMgdGhleSdyZSBub3Qgb2YgdGhlIGNvcnJlY3QgdHlwZS4gT25lIGNvdWxkLCB0aG91Z2gsXG4vLy4gdXNlIGEgdHlwZSBjb25zdHJ1Y3RvciB0byBkZWZpbmUgYSBmaXhlZCBudW1iZXIgb2YgY29uY3JldGUgdHlwZXM6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gICAgZW52IDo6IEFycmF5IFR5cGVcbi8vLiBjb25zdCBlbnYgPSAkLmVudi5jb25jYXQgKFtcbi8vLiAgIExpc3QgKCQuTnVtYmVyKSwgICAgICAgICAgICAgICAgLy8gOjogVHlwZVxuLy8uICAgTGlzdCAoJC5TdHJpbmcpLCAgICAgICAgICAgICAgICAvLyA6OiBUeXBlXG4vLy4gICBMaXN0IChMaXN0ICgkLk51bWJlcikpLCAgICAgICAgIC8vIDo6IFR5cGVcbi8vLiAgIExpc3QgKExpc3QgKCQuU3RyaW5nKSksICAgICAgICAgLy8gOjogVHlwZVxuLy8uICAgTGlzdCAoTGlzdCAoTGlzdCAoJC5OdW1iZXIpKSksICAvLyA6OiBUeXBlXG4vLy4gICBMaXN0IChMaXN0IChMaXN0ICgkLlN0cmluZykpKSwgIC8vIDo6IFR5cGVcbi8vLiBdKTtcbi8vLiBgYGBcbi8vLlxuLy8uIE5vdCBvbmx5IHdvdWxkIHRoaXMgYmUgdGVkaW91cywgYnV0IG9uZSBjb3VsZCBuZXZlciBlbnVtZXJhdGUgYWxsIHBvc3NpYmxlXG4vLy4gdHlwZXMgYXMgdGhlcmUgYXJlIGluZmluaXRlbHkgbWFueS4gSW5zdGVhZCwgb25lIHNob3VsZCB1c2UgW2BVbmtub3duYF1bXTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBlbnYgOjogQXJyYXkgVHlwZVxuLy8uIGNvbnN0IGVudiA9ICQuZW52LmNvbmNhdCAoW0xpc3QgKCQuVW5rbm93bildKTtcbi8vLiBgYGBcbi8vLlxuLy8uIFRoZSBuZXh0IHN0ZXAgaXMgdG8gZGVmaW5lIGEgYGRlZmAgZnVuY3Rpb24gZm9yIHRoZSBlbnZpcm9ubWVudDpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBjb25zdCBkZWYgPSAkLmNyZWF0ZSAoe2NoZWNrVHlwZXM6IHRydWUsIGVudn0pO1xuLy8uIGBgYFxuLy8uXG4vLy4gVGhlIGBjaGVja1R5cGVzYCBvcHRpb24gZGV0ZXJtaW5lcyB3aGV0aGVyIHR5cGUgY2hlY2tpbmcgaXMgZW5hYmxlZC5cbi8vLiBUaGlzIGFsbG93cyBvbmUgdG8gb25seSBwYXkgdGhlIHBlcmZvcm1hbmNlIGNvc3Qgb2YgcnVuLXRpbWUgdHlwZSBjaGVja2luZ1xuLy8uIGR1cmluZyBkZXZlbG9wbWVudC4gRm9yIGV4YW1wbGU6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gY29uc3QgZGVmID0gJC5jcmVhdGUgKHtcbi8vLiAgIGNoZWNrVHlwZXM6IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnLFxuLy8uICAgZW52LFxuLy8uIH0pO1xuLy8uIGBgYFxuLy8uXG4vLy4gYGRlZmAgaXMgYSBmdW5jdGlvbiBmb3IgZGVmaW5pbmcgZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBhZGQgOjogTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbi8vLiBjb25zdCBhZGQgPVxuLy8uIGRlZiAoJ2FkZCcpXG4vLy4gICAgICh7fSlcbi8vLiAgICAgKFskLk51bWJlciwgJC5OdW1iZXIsICQuTnVtYmVyXSlcbi8vLiAgICAgKHggPT4geSA9PiB4ICsgeSk7XG4vLy4gYGBgXG4vLy5cbi8vLiBgWyQuTnVtYmVyLCAkLk51bWJlciwgJC5OdW1iZXJdYCBzcGVjaWZpZXMgdGhhdCBgYWRkYCB0YWtlcyB0d28gYXJndW1lbnRzXG4vLy4gb2YgdHlwZSBgTnVtYmVyYCwgb25lIGF0IGEgdGltZSwgYW5kIHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIGBOdW1iZXJgLlxuLy8uXG4vLy4gQXBwbHlpbmcgYGFkZGAgdG8gdHdvIGFyZ3VtZW50cywgb25lIGF0IGEgdGltZSwgZ2l2ZXMgdGhlIGV4cGVjdGVkIHJlc3VsdDpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBhZGQgKDIpICgyKTtcbi8vLiAvLyA9PiA0XG4vLy4gYGBgXG4vLy5cbi8vLiBBcHBseWluZyBgYWRkYCB0byBtdWx0aXBsZSBhcmd1bWVudHMgYXQgb25jZSByZXN1bHRzIGluIGFuIGV4Y2VwdGlvbiBiZWluZ1xuLy8uIHRocm93bjpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBhZGQgKDIsIDIsIDIpO1xuLy8uIC8vICEgVHlwZUVycm9yOiDigJhhZGTigJkgYXBwbGllZCB0byB0aGUgd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1xuLy8uIC8vXG4vLy4gLy8gICBhZGQgOjogTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbi8vLiAvLyAgICAgICAgICBeXl5eXl5cbi8vLiAvLyAgICAgICAgICAgIDFcbi8vLiAvL1xuLy8uIC8vICAgRXhwZWN0ZWQgb25lIGFyZ3VtZW50IGJ1dCByZWNlaXZlZCB0aHJlZSBhcmd1bWVudHM6XG4vLy4gLy9cbi8vLiAvLyAgICAgLSAyXG4vLy4gLy8gICAgIC0gMlxuLy8uIC8vICAgICAtIDJcbi8vLiBgYGBcbi8vLlxuLy8uIEFwcGx5aW5nIGBhZGRgIHRvIG9uZSBhcmd1bWVudCBwcm9kdWNlcyBhIGZ1bmN0aW9uIGF3YWl0aW5nIHRoZSByZW1haW5pbmdcbi8vLiBhcmd1bWVudC4gVGhpcyBpcyBrbm93biBhcyBwYXJ0aWFsIGFwcGxpY2F0aW9uLiBQYXJ0aWFsIGFwcGxpY2F0aW9uIGFsbG93c1xuLy8uIG1vcmUgc3BlY2lmaWMgZnVuY3Rpb25zIHRvIGJlIGRlZmluZWQgaW4gdGVybXMgb2YgbW9yZSBnZW5lcmFsIG9uZXM6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gICAgaW5jIDo6IE51bWJlciAtPiBOdW1iZXJcbi8vLiBjb25zdCBpbmMgPSBhZGQgKDEpO1xuLy8uXG4vLy4gaW5jICg3KTtcbi8vLiAvLyA9PiA4XG4vLy4gYGBgXG4vLy5cbi8vLiBKYXZhU2NyaXB0J3MgaW1wbGljaXQgdHlwZSBjb2VyY2lvbiBvZnRlbiBvYmZ1c2NhdGVzIHRoZSBzb3VyY2Ugb2YgdHlwZVxuLy8uIGVycm9ycy4gQ29uc2lkZXIgdGhlIGZvbGxvd2luZyBmdW5jdGlvbjpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBfYWRkIDo6IE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4vLy4gY29uc3QgX2FkZCA9IHggPT4geSA9PiB4ICsgeTtcbi8vLiBgYGBcbi8vLlxuLy8uIFRoZSB0eXBlIHNpZ25hdHVyZSBpbmRpY2F0ZXMgdGhhdCBgX2FkZGAgdGFrZXMgYXJndW1lbnRzIG9mIHR5cGUgYE51bWJlcmAsXG4vLy4gYnV0IHRoaXMgaXMgbm90IGVuZm9yY2VkLiBUaGlzIGFsbG93cyB0eXBlIGVycm9ycyB0byBiZSBzaWxlbnRseSBpZ25vcmVkOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIF9hZGQgKCcyJykgKCcyJyk7XG4vLy4gLy8gPT4gJzIyJ1xuLy8uIGBgYFxuLy8uXG4vLy4gYGFkZGAsIG9uIHRoZSBvdGhlciBoYW5kLCB0aHJvd3MgaWYgYXBwbGllZCB0byBhcmd1bWVudHMgb2YgdGhlIHdyb25nXG4vLy4gdHlwZXM6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gYWRkICgnMicpICgnMicpO1xuLy8uIC8vICEgVHlwZUVycm9yOiBJbnZhbGlkIHZhbHVlXG4vLy4gLy9cbi8vLiAvLyAgIGFkZCA6OiBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuLy8uIC8vICAgICAgICAgIF5eXl5eXlxuLy8uIC8vICAgICAgICAgICAgMVxuLy8uIC8vXG4vLy4gLy8gICAxKSAgXCIyXCIgOjogU3RyaW5nXG4vLy4gLy9cbi8vLiAvLyAgIFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGlzIG5vdCBhIG1lbWJlciBvZiDigJhOdW1iZXLigJkuXG4vLy4gYGBgXG4vLy5cbi8vLiBUeXBlIGNoZWNraW5nIGlzIHBlcmZvcm1lZCBhcyBhcmd1bWVudHMgYXJlIHByb3ZpZGVkIChyYXRoZXIgdGhhbiBvbmNlIGFsbFxuLy8uIGFyZ3VtZW50cyBoYXZlIGJlZW4gcHJvdmlkZWQpLCBzbyB0eXBlIGVycm9ycyBhcmUgcmVwb3J0ZWQgZWFybHk6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gYWRkICgnWCcpO1xuLy8uIC8vICEgVHlwZUVycm9yOiBJbnZhbGlkIHZhbHVlXG4vLy4gLy9cbi8vLiAvLyAgIGFkZCA6OiBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuLy8uIC8vICAgICAgICAgIF5eXl5eXlxuLy8uIC8vICAgICAgICAgICAgMVxuLy8uIC8vXG4vLy4gLy8gICAxKSAgXCJYXCIgOjogU3RyaW5nXG4vLy4gLy9cbi8vLiAvLyAgIFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGlzIG5vdCBhIG1lbWJlciBvZiDigJhOdW1iZXLigJkuXG4vLy4gYGBgXG5cbihmdW5jdGlvbihmKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmIChyZXF1aXJlICgnc2FuY3R1YXJ5LWVpdGhlcicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJ3NhbmN0dWFyeS1zaG93JyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAhPSBudWxsKSB7XG4gICAgZGVmaW5lIChbJ3NhbmN0dWFyeS1laXRoZXInLFxuICAgICAgICAgICAgICdzYW5jdHVhcnktc2hvdycsXG4gICAgICAgICAgICAgJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnLFxuICAgICAgICAgICAgICdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycyddLFxuICAgICAgICAgICAgZik7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zYW5jdHVhcnlEZWYgPSBmIChzZWxmLnNhbmN0dWFyeUVpdGhlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2FuY3R1YXJ5U2hvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2FuY3R1YXJ5VHlwZUNsYXNzZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNhbmN0dWFyeVR5cGVJZGVudGlmaWVycyk7XG4gIH1cblxufSAoZnVuY3Rpb24oRWl0aGVyLCBzaG93LCBaLCB0eXBlKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBNQVhfU0FGRV9JTlRFR0VSID0gTWF0aC5wb3cgKDIsIDUzKSAtIDE7XG4gIHZhciBNSU5fU0FGRV9JTlRFR0VSID0gLU1BWF9TQUZFX0lOVEVHRVI7XG5cbiAgdmFyIHNsaWNlICAgICAgICAgICAgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuICB2YXIgaGFzT3duUHJvcGVydHkgICAgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgdG9TdHJpbmcgICAgICAgICAgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIHZhciBpbnNwZWN0ID0gKGZ1bmN0aW9uKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciB1dGlsID0gcmVxdWlyZSAoJ3V0aWwnKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodHlwZW9mIHV0aWwuaW5zcGVjdC5jdXN0b20gPT09ICdzeW1ib2wnKSByZXR1cm4gdXRpbC5pbnNwZWN0LmN1c3RvbTtcbiAgICB9XG4gICAgcmV0dXJuICdpbnNwZWN0JztcbiAgfSAoKSk7XG5cbiAgLy8gIExlZnQgOjogYSAtPiBFaXRoZXIgYSBiXG4gIHZhciBMZWZ0ID0gRWl0aGVyLkxlZnQ7XG5cbiAgLy8gIFJpZ2h0IDo6IGIgLT4gRWl0aGVyIGEgYlxuICB2YXIgUmlnaHQgPSBFaXRoZXIuUmlnaHQ7XG5cbiAgLy8gIEsgOjogYSAtPiBiIC0+IGFcbiAgZnVuY3Rpb24gSyh4KSB7IHJldHVybiBmdW5jdGlvbih5KSB7IHJldHVybiB4OyB9OyB9XG5cbiAgLy8gIFcgOjogKGEgLT4gYSAtPiBiKSAtPiBhIC0+IGJcbiAgZnVuY3Rpb24gVyhmKSB7IHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBmICh4KSAoeCk7IH07IH1cblxuICAvLyAgYWx3YXlzMCA6OiBhIC0+ICgpIC0+IGFcbiAgZnVuY3Rpb24gYWx3YXlzMCh4KSB7IHJldHVybiBmdW5jdGlvbigpIHsgcmV0dXJuIHg7IH07IH1cblxuICAvLyAgYWx3YXlzMiA6OiBhIC0+IChiLCBjKSAtPiBhXG4gIGZ1bmN0aW9uIGFsd2F5czIoeCkgeyByZXR1cm4gZnVuY3Rpb24oeSwgeikgeyByZXR1cm4geDsgfTsgfVxuXG4gIC8vICBjb21wb3NlIDo6IChiIC0+IGMsIGEgLT4gYikgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gY29tcG9zZShmLCBnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBmIChnICh4KSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBpZCA6OiBhIC0+IGFcbiAgZnVuY3Rpb24gaWQoeCkgeyByZXR1cm4geDsgfVxuXG4gIC8vICBpbml0IDo6IEFycmF5IGEgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBpbml0KHhzKSB7IHJldHVybiB4cy5zbGljZSAoMCwgLTEpOyB9XG5cbiAgLy8gIGlzRW1wdHkgOjogQXJyYXkgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIGlzRW1wdHkoeHMpIHsgcmV0dXJuIHhzLmxlbmd0aCA9PT0gMDsgfVxuXG4gIC8vICBpc1ByZWZpeCA6OiBBcnJheSBhIC0+IEFycmF5IGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBpc1ByZWZpeChjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIGlmIChjYW5kaWRhdGUubGVuZ3RoID4geHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBjYW5kaWRhdGUubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgICBpZiAoY2FuZGlkYXRlW2lkeF0gIT09IHhzW2lkeF0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH1cblxuICAvLyAgam9pbldpdGggOjogKFN0cmluZywgQXJyYXkgU3RyaW5nKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gam9pbldpdGgoc2VwYXJhdG9yLCBzcykge1xuICAgIHJldHVybiBzcy5qb2luIChzZXBhcmF0b3IpO1xuICB9XG5cbiAgLy8gIGxhc3QgOjogQXJyYXkgYSAtPiBhXG4gIGZ1bmN0aW9uIGxhc3QoeHMpIHsgcmV0dXJuIHhzW3hzLmxlbmd0aCAtIDFdOyB9XG5cbiAgLy8gIG1lbWJlck9mIDo6IEFycmF5IGEgLT4gYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIG1lbWJlck9mKHhzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB4cy5zb21lIChmdW5jdGlvbih4KSB7IHJldHVybiBaLmVxdWFscyAoeCwgeSk7IH0pO1xuICAgIH07XG4gIH1cblxuICAvLyAgb3IgOjogKEFycmF5IGEsIEFycmF5IGEpIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gb3IoeHMsIHlzKSB7IHJldHVybiBpc0VtcHR5ICh4cykgPyB5cyA6IHhzOyB9XG5cbiAgLy8gIHN0clJlcGVhdCA6OiAoU3RyaW5nLCBJbnRlZ2VyKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gc3RyUmVwZWF0KHMsIHRpbWVzKSB7XG4gICAgcmV0dXJuIGpvaW5XaXRoIChzLCBBcnJheSAodGltZXMgKyAxKSk7XG4gIH1cblxuICAvLyAgciA6OiBDaGFyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gcihjKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBzdHJSZXBlYXQgKGMsIHMubGVuZ3RoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIF8gOjogU3RyaW5nIC0+IFN0cmluZ1xuICB2YXIgXyA9IHIgKCcgJyk7XG5cbiAgLy8gIHNvcnRlZEtleXMgOjogT2JqZWN0IC0+IEFycmF5IFN0cmluZ1xuICBmdW5jdGlvbiBzb3J0ZWRLZXlzKG8pIHtcbiAgICByZXR1cm4gKE9iamVjdC5rZXlzIChvKSkuc29ydCAoKTtcbiAgfVxuXG4gIC8vICBzdHJpcE91dGVybW9zdFBhcmVucyA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHN0cmlwT3V0ZXJtb3N0UGFyZW5zKHMpIHtcbiAgICByZXR1cm4gcy5zbGljZSAoJygnLmxlbmd0aCwgLScpJy5sZW5ndGgpO1xuICB9XG5cbiAgLy8gIHRvTWFya2Rvd25MaXN0IDo6IChTdHJpbmcsIFN0cmluZywgYSAtPiBTdHJpbmcsIEFycmF5IGEpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiB0b01hcmtkb3duTGlzdChlbXB0eSwgcywgZiwgeHMpIHtcbiAgICByZXR1cm4gaXNFbXB0eSAoeHMpID9cbiAgICAgIGVtcHR5IDpcbiAgICAgIFoucmVkdWNlIChmdW5jdGlvbihzLCB4KSB7IHJldHVybiBzICsgJyAgLSAnICsgZiAoeCkgKyAnXFxuJzsgfSwgcywgeHMpO1xuICB9XG5cbiAgLy8gIHRyaW1UcmFpbGluZ1NwYWNlcyA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHRyaW1UcmFpbGluZ1NwYWNlcyhzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSAoL1sgXSskL2dtLCAnJyk7XG4gIH1cblxuICAvLyAgdW5sZXNzIDo6IChCb29sZWFuLCAoYSAtPiBhKSwgYSkgLT4gYVxuICBmdW5jdGlvbiB1bmxlc3MoYm9vbCwgZiwgeCkge1xuICAgIHJldHVybiBib29sID8geCA6IGYgKHgpO1xuICB9XG5cbiAgLy8gIHdoZW4gOjogKEJvb2xlYW4sIChhIC0+IGEpLCBhKSAtPiBhXG4gIGZ1bmN0aW9uIHdoZW4oYm9vbCwgZiwgeCkge1xuICAgIHJldHVybiBib29sID8gZiAoeCkgOiB4O1xuICB9XG5cbiAgLy8gIHdyYXAgOjogU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHdyYXAocHJlZml4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN1ZmZpeCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHMgKyBzdWZmaXg7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICAvLyAgcGFyZW50aGVzaXplIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgdmFyIHBhcmVudGhlc2l6ZSA9IHdyYXAgKCcoJykgKCcpJyk7XG5cbiAgLy8gIHEgOjogU3RyaW5nIC0+IFN0cmluZ1xuICB2YXIgcSA9IHdyYXAgKCdcXHUyMDE4JykgKCdcXHUyMDE5Jyk7XG5cbiAgLy8gIHN0cmlwTmFtZXNwYWNlIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gc3RyaXBOYW1lc3BhY2UocykgeyByZXR1cm4gcy5zbGljZSAocy5pbmRleE9mICgnLycpICsgMSk7IH1cblxuICAvLyAgX1R5cGUgOjogLi4uIC0+IFR5cGVcbiAgZnVuY3Rpb24gX1R5cGUoXG4gICAgdHlwZSwgICAgICAgLy8gOjogU3RyaW5nXG4gICAgbmFtZSwgICAgICAgLy8gOjogU3RyaW5nXG4gICAgdXJsLCAgICAgICAgLy8gOjogU3RyaW5nXG4gICAgZm9ybWF0LCAgICAgLy8gOjogKFN0cmluZyAtPiBTdHJpbmcsIFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nKSAtPiBTdHJpbmdcbiAgICB0ZXN0LCAgICAgICAvLyA6OiBBbnkgLT4gQm9vbGVhblxuICAgIGtleXMsICAgICAgIC8vIDo6IEFycmF5IFN0cmluZ1xuICAgIHR5cGVzICAgICAgIC8vIDo6IFN0ck1hcCB7IGV4dHJhY3RvciA6OiBhIC0+IEFycmF5IGIsIHR5cGUgOjogVHlwZSB9XG4gICkge1xuICAgIHRoaXMuX3Rlc3QgPSB0ZXN0O1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMua2V5cyA9IGtleXM7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgfVxuXG4gIF9UeXBlWydAQHR5cGUnXSA9ICdzYW5jdHVhcnktZGVmL1R5cGUnO1xuXG4gIC8vICBUeXBlI2ZhbnRhc3ktbGFuZC9lcXVhbHMgOjogVHlwZSB+PiBUeXBlIC0+IEJvb2xlYW5cbiAgX1R5cGUucHJvdG90eXBlWydmYW50YXN5LWxhbmQvZXF1YWxzJ10gPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHJldHVybiAoXG4gICAgICBaLmVxdWFscyAodGhpcy50eXBlLCBvdGhlci50eXBlKSAmJlxuICAgICAgWi5lcXVhbHMgKHRoaXMubmFtZSwgb3RoZXIubmFtZSkgJiZcbiAgICAgIFouZXF1YWxzICh0aGlzLnVybCwgb3RoZXIudXJsKSAmJlxuICAgICAgWi5lcXVhbHMgKHRoaXMua2V5cywgb3RoZXIua2V5cykgJiZcbiAgICAgIHRoaXMua2V5cy5ldmVyeSAoZnVuY3Rpb24oaykge1xuICAgICAgICByZXR1cm4gWi5lcXVhbHMgKHRoaXMudHlwZXNba10udHlwZSwgb3RoZXIudHlwZXNba10udHlwZSk7XG4gICAgICB9LCB0aGlzKVxuICAgICk7XG4gIH07XG5cbiAgX1R5cGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICghKHRoaXMuX3Rlc3QgKHgpKSkgcmV0dXJuIExlZnQgKHt2YWx1ZTogeCwgcHJvcFBhdGg6IFtdfSk7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5rZXlzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIHZhciBrID0gdGhpcy5rZXlzW2lkeF07XG4gICAgICB2YXIgdCA9IHRoaXMudHlwZXNba107XG4gICAgICBmb3IgKHZhciBpZHgyID0gMCwgeXMgPSB0LmV4dHJhY3RvciAoeCk7IGlkeDIgPCB5cy5sZW5ndGg7IGlkeDIgKz0gMSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdC50eXBlLnZhbGlkYXRlICh5c1tpZHgyXSk7XG4gICAgICAgIGlmIChyZXN1bHQuaXNMZWZ0KSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlLnZhbHVlO1xuICAgICAgICAgIHZhciBwcm9wUGF0aCA9IFouY29uY2F0IChba10sIHJlc3VsdC52YWx1ZS5wcm9wUGF0aCk7XG4gICAgICAgICAgcmV0dXJuIExlZnQgKHt2YWx1ZTogdmFsdWUsIHByb3BQYXRoOiBwcm9wUGF0aH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBSaWdodCAoeCk7XG4gIH07XG5cbiAgX1R5cGUucHJvdG90eXBlWydAQHNob3cnXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdCAoaWQsIEsgKGlkKSk7XG4gIH07XG5cbiAgdmFyIEJJTkFSWSAgICAgICAgPSAnQklOQVJZJztcbiAgdmFyIEZVTkNUSU9OICAgICAgPSAnRlVOQ1RJT04nO1xuICB2YXIgSU5DT05TSVNURU5UICA9ICdJTkNPTlNJU1RFTlQnO1xuICB2YXIgTk9fQVJHVU1FTlRTICA9ICdOT19BUkdVTUVOVFMnO1xuICB2YXIgTlVMTEFSWSAgICAgICA9ICdOVUxMQVJZJztcbiAgdmFyIFJFQ09SRCAgICAgICAgPSAnUkVDT1JEJztcbiAgdmFyIFVOQVJZICAgICAgICAgPSAnVU5BUlknO1xuICB2YXIgVU5LTk9XTiAgICAgICA9ICdVTktOT1dOJztcbiAgdmFyIFZBUklBQkxFICAgICAgPSAnVkFSSUFCTEUnO1xuXG4gIC8vICBJbmNvbnNpc3RlbnQgOjogVHlwZVxuICB2YXIgSW5jb25zaXN0ZW50ID1cbiAgbmV3IF9UeXBlIChJTkNPTlNJU1RFTlQsICcnLCAnJywgYWx3YXlzMiAoJz8/PycpLCBLIChmYWxzZSksIFtdLCB7fSk7XG5cbiAgLy8gIE5vQXJndW1lbnRzIDo6IFR5cGVcbiAgdmFyIE5vQXJndW1lbnRzID1cbiAgbmV3IF9UeXBlIChOT19BUkdVTUVOVFMsICcnLCAnJywgYWx3YXlzMiAoJygpJyksIEsgKHRydWUpLCBbXSwge30pO1xuXG4gIC8vICB0eXBlRXEgOjogU3RyaW5nIC0+IGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiB0eXBlRXEobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZSAoeCkgPT09IG5hbWU7XG4gICAgfTtcbiAgfVxuXG4gIC8vICB0eXBlb2ZFcSA6OiBTdHJpbmcgLT4gYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIHR5cGVvZkVxKHR5cGVvZl8pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSB0eXBlb2ZfO1xuICAgIH07XG4gIH1cblxuICAvLyAgZnVuY3Rpb25VcmwgOjogU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBmdW5jdGlvblVybChuYW1lKSB7XG4gICAgdmFyIHZlcnNpb24gPSAnMC4xOC4xJzsgIC8vIHVwZGF0ZWQgcHJvZ3JhbW1hdGljYWxseVxuICAgIHJldHVybiAnaHR0cHM6Ly9naXRodWIuY29tL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnktZGVmL3RyZWUvdicgKyB2ZXJzaW9uICtcbiAgICAgICAgICAgJyMnICsgc3RyaXBOYW1lc3BhY2UgKG5hbWUpO1xuICB9XG5cbiAgLy8gIE51bGxhcnlUeXBlV2l0aFVybCA6OiAoU3RyaW5nLCBBbnkgLT4gQm9vbGVhbikgLT4gVHlwZVxuICBmdW5jdGlvbiBOdWxsYXJ5VHlwZVdpdGhVcmwobmFtZSwgdGVzdCkge1xuICAgIHJldHVybiBOdWxsYXJ5VHlwZSAobmFtZSkgKGZ1bmN0aW9uVXJsIChuYW1lKSkgKHRlc3QpO1xuICB9XG5cbiAgLy8gIEVudW1UeXBlV2l0aFVybCA6OiAoU3RyaW5nLCBBcnJheSBBbnkpIC0+IFR5cGVcbiAgZnVuY3Rpb24gRW51bVR5cGVXaXRoVXJsKG5hbWUsIG1lbWJlcnMpIHtcbiAgICByZXR1cm4gRW51bVR5cGUgKG5hbWUpIChmdW5jdGlvblVybCAobmFtZSkpIChtZW1iZXJzKTtcbiAgfVxuXG4gIC8vICBVbmFyeVR5cGVXaXRoVXJsIDo6XG4gIC8vICAgIChTdHJpbmcsIEFueSAtPiBCb29sZWFuLCB0IGEgLT4gQXJyYXkgYSkgLT4gKFR5cGUgLT4gVHlwZSlcbiAgZnVuY3Rpb24gVW5hcnlUeXBlV2l0aFVybChuYW1lLCB0ZXN0LCBfMSkge1xuICAgIHJldHVybiBVbmFyeVR5cGUgKG5hbWUpIChmdW5jdGlvblVybCAobmFtZSkpICh0ZXN0KSAoXzEpO1xuICB9XG5cbiAgLy8gIEJpbmFyeVR5cGVXaXRoVXJsIDo6XG4gIC8vICAgIChTdHJpbmcsIEFueSAtPiBCb29sZWFuLCB0IGEgYiAtPiBBcnJheSBhLCB0IGEgYiAtPiBBcnJheSBiKSAtPlxuICAvLyAgICAgICgoVHlwZSwgVHlwZSkgLT4gVHlwZSlcbiAgZnVuY3Rpb24gQmluYXJ5VHlwZVdpdGhVcmwobmFtZSwgdGVzdCwgXzEsIF8yKSB7XG4gICAgcmV0dXJuIEJpbmFyeVR5cGUgKG5hbWUpIChmdW5jdGlvblVybCAobmFtZSkpICh0ZXN0KSAoXzEpIChfMik7XG4gIH1cblxuICAvLy4gIyMjIFR5cGVzXG4gIC8vLlxuICAvLy4gQ29uY2VwdHVhbGx5LCBhIHR5cGUgaXMgYSBzZXQgb2YgdmFsdWVzLiBPbmUgY2FuIHRoaW5rIG9mIGEgdmFsdWUgb2ZcbiAgLy8uIHR5cGUgYFR5cGVgIGFzIGEgZnVuY3Rpb24gb2YgdHlwZSBgQW55IC0+IEJvb2xlYW5gIHdoaWNoIHRlc3RzIHZhbHVlc1xuICAvLy4gZm9yIG1lbWJlcnNoaXAgaW4gdGhlIHNldCAodGhvdWdoIHRoaXMgaXMgYW4gb3ZlcnNpbXBsaWZpY2F0aW9uKS5cblxuICAvLyMgQW55IDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgdmFyIEFueSA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ3NhbmN0dWFyeS1kZWYvQW55JywgSyAodHJ1ZSkpO1xuXG4gIC8vIyBBbnlGdW5jdGlvbiA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IEZ1bmN0aW9uIHZhbHVlLlxuICB2YXIgQW55RnVuY3Rpb24gPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdGdW5jdGlvbicsIHR5cGVvZkVxICgnZnVuY3Rpb24nKSk7XG5cbiAgLy8jIEFyZ3VtZW50cyA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgYXJndW1lbnRzYF1bYXJndW1lbnRzXSBvYmplY3QuXG4gIHZhciBBcmd1bWVudHMgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdBcmd1bWVudHMnLCB0eXBlRXEgKCdBcmd1bWVudHMnKSk7XG5cbiAgLy8jIEFycmF5IDo6IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciBob21vZ2VuZW91cyBBcnJheSB0eXBlcy5cbiAgdmFyIEFycmF5XyA9IFVuYXJ5VHlwZVdpdGhVcmwgKCdBcnJheScsIHR5cGVFcSAoJ0FycmF5JyksIGlkKTtcblxuICAvLyMgQXJyYXkwIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIHdob3NlIHNvbGUgbWVtYmVyIGlzIGBbXWAuXG4gIHZhciBBcnJheTAgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL0FycmF5MCcsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gdHlwZUVxICgnQXJyYXknKSAoeCkgJiYgeC5sZW5ndGggPT09IDA7IH1cbiAgKTtcblxuICAvLyMgQXJyYXkxIDo6IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciBzaW5nbGV0b24gQXJyYXkgdHlwZXMuXG4gIHZhciBBcnJheTEgPSBVbmFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9BcnJheTEnLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHR5cGVFcSAoJ0FycmF5JykgKHgpICYmIHgubGVuZ3RoID09PSAxOyB9LFxuICAgIGlkXG4gICk7XG5cbiAgLy8jIEFycmF5MiA6OiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciBoZXRlcm9nZW5lb3VzIEFycmF5IHR5cGVzIG9mIGxlbmd0aCAyLiBgWydmb28nLCB0cnVlXWAgaXNcbiAgLy8uIGEgbWVtYmVyIG9mIGBBcnJheTIgU3RyaW5nIEJvb2xlYW5gLlxuICB2YXIgQXJyYXkyID0gQmluYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL0FycmF5MicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gdHlwZUVxICgnQXJyYXknKSAoeCkgJiYgeC5sZW5ndGggPT09IDI7IH0sXG4gICAgZnVuY3Rpb24oYXJyYXkyKSB7IHJldHVybiBbYXJyYXkyWzBdXTsgfSxcbiAgICBmdW5jdGlvbihhcnJheTIpIHsgcmV0dXJuIFthcnJheTJbMV1dOyB9XG4gICk7XG5cbiAgLy8jIEJvb2xlYW4gOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBgdHJ1ZWAgYW5kIGBmYWxzZWAuXG4gIHZhciBCb29sZWFuXyA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ0Jvb2xlYW4nLCB0eXBlb2ZFcSAoJ2Jvb2xlYW4nKSk7XG5cbiAgLy8jIERhdGUgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBEYXRlIHZhbHVlLlxuICB2YXIgRGF0ZV8gPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdEYXRlJywgdHlwZUVxICgnRGF0ZScpKTtcblxuICAvLyMgRXJyb3IgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBFcnJvciB2YWx1ZSwgaW5jbHVkaW5nIHZhbHVlcyBvZiBtb3JlIHNwZWNpZmljXG4gIC8vLiBjb25zdHJ1Y3RvcnMgc3VjaCBhcyBbYFN5bnRheEVycm9yYF1bXSBhbmQgW2BUeXBlRXJyb3JgXVtdLlxuICB2YXIgRXJyb3JfID0gTnVsbGFyeVR5cGVXaXRoVXJsICgnRXJyb3InLCB0eXBlRXEgKCdFcnJvcicpKTtcblxuICAvLyMgRmluaXRlTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BWYWxpZE51bWJlcmBdW10gdmFsdWUgZXhjZXB0IGBJbmZpbml0eWAgYW5kXG4gIC8vLiBgLUluZmluaXR5YC5cbiAgdmFyIEZpbml0ZU51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvRmluaXRlTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBWYWxpZE51bWJlci5fdGVzdCAoeCkgJiYgaXNGaW5pdGUgKHgpOyB9XG4gICk7XG5cbiAgLy8gIGF1Z21lbnRUaHVuayA6OiBOb25FbXB0eSAoQXJyYXkgVHlwZSkgLT4gTm9uRW1wdHkgKEFycmF5IFR5cGUpXG4gIGZ1bmN0aW9uIGF1Z21lbnRUaHVuayh0eXBlcykge1xuICAgIHJldHVybiB0eXBlcy5sZW5ndGggPT09IDEgPyBaLmNvbmNhdCAoW05vQXJndW1lbnRzXSwgdHlwZXMpIDogdHlwZXM7XG4gIH1cblxuICAvLyMgRnVuY3Rpb24gOjogTm9uRW1wdHkgKEFycmF5IFR5cGUpIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RvciBmb3IgRnVuY3Rpb24gdHlwZXMuXG4gIC8vLlxuICAvLy4gRXhhbXBsZXM6XG4gIC8vLlxuICAvLy4gICAtIGAkLkZ1bmN0aW9uIChbJC5EYXRlLCAkLlN0cmluZ10pYCByZXByZXNlbnRzIHRoZSBgRGF0ZSAtPiBTdHJpbmdgXG4gIC8vLiAgICAgdHlwZTsgYW5kXG4gIC8vLiAgIC0gYCQuRnVuY3Rpb24gKFthLCBiLCBhXSlgIHJlcHJlc2VudHMgdGhlIGAoYSwgYikgLT4gYWAgdHlwZS5cbiAgZnVuY3Rpb24gRnVuY3Rpb25fKF90eXBlcykge1xuICAgIHZhciB0eXBlcyA9IGF1Z21lbnRUaHVuayAoX3R5cGVzKTtcblxuICAgIGZ1bmN0aW9uIGZvcm1hdChvdXRlciwgaW5uZXIpIHtcbiAgICAgIHZhciB4cyA9IHR5cGVzLm1hcCAoZnVuY3Rpb24odCwgaWR4KSB7XG4gICAgICAgIHJldHVybiB1bmxlc3MgKHQudHlwZSA9PT0gUkVDT1JEIHx8IGlzRW1wdHkgKHQua2V5cyksXG4gICAgICAgICAgICAgICAgICAgICAgIHN0cmlwT3V0ZXJtb3N0UGFyZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICBpbm5lciAoJyQnICsgc2hvdyAoaWR4ICsgMSkpIChzaG93ICh0KSkpO1xuICAgICAgfSk7XG4gICAgICB2YXIgcGFyZW50aGVzaXplID0gd3JhcCAob3V0ZXIgKCcoJykpIChvdXRlciAoJyknKSk7XG4gICAgICByZXR1cm4gcGFyZW50aGVzaXplICh1bmxlc3MgKHR5cGVzLmxlbmd0aCA9PT0gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50aGVzaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqb2luV2l0aCAob3V0ZXIgKCcsICcpLCBpbml0ICh4cykpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlciAoJyAtPiAnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ICh4cykpO1xuICAgIH1cblxuICAgIHZhciB0ZXN0ID0gQW55RnVuY3Rpb24uX3Rlc3Q7XG5cbiAgICB2YXIgJGtleXMgPSBbXTtcbiAgICB2YXIgJHR5cGVzID0ge307XG4gICAgdHlwZXMuZm9yRWFjaCAoZnVuY3Rpb24odCwgaWR4KSB7XG4gICAgICB2YXIgayA9ICckJyArIHNob3cgKGlkeCArIDEpO1xuICAgICAgJGtleXMucHVzaCAoayk7XG4gICAgICAkdHlwZXNba10gPSB7ZXh0cmFjdG9yOiBLIChbXSksIHR5cGU6IHR9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBfVHlwZSAoRlVOQ1RJT04sICcnLCAnJywgZm9ybWF0LCB0ZXN0LCAka2V5cywgJHR5cGVzKTtcbiAgfVxuXG4gIC8vIyBHbG9iYWxSZWdFeHAgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYFJlZ0V4cGBdW10gdmFsdWUgd2hvc2UgYGdsb2JhbGAgZmxhZyBpcyBgdHJ1ZWAuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BOb25HbG9iYWxSZWdFeHBgXVtdLlxuICB2YXIgR2xvYmFsUmVnRXhwID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9HbG9iYWxSZWdFeHAnLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFJlZ0V4cF8uX3Rlc3QgKHgpICYmIHguZ2xvYmFsOyB9XG4gICk7XG5cbiAgLy8jIEh0bWxFbGVtZW50IDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW0hUTUwgZWxlbWVudF1bXS5cbiAgdmFyIEh0bWxFbGVtZW50ID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9IdG1sRWxlbWVudCcsXG4gICAgZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIC9eXFxbb2JqZWN0IEhUTUwuK0VsZW1lbnRcXF0kLy50ZXN0ICh0b1N0cmluZy5jYWxsICh4KSk7XG4gICAgfVxuICApO1xuXG4gIC8vIyBJbnRlZ2VyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgaW50ZWdlciBpbiB0aGUgcmFuZ2VcbiAgLy8uIFtbYE51bWJlci5NSU5fU0FGRV9JTlRFR0VSYF1bbWluXSAuLiBbYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYF1bbWF4XV0uXG4gIHZhciBJbnRlZ2VyID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9JbnRlZ2VyJyxcbiAgICBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gVmFsaWROdW1iZXIuX3Rlc3QgKHgpICYmXG4gICAgICAgICAgICAgTWF0aC5mbG9vciAoeCkgPT09IHggJiZcbiAgICAgICAgICAgICB4ID49IE1JTl9TQUZFX0lOVEVHRVIgJiZcbiAgICAgICAgICAgICB4IDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICApO1xuXG4gIC8vIyBOZWdhdGl2ZUZpbml0ZU51bWJlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgRmluaXRlTnVtYmVyYF1bXSB2YWx1ZSBsZXNzIHRoYW4gemVyby5cbiAgdmFyIE5lZ2F0aXZlRmluaXRlTnVtYmVyID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9OZWdhdGl2ZUZpbml0ZU51bWJlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gRmluaXRlTnVtYmVyLl90ZXN0ICh4KSAmJiB4IDwgMDsgfVxuICApO1xuXG4gIC8vIyBOZWdhdGl2ZUludGVnZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYEludGVnZXJgXVtdIHZhbHVlIGxlc3MgdGhhbiB6ZXJvLlxuICB2YXIgTmVnYXRpdmVJbnRlZ2VyID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9OZWdhdGl2ZUludGVnZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIEludGVnZXIuX3Rlc3QgKHgpICYmIHggPCAwOyB9XG4gICk7XG5cbiAgLy8jIE5lZ2F0aXZlTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BOdW1iZXJgXVtdIHZhbHVlIGxlc3MgdGhhbiB6ZXJvLlxuICB2YXIgTmVnYXRpdmVOdW1iZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL05lZ2F0aXZlTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBOdW1iZXJfLl90ZXN0ICh4KSAmJiB4IDwgMDsgfVxuICApO1xuXG4gIC8vIyBOb25FbXB0eSA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RvciBmb3Igbm9uLWVtcHR5IHR5cGVzLiBgJC5Ob25FbXB0eSAoJC5TdHJpbmcpYCwgZm9yIGV4YW1wbGUsIGlzXG4gIC8vLiB0aGUgdHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgU3RyaW5nYF1bXSB2YWx1ZSBleGNlcHQgYCcnYC5cbiAgLy8uXG4gIC8vLiBUaGUgZ2l2ZW4gdHlwZSBtdXN0IHNhdGlzZnkgdGhlIFtNb25vaWRdW10gYW5kIFtTZXRvaWRdW10gc3BlY2lmaWNhdGlvbnMuXG4gIHZhciBOb25FbXB0eSA9IFVuYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL05vbkVtcHR5JyxcbiAgICBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gWi5Nb25vaWQudGVzdCAoeCkgJiZcbiAgICAgICAgICAgICBaLlNldG9pZC50ZXN0ICh4KSAmJlxuICAgICAgICAgICAgICEoWi5lcXVhbHMgKHgsIFouZW1wdHkgKHguY29uc3RydWN0b3IpKSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihtb25vaWQpIHsgcmV0dXJuIFttb25vaWRdOyB9XG4gICk7XG5cbiAgLy8jIE5vbkdsb2JhbFJlZ0V4cCA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgUmVnRXhwYF1bXSB2YWx1ZSB3aG9zZSBgZ2xvYmFsYCBmbGFnIGlzIGBmYWxzZWAuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BHbG9iYWxSZWdFeHBgXVtdLlxuICB2YXIgTm9uR2xvYmFsUmVnRXhwID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9Ob25HbG9iYWxSZWdFeHAnLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFJlZ0V4cF8uX3Rlc3QgKHgpICYmICF4Lmdsb2JhbDsgfVxuICApO1xuXG4gIC8vIyBOb25OZWdhdGl2ZUludGVnZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBub24tbmVnYXRpdmUgW2BJbnRlZ2VyYF1bXSB2YWx1ZSAoaW5jbHVkaW5nIGAtMGApLlxuICAvLy4gQWxzbyBrbm93biBhcyB0aGUgc2V0IG9mIG5hdHVyYWwgbnVtYmVycyB1bmRlciBJU08gODAwMDAtMjoyMDA5LlxuICB2YXIgTm9uTmVnYXRpdmVJbnRlZ2VyID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9Ob25OZWdhdGl2ZUludGVnZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIEludGVnZXIuX3Rlc3QgKHgpICYmIHggPj0gMDsgfVxuICApO1xuXG4gIC8vIyBOb25aZXJvRmluaXRlTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BGaW5pdGVOdW1iZXJgXVtdIHZhbHVlIGV4Y2VwdCBgMGAgYW5kIGAtMGAuXG4gIHZhciBOb25aZXJvRmluaXRlTnVtYmVyID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9Ob25aZXJvRmluaXRlTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBGaW5pdGVOdW1iZXIuX3Rlc3QgKHgpICYmIHggIT09IDA7IH1cbiAgKTtcblxuICAvLyMgTm9uWmVyb0ludGVnZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYEludGVnZXJgXVtdIHZhbHVlIGV4Y2VwdCBgMGAgYW5kIGAtMGAuXG4gIHZhciBOb25aZXJvSW50ZWdlciA9IE51bGxhcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvTm9uWmVyb0ludGVnZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIEludGVnZXIuX3Rlc3QgKHgpICYmIHggIT09IDA7IH1cbiAgKTtcblxuICAvLyMgTm9uWmVyb1ZhbGlkTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BWYWxpZE51bWJlcmBdW10gdmFsdWUgZXhjZXB0IGAwYCBhbmQgYC0wYC5cbiAgdmFyIE5vblplcm9WYWxpZE51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvTm9uWmVyb1ZhbGlkTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBWYWxpZE51bWJlci5fdGVzdCAoeCkgJiYgeCAhPT0gMDsgfVxuICApO1xuXG4gIC8vIyBOdWxsIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIHdob3NlIHNvbGUgbWVtYmVyIGlzIGBudWxsYC5cbiAgdmFyIE51bGwgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdOdWxsJywgdHlwZUVxICgnTnVsbCcpKTtcblxuICAvLyMgTnVsbGFibGUgOjogVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gQ29uc3RydWN0b3IgZm9yIHR5cGVzIHdoaWNoIGluY2x1ZGUgYG51bGxgIGFzIGEgbWVtYmVyLlxuICB2YXIgTnVsbGFibGUgPSBVbmFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9OdWxsYWJsZScsXG4gICAgSyAodHJ1ZSksXG4gICAgZnVuY3Rpb24obnVsbGFibGUpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgIHJldHVybiBudWxsYWJsZSA9PT0gbnVsbCA/IFtdIDogW251bGxhYmxlXTtcbiAgICB9XG4gICk7XG5cbiAgLy8jIE51bWJlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IHByaW1pdGl2ZSBOdW1iZXIgdmFsdWUgKGluY2x1ZGluZyBgTmFOYCkuXG4gIHZhciBOdW1iZXJfID0gTnVsbGFyeVR5cGVXaXRoVXJsICgnTnVtYmVyJywgdHlwZW9mRXEgKCdudW1iZXInKSk7XG5cbiAgLy8jIE9iamVjdCA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFwicGxhaW5cIiBPYmplY3QgdmFsdWUuIFNwZWNpZmljYWxseSwgdmFsdWVzXG4gIC8vLiBjcmVhdGVkIHZpYTpcbiAgLy8uXG4gIC8vLiAgIC0gb2JqZWN0IGxpdGVyYWwgc3ludGF4O1xuICAvLy4gICAtIFtgT2JqZWN0LmNyZWF0ZWBdW107IG9yXG4gIC8vLiAgIC0gdGhlIGBuZXdgIG9wZXJhdG9yIGluIGNvbmp1bmN0aW9uIHdpdGggYE9iamVjdGAgb3IgYSBjdXN0b21cbiAgLy8uICAgICBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgdmFyIE9iamVjdF8gPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdPYmplY3QnLCB0eXBlRXEgKCdPYmplY3QnKSk7XG5cbiAgLy8jIFBvc2l0aXZlRmluaXRlTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BGaW5pdGVOdW1iZXJgXVtdIHZhbHVlIGdyZWF0ZXIgdGhhbiB6ZXJvLlxuICB2YXIgUG9zaXRpdmVGaW5pdGVOdW1iZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL1Bvc2l0aXZlRmluaXRlTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBGaW5pdGVOdW1iZXIuX3Rlc3QgKHgpICYmIHggPiAwOyB9XG4gICk7XG5cbiAgLy8jIFBvc2l0aXZlSW50ZWdlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgSW50ZWdlcmBdW10gdmFsdWUgZ3JlYXRlciB0aGFuIHplcm8uXG4gIHZhciBQb3NpdGl2ZUludGVnZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL1Bvc2l0aXZlSW50ZWdlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gSW50ZWdlci5fdGVzdCAoeCkgJiYgeCA+IDA7IH1cbiAgKTtcblxuICAvLyMgUG9zaXRpdmVOdW1iZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYE51bWJlcmBdW10gdmFsdWUgZ3JlYXRlciB0aGFuIHplcm8uXG4gIHZhciBQb3NpdGl2ZU51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvUG9zaXRpdmVOdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE51bWJlcl8uX3Rlc3QgKHgpICYmIHggPiAwOyB9XG4gICk7XG5cbiAgLy8jIFJlZ0V4cCA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFJlZ0V4cCB2YWx1ZS5cbiAgdmFyIFJlZ0V4cF8gPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdSZWdFeHAnLCB0eXBlRXEgKCdSZWdFeHAnKSk7XG5cbiAgLy8jIFJlZ2V4RmxhZ3MgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyB0aGUgY2Fub25pY2FsIFJlZ0V4cCBmbGFnczpcbiAgLy8uXG4gIC8vLiAgIC0gYCcnYFxuICAvLy4gICAtIGAnZydgXG4gIC8vLiAgIC0gYCdpJ2BcbiAgLy8uICAgLSBgJ20nYFxuICAvLy4gICAtIGAnZ2knYFxuICAvLy4gICAtIGAnZ20nYFxuICAvLy4gICAtIGAnaW0nYFxuICAvLy4gICAtIGAnZ2ltJ2BcbiAgdmFyIFJlZ2V4RmxhZ3MgPSBFbnVtVHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL1JlZ2V4RmxhZ3MnLFxuICAgIFsnJywgJ2cnLCAnaScsICdtJywgJ2dpJywgJ2dtJywgJ2ltJywgJ2dpbSddXG4gICk7XG5cbiAgLy8jIFN0ck1hcCA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RvciBmb3IgaG9tb2dlbmVvdXMgT2JqZWN0IHR5cGVzLlxuICAvLy5cbiAgLy8uIGB7Zm9vOiAxLCBiYXI6IDIsIGJhejogM31gLCBmb3IgZXhhbXBsZSwgaXMgYSBtZW1iZXIgb2YgYFN0ck1hcCBOdW1iZXJgO1xuICAvLy4gYHtmb286IDEsIGJhcjogMiwgYmF6OiAnWFhYJ31gIGlzIG5vdC5cbiAgdmFyIFN0ck1hcCA9IFVuYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL1N0ck1hcCcsXG4gICAgT2JqZWN0Xy5fdGVzdCxcbiAgICBmdW5jdGlvbihzdHJNYXApIHtcbiAgICAgIHJldHVybiBaLnJlZHVjZSAoZnVuY3Rpb24oeHMsIHgpIHsgeHMucHVzaCAoeCk7IHJldHVybiB4czsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgICAgIHN0ck1hcCk7XG4gICAgfVxuICApO1xuXG4gIC8vIyBTdHJpbmcgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBwcmltaXRpdmUgU3RyaW5nIHZhbHVlLlxuICB2YXIgU3RyaW5nXyA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ1N0cmluZycsIHR5cGVvZkVxICgnc3RyaW5nJykpO1xuXG4gIC8vIyBTeW1ib2wgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBTeW1ib2wgdmFsdWUuXG4gIHZhciBTeW1ib2xfID0gTnVsbGFyeVR5cGVXaXRoVXJsICgnU3ltYm9sJywgdHlwZW9mRXEgKCdzeW1ib2wnKSk7XG5cbiAgLy8jIFR5cGUgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBgVHlwZWAgdmFsdWUuXG4gIHZhciBUeXBlID0gTnVsbGFyeVR5cGVXaXRoVXJsICgnVHlwZScsIHR5cGVFcSAoJ3NhbmN0dWFyeS1kZWYvVHlwZScpKTtcblxuICAvLyMgVHlwZUNsYXNzIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BUeXBlQ2xhc3NgXVtdIHZhbHVlLlxuICB2YXIgVHlwZUNsYXNzID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnVHlwZUNsYXNzJyxcbiAgICB0eXBlRXEgKCdzYW5jdHVhcnktdHlwZS1jbGFzc2VzL1R5cGVDbGFzcycpXG4gICk7XG5cbiAgLy8jIFVuZGVmaW5lZCA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSB3aG9zZSBzb2xlIG1lbWJlciBpcyBgdW5kZWZpbmVkYC5cbiAgdmFyIFVuZGVmaW5lZCA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ1VuZGVmaW5lZCcsIHR5cGVFcSAoJ1VuZGVmaW5lZCcpKTtcblxuICAvLyMgVW5rbm93biA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSB1c2VkIHRvIHJlcHJlc2VudCBtaXNzaW5nIHR5cGUgaW5mb3JtYXRpb24uIFRoZSB0eXBlIG9mIGBbXWAsXG4gIC8vLiBmb3IgZXhhbXBsZSwgaXMgYEFycmF5ID8/P2AuXG4gIC8vLlxuICAvLy4gTWF5IGJlIHVzZWQgd2l0aCB0eXBlIGNvbnN0cnVjdG9ycyB3aGVuIGRlZmluaW5nIGVudmlyb25tZW50cy4gR2l2ZW4gYVxuICAvLy4gdHlwZSBjb25zdHJ1Y3RvciBgTGlzdCA6OiBUeXBlIC0+IFR5cGVgLCBvbmUgY291bGQgdXNlIGBMaXN0ICgkLlVua25vd24pYFxuICAvLy4gdG8gaW5jbHVkZSBhbiBpbmZpbml0ZSBudW1iZXIgb2YgdHlwZXMgaW4gYW4gZW52aXJvbm1lbnQ6XG4gIC8vLlxuICAvLy4gICAtIGBMaXN0IE51bWJlcmBcbiAgLy8uICAgLSBgTGlzdCBTdHJpbmdgXG4gIC8vLiAgIC0gYExpc3QgKExpc3QgTnVtYmVyKWBcbiAgLy8uICAgLSBgTGlzdCAoTGlzdCBTdHJpbmcpYFxuICAvLy4gICAtIGBMaXN0IChMaXN0IChMaXN0IE51bWJlcikpYFxuICAvLy4gICAtIGBMaXN0IChMaXN0IChMaXN0IFN0cmluZykpYFxuICAvLy4gICAtIGAuLi5gXG4gIHZhciBVbmtub3duID1cbiAgbmV3IF9UeXBlIChVTktOT1dOLCAnJywgJycsIGFsd2F5czIgKCdVbmtub3duJyksIEsgKHRydWUpLCBbXSwge30pO1xuXG4gIC8vIyBWYWxpZERhdGUgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYERhdGVgXVtdIHZhbHVlIGV4Y2VwdCBgbmV3IERhdGUgKE5hTilgLlxuICB2YXIgVmFsaWREYXRlID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9WYWxpZERhdGUnLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIERhdGVfLl90ZXN0ICh4KSAmJiAhaXNOYU4gKHgudmFsdWVPZiAoKSk7IH1cbiAgKTtcblxuICAvLyMgVmFsaWROdW1iZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYE51bWJlcmBdW10gdmFsdWUgZXhjZXB0IGBOYU5gLlxuICB2YXIgVmFsaWROdW1iZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL1ZhbGlkTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBOdW1iZXJfLl90ZXN0ICh4KSAmJiAhaXNOYU4gKHgpOyB9XG4gICk7XG5cbiAgLy8jIGVudiA6OiBBcnJheSBUeXBlXG4gIC8vLlxuICAvLy4gQW4gYXJyYXkgb2YgW3R5cGVzXVtdOlxuICAvLy5cbiAgLy8uICAgLSA8Y29kZT5bQW55RnVuY3Rpb25dKCNBbnlGdW5jdGlvbik8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W0FyZ3VtZW50c10oI0FyZ3VtZW50cyk8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W0FycmF5XSgjQXJyYXkpIChbVW5rbm93bl0oI1Vua25vd24pKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bQm9vbGVhbl0oI0Jvb2xlYW4pPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltEYXRlXSgjRGF0ZSk8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W0Vycm9yXSgjRXJyb3IpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltIdG1sRWxlbWVudF0oI0h0bWxFbGVtZW50KTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bTnVsbF0oI051bGwpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltOdW1iZXJdKCNOdW1iZXIpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltPYmplY3RdKCNPYmplY3QpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltSZWdFeHBdKCNSZWdFeHApPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltTdHJNYXBdKCNTdHJNYXApIChbVW5rbm93bl0oI1Vua25vd24pKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bU3RyaW5nXSgjU3RyaW5nKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bU3ltYm9sXSgjU3ltYm9sKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bVW5kZWZpbmVkXSgjVW5kZWZpbmVkKTwvY29kZT5cbiAgdmFyIGVudiA9IFtcbiAgICBBbnlGdW5jdGlvbixcbiAgICBBcmd1bWVudHMsXG4gICAgQXJyYXlfIChVbmtub3duKSxcbiAgICBCb29sZWFuXyxcbiAgICBEYXRlXyxcbiAgICBFcnJvcl8sXG4gICAgSHRtbEVsZW1lbnQsXG4gICAgTnVsbCxcbiAgICBOdW1iZXJfLFxuICAgIE9iamVjdF8sXG4gICAgUmVnRXhwXyxcbiAgICBTdHJNYXAgKFVua25vd24pLFxuICAgIFN0cmluZ18sXG4gICAgU3ltYm9sXyxcbiAgICBVbmRlZmluZWRcbiAgXTtcblxuICAvLyAgVW5jaGVja2VkIDo6IFN0cmluZyAtPiBUeXBlXG4gIGZ1bmN0aW9uIFVuY2hlY2tlZChzKSB7IHJldHVybiBOdWxsYXJ5VHlwZSAocykgKCcnKSAoSyAodHJ1ZSkpOyB9XG5cbiAgLy8gIHByb2R1Y3Rpb24gOjogQm9vbGVhblxuICB2YXIgcHJvZHVjdGlvbiA9XG4gICAgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLyogZ2xvYmFsIHByb2Nlc3M6ZmFsc2UgKi9cbiAgICBwcm9jZXNzICE9IG51bGwgJiZcbiAgICBwcm9jZXNzLmVudiAhPSBudWxsICYmXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJztcblxuICB2YXIgZGVmID0gX2NyZWF0ZSAoe2NoZWNrVHlwZXM6ICFwcm9kdWN0aW9uLCBlbnY6IGVudn0pO1xuXG4gIC8vICBudW1iZXJzIDo6IEFycmF5IFN0cmluZ1xuICB2YXIgbnVtYmVycyA9IFtcbiAgICAnemVybycsXG4gICAgJ29uZScsXG4gICAgJ3R3bycsXG4gICAgJ3RocmVlJyxcbiAgICAnZm91cicsXG4gICAgJ2ZpdmUnLFxuICAgICdzaXgnLFxuICAgICdzZXZlbicsXG4gICAgJ2VpZ2h0JyxcbiAgICAnbmluZSdcbiAgXTtcblxuICAvLyAgbnVtQXJncyA6OiBJbnRlZ2VyIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBudW1BcmdzKG4pIHtcbiAgICByZXR1cm4gKG4gPCBudW1iZXJzLmxlbmd0aCA/IG51bWJlcnNbbl0gOiBzaG93IChuKSkgKyAnICcgK1xuICAgICAgICAgICAobiA9PT0gMSA/ICdhcmd1bWVudCcgOiAnYXJndW1lbnRzJyk7XG4gIH1cblxuICAvLyAgZXhwYW5kVW5rbm93biA6OiAuLi4gLT4gQXJyYXkgVHlwZVxuICBmdW5jdGlvbiBleHBhbmRVbmtub3duKFxuICAgIGVudiwgICAgICAgICAgICAvLyA6OiBBcnJheSBUeXBlXG4gICAgc2VlbiwgICAgICAgICAgIC8vIDo6IEFycmF5IE9iamVjdFxuICAgIHZhbHVlLCAgICAgICAgICAvLyA6OiBBbnlcbiAgICByICAgICAgICAgICAgICAgLy8gOjogeyBleHRyYWN0b3IgOjogYSAtPiBBcnJheSBiLCB0eXBlIDo6IFR5cGUgfVxuICApIHtcbiAgICByZXR1cm4gci50eXBlLnR5cGUgPT09IFVOS05PV04gP1xuICAgICAgX2RldGVybWluZUFjdHVhbFR5cGVzIChlbnYsIHNlZW4sIHIuZXh0cmFjdG9yICh2YWx1ZSkpIDpcbiAgICAgIFtyLnR5cGVdO1xuICB9XG5cbiAgLy8gIF9kZXRlcm1pbmVBY3R1YWxUeXBlcyA6OiAuLi4gLT4gQXJyYXkgVHlwZVxuICBmdW5jdGlvbiBfZGV0ZXJtaW5lQWN0dWFsVHlwZXMoXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICBzZWVuLCAgICAgICAgICAgLy8gOjogQXJyYXkgT2JqZWN0XG4gICAgdmFsdWVzICAgICAgICAgIC8vIDo6IEFycmF5IEFueVxuICApIHtcbiAgICBmdW5jdGlvbiByZWZpbmUodHlwZXMsIHZhbHVlKSB7XG4gICAgICB2YXIgc2VlbiQ7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICBBYm9ydCBpZiBhIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyBlbmNvdW50ZXJlZDsgYWRkIHRoZSBjdXJyZW50XG4gICAgICAgIC8vICBvYmplY3QgdG8gdGhlIGFycmF5IG9mIHNlZW4gb2JqZWN0cyBvdGhlcndpc2UuXG4gICAgICAgIGlmIChzZWVuLmluZGV4T2YgKHZhbHVlKSA+PSAwKSByZXR1cm4gW107XG4gICAgICAgIHNlZW4kID0gWi5jb25jYXQgKHNlZW4sIFt2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VlbiQgPSBzZWVuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFouY2hhaW4gKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0Lm5hbWUgPT09ICdzYW5jdHVhcnktZGVmL051bGxhYmxlJyB8fCAodC52YWxpZGF0ZSAodmFsdWUpKS5pc0xlZnQgP1xuICAgICAgICAgICAgW10gOlxuICAgICAgICAgIHQudHlwZSA9PT0gVU5BUlkgP1xuICAgICAgICAgICAgWi5tYXAgKGZyb21VbmFyeVR5cGUgKHQpLFxuICAgICAgICAgICAgICAgICAgIGV4cGFuZFVua25vd24gKGVudiwgc2VlbiQsIHZhbHVlLCB0LnR5cGVzLiQxKSkgOlxuICAgICAgICAgIHQudHlwZSA9PT0gQklOQVJZID9cbiAgICAgICAgICAgIHhwcm9kICh0LFxuICAgICAgICAgICAgICAgICAgIGV4cGFuZFVua25vd24gKGVudiwgc2VlbiQsIHZhbHVlLCB0LnR5cGVzLiQxKSxcbiAgICAgICAgICAgICAgICAgICBleHBhbmRVbmtub3duIChlbnYsIHNlZW4kLCB2YWx1ZSwgdC50eXBlcy4kMikpIDpcbiAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICBbdF1cbiAgICAgICAgKTtcbiAgICAgIH0sIHR5cGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNFbXB0eSAodmFsdWVzKSA/XG4gICAgICBbVW5rbm93bl0gOlxuICAgICAgb3IgKFoucmVkdWNlIChyZWZpbmUsIGVudiwgdmFsdWVzKSwgW0luY29uc2lzdGVudF0pO1xuICB9XG5cbiAgLy8gIGlzQ29uc2lzdGVudCA6OiBUeXBlIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gaXNDb25zaXN0ZW50KHQpIHtcbiAgICByZXR1cm4gdC50eXBlID09PSBVTkFSWSAgID8gaXNDb25zaXN0ZW50ICh0LnR5cGVzLiQxLnR5cGUpIDpcbiAgICAgICAgICAgdC50eXBlID09PSBCSU5BUlkgID8gaXNDb25zaXN0ZW50ICh0LnR5cGVzLiQxLnR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQ29uc2lzdGVudCAodC50eXBlcy4kMi50eXBlKSA6XG4gICAgICAgICAgIC8qIGVsc2UgKi8gICAgICAgICAgIHQudHlwZSAhPT0gSU5DT05TSVNURU5UO1xuICB9XG5cbiAgLy8gIGRldGVybWluZUFjdHVhbFR5cGVzU3RyaWN0IDo6IChBcnJheSBUeXBlLCBBcnJheSBBbnkpIC0+IEFycmF5IFR5cGVcbiAgZnVuY3Rpb24gZGV0ZXJtaW5lQWN0dWFsVHlwZXNTdHJpY3QoZW52LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gWi5maWx0ZXIgKGlzQ29uc2lzdGVudCxcbiAgICAgICAgICAgICAgICAgICAgIF9kZXRlcm1pbmVBY3R1YWxUeXBlcyAoZW52LCBbXSwgdmFsdWVzKSk7XG4gIH1cblxuICAvLyAgZGV0ZXJtaW5lQWN0dWFsVHlwZXNMb29zZSA6OiAoQXJyYXkgVHlwZSwgQXJyYXkgQW55KSAtPiBBcnJheSBUeXBlXG4gIGZ1bmN0aW9uIGRldGVybWluZUFjdHVhbFR5cGVzTG9vc2UoZW52LCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gWi5yZWplY3QgKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQudHlwZSA9PT0gSU5DT05TSVNURU5UOyB9LFxuICAgICAgICAgICAgICAgICAgICAgX2RldGVybWluZUFjdHVhbFR5cGVzIChlbnYsIFtdLCB2YWx1ZXMpKTtcbiAgfVxuXG4gIC8vICBUeXBlSW5mbyA9IHsgbmFtZSA6OiBTdHJpbmdcbiAgLy8gICAgICAgICAgICAgLCBjb25zdHJhaW50cyA6OiBTdHJNYXAgKEFycmF5IFR5cGVDbGFzcylcbiAgLy8gICAgICAgICAgICAgLCB0eXBlcyA6OiBOb25FbXB0eSAoQXJyYXkgVHlwZSkgfVxuICAvL1xuICAvLyAgVHlwZVZhck1hcCA9IFN0ck1hcCB7IHR5cGVzIDo6IEFycmF5IFR5cGVcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgLCB2YWx1ZXNCeVBhdGggOjogU3RyTWFwIChBcnJheSBBbnkpIH1cbiAgLy9cbiAgLy8gIFByb3BQYXRoID0gQXJyYXkgKE51bWJlciB8IFN0cmluZylcblxuICAvLyAgdXBkYXRlVHlwZVZhck1hcCA6OiAuLi4gLT4gVHlwZVZhck1hcFxuICBmdW5jdGlvbiB1cGRhdGVUeXBlVmFyTWFwKFxuICAgIGVudiwgICAgICAgICAgICAvLyA6OiBBcnJheSBUeXBlXG4gICAgdHlwZVZhck1hcCwgICAgIC8vIDo6IFR5cGVWYXJNYXBcbiAgICB0eXBlVmFyLCAgICAgICAgLy8gOjogVHlwZVxuICAgIGluZGV4LCAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICAgcHJvcFBhdGgsICAgICAgIC8vIDo6IFByb3BQYXRoXG4gICAgdmFsdWVzICAgICAgICAgIC8vIDo6IEFycmF5IEFueVxuICApIHtcbiAgICB2YXIgJHR5cGVWYXJNYXAgPSB7fTtcbiAgICBmb3IgKHZhciB0eXBlVmFyTmFtZSBpbiB0eXBlVmFyTWFwKSB7XG4gICAgICB2YXIgZW50cnkgPSB0eXBlVmFyTWFwW3R5cGVWYXJOYW1lXTtcbiAgICAgIHZhciAkZW50cnkgPSB7dHlwZXM6IGVudHJ5LnR5cGVzLnNsaWNlICgpLCB2YWx1ZXNCeVBhdGg6IHt9fTtcbiAgICAgIGZvciAodmFyIGsgaW4gZW50cnkudmFsdWVzQnlQYXRoKSB7XG4gICAgICAgICRlbnRyeS52YWx1ZXNCeVBhdGhba10gPSBlbnRyeS52YWx1ZXNCeVBhdGhba10uc2xpY2UgKCk7XG4gICAgICB9XG4gICAgICAkdHlwZVZhck1hcFt0eXBlVmFyTmFtZV0gPSAkZW50cnk7XG4gICAgfVxuICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwgKCR0eXBlVmFyTWFwLCB0eXBlVmFyLm5hbWUpKSkge1xuICAgICAgJHR5cGVWYXJNYXBbdHlwZVZhci5uYW1lXSA9IHt0eXBlczogZW52LnNsaWNlICgpLCB2YWx1ZXNCeVBhdGg6IHt9fTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkgKFouY29uY2F0IChbaW5kZXhdLCBwcm9wUGF0aCkpO1xuICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwgKCR0eXBlVmFyTWFwW3R5cGVWYXIubmFtZV0udmFsdWVzQnlQYXRoLCBrZXkpKSkge1xuICAgICAgJHR5cGVWYXJNYXBbdHlwZVZhci5uYW1lXS52YWx1ZXNCeVBhdGhba2V5XSA9IFtdO1xuICAgIH1cblxuICAgIHZhciBpc051bGxhcnlUeXBlVmFyID0gaXNFbXB0eSAodHlwZVZhci5rZXlzKTtcbiAgICB2YXIgaXNWYWxpZCA9IHRlc3QgKGVudik7XG5cbiAgICBmdW5jdGlvbiBleHBhbmRVbmtub3duU3RyaWN0KHZhbHVlLCByKSB7XG4gICAgICByZXR1cm4gWi5maWx0ZXIgKGlzQ29uc2lzdGVudCwgZXhwYW5kVW5rbm93biAoZW52LCBbXSwgdmFsdWUsIHIpKTtcbiAgICB9XG5cbiAgICB2YWx1ZXMuZm9yRWFjaCAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICR0eXBlVmFyTWFwW3R5cGVWYXIubmFtZV0udmFsdWVzQnlQYXRoW2tleV0ucHVzaCAodmFsdWUpO1xuICAgICAgJHR5cGVWYXJNYXBbdHlwZVZhci5uYW1lXS50eXBlcyA9IFouY2hhaW4gKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0LmtleXMubGVuZ3RoIDwgdHlwZVZhci5rZXlzLmxlbmd0aCB8fCAhaXNWYWxpZCAodCkgKHZhbHVlKSA/XG4gICAgICAgICAgICBbXSA6XG4gICAgICAgICAgaXNOdWxsYXJ5VHlwZVZhciAmJiB0LnR5cGUgPT09IFVOQVJZID9cbiAgICAgICAgICAgIFoubWFwIChmcm9tVW5hcnlUeXBlICh0KSxcbiAgICAgICAgICAgICAgICAgICBleHBhbmRVbmtub3duU3RyaWN0ICh2YWx1ZSwgdC50eXBlcy4kMSkpIDpcbiAgICAgICAgICBpc051bGxhcnlUeXBlVmFyICYmIHQudHlwZSA9PT0gQklOQVJZID9cbiAgICAgICAgICAgIHhwcm9kICh0LFxuICAgICAgICAgICAgICAgICAgIGV4cGFuZFVua25vd25TdHJpY3QgKHZhbHVlLCB0LnR5cGVzLiQxKSxcbiAgICAgICAgICAgICAgICAgICBleHBhbmRVbmtub3duU3RyaWN0ICh2YWx1ZSwgdC50eXBlcy4kMikpIDpcbiAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICBbdF1cbiAgICAgICAgKTtcbiAgICAgIH0sICR0eXBlVmFyTWFwW3R5cGVWYXIubmFtZV0udHlwZXMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuICR0eXBlVmFyTWFwO1xuICB9XG5cbiAgLy8gIHVuZGVybGluZVR5cGVWYXJzIDo6IChUeXBlSW5mbywgU3RyTWFwIChBcnJheSBBbnkpKSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gdW5kZXJsaW5lVHlwZVZhcnModHlwZUluZm8sIHZhbHVlc0J5UGF0aCkge1xuICAgIC8vICBOb3RlOiBTb3J0aW5nIHRoZXNlIGtleXMgbGV4aWNvZ3JhcGhpY2FsbHkgaXMgbm90IFwiY29ycmVjdFwiLCBidXQgaXRcbiAgICAvLyAgZG9lcyB0aGUgcmlnaHQgdGhpbmcgZm9yIGluZGV4ZXMgbGVzcyB0aGFuIDEwLlxuICAgIHZhciBwYXRocyA9IFoubWFwIChKU09OLnBhcnNlLCBzb3J0ZWRLZXlzICh2YWx1ZXNCeVBhdGgpKTtcbiAgICByZXR1cm4gdW5kZXJsaW5lIChcbiAgICAgIHR5cGVJbmZvLFxuICAgICAgSyAoSyAoXykpLFxuICAgICAgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3BQYXRoKSB7XG4gICAgICAgICAgICAgIHZhciBpbmRleGVkUHJvcFBhdGggPSBaLmNvbmNhdCAoW2luZGV4XSwgcHJvcFBhdGgpO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgIGlmIChwYXRocy5zb21lIChpc1ByZWZpeCAoaW5kZXhlZFByb3BQYXRoKSkpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeSAoaW5kZXhlZFByb3BQYXRoKTtcbiAgICAgICAgICAgICAgICAgIGlmICghKGhhc093blByb3BlcnR5LmNhbGwgKHZhbHVlc0J5UGF0aCwga2V5KSkpIHJldHVybiBzO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoaXNFbXB0eSAodmFsdWVzQnlQYXRoW2tleV0pKSkgcmV0dXJuIGYgKHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gXyAocyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8vICBzYXRpc2ZhY3RvcnlUeXBlcyA6OiAuLi4gLT4gRWl0aGVyICgoKSAtPiBFcnJvcilcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyB0eXBlVmFyTWFwIDo6IFR5cGVWYXJNYXBcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCB0eXBlcyA6OiBBcnJheSBUeXBlIH1cbiAgZnVuY3Rpb24gc2F0aXNmYWN0b3J5VHlwZXMoXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICB0eXBlSW5mbywgICAgICAgLy8gOjogVHlwZUluZm9cbiAgICB0eXBlVmFyTWFwLCAgICAgLy8gOjogVHlwZVZhck1hcFxuICAgIGV4cFR5cGUsICAgICAgICAvLyA6OiBUeXBlXG4gICAgaW5kZXgsICAgICAgICAgIC8vIDo6IEludGVnZXJcbiAgICBwcm9wUGF0aCwgICAgICAgLy8gOjogUHJvcFBhdGhcbiAgICB2YWx1ZXMgICAgICAgICAgLy8gOjogQXJyYXkgQW55XG4gICkge1xuICAgIHZhciByZWN1ciA9IHNhdGlzZmFjdG9yeVR5cGVzO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdmFsdWVzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIHZhciByZXN1bHQgPSBleHBUeXBlLnZhbGlkYXRlICh2YWx1ZXNbaWR4XSk7XG4gICAgICBpZiAocmVzdWx0LmlzTGVmdCkge1xuICAgICAgICByZXR1cm4gTGVmdCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWx1ZSAoZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFouY29uY2F0IChwcm9wUGF0aCwgcmVzdWx0LnZhbHVlLnByb3BQYXRoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV4cFR5cGUudHlwZSkge1xuXG4gICAgICBjYXNlIFZBUklBQkxFOlxuICAgICAgICB2YXIgdHlwZVZhck5hbWUgPSBleHBUeXBlLm5hbWU7XG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IHR5cGVJbmZvLmNvbnN0cmFpbnRzO1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCAoY29uc3RyYWludHMsIHR5cGVWYXJOYW1lKSkge1xuICAgICAgICAgIHZhciB0eXBlQ2xhc3NlcyA9IGNvbnN0cmFpbnRzW3R5cGVWYXJOYW1lXTtcbiAgICAgICAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IHZhbHVlcy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpZHgyID0gMDsgaWR4MiA8IHR5cGVDbGFzc2VzLmxlbmd0aDsgaWR4MiArPSAxKSB7XG4gICAgICAgICAgICAgIGlmICghdHlwZUNsYXNzZXNbaWR4Ml0udGVzdCAodmFsdWVzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExlZnQgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVDbGFzc0NvbnN0cmFpbnRWaW9sYXRpb24gKFxuICAgICAgICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICB0eXBlQ2xhc3Nlc1tpZHgyXSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHByb3BQYXRoLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNbaWR4XSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZVZhck1hcFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0eXBlVmFyTWFwJCA9IHVwZGF0ZVR5cGVWYXJNYXAgKGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMpO1xuXG4gICAgICAgIHZhciBva1R5cGVzID0gdHlwZVZhck1hcCRbdHlwZVZhck5hbWVdLnR5cGVzO1xuICAgICAgICByZXR1cm4gaXNFbXB0eSAob2tUeXBlcykgP1xuICAgICAgICAgIExlZnQgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVWYXJDb25zdHJhaW50VmlvbGF0aW9uIChcbiAgICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgIHByb3BQYXRoLFxuICAgICAgICAgICAgICB0eXBlVmFyTWFwJFt0eXBlVmFyTmFtZV0udmFsdWVzQnlQYXRoXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0pIDpcbiAgICAgICAgICBaLnJlZHVjZSAoZnVuY3Rpb24oZSwgdCkge1xuICAgICAgICAgICAgcmV0dXJuIFouY2hhaW4gKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgLy8gIFRoZSBgYWAgaW4gYEZ1bmN0b3IgZiA9PiBmIGFgIGNvcnJlc3BvbmRzIHRvIHRoZSBgYWBcbiAgICAgICAgICAgICAgLy8gIGluIGBNYXliZSBhYCBidXQgdG8gdGhlIGBiYCBpbiBgRWl0aGVyIGEgYmAuIEEgdHlwZVxuICAgICAgICAgICAgICAvLyAgdmFyaWFibGUncyAkMSB3aWxsIGNvcnJlc3BvbmQgdG8gZWl0aGVyICQxIG9yICQyIG9mXG4gICAgICAgICAgICAgIC8vICB0aGUgYWN0dWFsIHR5cGUgZGVwZW5kaW5nIG9uIHRoZSBhY3R1YWwgdHlwZSdzIGFyaXR5LlxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gdC5rZXlzLmxlbmd0aCAtIGV4cFR5cGUua2V5cy5sZW5ndGg7XG4gICAgICAgICAgICAgIHJldHVybiBleHBUeXBlLmtleXMucmVkdWNlIChmdW5jdGlvbihlLCBrLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0cmFjdG9yID0gdC50eXBlc1t0LmtleXNbb2Zmc2V0ICsgaWR4XV0uZXh0cmFjdG9yO1xuICAgICAgICAgICAgICAgIHJldHVybiBaLnJlZHVjZSAoZnVuY3Rpb24oZSwgeCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFouY2hhaW4gKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY3VyIChlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci50eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cFR5cGUudHlwZXNba10udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBaLmNvbmNhdCAocHJvcFBhdGgsIFtrXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3hdKTtcbiAgICAgICAgICAgICAgICAgIH0sIGUpO1xuICAgICAgICAgICAgICAgIH0sIGUsIFouY2hhaW4gKGV4dHJhY3RvciwgdmFsdWVzKSk7XG4gICAgICAgICAgICAgIH0sIFJpZ2h0IChyKSk7XG4gICAgICAgICAgICB9LCBlKTtcbiAgICAgICAgICB9LCBSaWdodCAoe3R5cGVWYXJNYXA6IHR5cGVWYXJNYXAkLCB0eXBlczogb2tUeXBlc30pLCBva1R5cGVzKTtcblxuICAgICAgY2FzZSBVTkFSWTpcbiAgICAgICAgcmV0dXJuIFoubWFwIChcbiAgICAgICAgICBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGVWYXJNYXA6IHJlc3VsdC50eXBlVmFyTWFwLFxuICAgICAgICAgICAgICB0eXBlczogWi5tYXAgKGZyb21VbmFyeVR5cGUgKGV4cFR5cGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIChyZXN1bHQudHlwZXMsIFtleHBUeXBlLnR5cGVzLiQxLnR5cGVdKSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWN1ciAoZW52LFxuICAgICAgICAgICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgdHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgZXhwVHlwZS50eXBlcy4kMS50eXBlLFxuICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgWi5jb25jYXQgKHByb3BQYXRoLCBbJyQxJ10pLFxuICAgICAgICAgICAgICAgICBaLmNoYWluIChleHBUeXBlLnR5cGVzLiQxLmV4dHJhY3RvciwgdmFsdWVzKSlcbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBCSU5BUlk6XG4gICAgICAgIHJldHVybiBaLmNoYWluIChcbiAgICAgICAgICBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciAkMXMgPSByZXN1bHQudHlwZXM7XG4gICAgICAgICAgICByZXR1cm4gWi5tYXAgKFxuICAgICAgICAgICAgICBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgJDJzID0gcmVzdWx0LnR5cGVzO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICB0eXBlVmFyTWFwOiByZXN1bHQudHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgIHR5cGVzOiB4cHJvZCAoZXhwVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgKCQxcywgW2V4cFR5cGUudHlwZXMuJDEudHlwZV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciAoJDJzLCBbZXhwVHlwZS50eXBlcy4kMi50eXBlXSkpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVjdXIgKGVudixcbiAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgICAgICAgICBleHBUeXBlLnR5cGVzLiQyLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgIFouY29uY2F0IChwcm9wUGF0aCwgWyckMiddKSxcbiAgICAgICAgICAgICAgICAgICAgIFouY2hhaW4gKGV4cFR5cGUudHlwZXMuJDIuZXh0cmFjdG9yLCB2YWx1ZXMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3VyIChlbnYsXG4gICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICB0eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICBleHBUeXBlLnR5cGVzLiQxLnR5cGUsXG4gICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICBaLmNvbmNhdCAocHJvcFBhdGgsIFsnJDEnXSksXG4gICAgICAgICAgICAgICAgIFouY2hhaW4gKGV4cFR5cGUudHlwZXMuJDEuZXh0cmFjdG9yLCB2YWx1ZXMpKVxuICAgICAgICApO1xuXG4gICAgICBjYXNlIFJFQ09SRDpcbiAgICAgICAgcmV0dXJuIFoucmVkdWNlIChmdW5jdGlvbihlLCBrKSB7XG4gICAgICAgICAgcmV0dXJuIFouY2hhaW4gKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN1ciAoZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgci50eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBleHBUeXBlLnR5cGVzW2tdLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBaLmNvbmNhdCAocHJvcFBhdGgsIFtrXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFouY2hhaW4gKGV4cFR5cGUudHlwZXNba10uZXh0cmFjdG9yLCB2YWx1ZXMpKTtcbiAgICAgICAgICB9LCBlKTtcbiAgICAgICAgfSwgUmlnaHQgKHt0eXBlVmFyTWFwOiB0eXBlVmFyTWFwLCB0eXBlczogW2V4cFR5cGVdfSksIGV4cFR5cGUua2V5cyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBSaWdodCAoe3R5cGVWYXJNYXA6IHR5cGVWYXJNYXAsIHR5cGVzOiBbZXhwVHlwZV19KTtcbiAgICB9XG4gIH1cblxuICAvLyMgdGVzdCA6OiBBcnJheSBUeXBlIC0+IFR5cGUgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYW4gZW52aXJvbm1lbnQsIGEgdHlwZSwgYW5kIGFueSB2YWx1ZS4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlXG4gIC8vLiBpcyBhIG1lbWJlciBvZiB0aGUgdHlwZTsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gVGhlIGVudmlyb25tZW50IGlzIG9ubHkgc2lnbmlmaWNhbnQgaWYgdGhlIHR5cGUgY29udGFpbnNcbiAgLy8uIFt0eXBlIHZhcmlhYmxlc11bXS5cbiAgLy8uXG4gIC8vLiBPbmUgbWF5IGRlZmluZSBhIG1vcmUgcmVzdHJpY3RpdmUgdHlwZSBpbiB0ZXJtcyBvZiBhIG1vcmUgZ2VuZXJhbCBvbmU6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gLy8gICAgTm9uTmVnYXRpdmVJbnRlZ2VyIDo6IFR5cGVcbiAgLy8uIGNvbnN0IE5vbk5lZ2F0aXZlSW50ZWdlciA9ICQuTnVsbGFyeVR5cGVcbiAgLy8uICAgKCdteS1wYWNrYWdlL05vbk5lZ2F0aXZlSW50ZWdlcicpXG4gIC8vLiAgICgnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjTm9uTmVnYXRpdmVJbnRlZ2VyJylcbiAgLy8uICAgKHggPT4gJC50ZXN0IChbXSkgKCQuSW50ZWdlcikgKHgpICYmIHggPj0gMCk7XG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBVc2luZyB0eXBlcyBhcyBwcmVkaWNhdGVzIGlzIHVzZWZ1bCBpbiBvdGhlciBjb250ZXh0cyB0b28uIE9uZSBjb3VsZCxcbiAgLy8uIGZvciBleGFtcGxlLCBkZWZpbmUgYSBbcmVjb3JkIHR5cGVdW10gZm9yIGVhY2ggZW5kcG9pbnQgb2YgYSBSRVNUIEFQSVxuICAvLy4gYW5kIHZhbGlkYXRlIHRoZSBib2RpZXMgb2YgaW5jb21pbmcgUE9TVCByZXF1ZXN0cyBhZ2FpbnN0IHRoZXNlIHR5cGVzLlxuICBmdW5jdGlvbiB0ZXN0KGVudikge1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgdHlwZUluZm8gPSB7bmFtZTogJ25hbWUnLCBjb25zdHJhaW50czoge30sIHR5cGVzOiBbdF19O1xuICAgICAgICByZXR1cm4gKHNhdGlzZmFjdG9yeVR5cGVzIChlbnYsIHR5cGVJbmZvLCB7fSwgdCwgMCwgW10sIFt4XSkpLmlzUmlnaHQ7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICAvLy4gIyMjIFR5cGUgY29uc3RydWN0b3JzXG4gIC8vLlxuICAvLy4gc2FuY3R1YXJ5LWRlZiBwcm92aWRlcyBzZXZlcmFsIGZ1bmN0aW9ucyBmb3IgZGVmaW5pbmcgdHlwZXMuXG5cbiAgLy8jIE51bGxhcnlUeXBlIDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gKEFueSAtPiBCb29sZWFuKSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb25zdHJ1Y3RvciBmb3IgdHlwZXMgd2l0aCBubyB0eXBlIHZhcmlhYmxlcyAoc3VjaCBhcyBbYE51bWJlcmBdW10pLlxuICAvLy5cbiAgLy8uIFRvIGRlZmluZSBhIG51bGxhcnkgdHlwZSBgdGAgb25lIG11c3QgcHJvdmlkZTpcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIG5hbWUgb2YgYHRgIChleHBvc2VkIGFzIGB0Lm5hbWVgKTtcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIGRvY3VtZW50YXRpb24gVVJMIG9mIGB0YCAoZXhwb3NlZCBhcyBgdC51cmxgKTsgYW5kXG4gIC8vLlxuICAvLy4gICAtIGEgcHJlZGljYXRlIHdoaWNoIGFjY2VwdHMgYW55IEphdmFTY3JpcHQgdmFsdWUgYW5kIHJldHVybnMgYHRydWVgIGlmXG4gIC8vLiAgICAgKGFuZCBvbmx5IGlmKSB0aGUgdmFsdWUgaXMgYSBtZW1iZXIgb2YgYHRgLlxuICAvLy5cbiAgLy8uIEZvciBleGFtcGxlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIC8vICAgIEludGVnZXIgOjogVHlwZVxuICAvLy4gY29uc3QgSW50ZWdlciA9ICQuTnVsbGFyeVR5cGVcbiAgLy8uICAgKCdteS1wYWNrYWdlL0ludGVnZXInKVxuICAvLy4gICAoJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI0ludGVnZXInKVxuICAvLy4gICAoeCA9PiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiZcbiAgLy8uICAgICAgICAgTWF0aC5mbG9vciAoeCkgPT09IHggJiZcbiAgLy8uICAgICAgICAgeCA+PSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiAmJlxuICAvLy4gICAgICAgICB4IDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBOb25aZXJvSW50ZWdlciA6OiBUeXBlXG4gIC8vLiBjb25zdCBOb25aZXJvSW50ZWdlciA9ICQuTnVsbGFyeVR5cGVcbiAgLy8uICAgKCdteS1wYWNrYWdlL05vblplcm9JbnRlZ2VyJylcbiAgLy8uICAgKCdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNOb25aZXJvSW50ZWdlcicpXG4gIC8vLiAgICh4ID0+ICQudGVzdCAoW10pIChJbnRlZ2VyKSAoeCkgJiYgeCAhPT0gMCk7XG4gIC8vLlxuICAvLy4gLy8gICAgcmVtIDo6IEludGVnZXIgLT4gTm9uWmVyb0ludGVnZXIgLT4gSW50ZWdlclxuICAvLy4gY29uc3QgcmVtID1cbiAgLy8uIGRlZiAoJ3JlbScpXG4gIC8vLiAgICAgKHt9KVxuICAvLy4gICAgIChbSW50ZWdlciwgTm9uWmVyb0ludGVnZXIsIEludGVnZXJdKVxuICAvLy4gICAgICh4ID0+IHkgPT4geCAlIHkpO1xuICAvLy5cbiAgLy8uIHJlbSAoNDIpICg1KTtcbiAgLy8uIC8vID0+IDJcbiAgLy8uXG4gIC8vLiByZW0gKDAuNSk7XG4gIC8vLiAvLyAhIFR5cGVFcnJvcjogSW52YWxpZCB2YWx1ZVxuICAvLy4gLy9cbiAgLy8uIC8vICAgcmVtIDo6IEludGVnZXIgLT4gTm9uWmVyb0ludGVnZXIgLT4gSW50ZWdlclxuICAvLy4gLy8gICAgICAgICAgXl5eXl5eXlxuICAvLy4gLy8gICAgICAgICAgICAgMVxuICAvLy4gLy9cbiAgLy8uIC8vICAgMSkgIDAuNSA6OiBOdW1iZXJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGlzIG5vdCBhIG1lbWJlciBvZiDigJhJbnRlZ2Vy4oCZLlxuICAvLy5cbiAgLy8uIHJlbSAoNDIpICgwKTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiBJbnZhbGlkIHZhbHVlXG4gIC8vLiAvL1xuICAvLy4gLy8gICByZW0gOjogSW50ZWdlciAtPiBOb25aZXJvSW50ZWdlciAtPiBJbnRlZ2VyXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXl5eXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDEpICAwIDo6IE51bWJlclxuICAvLy4gLy9cbiAgLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmE5vblplcm9JbnRlZ2Vy4oCZLlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE51bGxhcnlUeXBlKG5hbWUpIHtcbiAgICBmdW5jdGlvbiBmb3JtYXQob3V0ZXIsIGlubmVyKSB7XG4gICAgICByZXR1cm4gb3V0ZXIgKHN0cmlwTmFtZXNwYWNlIChuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbih1cmwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgX1R5cGUgKE5VTExBUlksIG5hbWUsIHVybCwgZm9ybWF0LCB0ZXN0LCBbXSwge30pO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIENoZWNrZWROdWxsYXJ5VHlwZSA9XG4gIGRlZiAoJ051bGxhcnlUeXBlJylcbiAgICAgICh7fSlcbiAgICAgIChbU3RyaW5nXywgU3RyaW5nXywgRnVuY3Rpb25fIChbQW55LCBCb29sZWFuX10pLCBUeXBlXSlcbiAgICAgIChOdWxsYXJ5VHlwZSk7XG5cbiAgLy8jIFVuYXJ5VHlwZSA6OiBTdHJpbmcgLT4gU3RyaW5nIC0+IChBbnkgLT4gQm9vbGVhbikgLT4gKHQgYSAtPiBBcnJheSBhKSAtPiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbnN0cnVjdG9yIGZvciB0eXBlcyB3aXRoIG9uZSB0eXBlIHZhcmlhYmxlIChzdWNoIGFzIFtgQXJyYXlgXVtdKS5cbiAgLy8uXG4gIC8vLiBUbyBkZWZpbmUgYSB1bmFyeSB0eXBlIGB0IGFgIG9uZSBtdXN0IHByb3ZpZGU6XG4gIC8vLlxuICAvLy4gICAtIHRoZSBuYW1lIG9mIGB0YCAoZXhwb3NlZCBhcyBgdC5uYW1lYCk7XG4gIC8vLlxuICAvLy4gICAtIHRoZSBkb2N1bWVudGF0aW9uIFVSTCBvZiBgdGAgKGV4cG9zZWQgYXMgYHQudXJsYCk7XG4gIC8vLlxuICAvLy4gICAtIGEgcHJlZGljYXRlIHdoaWNoIGFjY2VwdHMgYW55IEphdmFTY3JpcHQgdmFsdWUgYW5kIHJldHVybnMgYHRydWVgXG4gIC8vLiAgICAgaWYgKGFuZCBvbmx5IGlmKSB0aGUgdmFsdWUgaXMgYSBtZW1iZXIgb2YgYHQgeGAgZm9yIHNvbWUgdHlwZSBgeGA7XG4gIC8vLlxuICAvLy4gICAtIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW55IHZhbHVlIG9mIHR5cGUgYHQgYWAgYW5kIHJldHVybnMgYW4gYXJyYXlcbiAgLy8uICAgICBvZiB0aGUgdmFsdWVzIG9mIHR5cGUgYGFgIGNvbnRhaW5lZCBpbiB0aGUgYHRgIChleHBvc2VkIGFzXG4gIC8vLiAgICAgYHQudHlwZXMuJDEuZXh0cmFjdG9yYCk7IGFuZFxuICAvLy5cbiAgLy8uICAgLSB0aGUgdHlwZSBvZiBgYWAgKGV4cG9zZWQgYXMgYHQudHlwZXMuJDEudHlwZWApLlxuICAvLy5cbiAgLy8uIEZvciBleGFtcGxlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIGNvbnN0IHNob3cgPSByZXF1aXJlICgnc2FuY3R1YXJ5LXNob3cnKTtcbiAgLy8uIGNvbnN0IHR5cGUgPSByZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBtYXliZVR5cGVJZGVudCA6OiBTdHJpbmdcbiAgLy8uIGNvbnN0IG1heWJlVHlwZUlkZW50ID0gJ215LXBhY2thZ2UvTWF5YmUnO1xuICAvLy5cbiAgLy8uIC8vICAgIE1heWJlIDo6IFR5cGUgLT4gVHlwZVxuICAvLy4gY29uc3QgTWF5YmUgPSAkLlVuYXJ5VHlwZVxuICAvLy4gICAobWF5YmVUeXBlSWRlbnQpXG4gIC8vLiAgICgnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjTWF5YmUnKVxuICAvLy4gICAoeCA9PiB0eXBlICh4KSA9PT0gbWF5YmVUeXBlSWRlbnQpXG4gIC8vLiAgIChtYXliZSA9PiBtYXliZS5pc0p1c3QgPyBbbWF5YmUudmFsdWVdIDogW10pO1xuICAvLy5cbiAgLy8uIC8vICAgIE1heWJlVHlwZVJlcCA6OiBUeXBlUmVwIE1heWJlXG4gIC8vLiBjb25zdCBNYXliZVR5cGVSZXAgPSB7J0BAdHlwZSc6IG1heWJlVHlwZUlkZW50fTtcbiAgLy8uXG4gIC8vLiAvLyAgICBOb3RoaW5nIDo6IE1heWJlIGFcbiAgLy8uIGNvbnN0IE5vdGhpbmcgPSB7XG4gIC8vLiAgICdjb25zdHJ1Y3Rvcic6IE1heWJlVHlwZVJlcCxcbiAgLy8uICAgJ2lzSnVzdCc6IGZhbHNlLFxuICAvLy4gICAnaXNOb3RoaW5nJzogdHJ1ZSxcbiAgLy8uICAgJ0BAc2hvdyc6ICgpID0+ICdOb3RoaW5nJyxcbiAgLy8uIH07XG4gIC8vLlxuICAvLy4gLy8gICAgSnVzdCA6OiBhIC0+IE1heWJlIGFcbiAgLy8uIGNvbnN0IEp1c3QgPSB4ID0+ICh7XG4gIC8vLiAgICdjb25zdHJ1Y3Rvcic6IE1heWJlVHlwZVJlcCxcbiAgLy8uICAgJ2lzSnVzdCc6IHRydWUsXG4gIC8vLiAgICdpc05vdGhpbmcnOiBmYWxzZSxcbiAgLy8uICAgJ0BAc2hvdyc6ICgpID0+IGBKdXN0ICgke3Nob3cgKHgpfSlgLFxuICAvLy4gICAndmFsdWUnOiB4LFxuICAvLy4gfSk7XG4gIC8vLlxuICAvLy4gLy8gICAgZnJvbU1heWJlIDo6IGEgLT4gTWF5YmUgYSAtPiBhXG4gIC8vLiBjb25zdCBmcm9tTWF5YmUgPVxuICAvLy4gZGVmICgnZnJvbU1heWJlJylcbiAgLy8uICAgICAoe30pXG4gIC8vLiAgICAgKFthLCBNYXliZSAoYSksIGFdKVxuICAvLy4gICAgICh4ID0+IG0gPT4gbS5pc0p1c3QgPyBtLnZhbHVlIDogeCk7XG4gIC8vLlxuICAvLy4gZnJvbU1heWJlICgwKSAoSnVzdCAoNDIpKTtcbiAgLy8uIC8vID0+IDQyXG4gIC8vLlxuICAvLy4gZnJvbU1heWJlICgwKSAoTm90aGluZyk7XG4gIC8vLiAvLyA9PiAwXG4gIC8vLlxuICAvLy4gZnJvbU1heWJlICgwKSAoSnVzdCAoJ1hYWCcpKTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiBUeXBlLXZhcmlhYmxlIGNvbnN0cmFpbnQgdmlvbGF0aW9uXG4gIC8vLiAvL1xuICAvLy4gLy8gICBmcm9tTWF5YmUgOjogYSAtPiBNYXliZSBhIC0+IGFcbiAgLy8uIC8vICAgICAgICAgICAgICAgIF4gICAgICAgICAgXlxuICAvLy4gLy8gICAgICAgICAgICAgICAgMSAgICAgICAgICAyXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAgMCA6OiBOdW1iZXJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDIpICBcIlhYWFwiIDo6IFN0cmluZ1xuICAvLy4gLy9cbiAgLy8uIC8vICAgU2luY2UgdGhlcmUgaXMgbm8gdHlwZSBvZiB3aGljaCBhbGwgdGhlIGFib3ZlIHZhbHVlcyBhcmUgbWVtYmVycywgdGhlIHR5cGUtdmFyaWFibGUgY29uc3RyYWludCBoYXMgYmVlbiB2aW9sYXRlZC5cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBVbmFyeVR5cGUobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih1cmwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihfMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkMSkge1xuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0KG91dGVyLCBpbm5lcikge1xuICAgICAgICAgICAgICByZXR1cm4gb3V0ZXIgKCcoJyArIHN0cmlwTmFtZXNwYWNlIChuYW1lKSArICcgJykgK1xuICAgICAgICAgICAgICAgICAgICAgaW5uZXIgKCckMScpIChzaG93ICgkMSkpICtcbiAgICAgICAgICAgICAgICAgICAgIG91dGVyICgnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHR5cGVzID0geyQxOiB7ZXh0cmFjdG9yOiBfMSwgdHlwZTogJDF9fTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgX1R5cGUgKFVOQVJZLCBuYW1lLCB1cmwsIGZvcm1hdCwgdGVzdCwgWyckMSddLCB0eXBlcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHZhciBDaGVja2VkVW5hcnlUeXBlID1cbiAgZGVmICgnVW5hcnlUeXBlJylcbiAgICAgICh7fSlcbiAgICAgIChbU3RyaW5nXyxcbiAgICAgICAgU3RyaW5nXyxcbiAgICAgICAgRnVuY3Rpb25fIChbQW55LCBCb29sZWFuX10pLFxuICAgICAgICBGdW5jdGlvbl8gKFtVbmNoZWNrZWQgKCd0IGEnKSwgQXJyYXlfIChVbmNoZWNrZWQgKCdhJykpXSksXG4gICAgICAgIEFueUZ1bmN0aW9uXSlcbiAgICAgIChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICByZXR1cm4gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICAgICAgICAgcmV0dXJuIGNvbXBvc2UgKGRlZiAoc3RyaXBOYW1lc3BhY2UgKG5hbWUpKSAoe30pIChbVHlwZSwgVHlwZV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVbmFyeVR5cGUgKG5hbWUpICh1cmwpICh0ZXN0KSk7XG4gICAgICAgICAgIH07XG4gICAgICAgICB9O1xuICAgICAgIH0pO1xuXG4gIC8vICBmcm9tVW5hcnlUeXBlIDo6IFR5cGUgLT4gKFR5cGUgLT4gVHlwZSlcbiAgZnVuY3Rpb24gZnJvbVVuYXJ5VHlwZSh0KSB7XG4gICAgcmV0dXJuIFVuYXJ5VHlwZSAodC5uYW1lKSAodC51cmwpICh0Ll90ZXN0KSAodC50eXBlcy4kMS5leHRyYWN0b3IpO1xuICB9XG5cbiAgLy8jIEJpbmFyeVR5cGUgOjogU3RyaW5nIC0+IFN0cmluZyAtPiAoQW55IC0+IEJvb2xlYW4pIC0+ICh0IGEgYiAtPiBBcnJheSBhKSAtPiAodCBhIGIgLT4gQXJyYXkgYikgLT4gVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbnN0cnVjdG9yIGZvciB0eXBlcyB3aXRoIHR3byB0eXBlIHZhcmlhYmxlcyAoc3VjaCBhc1xuICAvLy4gW2BBcnJheTJgXVtdKS5cbiAgLy8uXG4gIC8vLiBUbyBkZWZpbmUgYSBiaW5hcnkgdHlwZSBgdCBhIGJgIG9uZSBtdXN0IHByb3ZpZGU6XG4gIC8vLlxuICAvLy4gICAtIHRoZSBuYW1lIG9mIGB0YCAoZXhwb3NlZCBhcyBgdC5uYW1lYCk7XG4gIC8vLlxuICAvLy4gICAtIHRoZSBkb2N1bWVudGF0aW9uIFVSTCBvZiBgdGAgKGV4cG9zZWQgYXMgYHQudXJsYCk7XG4gIC8vLlxuICAvLy4gICAtIGEgcHJlZGljYXRlIHdoaWNoIGFjY2VwdHMgYW55IEphdmFTY3JpcHQgdmFsdWUgYW5kIHJldHVybnMgYHRydWVgXG4gIC8vLiAgICAgaWYgKGFuZCBvbmx5IGlmKSB0aGUgdmFsdWUgaXMgYSBtZW1iZXIgb2YgYHQgeCB5YCBmb3Igc29tZSB0eXBlc1xuICAvLy4gICAgIGB4YCBhbmQgYHlgO1xuICAvLy5cbiAgLy8uICAgLSBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGFueSB2YWx1ZSBvZiB0eXBlIGB0IGEgYmAgYW5kIHJldHVybnMgYW4gYXJyYXlcbiAgLy8uICAgICBvZiB0aGUgdmFsdWVzIG9mIHR5cGUgYGFgIGNvbnRhaW5lZCBpbiB0aGUgYHRgIChleHBvc2VkIGFzXG4gIC8vLiAgICAgYHQudHlwZXMuJDEuZXh0cmFjdG9yYCk7XG4gIC8vLlxuICAvLy4gICAtIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW55IHZhbHVlIG9mIHR5cGUgYHQgYSBiYCBhbmQgcmV0dXJucyBhbiBhcnJheVxuICAvLy4gICAgIG9mIHRoZSB2YWx1ZXMgb2YgdHlwZSBgYmAgY29udGFpbmVkIGluIHRoZSBgdGAgKGV4cG9zZWQgYXNcbiAgLy8uICAgICBgdC50eXBlcy4kMi5leHRyYWN0b3JgKTtcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIHR5cGUgb2YgYGFgIChleHBvc2VkIGFzIGB0LnR5cGVzLiQxLnR5cGVgKTsgYW5kXG4gIC8vLlxuICAvLy4gICAtIHRoZSB0eXBlIG9mIGBiYCAoZXhwb3NlZCBhcyBgdC50eXBlcy4kMi50eXBlYCkuXG4gIC8vLlxuICAvLy4gRm9yIGV4YW1wbGU6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gY29uc3QgdHlwZSA9IHJlcXVpcmUgKCdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycycpO1xuICAvLy5cbiAgLy8uIC8vICAgIHBhaXJUeXBlSWRlbnQgOjogU3RyaW5nXG4gIC8vLiBjb25zdCBwYWlyVHlwZUlkZW50ID0gJ215LXBhY2thZ2UvUGFpcic7XG4gIC8vLlxuICAvLy4gLy8gICAgJFBhaXIgOjogVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgLy8uIGNvbnN0ICRQYWlyID0gJC5CaW5hcnlUeXBlXG4gIC8vLiAgIChwYWlyVHlwZUlkZW50KVxuICAvLy4gICAoJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI1BhaXInKVxuICAvLy4gICAoeCA9PiB0eXBlICh4KSA9PT0gcGFpclR5cGVJZGVudClcbiAgLy8uICAgKCh7ZnN0fSkgPT4gW2ZzdF0pXG4gIC8vLiAgICgoe3NuZH0pID0+IFtzbmRdKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBQYWlyVHlwZVJlcCA6OiBUeXBlUmVwIFBhaXJcbiAgLy8uIGNvbnN0IFBhaXJUeXBlUmVwID0geydAQHR5cGUnOiBwYWlyVHlwZUlkZW50fTtcbiAgLy8uXG4gIC8vLiAvLyAgICBQYWlyIDo6IGEgLT4gYiAtPiBQYWlyIGEgYlxuICAvLy4gY29uc3QgUGFpciA9XG4gIC8vLiBkZWYgKCdQYWlyJylcbiAgLy8uICAgICAoe30pXG4gIC8vLiAgICAgKFthLCBiLCAkUGFpciAoYSkgKGIpXSlcbiAgLy8uICAgICAoZnN0ID0+IHNuZCA9PiAoe1xuICAvLy4gICAgICAgICdjb25zdHJ1Y3Rvcic6IFBhaXJUeXBlUmVwLFxuICAvLy4gICAgICAgICdmc3QnOiBmc3QsXG4gIC8vLiAgICAgICAgJ3NuZCc6IHNuZCxcbiAgLy8uICAgICAgICAnQEBzaG93JzogKCkgPT4gYFBhaXIgKCR7c2hvdyAoZnN0KX0pICgke3Nob3cgKHNuZCl9KWAsXG4gIC8vLiAgICAgIH0pKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBSYW5rIDo6IFR5cGVcbiAgLy8uIGNvbnN0IFJhbmsgPSAkLk51bGxhcnlUeXBlXG4gIC8vLiAgICgnbXktcGFja2FnZS9SYW5rJylcbiAgLy8uICAgKCdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNSYW5rJylcbiAgLy8uICAgKHggPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnICYmXG4gIC8vLiAgICAgICAgIC9eKEF8MnwzfDR8NXw2fDd8OHw5fDEwfEp8UXxLKSQvLnRlc3QgKHgpKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBTdWl0IDo6IFR5cGVcbiAgLy8uIGNvbnN0IFN1aXQgPSAkLk51bGxhcnlUeXBlXG4gIC8vLiAgICgnbXktcGFja2FnZS9TdWl0JylcbiAgLy8uICAgKCdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNTdWl0JylcbiAgLy8uICAgKHggPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnICYmXG4gIC8vLiAgICAgICAgIC9eW1xcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZdJC8udGVzdCAoeCkpO1xuICAvLy5cbiAgLy8uIC8vICAgIENhcmQgOjogVHlwZVxuICAvLy4gY29uc3QgQ2FyZCA9ICRQYWlyIChSYW5rKSAoU3VpdCk7XG4gIC8vLlxuICAvLy4gLy8gICAgc2hvd0NhcmQgOjogQ2FyZCAtPiBTdHJpbmdcbiAgLy8uIGNvbnN0IHNob3dDYXJkID1cbiAgLy8uIGRlZiAoJ3Nob3dDYXJkJylcbiAgLy8uICAgICAoe30pXG4gIC8vLiAgICAgKFtDYXJkLCAkLlN0cmluZ10pXG4gIC8vLiAgICAgKGNhcmQgPT4gY2FyZC5mc3QgKyBjYXJkLnNuZCk7XG4gIC8vLlxuICAvLy4gc2hvd0NhcmQgKFBhaXIgKCdBJykgKCfimaAnKSk7XG4gIC8vLiAvLyA9PiAnQeKZoCdcbiAgLy8uXG4gIC8vLiBzaG93Q2FyZCAoUGFpciAoJ1gnKSAoJ+KZoCcpKTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiBJbnZhbGlkIHZhbHVlXG4gIC8vLiAvL1xuICAvLy4gLy8gICBzaG93Q2FyZCA6OiBQYWlyIFJhbmsgU3VpdCAtPiBTdHJpbmdcbiAgLy8uIC8vICAgICAgICAgICAgICAgICAgICBeXl5eXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgIDFcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDEpICBcIlhcIiA6OiBTdHJpbmdcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGlzIG5vdCBhIG1lbWJlciBvZiDigJhSYW5r4oCZLlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIEJpbmFyeVR5cGUobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih1cmwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihfMSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihfMikge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCQxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigkMikge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdChvdXRlciwgaW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRlciAoJygnICsgc3RyaXBOYW1lc3BhY2UgKG5hbWUpICsgJyAnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXIgKCckMScpIChzaG93ICgkMSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlciAoJyAnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXIgKCckMicpIChzaG93ICgkMikpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlciAoJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfVHlwZSAoQklOQVJZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFsnJDEnLCAnJDInXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7JDE6IHtleHRyYWN0b3I6IF8xLCB0eXBlOiAkMX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICQyOiB7ZXh0cmFjdG9yOiBfMiwgdHlwZTogJDJ9fSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB2YXIgQ2hlY2tlZEJpbmFyeVR5cGUgPVxuICBkZWYgKCdCaW5hcnlUeXBlJylcbiAgICAgICh7fSlcbiAgICAgIChbU3RyaW5nXyxcbiAgICAgICAgU3RyaW5nXyxcbiAgICAgICAgRnVuY3Rpb25fIChbQW55LCBCb29sZWFuX10pLFxuICAgICAgICBGdW5jdGlvbl8gKFtVbmNoZWNrZWQgKCd0IGEgYicpLCBBcnJheV8gKFVuY2hlY2tlZCAoJ2EnKSldKSxcbiAgICAgICAgRnVuY3Rpb25fIChbVW5jaGVja2VkICgndCBhIGInKSwgQXJyYXlfIChVbmNoZWNrZWQgKCdiJykpXSksXG4gICAgICAgIEFueUZ1bmN0aW9uXSlcbiAgICAgIChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICByZXR1cm4gZnVuY3Rpb24odXJsKSB7XG4gICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0ZXN0KSB7XG4gICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKF8xKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oXzIpIHtcbiAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZiAoc3RyaXBOYW1lc3BhY2UgKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh7fSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoW1R5cGUsIFR5cGUsIFR5cGVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChCaW5hcnlUeXBlIChuYW1lKSAodXJsKSAodGVzdCkgKF8xKSAoXzIpKTtcbiAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgfTtcbiAgICAgICAgICAgfTtcbiAgICAgICAgIH07XG4gICAgICAgfSk7XG5cbiAgLy8gIHhwcm9kIDo6IChUeXBlLCBBcnJheSBUeXBlLCBBcnJheSBUeXBlKSAtPiBBcnJheSBUeXBlXG4gIGZ1bmN0aW9uIHhwcm9kKHQsICQxcywgJDJzKSB7XG4gICAgcmV0dXJuIFouY2hhaW4gKFxuICAgICAgZnVuY3Rpb24oc3BlY2lhbGl6ZSkgeyByZXR1cm4gWi5tYXAgKHNwZWNpYWxpemUsICQycyk7IH0sXG4gICAgICBaLm1hcCAoQmluYXJ5VHlwZSAodC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHQudXJsKVxuICAgICAgICAgICAgICAgICAgICAgICAgKHQuX3Rlc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAodC50eXBlcy4kMS5leHRyYWN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAodC50eXBlcy4kMi5leHRyYWN0b3IpLFxuICAgICAgICAgICAgICQxcylcbiAgICApO1xuICB9XG5cbiAgLy8jIEVudW1UeXBlIDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gQXJyYXkgQW55IC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbnN0cnVjdG9yIGZvciBbZW51bWVyYXRlZCB0eXBlc11bXSAoc3VjaCBhcyBbYFJlZ2V4RmxhZ3NgXVtdKS5cbiAgLy8uXG4gIC8vLiBUbyBkZWZpbmUgYW4gZW51bWVyYXRlZCB0eXBlIGB0YCBvbmUgbXVzdCBwcm92aWRlOlxuICAvLy5cbiAgLy8uICAgLSB0aGUgbmFtZSBvZiBgdGAgKGV4cG9zZWQgYXMgYHQubmFtZWApO1xuICAvLy5cbiAgLy8uICAgLSB0aGUgZG9jdW1lbnRhdGlvbiBVUkwgb2YgYHRgIChleHBvc2VkIGFzIGB0LnVybGApOyBhbmRcbiAgLy8uXG4gIC8vLiAgIC0gYW4gYXJyYXkgb2YgZGlzdGluY3QgdmFsdWVzLlxuICAvLy5cbiAgLy8uIEZvciBleGFtcGxlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIC8vICAgIERlbm9taW5hdGlvbiA6OiBUeXBlXG4gIC8vLiBjb25zdCBEZW5vbWluYXRpb24gPSAkLkVudW1UeXBlXG4gIC8vLiAgICgnbXktcGFja2FnZS9EZW5vbWluYXRpb24nKVxuICAvLy4gICAoJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI0Rlbm9taW5hdGlvbicpXG4gIC8vLiAgIChbMTAsIDIwLCA1MCwgMTAwLCAyMDBdKTtcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBFbnVtVHlwZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVybCkge1xuICAgICAgcmV0dXJuIGNvbXBvc2UgKE51bGxhcnlUeXBlIChuYW1lKSAodXJsKSwgbWVtYmVyT2YpO1xuICAgIH07XG4gIH1cblxuICB2YXIgQ2hlY2tlZEVudW1UeXBlID1cbiAgZGVmICgnRW51bVR5cGUnKVxuICAgICAgKHt9KVxuICAgICAgKFtTdHJpbmdfLCBTdHJpbmdfLCBBcnJheV8gKEFueSksIFR5cGVdKVxuICAgICAgKEVudW1UeXBlKTtcblxuICAvLyMgUmVjb3JkVHlwZSA6OiBTdHJNYXAgVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gYFJlY29yZFR5cGVgIGlzIHVzZWQgdG8gY29uc3RydWN0IHJlY29yZCB0eXBlcy4gVGhlIHR5cGUgZGVmaW5pdGlvblxuICAvLy4gc3BlY2lmaWVzIHRoZSBuYW1lIGFuZCB0eXBlIG9mIGVhY2ggcmVxdWlyZWQgZmllbGQuIEEgZmllbGQgaXMgYW5cbiAgLy8uIGVudW1lcmFibGUgcHJvcGVydHkgKGVpdGhlciBhbiBvd24gcHJvcGVydHkgb3IgYW4gaW5oZXJpdGVkIHByb3BlcnR5KS5cbiAgLy8uXG4gIC8vLiBUbyBkZWZpbmUgYSByZWNvcmQgdHlwZSBvbmUgbXVzdCBwcm92aWRlOlxuICAvLy5cbiAgLy8uICAgLSBhbiBvYmplY3QgbWFwcGluZyBmaWVsZCBuYW1lIHRvIHR5cGUuXG4gIC8vLlxuICAvLy4gRm9yIGV4YW1wbGU6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gLy8gICAgUG9pbnQgOjogVHlwZVxuICAvLy4gY29uc3QgUG9pbnQgPSAkLlJlY29yZFR5cGUgKHt4OiAkLkZpbml0ZU51bWJlciwgeTogJC5GaW5pdGVOdW1iZXJ9KTtcbiAgLy8uXG4gIC8vLiAvLyAgICBkaXN0IDo6IFBvaW50IC0+IFBvaW50IC0+IEZpbml0ZU51bWJlclxuICAvLy4gY29uc3QgZGlzdCA9XG4gIC8vLiBkZWYgKCdkaXN0JylcbiAgLy8uICAgICAoe30pXG4gIC8vLiAgICAgKFtQb2ludCwgUG9pbnQsICQuRmluaXRlTnVtYmVyXSlcbiAgLy8uICAgICAocCA9PiBxID0+IE1hdGguc3FydCAoTWF0aC5wb3cgKHAueCAtIHEueCwgMikgK1xuICAvLy4gICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyAocC55IC0gcS55LCAyKSkpO1xuICAvLy5cbiAgLy8uIGRpc3QgKHt4OiAwLCB5OiAwfSkgKHt4OiAzLCB5OiA0fSk7XG4gIC8vLiAvLyA9PiA1XG4gIC8vLlxuICAvLy4gZGlzdCAoe3g6IDAsIHk6IDB9KSAoe3g6IDMsIHk6IDQsIGNvbG9yOiAncmVkJ30pO1xuICAvLy4gLy8gPT4gNVxuICAvLy5cbiAgLy8uIGRpc3QgKHt4OiAwLCB5OiAwfSkgKHt4OiBOYU4sIHk6IE5hTn0pO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIGRpc3QgOjogeyB4IDo6IEZpbml0ZU51bWJlciwgeSA6OiBGaW5pdGVOdW1iZXIgfSAtPiB7IHggOjogRmluaXRlTnVtYmVyLCB5IDo6IEZpbml0ZU51bWJlciB9IC0+IEZpbml0ZU51bWJlclxuICAvLy4gLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXlxuICAvLy4gLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAvLy4gLy9cbiAgLy8uIC8vICAgMSkgIE5hTiA6OiBOdW1iZXJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGlzIG5vdCBhIG1lbWJlciBvZiDigJhGaW5pdGVOdW1iZXLigJkuXG4gIC8vLlxuICAvLy4gZGlzdCAoMCk7XG4gIC8vLiAvLyAhIFR5cGVFcnJvcjogSW52YWxpZCB2YWx1ZVxuICAvLy4gLy9cbiAgLy8uIC8vICAgZGlzdCA6OiB7IHggOjogRmluaXRlTnVtYmVyLCB5IDo6IEZpbml0ZU51bWJlciB9IC0+IHsgeCA6OiBGaW5pdGVOdW1iZXIsIHkgOjogRmluaXRlTnVtYmVyIH0gLT4gRmluaXRlTnVtYmVyXG4gIC8vLiAvLyAgICAgICAgICAgXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxuICAvLy4gLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAgMCA6OiBOdW1iZXJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIFRoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGlzIG5vdCBhIG1lbWJlciBvZiDigJh7IHggOjogRmluaXRlTnVtYmVyLCB5IDo6IEZpbml0ZU51bWJlciB94oCZLlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFJlY29yZFR5cGUoZmllbGRzKSB7XG4gICAgdmFyIGtleXMgPSBzb3J0ZWRLZXlzIChmaWVsZHMpO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0KG91dGVyLCBpbm5lcikge1xuICAgICAgaWYgKGlzRW1wdHkgKGtleXMpKSByZXR1cm4gb3V0ZXIgKCd7fScpO1xuICAgICAgdmFyIHJlcHJzID0gWi5tYXAgKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdmFyIHQgPSBmaWVsZHNba107XG4gICAgICAgIHJldHVybiBvdXRlciAoJyAnKSArXG4gICAgICAgICAgICAgICBvdXRlciAoL14oPyFcXGQpWyRcXHddKyQvLnRlc3QgKGspID8gayA6IHNob3cgKGspKSArXG4gICAgICAgICAgICAgICBvdXRlciAoJyA6OiAnKSArXG4gICAgICAgICAgICAgICB1bmxlc3MgKHQudHlwZSA9PT0gUkVDT1JEIHx8IGlzRW1wdHkgKHQua2V5cyksXG4gICAgICAgICAgICAgICAgICAgICAgIHN0cmlwT3V0ZXJtb3N0UGFyZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICBpbm5lciAoaykgKHNob3cgKHQpKSk7XG4gICAgICB9LCBrZXlzKTtcbiAgICAgIHJldHVybiB3cmFwIChvdXRlciAoJ3snKSkgKG91dGVyICgnIH0nKSkgKGpvaW5XaXRoIChvdXRlciAoJywnKSwgcmVwcnMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0ZXN0KHgpIHtcbiAgICAgIHZhciBtaXNzaW5nID0ge307XG4gICAgICBrZXlzLmZvckVhY2ggKGZ1bmN0aW9uKGspIHsgbWlzc2luZ1trXSA9IGs7IH0pO1xuICAgICAgZm9yICh2YXIgayBpbiB4KSBkZWxldGUgbWlzc2luZ1trXTtcbiAgICAgIHJldHVybiBpc0VtcHR5IChPYmplY3Qua2V5cyAobWlzc2luZykpO1xuICAgIH1cblxuICAgIHZhciAkdHlwZXMgPSB7fTtcbiAgICBrZXlzLmZvckVhY2ggKGZ1bmN0aW9uKGspIHtcbiAgICAgICR0eXBlc1trXSA9IHtleHRyYWN0b3I6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFt4W2tdXTsgfSwgdHlwZTogZmllbGRzW2tdfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgX1R5cGUgKFJFQ09SRCwgJycsICcnLCBmb3JtYXQsIHRlc3QsIGtleXMsICR0eXBlcyk7XG4gIH1cblxuICB2YXIgQ2hlY2tlZFJlY29yZFR5cGUgPVxuICBkZWYgKCdSZWNvcmRUeXBlJykgKHt9KSAoW1N0ck1hcCAoVHlwZSksIFR5cGVdKSAoUmVjb3JkVHlwZSk7XG5cbiAgLy8jIFR5cGVWYXJpYWJsZSA6OiBTdHJpbmcgLT4gVHlwZVxuICAvLy5cbiAgLy8uIFBvbHltb3JwaGlzbSBpcyBwb3dlcmZ1bC4gTm90IGJlaW5nIGFibGUgdG8gZGVmaW5lIGEgZnVuY3Rpb24gZm9yXG4gIC8vLiBhbGwgdHlwZXMgd291bGQgYmUgdmVyeSBsaW1pdGluZyBpbmRlZWQ6IG9uZSBjb3VsZG4ndCBldmVuIGRlZmluZSB0aGVcbiAgLy8uIGlkZW50aXR5IGZ1bmN0aW9uIVxuICAvLy5cbiAgLy8uIEJlZm9yZSBkZWZpbmluZyBhIHBvbHltb3JwaGljIGZ1bmN0aW9uIG9uZSBtdXN0IGRlZmluZSBvbmUgb3IgbW9yZSB0eXBlXG4gIC8vLiB2YXJpYWJsZXM6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gY29uc3QgYSA9ICQuVHlwZVZhcmlhYmxlICgnYScpO1xuICAvLy4gY29uc3QgYiA9ICQuVHlwZVZhcmlhYmxlICgnYicpO1xuICAvLy5cbiAgLy8uIC8vICAgIGlkIDo6IGEgLT4gYVxuICAvLy4gY29uc3QgaWQgPSBkZWYgKCdpZCcpICh7fSkgKFthLCBhXSkgKHggPT4geCk7XG4gIC8vLlxuICAvLy4gaWQgKDQyKTtcbiAgLy8uIC8vID0+IDQyXG4gIC8vLlxuICAvLy4gaWQgKG51bGwpO1xuICAvLy4gLy8gPT4gbnVsbFxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gVGhlIHNhbWUgdHlwZSB2YXJpYWJsZSBtYXkgYmUgdXNlZCBpbiBtdWx0aXBsZSBwb3NpdGlvbnMsIGNyZWF0aW5nIGFcbiAgLy8uIGNvbnN0cmFpbnQ6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gLy8gICAgY21wIDo6IGEgLT4gYSAtPiBOdW1iZXJcbiAgLy8uIGNvbnN0IGNtcCA9XG4gIC8vLiBkZWYgKCdjbXAnKVxuICAvLy4gICAgICh7fSlcbiAgLy8uICAgICAoW2EsIGEsICQuTnVtYmVyXSlcbiAgLy8uICAgICAoeCA9PiB5ID0+IHggPCB5ID8gLTEgOiB4ID4geSA/IDEgOiAwKTtcbiAgLy8uXG4gIC8vLiBjbXAgKDQyKSAoNDIpO1xuICAvLy4gLy8gPT4gMFxuICAvLy5cbiAgLy8uIGNtcCAoJ2EnKSAoJ3onKTtcbiAgLy8uIC8vID0+IC0xXG4gIC8vLlxuICAvLy4gY21wICgneicpICgnYScpO1xuICAvLy4gLy8gPT4gMVxuICAvLy5cbiAgLy8uIGNtcCAoMCkgKCcxJyk7XG4gIC8vLiAvLyAhIFR5cGVFcnJvcjogVHlwZS12YXJpYWJsZSBjb25zdHJhaW50IHZpb2xhdGlvblxuICAvLy4gLy9cbiAgLy8uIC8vICAgY21wIDo6IGEgLT4gYSAtPiBOdW1iZXJcbiAgLy8uIC8vICAgICAgICAgIF4gICAgXlxuICAvLy4gLy8gICAgICAgICAgMSAgICAyXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAgMCA6OiBOdW1iZXJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDIpICBcIjFcIiA6OiBTdHJpbmdcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIFNpbmNlIHRoZXJlIGlzIG5vIHR5cGUgb2Ygd2hpY2ggYWxsIHRoZSBhYm92ZSB2YWx1ZXMgYXJlIG1lbWJlcnMsIHRoZSB0eXBlLXZhcmlhYmxlIGNvbnN0cmFpbnQgaGFzIGJlZW4gdmlvbGF0ZWQuXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gVHlwZVZhcmlhYmxlKG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IF9UeXBlIChWQVJJQUJMRSwgbmFtZSwgJycsIGFsd2F5czIgKG5hbWUpLCBLICh0cnVlKSwgW10sIHt9KTtcbiAgfVxuXG4gIHZhciBDaGVja2VkVHlwZVZhcmlhYmxlID1cbiAgZGVmICgnVHlwZVZhcmlhYmxlJykgKHt9KSAoW1N0cmluZ18sIFR5cGVdKSAoVHlwZVZhcmlhYmxlKTtcblxuICAvLyMgVW5hcnlUeXBlVmFyaWFibGUgOjogU3RyaW5nIC0+IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbWJpbmVzIFtgVW5hcnlUeXBlYF1bXSBhbmQgW2BUeXBlVmFyaWFibGVgXVtdLlxuICAvLy5cbiAgLy8uIFRvIGRlZmluZSBhIHVuYXJ5IHR5cGUgdmFyaWFibGUgYHQgYWAgb25lIG11c3QgcHJvdmlkZTpcbiAgLy8uXG4gIC8vLiAgIC0gYSBuYW1lIChjb252ZW50aW9uYWxseSBtYXRjaGluZyBgXlthLXpdJGApOyBhbmRcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIHR5cGUgb2YgYGFgIChleHBvc2VkIGFzIGB0LnR5cGVzLiQxLnR5cGVgKS5cbiAgLy8uXG4gIC8vLiBDb25zaWRlciB0aGUgdHlwZSBvZiBhIGdlbmVyYWxpemVkIGBtYXBgOlxuICAvLy5cbiAgLy8uIGBgYGhhc2tlbGxcbiAgLy8uIG1hcCA6OiBGdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gYGZgIGlzIGEgdW5hcnkgdHlwZSB2YXJpYWJsZS4gV2l0aCB0d28gKG51bGxhcnkpIHR5cGUgdmFyaWFibGVzLCBvbmVcbiAgLy8uIHVuYXJ5IHR5cGUgdmFyaWFibGUsIGFuZCBvbmUgW3R5cGUgY2xhc3NdW10gaXQncyBwb3NzaWJsZSB0byBkZWZpbmUgYVxuICAvLy4gZnVsbHkgcG9seW1vcnBoaWMgYG1hcGAgZnVuY3Rpb246XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gY29uc3QgJCA9IHJlcXVpcmUgKCdzYW5jdHVhcnktZGVmJyk7XG4gIC8vLiBjb25zdCBaID0gcmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnKTtcbiAgLy8uXG4gIC8vLiBjb25zdCBhID0gJC5UeXBlVmFyaWFibGUgKCdhJyk7XG4gIC8vLiBjb25zdCBiID0gJC5UeXBlVmFyaWFibGUgKCdiJyk7XG4gIC8vLiBjb25zdCBmID0gJC5VbmFyeVR5cGVWYXJpYWJsZSAoJ2YnKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBtYXAgOjogRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgLy8uIGNvbnN0IG1hcCA9XG4gIC8vLiBkZWYgKCdtYXAnKVxuICAvLy4gICAgICh7ZjogW1ouRnVuY3Rvcl19KVxuICAvLy4gICAgIChbJC5GdW5jdGlvbiAoW2EsIGJdKSwgZiAoYSksIGYgKGIpXSlcbiAgLy8uICAgICAoZiA9PiBmdW5jdG9yID0+IFoubWFwIChmLCBmdW5jdG9yKSk7XG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBXaGVyZWFzIGEgcmVndWxhciB0eXBlIHZhcmlhYmxlIGlzIGZ1bGx5IHJlc29sdmVkIChgYWAgbWlnaHQgYmVjb21lXG4gIC8vLiBgQXJyYXkgKEFycmF5IFN0cmluZylgLCBmb3IgZXhhbXBsZSksIGEgdW5hcnkgdHlwZSB2YXJpYWJsZSBkZWZlcnMgdG9cbiAgLy8uIGl0cyB0eXBlIGFyZ3VtZW50LCB3aGljaCBtYXkgaXRzZWxmIGJlIGEgdHlwZSB2YXJpYWJsZS4gVGhlIHR5cGUgYXJndW1lbnRcbiAgLy8uIGNvcnJlc3BvbmRzIHRvIHRoZSB0eXBlIGFyZ3VtZW50IG9mIGEgdW5hcnkgdHlwZSBvciB0aGUgKnNlY29uZCogdHlwZVxuICAvLy4gYXJndW1lbnQgb2YgYSBiaW5hcnkgdHlwZS4gVGhlIHNlY29uZCB0eXBlIGFyZ3VtZW50IG9mIGBNYXAgayB2YCwgZm9yXG4gIC8vLiBleGFtcGxlLCBpcyBgdmAuIE9uZSBjb3VsZCByZXBsYWNlIGBGdW5jdG9yID0+IGZgIHdpdGggYE1hcCBrYCBvciB3aXRoXG4gIC8vLiBgTWFwIEludGVnZXJgLCBidXQgbm90IHdpdGggYE1hcGAuXG4gIC8vLlxuICAvLy4gVGhpcyBzaGFsbG93IGluc3BlY3Rpb24gbWFrZXMgaXQgcG9zc2libGUgdG8gY29uc3RyYWluIGEgdmFsdWUncyBcIm91dGVyXCJcbiAgLy8uIGFuZCBcImlubmVyXCIgdHlwZXMgaW5kZXBlbmRlbnRseS5cbiAgZnVuY3Rpb24gVW5hcnlUeXBlVmFyaWFibGUobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigkMSkge1xuICAgICAgZnVuY3Rpb24gZm9ybWF0KG91dGVyLCBpbm5lcikge1xuICAgICAgICByZXR1cm4gb3V0ZXIgKCcoJyArIG5hbWUgKyAnICcpICtcbiAgICAgICAgICAgICAgIGlubmVyICgnJDEnKSAoc2hvdyAoJDEpKSArXG4gICAgICAgICAgICAgICBvdXRlciAoJyknKTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlcyA9IHskMToge2V4dHJhY3RvcjogSyAoW10pLCB0eXBlOiAkMX19O1xuICAgICAgcmV0dXJuIG5ldyBfVHlwZSAoVkFSSUFCTEUsIG5hbWUsICcnLCBmb3JtYXQsIEsgKHRydWUpLCBbJyQxJ10sIHR5cGVzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIENoZWNrZWRVbmFyeVR5cGVWYXJpYWJsZSA9XG4gIGRlZiAoJ1VuYXJ5VHlwZVZhcmlhYmxlJylcbiAgICAgICh7fSlcbiAgICAgIChbU3RyaW5nXywgQW55RnVuY3Rpb25dKVxuICAgICAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgIHJldHVybiBkZWYgKG5hbWUpICh7fSkgKFtUeXBlLCBUeXBlXSkgKFVuYXJ5VHlwZVZhcmlhYmxlIChuYW1lKSk7XG4gICAgICAgfSk7XG5cbiAgLy8jIEJpbmFyeVR5cGVWYXJpYWJsZSA6OiBTdHJpbmcgLT4gVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBDb21iaW5lcyBbYEJpbmFyeVR5cGVgXVtdIGFuZCBbYFR5cGVWYXJpYWJsZWBdW10uXG4gIC8vLlxuICAvLy4gVG8gZGVmaW5lIGEgYmluYXJ5IHR5cGUgdmFyaWFibGUgYHQgYSBiYCBvbmUgbXVzdCBwcm92aWRlOlxuICAvLy5cbiAgLy8uICAgLSBhIG5hbWUgKGNvbnZlbnRpb25hbGx5IG1hdGNoaW5nIGBeW2Etel0kYCk7XG4gIC8vLlxuICAvLy4gICAtIHRoZSB0eXBlIG9mIGBhYCAoZXhwb3NlZCBhcyBgdC50eXBlcy4kMS50eXBlYCk7IGFuZFxuICAvLy5cbiAgLy8uICAgLSB0aGUgdHlwZSBvZiBgYmAgKGV4cG9zZWQgYXMgYHQudHlwZXMuJDIudHlwZWApLlxuICAvLy5cbiAgLy8uIFRoZSBtb3JlIGRldGFpbGVkIGV4cGxhbmF0aW9uIG9mIFtgVW5hcnlUeXBlVmFyaWFibGVgXVtdIGFsc28gYXBwbGllcyB0b1xuICAvLy4gYEJpbmFyeVR5cGVWYXJpYWJsZWAuXG4gIGZ1bmN0aW9uIEJpbmFyeVR5cGVWYXJpYWJsZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCQxKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oJDIpIHtcbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0KG91dGVyLCBpbm5lcikge1xuICAgICAgICAgIHJldHVybiBvdXRlciAoJygnICsgbmFtZSArICcgJykgK1xuICAgICAgICAgICAgICAgICBpbm5lciAoJyQxJykgKHNob3cgKCQxKSkgK1xuICAgICAgICAgICAgICAgICBvdXRlciAoJyAnKSArXG4gICAgICAgICAgICAgICAgIGlubmVyICgnJDInKSAoc2hvdyAoJDIpKSArXG4gICAgICAgICAgICAgICAgIG91dGVyICgnKScpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlzID0gWyckMScsICckMiddO1xuICAgICAgICB2YXIgdHlwZXMgPSB7JDE6IHtleHRyYWN0b3I6IEsgKFtdKSwgdHlwZTogJDF9LFxuICAgICAgICAgICAgICAgICAgICAgJDI6IHtleHRyYWN0b3I6IEsgKFtdKSwgdHlwZTogJDJ9fTtcbiAgICAgICAgcmV0dXJuIG5ldyBfVHlwZSAoVkFSSUFCTEUsIG5hbWUsICcnLCBmb3JtYXQsIEsgKHRydWUpLCBrZXlzLCB0eXBlcyk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB2YXIgQ2hlY2tlZEJpbmFyeVR5cGVWYXJpYWJsZSA9XG4gIGRlZiAoJ0JpbmFyeVR5cGVWYXJpYWJsZScpXG4gICAgICAoe30pXG4gICAgICAoW1N0cmluZ18sIEFueUZ1bmN0aW9uXSlcbiAgICAgIChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICByZXR1cm4gZGVmIChuYW1lKVxuICAgICAgICAgICAgICAgICAgICAoe30pXG4gICAgICAgICAgICAgICAgICAgIChbVHlwZSwgVHlwZSwgVHlwZV0pXG4gICAgICAgICAgICAgICAgICAgIChCaW5hcnlUeXBlVmFyaWFibGUgKG5hbWUpKTtcbiAgICAgICB9KTtcblxuICAvLyMgVGh1bmsgOjogVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gYCQuVGh1bmsgKFQpYCBpcyBzaG9ydGhhbmQgZm9yIGAkLkZ1bmN0aW9uIChbVF0pYCwgdGhlIHR5cGUgY29tcHJpc2luZ1xuICAvLy4gZXZlcnkgbnVsbGFyeSBmdW5jdGlvbiAodGh1bmspIHdoaWNoIHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIGBUYC5cbiAgdmFyIFRodW5rID1cbiAgZGVmICgnVGh1bmsnKVxuICAgICAgKHt9KVxuICAgICAgKFtUeXBlLCBUeXBlXSlcbiAgICAgIChmdW5jdGlvbih0KSB7IHJldHVybiBGdW5jdGlvbl8gKFt0XSk7IH0pO1xuXG4gIC8vIyBQcmVkaWNhdGUgOjogVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gYCQuUHJlZGljYXRlIChUKWAgaXMgc2hvcnRoYW5kIGZvciBgJC5GdW5jdGlvbiAoW1QsICQuQm9vbGVhbl0pYCwgdGhlXG4gIC8vLiB0eXBlIGNvbXByaXNpbmcgZXZlcnkgcHJlZGljYXRlIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGEgdmFsdWUgb2YgdHlwZSBgVGAuXG4gIHZhciBQcmVkaWNhdGUgPVxuICBkZWYgKCdQcmVkaWNhdGUnKVxuICAgICAgKHt9KVxuICAgICAgKFtUeXBlLCBUeXBlXSlcbiAgICAgIChmdW5jdGlvbih0KSB7IHJldHVybiBGdW5jdGlvbl8gKFt0LCBCb29sZWFuX10pOyB9KTtcblxuICAvLy4gIyMjIFR5cGUgY2xhc3Nlc1xuICAvLy5cbiAgLy8uIGBjb25jYXRTYCwgZGVmaW5lZCBlYXJsaWVyLCBpcyBhIGZ1bmN0aW9uIHdoaWNoIGNvbmNhdGVuYXRlcyB0d28gc3RyaW5ncy5cbiAgLy8uIFRoaXMgaXMgb3Zlcmx5IHJlc3RyaWN0aXZlLCBzaW5jZSBvdGhlciB0eXBlcyBzdXBwb3J0IGNvbmNhdGVuYXRpb25cbiAgLy8uIChBcnJheSwgZm9yIGV4YW1wbGUpLlxuICAvLy5cbiAgLy8uIE9uZSBjb3VsZCB1c2UgYSB0eXBlIHZhcmlhYmxlIHRvIGRlZmluZSBhIHBvbHltb3JwaGljIFwiY29uY2F0XCIgZnVuY3Rpb246XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gLy8gICAgX2NvbmNhdCA6OiBhIC0+IGEgLT4gYVxuICAvLy4gY29uc3QgX2NvbmNhdCA9XG4gIC8vLiBkZWYgKCdfY29uY2F0JylcbiAgLy8uICAgICAoe30pXG4gIC8vLiAgICAgKFthLCBhLCBhXSlcbiAgLy8uICAgICAoeCA9PiB5ID0+IHguY29uY2F0ICh5KSk7XG4gIC8vLlxuICAvLy4gX2NvbmNhdCAoJ2ZpenonKSAoJ2J1enonKTtcbiAgLy8uIC8vID0+ICdmaXp6YnV6eidcbiAgLy8uXG4gIC8vLiBfY29uY2F0IChbMSwgMl0pIChbMywgNF0pO1xuICAvLy4gLy8gPT4gWzEsIDIsIDMsIDRdXG4gIC8vLlxuICAvLy4gX2NvbmNhdCAoWzEsIDJdKSAoJ2J1enonKTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiBUeXBlLXZhcmlhYmxlIGNvbnN0cmFpbnQgdmlvbGF0aW9uXG4gIC8vLiAvL1xuICAvLy4gLy8gICBfY29uY2F0IDo6IGEgLT4gYSAtPiBhXG4gIC8vLiAvLyAgICAgICAgICAgICAgXiAgICBeXG4gIC8vLiAvLyAgICAgICAgICAgICAgMSAgICAyXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAgWzEsIDJdIDo6IEFycmF5IE51bWJlclxuICAvLy4gLy9cbiAgLy8uIC8vICAgMikgIFwiYnV6elwiIDo6IFN0cmluZ1xuICAvLy4gLy9cbiAgLy8uIC8vICAgU2luY2UgdGhlcmUgaXMgbm8gdHlwZSBvZiB3aGljaCBhbGwgdGhlIGFib3ZlIHZhbHVlcyBhcmUgbWVtYmVycywgdGhlIHR5cGUtdmFyaWFibGUgY29uc3RyYWludCBoYXMgYmVlbiB2aW9sYXRlZC5cbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFRoZSB0eXBlIG9mIGBfY29uY2F0YCBpcyBtaXNsZWFkaW5nOiBpdCBzdWdnZXN0cyB0aGF0IGl0IGNhbiBvcGVyYXRlIG9uXG4gIC8vLiBhbnkgdHdvIHZhbHVlcyBvZiAqYW55KiBvbmUgdHlwZS4gSW4gZmFjdCB0aGVyZSdzIGFuIGltcGxpY2l0IGNvbnN0cmFpbnQsXG4gIC8vLiBzaW5jZSB0aGUgdHlwZSBtdXN0IHN1cHBvcnQgY29uY2F0ZW5hdGlvbiAoaW4gW21hdGhlbWF0aWNhbF1bc2VtaWdyb3VwXVxuICAvLy4gdGVybXMsIHRoZSB0eXBlIG11c3QgaGF2ZSBhIFtzZW1pZ3JvdXBdW0ZMOlNlbWlncm91cF0pLiBWaW9sYXRpbmcgdGhpc1xuICAvLy4gaW1wbGljaXQgY29uc3RyYWludCByZXN1bHRzIGluIGEgcnVuLXRpbWUgZXJyb3IgaW4gdGhlIGltcGxlbWVudGF0aW9uOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIF9jb25jYXQgKG51bGwpIChudWxsKTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiBDYW5ub3QgcmVhZCBwcm9wZXJ0eSAnY29uY2F0JyBvZiBudWxsXG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBUaGUgc29sdXRpb24gaXMgdG8gY29uc3RyYWluIGBhYCBieSBmaXJzdCBkZWZpbmluZyBhIFtgVHlwZUNsYXNzYF1bXVxuICAvLy4gdmFsdWUsIHRoZW4gc3BlY2lmeWluZyB0aGUgY29uc3RyYWludCBpbiB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgXCJjb25jYXRcIlxuICAvLy4gZnVuY3Rpb246XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gY29uc3QgWiA9IHJlcXVpcmUgKCdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJyk7XG4gIC8vLlxuICAvLy4gLy8gICAgU2VtaWdyb3VwIDo6IFR5cGVDbGFzc1xuICAvLy4gY29uc3QgU2VtaWdyb3VwID0gWi5UeXBlQ2xhc3MgKFxuICAvLy4gICAnbXktcGFja2FnZS9TZW1pZ3JvdXAnLFxuICAvLy4gICAnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjU2VtaWdyb3VwJyxcbiAgLy8uICAgW10sXG4gIC8vLiAgIHggPT4geCAhPSBudWxsICYmIHR5cGVvZiB4LmNvbmNhdCA9PT0gJ2Z1bmN0aW9uJ1xuICAvLy4gKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBjb25jYXQgOjogU2VtaWdyb3VwIGEgPT4gYSAtPiBhIC0+IGFcbiAgLy8uIGNvbnN0IGNvbmNhdCA9XG4gIC8vLiBkZWYgKCdjb25jYXQnKVxuICAvLy4gICAgICh7YTogW1NlbWlncm91cF19KVxuICAvLy4gICAgIChbYSwgYSwgYV0pXG4gIC8vLiAgICAgKHggPT4geSA9PiB4LmNvbmNhdCAoeSkpO1xuICAvLy5cbiAgLy8uIGNvbmNhdCAoWzEsIDJdKSAoWzMsIDRdKTtcbiAgLy8uIC8vID0+IFsxLCAyLCAzLCA0XVxuICAvLy5cbiAgLy8uIGNvbmNhdCAobnVsbCkgKG51bGwpO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IFR5cGUtY2xhc3MgY29uc3RyYWludCB2aW9sYXRpb25cbiAgLy8uIC8vXG4gIC8vLiAvLyAgIGNvbmNhdCA6OiBTZW1pZ3JvdXAgYSA9PiBhIC0+IGEgLT4gYVxuICAvLy4gLy8gICAgICAgICAgICAgXl5eXl5eXl5eXl4gICAgXlxuICAvLy4gLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAvLy4gLy9cbiAgLy8uIC8vICAgMSkgIG51bGwgOjogTnVsbFxuICAvLy4gLy9cbiAgLy8uIC8vICAg4oCYY29uY2F04oCZIHJlcXVpcmVzIOKAmGHigJkgdG8gc2F0aXNmeSB0aGUgU2VtaWdyb3VwIHR5cGUtY2xhc3MgY29uc3RyYWludDsgdGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgZG9lcyBub3QuXG4gIC8vLiAvL1xuICAvLy4gLy8gICBTZWUgaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjU2VtaWdyb3VwIGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbXktcGFja2FnZS9TZW1pZ3JvdXAgdHlwZSBjbGFzcy5cbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIE11bHRpcGxlIGNvbnN0cmFpbnRzIG1heSBiZSBwbGFjZWQgb24gYSB0eXBlIHZhcmlhYmxlIGJ5IGluY2x1ZGluZ1xuICAvLy4gbXVsdGlwbGUgYFR5cGVDbGFzc2AgdmFsdWVzIGluIHRoZSBhcnJheSAoZS5nLiBge2E6IFtGb28sIEJhciwgQmF6XX1gKS5cblxuICAvLyAgaW52YWxpZEFyZ3VtZW50c0NvdW50IDo6IChUeXBlSW5mbywgSW50ZWdlciwgSW50ZWdlciwgQXJyYXkgQW55KSAtPiBFcnJvclxuICAvL1xuICAvLyAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluIGBjdXJyeWAgd2hlbiBhIGZ1bmN0aW9uIGRlZmluZWQgdmlhIGBkZWZgXG4gIC8vICBpcyBhcHBsaWVkIHRvIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgZnVuY3Rpb24gaW52YWxpZEFyZ3VtZW50c0NvdW50KHR5cGVJbmZvLCBpbmRleCwgbnVtQXJnc0V4cGVjdGVkLCBhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IgKHRyaW1UcmFpbGluZ1NwYWNlcyAoXG4gICAgICBxICh0eXBlSW5mby5uYW1lKSArICcgYXBwbGllZCB0byB0aGUgd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1xcblxcbicgK1xuICAgICAgdW5kZXJsaW5lIChcbiAgICAgICAgdHlwZUluZm8sXG4gICAgICAgIEsgKEsgKF8pKSxcbiAgICAgICAgZnVuY3Rpb24oaW5kZXhfKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBLIChLIChpbmRleF8gPT09IGluZGV4ID8gZiA6IF8pKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICApICsgJ1xcbicgK1xuICAgICAgJ0V4cGVjdGVkICcgKyBudW1BcmdzIChudW1BcmdzRXhwZWN0ZWQpICtcbiAgICAgICcgYnV0IHJlY2VpdmVkICcgKyBudW1BcmdzIChhcmdzLmxlbmd0aCkgK1xuICAgICAgdG9NYXJrZG93bkxpc3QgKCcuXFxuJywgJzpcXG5cXG4nLCBzaG93LCBhcmdzKVxuICAgICkpO1xuICB9XG5cbiAgLy8gIGNvbnN0cmFpbnRzUmVwciA6OiAuLi4gLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIGNvbnN0cmFpbnRzUmVwcihcbiAgICBjb25zdHJhaW50cywgICAgLy8gOjogU3RyTWFwIChBcnJheSBUeXBlQ2xhc3MpXG4gICAgb3V0ZXIsICAgICAgICAgIC8vIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgICBpbm5lciAgICAgICAgICAgLy8gOjogU3RyaW5nIC0+IFR5cGVDbGFzcyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICkge1xuICAgIHZhciAkcmVwcnMgPSBbXTtcbiAgICAoc29ydGVkS2V5cyAoY29uc3RyYWludHMpKS5mb3JFYWNoIChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgZiA9IGlubmVyIChrKTtcbiAgICAgIGNvbnN0cmFpbnRzW2tdLmZvckVhY2ggKGZ1bmN0aW9uKHR5cGVDbGFzcykge1xuICAgICAgICAkcmVwcnMucHVzaCAoXG4gICAgICAgICAgZiAodHlwZUNsYXNzKSAoc3RyaXBOYW1lc3BhY2UgKHR5cGVDbGFzcy5uYW1lKSArICcgJyArIGspXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gd2hlbiAoJHJlcHJzLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMgKyBvdXRlciAoJyA9PiAnKTsgfSxcbiAgICAgICAgICAgICAgICAgd2hlbiAoJHJlcHJzLmxlbmd0aCA+IDEsXG4gICAgICAgICAgICAgICAgICAgICAgIHdyYXAgKG91dGVyICgnKCcpKSAob3V0ZXIgKCcpJykpLFxuICAgICAgICAgICAgICAgICAgICAgICBqb2luV2l0aCAob3V0ZXIgKCcsICcpLCAkcmVwcnMpKSk7XG4gIH1cblxuICAvLyAgbGFiZWwgOjogU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gbGFiZWwobGFiZWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIGRlbHRhID0gcy5sZW5ndGggLSBsYWJlbC5sZW5ndGg7XG4gICAgICByZXR1cm4gc3RyUmVwZWF0ICgnICcsIE1hdGguZmxvb3IgKGRlbHRhIC8gMikpICsgbGFiZWwgK1xuICAgICAgICAgICAgIHN0clJlcGVhdCAoJyAnLCBNYXRoLmNlaWwgKGRlbHRhIC8gMikpO1xuICAgIH07XG4gIH1cblxuICAvLyAgdHlwZVZhck5hbWVzIDo6IFR5cGUgLT4gQXJyYXkgU3RyaW5nXG4gIGZ1bmN0aW9uIHR5cGVWYXJOYW1lcyh0KSB7XG4gICAgcmV0dXJuIFouY29uY2F0IChcbiAgICAgIHQudHlwZSA9PT0gVkFSSUFCTEUgPyBbdC5uYW1lXSA6IFtdLFxuICAgICAgWi5jaGFpbiAoZnVuY3Rpb24oaykgeyByZXR1cm4gdHlwZVZhck5hbWVzICh0LnR5cGVzW2tdLnR5cGUpOyB9LCB0LmtleXMpXG4gICAgKTtcbiAgfVxuXG4gIC8vICBzaG93VHlwZVdpdGggOjogVHlwZUluZm8gLT4gVHlwZSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gc2hvd1R5cGVXaXRoKHR5cGVJbmZvKSB7XG4gICAgdmFyIG5hbWVzID0gWi5jaGFpbiAodHlwZVZhck5hbWVzLCB0eXBlSW5mby50eXBlcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBjb2RlID0gJ2EnLmNoYXJDb2RlQXQgKDApO1xuICAgICAgcmV0dXJuIHVubGVzcyAoXG4gICAgICAgIHQudHlwZSA9PT0gRlVOQ1RJT04gfHwgdC50eXBlID09PSBSRUNPUkQgfHwgaXNFbXB0eSAodC5rZXlzKSxcbiAgICAgICAgc3RyaXBPdXRlcm1vc3RQYXJlbnMsXG4gICAgICAgIChzaG93ICh0KSkucmVwbGFjZSAoL1xcYlVua25vd25cXGIvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBsdXNwbHVzXG4gICAgICAgICAgZG8gdmFyIG5hbWUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlIChjb2RlKyspO1xuICAgICAgICAgIHdoaWxlIChuYW1lcy5pbmRleE9mIChuYW1lKSA+PSAwKTtcbiAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBzaG93VHlwZVF1b3RlZCA6OiBUeXBlIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBzaG93VHlwZVF1b3RlZCh0KSB7XG4gICAgcmV0dXJuIHEgKHVubGVzcyAodC50eXBlID09PSBSRUNPUkQgfHwgaXNFbXB0eSAodC5rZXlzKSxcbiAgICAgICAgICAgICAgICAgICAgICBzdHJpcE91dGVybW9zdFBhcmVucyxcbiAgICAgICAgICAgICAgICAgICAgICBzaG93ICh0KSkpO1xuICB9XG5cbiAgLy8gIHNob3dWYWx1ZXNBbmRUeXBlcyA6OiAuLi4gLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHNob3dWYWx1ZXNBbmRUeXBlcyhcbiAgICBlbnYsICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHR5cGVJbmZvLCAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIHZhbHVlcywgICAgICAgICAvLyA6OiBBcnJheSBBbnlcbiAgICBwb3MgICAgICAgICAgICAgLy8gOjogSW50ZWdlclxuICApIHtcbiAgICB2YXIgc2hvd1R5cGUgPSBzaG93VHlwZVdpdGggKHR5cGVJbmZvKTtcbiAgICByZXR1cm4gc2hvdyAocG9zKSArICcpICAnICsgam9pbldpdGggKCdcXG4gICAgJywgWi5tYXAgKGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciB0eXBlcyA9IGRldGVybWluZUFjdHVhbFR5cGVzTG9vc2UgKGVudiwgW3hdKTtcbiAgICAgIHJldHVybiBzaG93ICh4KSArICcgOjogJyArIGpvaW5XaXRoICgnLCAnLCBaLm1hcCAoc2hvd1R5cGUsIHR5cGVzKSk7XG4gICAgfSwgdmFsdWVzKSk7XG4gIH1cblxuICAvLyAgdHlwZVNpZ25hdHVyZSA6OiBUeXBlSW5mbyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gdHlwZVNpZ25hdHVyZSh0eXBlSW5mbykge1xuICAgIHZhciByZXBycyA9IFoubWFwIChzaG93VHlwZVdpdGggKHR5cGVJbmZvKSwgdHlwZUluZm8udHlwZXMpO1xuICAgIHZhciBhcml0eSA9IHJlcHJzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHR5cGVJbmZvLm5hbWUgKyAnIDo6ICcgK1xuICAgICAgICAgICAgIGNvbnN0cmFpbnRzUmVwciAodHlwZUluZm8uY29uc3RyYWludHMsIGlkLCBLIChLIChpZCkpKSArXG4gICAgICAgICAgICAgd2hlbiAoYXJpdHkgPT09IDAsXG4gICAgICAgICAgICAgICAgICAgcGFyZW50aGVzaXplLFxuICAgICAgICAgICAgICAgICAgIGpvaW5XaXRoICgnIC0+ICcsIGluaXQgKHJlcHJzKSkpICtcbiAgICAgICAgICAgICAnIC0+ICcgKyBsYXN0IChyZXBycyk7XG4gIH1cblxuICAvLyAgX3VuZGVybGluZSA6OiAuLi4gLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIF91bmRlcmxpbmUoXG4gICAgdCwgICAgICAgICAgICAgIC8vIDo6IFR5cGVcbiAgICBwcm9wUGF0aCwgICAgICAgLy8gOjogUHJvcFBhdGhcbiAgICBmb3JtYXRUeXBlMyAgICAgLy8gOjogVHlwZSAtPiBBcnJheSBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICApIHtcbiAgICByZXR1cm4gdW5sZXNzICh0LnR5cGUgPT09IFJFQ09SRCB8fFxuICAgICAgICAgICAgICAgICAgICAgaXNFbXB0eSAodC5rZXlzKSB8fFxuICAgICAgICAgICAgICAgICAgICAgdC50eXBlID09PSBGVU5DVElPTiAmJiBpc0VtcHR5IChwcm9wUGF0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICFpc0VtcHR5IChwcm9wUGF0aCksXG4gICAgICAgICAgICAgICAgICAgc3RyaXBPdXRlcm1vc3RQYXJlbnMsXG4gICAgICAgICAgICAgICAgICAgZm9ybWF0VHlwZTMgKHQpIChwcm9wUGF0aCkgKHQuZm9ybWF0IChfLCBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gSyAoX3VuZGVybGluZSAodC50eXBlc1trXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFouY29uY2F0IChwcm9wUGF0aCwgW2tdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlMykpO1xuICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gIH1cblxuICAvLyAgdW5kZXJsaW5lIDo6IC4uLiAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gdW5kZXJsaW5lKFxuICAgIHR5cGVJbmZvLCAgICAgICAgICAgICAgIC8vIDo6IFR5cGVJbmZvXG4gICAgdW5kZXJsaW5lQ29uc3RyYWludCwgICAgLy8gOjogU3RyaW5nIC0+IFR5cGVDbGFzcyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICAgZm9ybWF0VHlwZTVcbiAgICAvLyA6OiBJbnRlZ2VyIC0+IChTdHJpbmcgLT4gU3RyaW5nKSAtPiBUeXBlIC0+IFByb3BQYXRoIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgKSB7XG4gICAgdmFyIHN0ID0gdHlwZUluZm8udHlwZXMucmVkdWNlIChmdW5jdGlvbihzdCwgdCwgaW5kZXgpIHtcbiAgICAgIHZhciBmb3JtYXRUeXBlNCA9IGZvcm1hdFR5cGU1IChpbmRleCk7XG4gICAgICBzdC5udW1iZXJzLnB1c2ggKF91bmRlcmxpbmUgKHQsIFtdLCBmb3JtYXRUeXBlNCAoZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gbGFiZWwgKHNob3cgKHN0LmNvdW50ZXIgKz0gMSkpIChzKTtcbiAgICAgIH0pKSk7XG4gICAgICBzdC5jYXJldHMucHVzaCAoX3VuZGVybGluZSAodCwgW10sIFcgKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdmFyIHJlcHIgPSBzaG93ICh0eXBlKTtcbiAgICAgICAgdmFyIHBhcmVudGhlc2l6ZWQgPSByZXByLnNsaWNlICgwLCAxKSArIHJlcHIuc2xpY2UgKC0xKSA9PT0gJygpJztcbiAgICAgICAgcmV0dXJuIGZvcm1hdFR5cGU0IChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudGhlc2l6ZWQgJiYgcmVwciAhPT0gJygpJyAmJiBzLmxlbmd0aCA9PT0gcmVwci5sZW5ndGggP1xuICAgICAgICAgICAgXyAoJygnKSArIHIgKCdeJykgKHMuc2xpY2UgKDEsIC0xKSkgKyBfICgnKScpIDpcbiAgICAgICAgICAgIHIgKCdeJykgKHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKSk7XG4gICAgICByZXR1cm4gc3Q7XG4gICAgfSwge2NhcmV0czogW10sIG51bWJlcnM6IFtdLCBjb3VudGVyOiAwfSk7XG5cbiAgICByZXR1cm4gdHlwZVNpZ25hdHVyZSAodHlwZUluZm8pICsgJ1xcbicgK1xuICAgICAgICAgICBfICh0eXBlSW5mby5uYW1lICsgJyA6OiAnKSArXG4gICAgICAgICAgICAgIGNvbnN0cmFpbnRzUmVwciAodHlwZUluZm8uY29uc3RyYWludHMsIF8sIHVuZGVybGluZUNvbnN0cmFpbnQpICtcbiAgICAgICAgICAgICAgam9pbldpdGggKF8gKCcgLT4gJyksIHN0LmNhcmV0cykgKyAnXFxuJyArXG4gICAgICAgICAgIF8gKHR5cGVJbmZvLm5hbWUgKyAnIDo6ICcpICtcbiAgICAgICAgICAgICAgY29uc3RyYWludHNSZXByICh0eXBlSW5mby5jb25zdHJhaW50cywgXywgSyAoSyAoXykpKSArXG4gICAgICAgICAgICAgIGpvaW5XaXRoIChfICgnIC0+ICcpLCBzdC5udW1iZXJzKSArICdcXG4nO1xuICB9XG5cbiAgLy8gIHJlc29sdmVQcm9wUGF0aCA6OiAoVHlwZSwgQXJyYXkgU3RyaW5nKSAtPiBUeXBlXG4gIGZ1bmN0aW9uIHJlc29sdmVQcm9wUGF0aCh0LCBwcm9wUGF0aCkge1xuICAgIHJldHVybiBaLnJlZHVjZSAoZnVuY3Rpb24odCwgcHJvcCkgeyByZXR1cm4gdC50eXBlc1twcm9wXS50eXBlOyB9LFxuICAgICAgICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICAgICAgIHByb3BQYXRoKTtcbiAgfVxuXG4gIC8vICBmb3JtYXRUeXBlNiA6OlxuICAvLyAgICBQcm9wUGF0aCAtPiBJbnRlZ2VyIC0+IChTdHJpbmcgLT4gU3RyaW5nKSAtPlxuICAvLyAgICAgIFR5cGUgLT4gUHJvcFBhdGggLT4gU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBmb3JtYXRUeXBlNihpbmRleGVkUHJvcFBhdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaW5kZXhfKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwcm9wUGF0aF8pIHtcbiAgICAgICAgICAgIHZhciBpbmRleGVkUHJvcFBhdGhfID0gWi5jb25jYXQgKFtpbmRleF9dLCBwcm9wUGF0aF8pO1xuICAgICAgICAgICAgdmFyIHAgPSBpc1ByZWZpeCAoaW5kZXhlZFByb3BQYXRoXykgKGluZGV4ZWRQcm9wUGF0aCk7XG4gICAgICAgICAgICB2YXIgcSA9IGlzUHJlZml4IChpbmRleGVkUHJvcFBhdGgpIChpbmRleGVkUHJvcFBhdGhfKTtcbiAgICAgICAgICAgIHJldHVybiBwICYmIHEgPyBmIDogcCA/IGlkIDogXztcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHNlZSA6OiAoU3RyaW5nLCB7IG5hbWUgOjogU3RyaW5nLCB1cmwgOjogU3RyaW5nPyB9KSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gc2VlKGxhYmVsLCByZWNvcmQpIHtcbiAgICByZXR1cm4gcmVjb3JkLnVybCA9PSBudWxsIHx8IHJlY29yZC51cmwgPT09ICcnID9cbiAgICAgICAgICAgJycgOlxuICAgICAgICAgICAnXFxuU2VlICcgKyByZWNvcmQudXJsICtcbiAgICAgICAgICAgJyBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlICcgKyByZWNvcmQubmFtZSArICcgJyArIGxhYmVsICsgJy5cXG4nO1xuICB9XG5cbiAgLy8gIHR5cGVDbGFzc0NvbnN0cmFpbnRWaW9sYXRpb24gOjogLi4uIC0+IEVycm9yXG4gIGZ1bmN0aW9uIHR5cGVDbGFzc0NvbnN0cmFpbnRWaW9sYXRpb24oXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICB0eXBlSW5mbywgICAgICAgLy8gOjogVHlwZUluZm9cbiAgICB0eXBlQ2xhc3MsICAgICAgLy8gOjogVHlwZUNsYXNzXG4gICAgaW5kZXgsICAgICAgICAgIC8vIDo6IEludGVnZXJcbiAgICBwcm9wUGF0aCwgICAgICAgLy8gOjogUHJvcFBhdGhcbiAgICB2YWx1ZSwgICAgICAgICAgLy8gOjogQW55XG4gICAgdHlwZVZhck1hcCAgICAgIC8vIDo6IFR5cGVWYXJNYXBcbiAgKSB7XG4gICAgdmFyIGV4cFR5cGUgPSByZXNvbHZlUHJvcFBhdGggKHR5cGVJbmZvLnR5cGVzW2luZGV4XSwgcHJvcFBhdGgpO1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yICh0cmltVHJhaWxpbmdTcGFjZXMgKFxuICAgICAgJ1R5cGUtY2xhc3MgY29uc3RyYWludCB2aW9sYXRpb25cXG5cXG4nICtcbiAgICAgIHVuZGVybGluZSAodHlwZUluZm8sXG4gICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHR2bikge1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0Yykge1xuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICAgdHZuID09PSBleHBUeXBlLm5hbWUgJiYgdGMubmFtZSA9PT0gdHlwZUNsYXNzLm5hbWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgIHIgKCdeJykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIF9cbiAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgZm9ybWF0VHlwZTYgKFouY29uY2F0IChbaW5kZXhdLCBwcm9wUGF0aCkpKSArXG4gICAgICAnXFxuJyArXG4gICAgICBzaG93VmFsdWVzQW5kVHlwZXMgKGVudiwgdHlwZUluZm8sIFt2YWx1ZV0sIDEpICsgJ1xcblxcbicgK1xuICAgICAgcSAodHlwZUluZm8ubmFtZSkgKyAnIHJlcXVpcmVzICcgK1xuICAgICAgcSAoZXhwVHlwZS5uYW1lKSArICcgdG8gc2F0aXNmeSB0aGUgJyArXG4gICAgICBzdHJpcE5hbWVzcGFjZSAodHlwZUNsYXNzLm5hbWUpICsgJyB0eXBlLWNsYXNzIGNvbnN0cmFpbnQ7ICcgK1xuICAgICAgJ3RoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGRvZXMgbm90LlxcbicgK1xuICAgICAgc2VlICgndHlwZSBjbGFzcycsIHR5cGVDbGFzcylcbiAgICApKTtcbiAgfVxuXG4gIC8vICB0eXBlVmFyQ29uc3RyYWludFZpb2xhdGlvbiA6OiAuLi4gLT4gRXJyb3JcbiAgZnVuY3Rpb24gdHlwZVZhckNvbnN0cmFpbnRWaW9sYXRpb24oXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICB0eXBlSW5mbywgICAgICAgLy8gOjogVHlwZUluZm9cbiAgICBpbmRleCwgICAgICAgICAgLy8gOjogSW50ZWdlclxuICAgIHByb3BQYXRoLCAgICAgICAvLyA6OiBQcm9wUGF0aFxuICAgIHZhbHVlc0J5UGF0aCAgICAvLyA6OiBTdHJNYXAgKEFycmF5IEFueSlcbiAgKSB7XG4gICAgLy8gIElmIHdlIGFwcGx5IGFuIOKAmGEgLT4gYSAtPiBhIC0+IGHigJkgZnVuY3Rpb24gdG8gTGVmdCAoJ3gnKSwgUmlnaHQgKDEpLFxuICAgIC8vICBhbmQgUmlnaHQgKG51bGwpIHdlJ2QgbGlrZSB0byBhdm9pZCB1bmRlcmxpbmluZyB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAvLyAgcG9zaXRpb24sIHNpbmNlIExlZnQgKCd4JykgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBvdGhlciDigJhh4oCZIHZhbHVlcy5cbiAgICB2YXIga2V5ID0gSlNPTi5zdHJpbmdpZnkgKFouY29uY2F0IChbaW5kZXhdLCBwcm9wUGF0aCkpO1xuICAgIHZhciB2YWx1ZXMgPSB2YWx1ZXNCeVBhdGhba2V5XTtcblxuICAgIC8vICBOb3RlOiBTb3J0aW5nIHRoZXNlIGtleXMgbGV4aWNvZ3JhcGhpY2FsbHkgaXMgbm90IFwiY29ycmVjdFwiLCBidXQgaXRcbiAgICAvLyAgZG9lcyB0aGUgcmlnaHQgdGhpbmcgZm9yIGluZGV4ZXMgbGVzcyB0aGFuIDEwLlxuICAgIHZhciBrZXlzID0gWi5maWx0ZXIgKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciB2YWx1ZXNfID0gdmFsdWVzQnlQYXRoW2tdO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gIEtlZXAgWCwgdGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSB2aW9sYXRpb24gd2FzIG9ic2VydmVkLlxuICAgICAgICBrID09PSBrZXkgfHxcbiAgICAgICAgLy8gIEtlZXAgcG9zaXRpb25zIHdob3NlIHZhbHVlcyBhcmUgaW5jb21wYXRpYmxlIHdpdGggdGhlIHZhbHVlcyBhdCBYLlxuICAgICAgICBpc0VtcHR5IChkZXRlcm1pbmVBY3R1YWxUeXBlc1N0cmljdCAoZW52LCBaLmNvbmNhdCAodmFsdWVzLCB2YWx1ZXNfKSkpXG4gICAgICApO1xuICAgIH0sIHNvcnRlZEtleXMgKHZhbHVlc0J5UGF0aCkpO1xuXG4gICAgdmFyIHVuZGVybGluZWRUeXBlVmFycyA9XG4gICAgdW5kZXJsaW5lVHlwZVZhcnMgKHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICBaLnJlZHVjZSAoZnVuY3Rpb24oJHZhbHVlc0J5UGF0aCwgaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICR2YWx1ZXNCeVBhdGhba10gPSB2YWx1ZXNCeVBhdGhba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR2YWx1ZXNCeVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgIH0sIHt9LCBrZXlzKSk7XG5cbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvciAodHJpbVRyYWlsaW5nU3BhY2VzIChcbiAgICAgIHZhbHVlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgIGlzRW1wdHkgKGRldGVybWluZUFjdHVhbFR5cGVzTG9vc2UgKGVudiwgdmFsdWVzKSkgP1xuICAgICAgICAnVW5yZWNvZ25pemVkIHZhbHVlXFxuXFxuJyArXG4gICAgICAgIHVuZGVybGluZWRUeXBlVmFycyArICdcXG4nICtcbiAgICAgICAgJzEpICAnICsgc2hvdyAodmFsdWVzWzBdKSArICcgOjogKG5vIHR5cGVzKVxcblxcbicgK1xuICAgICAgICB0b01hcmtkb3duTGlzdCAoXG4gICAgICAgICAgJ1RoZSBlbnZpcm9ubWVudCBpcyBlbXB0eSEgJyArXG4gICAgICAgICAgJ1BvbHltb3JwaGljIGZ1bmN0aW9ucyByZXF1aXJlIGEgbm9uLWVtcHR5IGVudmlyb25tZW50LlxcbicsXG4gICAgICAgICAgJ1RoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGlzIG5vdCBhIG1lbWJlciBvZiBhbnkgdHlwZSBpbiAnICtcbiAgICAgICAgICAndGhlIGVudmlyb25tZW50LlxcblxcbicgK1xuICAgICAgICAgICdUaGUgZW52aXJvbm1lbnQgY29udGFpbnMgdGhlIGZvbGxvd2luZyB0eXBlczpcXG5cXG4nLFxuICAgICAgICAgIHNob3dUeXBlV2l0aCAodHlwZUluZm8pLFxuICAgICAgICAgIGVudlxuICAgICAgICApIDpcbiAgICAgIC8vIGVsc2VcbiAgICAgICAgJ1R5cGUtdmFyaWFibGUgY29uc3RyYWludCB2aW9sYXRpb25cXG5cXG4nICtcbiAgICAgICAgdW5kZXJsaW5lZFR5cGVWYXJzICsgJ1xcbicgK1xuICAgICAgICAoWi5yZWR1Y2UgKGZ1bmN0aW9uKHN0LCBrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlcyA9IHZhbHVlc0J5UGF0aFtrXTtcbiAgICAgICAgICByZXR1cm4gaXNFbXB0eSAodmFsdWVzKSA/IHN0IDoge1xuICAgICAgICAgICAgaWR4OiBzdC5pZHggKyAxLFxuICAgICAgICAgICAgczogc3QucyArXG4gICAgICAgICAgICAgICBzaG93VmFsdWVzQW5kVHlwZXMgKGVudiwgdHlwZUluZm8sIHZhbHVlcywgc3QuaWR4ICsgMSkgK1xuICAgICAgICAgICAgICAgJ1xcblxcbidcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB7aWR4OiAwLCBzOiAnJ30sIGtleXMpKS5zICtcbiAgICAgICAgJ1NpbmNlIHRoZXJlIGlzIG5vIHR5cGUgb2Ygd2hpY2ggYWxsIHRoZSBhYm92ZSB2YWx1ZXMgYXJlICcgK1xuICAgICAgICAnbWVtYmVycywgdGhlIHR5cGUtdmFyaWFibGUgY29uc3RyYWludCBoYXMgYmVlbiB2aW9sYXRlZC5cXG4nXG4gICAgKSk7XG4gIH1cblxuICAvLyAgaW52YWxpZFZhbHVlIDo6IC4uLiAtPiBFcnJvclxuICBmdW5jdGlvbiBpbnZhbGlkVmFsdWUoXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICB0eXBlSW5mbywgICAgICAgLy8gOjogVHlwZUluZm9cbiAgICBpbmRleCwgICAgICAgICAgLy8gOjogSW50ZWdlclxuICAgIHByb3BQYXRoLCAgICAgICAvLyA6OiBQcm9wUGF0aFxuICAgIHZhbHVlICAgICAgICAgICAvLyA6OiBBbnlcbiAgKSB7XG4gICAgdmFyIHQgPSByZXNvbHZlUHJvcFBhdGggKHR5cGVJbmZvLnR5cGVzW2luZGV4XSwgcHJvcFBhdGgpO1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yICh0cmltVHJhaWxpbmdTcGFjZXMgKFxuICAgICAgJ0ludmFsaWQgdmFsdWVcXG5cXG4nICtcbiAgICAgIHVuZGVybGluZSAodHlwZUluZm8sXG4gICAgICAgICAgICAgICAgIEsgKEsgKF8pKSxcbiAgICAgICAgICAgICAgICAgZm9ybWF0VHlwZTYgKFouY29uY2F0IChbaW5kZXhdLCBwcm9wUGF0aCkpKSArXG4gICAgICAnXFxuJyArXG4gICAgICBzaG93VmFsdWVzQW5kVHlwZXMgKGVudiwgdHlwZUluZm8sIFt2YWx1ZV0sIDEpICsgJ1xcblxcbicgK1xuICAgICAgJ1RoZSB2YWx1ZSBhdCBwb3NpdGlvbiAxIGlzIG5vdCBhIG1lbWJlciBvZiAnICtcbiAgICAgIHNob3dUeXBlUXVvdGVkICh0KSArICcuXFxuJyArXG4gICAgICBzZWUgKCd0eXBlJywgdClcbiAgICApKTtcbiAgfVxuXG4gIC8vICBpbnZhbGlkQXJndW1lbnRzTGVuZ3RoIDo6IC4uLiAtPiBFcnJvclxuICAvL1xuICAvLyAgVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluIGB3cmFwRnVuY3Rpb25Db25kYCB0byBlbnN1cmUgdGhhdCBoaWdoZXItb3JkZXJcbiAgLy8gIGZ1bmN0aW9ucyBkZWZpbmVkIHZpYSBgZGVmYCBvbmx5IGV2ZXIgYXBwbHkgYSBmdW5jdGlvbiBhcmd1bWVudCB0byB0aGVcbiAgLy8gIGNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cy5cbiAgZnVuY3Rpb24gaW52YWxpZEFyZ3VtZW50c0xlbmd0aChcbiAgICB0eXBlSW5mbywgICAgICAgICAgIC8vIDo6IFR5cGVJbmZvXG4gICAgaW5kZXgsICAgICAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICAgbnVtQXJnc0V4cGVjdGVkLCAgICAvLyA6OiBJbnRlZ2VyXG4gICAgYXJncyAgICAgICAgICAgICAgICAvLyA6OiBBcnJheSBBbnlcbiAgKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IgKHRyaW1UcmFpbGluZ1NwYWNlcyAoXG4gICAgICBxICh0eXBlSW5mby5uYW1lKSArXG4gICAgICAnIGFwcGxpZWQgJyArIHNob3dUeXBlUXVvdGVkICh0eXBlSW5mby50eXBlc1tpbmRleF0pICtcbiAgICAgICcgdG8gdGhlIHdyb25nIG51bWJlciBvZiBhcmd1bWVudHNcXG5cXG4nICtcbiAgICAgIHVuZGVybGluZSAoXG4gICAgICAgIHR5cGVJbmZvLFxuICAgICAgICBLIChLIChfKSksXG4gICAgICAgIGZ1bmN0aW9uKGluZGV4Xykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvcFBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4XyA9PT0gaW5kZXggP1xuICAgICAgICAgICAgICAgICAgICB0LmZvcm1hdCAoXywgZnVuY3Rpb24oaykgeyByZXR1cm4gayA9PT0gJyQxJyA/IGYgOiBfOyB9KSA6XG4gICAgICAgICAgICAgICAgICAgIF8gKHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICkgKyAnXFxuJyArXG4gICAgICAnRXhwZWN0ZWQgJyArIG51bUFyZ3MgKG51bUFyZ3NFeHBlY3RlZCkgK1xuICAgICAgJyBidXQgcmVjZWl2ZWQgJyArIG51bUFyZ3MgKGFyZ3MubGVuZ3RoKSArXG4gICAgICB0b01hcmtkb3duTGlzdCAoJy5cXG4nLCAnOlxcblxcbicsIHNob3csIGFyZ3MpXG4gICAgKSk7XG4gIH1cblxuICAvLyAgYXNzZXJ0UmlnaHQgOjogRWl0aGVyICgoKSAtPiBFcnJvcikgYSAtPiBhICFcbiAgZnVuY3Rpb24gYXNzZXJ0UmlnaHQoZWl0aGVyKSB7XG4gICAgaWYgKGVpdGhlci5pc0xlZnQpIHRocm93IGVpdGhlci52YWx1ZSAoKTtcbiAgICByZXR1cm4gZWl0aGVyLnZhbHVlO1xuICB9XG5cbiAgLy8gIHdpdGhUeXBlQ2hlY2tpbmcgOjogLi4uIC0+IEZ1bmN0aW9uXG4gIGZ1bmN0aW9uIHdpdGhUeXBlQ2hlY2tpbmcoXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICB0eXBlSW5mbywgICAgICAgLy8gOjogVHlwZUluZm9cbiAgICBpbXBsICAgICAgICAgICAgLy8gOjogRnVuY3Rpb25cbiAgKSB7XG4gICAgdmFyIG4gPSB0eXBlSW5mby50eXBlcy5sZW5ndGggLSAxO1xuXG4gICAgLy8gIHdyYXBGdW5jdGlvbkNvbmQgOjogKFR5cGVWYXJNYXAsIEludGVnZXIsIGEpIC0+IGFcbiAgICBmdW5jdGlvbiB3cmFwRnVuY3Rpb25Db25kKF90eXBlVmFyTWFwLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlSW5mby50eXBlc1tpbmRleF0udHlwZSAhPT0gRlVOQ1RJT04pIHJldHVybiB2YWx1ZTtcblxuICAgICAgdmFyIGV4cFR5cGUgPSB0eXBlSW5mby50eXBlc1tpbmRleF07XG5cbiAgICAgIC8vICBjaGVja1ZhbHVlIDo6IChUeXBlVmFyTWFwLCBJbnRlZ2VyLCBTdHJpbmcsIGEpIC0+IEVpdGhlciAoKCkgLT4gRXJyb3IpIFR5cGVWYXJNYXBcbiAgICAgIGZ1bmN0aW9uIGNoZWNrVmFsdWUodHlwZVZhck1hcCwgaW5kZXgsIGssIHgpIHtcbiAgICAgICAgdmFyIHByb3BQYXRoID0gW2tdO1xuICAgICAgICB2YXIgdCA9IGV4cFR5cGUudHlwZXNba10udHlwZTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0LnR5cGUgPT09IFZBUklBQkxFID9cbiAgICAgICAgICAgIFouY2hhaW4gKFxuICAgICAgICAgICAgICBmdW5jdGlvbih0eXBlVmFyTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHkgKHR5cGVWYXJNYXBbdC5uYW1lXS50eXBlcykgP1xuICAgICAgICAgICAgICAgICAgTGVmdCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlVmFyQ29uc3RyYWludFZpb2xhdGlvbiAoXG4gICAgICAgICAgICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgIHByb3BQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgIHR5cGVWYXJNYXBbdC5uYW1lXS52YWx1ZXNCeVBhdGhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH0pIDpcbiAgICAgICAgICAgICAgICAgIFJpZ2h0ICh0eXBlVmFyTWFwKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgUmlnaHQgKHVwZGF0ZVR5cGVWYXJNYXAgKGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wUGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt4XSkpXG4gICAgICAgICAgICApIDpcbiAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICBaLm1hcCAoXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHIpIHsgcmV0dXJuIHIudHlwZVZhck1hcDsgfSxcbiAgICAgICAgICAgICAgc2F0aXNmYWN0b3J5VHlwZXMgKGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3hdKVxuICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNUaHVuayA9IGV4cFR5cGUudHlwZXMuJDEudHlwZS50eXBlID09PSBOT19BUkdVTUVOVFM7XG4gICAgICB2YXIgbnVtQXJnc0V4cGVjdGVkID0gaXNUaHVuayA/IDAgOiBleHBUeXBlLmtleXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciB0eXBlVmFyTWFwID0gX3R5cGVWYXJNYXA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gbnVtQXJnc0V4cGVjdGVkKSB7XG4gICAgICAgICAgdGhyb3cgaW52YWxpZEFyZ3VtZW50c0xlbmd0aCAodHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtQXJnc0V4cGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlLmNhbGwgKGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHR5cGVWYXJNYXAgPSBhc3NlcnRSaWdodCAoXG4gICAgICAgICAgKGluaXQgKGV4cFR5cGUua2V5cykpLnJlZHVjZSAoZnVuY3Rpb24oZWl0aGVyLCBrLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzW2lkeF07XG4gICAgICAgICAgICByZXR1cm4gWi5jaGFpbiAoZnVuY3Rpb24odHlwZVZhck1hcCkge1xuICAgICAgICAgICAgICByZXR1cm4gY2hlY2tWYWx1ZSAodHlwZVZhck1hcCwgaW5kZXgsIGssIGFyZyk7XG4gICAgICAgICAgICB9LCBlaXRoZXIpO1xuICAgICAgICAgIH0sIFJpZ2h0ICh0eXBlVmFyTWFwKSlcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgb3V0cHV0ID0gdmFsdWUuYXBwbHkgKHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBrID0gbGFzdCAoZXhwVHlwZS5rZXlzKTtcbiAgICAgICAgdHlwZVZhck1hcCA9IGFzc2VydFJpZ2h0IChjaGVja1ZhbHVlICh0eXBlVmFyTWFwLCBpbmRleCwgaywgb3V0cHV0KSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vICB3cmFwTmV4dCA6OiAoVHlwZVZhck1hcCwgQXJyYXkgQW55LCBJbnRlZ2VyKSAtPiAoYSAtPiBiKVxuICAgIGZ1bmN0aW9uIHdyYXBOZXh0KF90eXBlVmFyTWFwLCBfdmFsdWVzLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsIChhcmd1bWVudHMpO1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBpbnZhbGlkQXJndW1lbnRzQ291bnQgKHR5cGVJbmZvLCBpbmRleCwgMSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHR5cGVWYXJNYXAgPSAoYXNzZXJ0UmlnaHQgKFxuICAgICAgICAgIHNhdGlzZmFjdG9yeVR5cGVzIChlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZXNbaW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MpXG4gICAgICAgICkpLnR5cGVWYXJNYXA7XG5cbiAgICAgICAgdmFyIHZhbHVlcyA9IFouY29uY2F0IChfdmFsdWVzLCBhcmdzKTtcbiAgICAgICAgaWYgKGluZGV4ICsgMSA9PT0gbikge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlcy5yZWR1Y2UgKGZ1bmN0aW9uKGYsIHgsIGlkeCkge1xuICAgICAgICAgICAgcmV0dXJuIGYgKHdyYXBGdW5jdGlvbkNvbmQgKHR5cGVWYXJNYXAsIGlkeCwgeCkpO1xuICAgICAgICAgIH0sIGltcGwpO1xuICAgICAgICAgIHR5cGVWYXJNYXAgPSAoYXNzZXJ0UmlnaHQgKFxuICAgICAgICAgICAgc2F0aXNmYWN0b3J5VHlwZXMgKGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGVzW25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXSlcbiAgICAgICAgICApKS50eXBlVmFyTWFwO1xuICAgICAgICAgIHJldHVybiB3cmFwRnVuY3Rpb25Db25kICh0eXBlVmFyTWFwLCBuLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHdyYXBOZXh0ICh0eXBlVmFyTWFwLCB2YWx1ZXMsIGluZGV4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHdyYXBwZWQgPSB0eXBlSW5mby50eXBlc1swXS50eXBlID09PSBOT19BUkdVTUVOVFMgP1xuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdGhyb3cgaW52YWxpZEFyZ3VtZW50c0NvdW50ICh0eXBlSW5mbywgMCwgMCwgc2xpY2UuY2FsbCAoYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gaW1wbCAoKTtcbiAgICAgICAgdmFyIHR5cGVWYXJNYXAgPSBhc3NlcnRSaWdodCAoXG4gICAgICAgICAgc2F0aXNmYWN0b3J5VHlwZXMgKGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlc1tuXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt2YWx1ZV0pXG4gICAgICAgICkudHlwZVZhck1hcDtcbiAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbkNvbmQgKHR5cGVWYXJNYXAsIG4sIHZhbHVlKTtcbiAgICAgIH0gOlxuICAgICAgd3JhcE5leHQgKHt9LCBbXSwgMCk7XG5cbiAgICB3cmFwcGVkW2luc3BlY3RdID0gd3JhcHBlZC50b1N0cmluZyA9IGFsd2F5czAgKHR5cGVTaWduYXR1cmUgKHR5cGVJbmZvKSk7XG5cbiAgICByZXR1cm4gd3JhcHBlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGUob3B0cykge1xuICAgIGZ1bmN0aW9uIGRlZihuYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oY29uc3RyYWludHMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV4cFR5cGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRzLmNoZWNrVHlwZXMgP1xuICAgICAgICAgICAgICB3aXRoVHlwZUNoZWNraW5nIChvcHRzLmVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50czogY29uc3RyYWludHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlczogYXVnbWVudFRodW5rIChleHBUeXBlcyl9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbXBsKSA6XG4gICAgICAgICAgICAgIGltcGw7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBkZWYgKGRlZi5uYW1lKVxuICAgICAgICAgICAgICAgKHt9KVxuICAgICAgICAgICAgICAgKFtTdHJpbmdfLFxuICAgICAgICAgICAgICAgICBTdHJNYXAgKEFycmF5XyAoVHlwZUNsYXNzKSksXG4gICAgICAgICAgICAgICAgIE5vbkVtcHR5IChBcnJheV8gKFR5cGUpKSxcbiAgICAgICAgICAgICAgICAgQW55RnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgIEFueUZ1bmN0aW9uXSlcbiAgICAgICAgICAgICAgIChkZWYpO1xuICB9XG5cbiAgdmFyIGNyZWF0ZSA9XG4gIGRlZiAoJ2NyZWF0ZScpXG4gICAgICAoe30pXG4gICAgICAoW1JlY29yZFR5cGUgKHtjaGVja1R5cGVzOiBCb29sZWFuXywgZW52OiBBcnJheV8gKEFueSl9KSwgQW55RnVuY3Rpb25dKVxuICAgICAgKF9jcmVhdGUpO1xuXG4gIC8vICBmcm9tVW5jaGVja2VkVW5hcnlUeXBlIDo6IChUeXBlIC0+IFR5cGUpIC0+IFR5cGUgLT4gVHlwZVxuICBmdW5jdGlvbiBmcm9tVW5jaGVja2VkVW5hcnlUeXBlKHR5cGVDb25zdHJ1Y3Rvcikge1xuICAgIHZhciB0ID0gdHlwZUNvbnN0cnVjdG9yIChVbmtub3duKTtcbiAgICB2YXIgXzEgPSB0LnR5cGVzLiQxLmV4dHJhY3RvcjtcbiAgICByZXR1cm4gQ2hlY2tlZFVuYXJ5VHlwZSAodC5uYW1lKSAodC51cmwpICh0Ll90ZXN0KSAoXzEpO1xuICB9XG5cbiAgLy8gIGZyb21VbmNoZWNrZWRCaW5hcnlUeXBlIDo6IChUeXBlIC0+IFR5cGUgLT4gVHlwZSkgLT4gVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgZnVuY3Rpb24gZnJvbVVuY2hlY2tlZEJpbmFyeVR5cGUodHlwZUNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIHQgPSB0eXBlQ29uc3RydWN0b3IgKFVua25vd24pIChVbmtub3duKTtcbiAgICB2YXIgXzEgPSB0LnR5cGVzLiQxLmV4dHJhY3RvcjtcbiAgICB2YXIgXzIgPSB0LnR5cGVzLiQyLmV4dHJhY3RvcjtcbiAgICByZXR1cm4gQ2hlY2tlZEJpbmFyeVR5cGUgKHQubmFtZSkgKHQudXJsKSAodC5fdGVzdCkgKF8xKSAoXzIpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBBbnk6IEFueSxcbiAgICBBbnlGdW5jdGlvbjogQW55RnVuY3Rpb24sXG4gICAgQXJndW1lbnRzOiBBcmd1bWVudHMsXG4gICAgQXJyYXk6IGZyb21VbmNoZWNrZWRVbmFyeVR5cGUgKEFycmF5XyksXG4gICAgQXJyYXkwOiBBcnJheTAsXG4gICAgQXJyYXkxOiBmcm9tVW5jaGVja2VkVW5hcnlUeXBlIChBcnJheTEpLFxuICAgIEFycmF5MjogZnJvbVVuY2hlY2tlZEJpbmFyeVR5cGUgKEFycmF5MiksXG4gICAgQm9vbGVhbjogQm9vbGVhbl8sXG4gICAgRGF0ZTogRGF0ZV8sXG4gICAgRXJyb3I6IEVycm9yXyxcbiAgICBGaW5pdGVOdW1iZXI6IEZpbml0ZU51bWJlcixcbiAgICBGdW5jdGlvbjogZGVmICgnRnVuY3Rpb24nKSAoe30pIChbQXJyYXlfIChUeXBlKSwgVHlwZV0pIChGdW5jdGlvbl8pLFxuICAgIEdsb2JhbFJlZ0V4cDogR2xvYmFsUmVnRXhwLFxuICAgIEh0bWxFbGVtZW50OiBIdG1sRWxlbWVudCxcbiAgICBJbnRlZ2VyOiBJbnRlZ2VyLFxuICAgIE5lZ2F0aXZlRmluaXRlTnVtYmVyOiBOZWdhdGl2ZUZpbml0ZU51bWJlcixcbiAgICBOZWdhdGl2ZUludGVnZXI6IE5lZ2F0aXZlSW50ZWdlcixcbiAgICBOZWdhdGl2ZU51bWJlcjogTmVnYXRpdmVOdW1iZXIsXG4gICAgTm9uRW1wdHk6IE5vbkVtcHR5LFxuICAgIE5vbkdsb2JhbFJlZ0V4cDogTm9uR2xvYmFsUmVnRXhwLFxuICAgIE5vbk5lZ2F0aXZlSW50ZWdlcjogTm9uTmVnYXRpdmVJbnRlZ2VyLFxuICAgIE5vblplcm9GaW5pdGVOdW1iZXI6IE5vblplcm9GaW5pdGVOdW1iZXIsXG4gICAgTm9uWmVyb0ludGVnZXI6IE5vblplcm9JbnRlZ2VyLFxuICAgIE5vblplcm9WYWxpZE51bWJlcjogTm9uWmVyb1ZhbGlkTnVtYmVyLFxuICAgIE51bGw6IE51bGwsXG4gICAgTnVsbGFibGU6IGZyb21VbmNoZWNrZWRVbmFyeVR5cGUgKE51bGxhYmxlKSxcbiAgICBOdW1iZXI6IE51bWJlcl8sXG4gICAgT2JqZWN0OiBPYmplY3RfLFxuICAgIFBvc2l0aXZlRmluaXRlTnVtYmVyOiBQb3NpdGl2ZUZpbml0ZU51bWJlcixcbiAgICBQb3NpdGl2ZUludGVnZXI6IFBvc2l0aXZlSW50ZWdlcixcbiAgICBQb3NpdGl2ZU51bWJlcjogUG9zaXRpdmVOdW1iZXIsXG4gICAgUmVnRXhwOiBSZWdFeHBfLFxuICAgIFJlZ2V4RmxhZ3M6IFJlZ2V4RmxhZ3MsXG4gICAgU3RyTWFwOiBmcm9tVW5jaGVja2VkVW5hcnlUeXBlIChTdHJNYXApLFxuICAgIFN0cmluZzogU3RyaW5nXyxcbiAgICBTeW1ib2w6IFN5bWJvbF8sXG4gICAgVHlwZTogVHlwZSxcbiAgICBUeXBlQ2xhc3M6IFR5cGVDbGFzcyxcbiAgICBVbmRlZmluZWQ6IFVuZGVmaW5lZCxcbiAgICBVbmtub3duOiBVbmtub3duLFxuICAgIFZhbGlkRGF0ZTogVmFsaWREYXRlLFxuICAgIFZhbGlkTnVtYmVyOiBWYWxpZE51bWJlcixcbiAgICBlbnY6IGVudixcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICB0ZXN0OiBkZWYgKCd0ZXN0JykgKHt9KSAoW0FycmF5XyAoVHlwZSksIFR5cGUsIEFueSwgQm9vbGVhbl9dKSAodGVzdCksXG4gICAgTnVsbGFyeVR5cGU6IENoZWNrZWROdWxsYXJ5VHlwZSxcbiAgICBVbmFyeVR5cGU6IENoZWNrZWRVbmFyeVR5cGUsXG4gICAgQmluYXJ5VHlwZTogQ2hlY2tlZEJpbmFyeVR5cGUsXG4gICAgRW51bVR5cGU6IENoZWNrZWRFbnVtVHlwZSxcbiAgICBSZWNvcmRUeXBlOiBDaGVja2VkUmVjb3JkVHlwZSxcbiAgICBUeXBlVmFyaWFibGU6IENoZWNrZWRUeXBlVmFyaWFibGUsXG4gICAgVW5hcnlUeXBlVmFyaWFibGU6IENoZWNrZWRVbmFyeVR5cGVWYXJpYWJsZSxcbiAgICBCaW5hcnlUeXBlVmFyaWFibGU6IENoZWNrZWRCaW5hcnlUeXBlVmFyaWFibGUsXG4gICAgVGh1bms6IFRodW5rLFxuICAgIFByZWRpY2F0ZTogUHJlZGljYXRlXG4gIH07XG5cbn0pKTtcblxuLy8uIFtGTDpTZW1pZ3JvdXBdOiAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2VtaWdyb3VwXG4vLy4gW0hUTUwgZWxlbWVudF06ICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50XG4vLy4gW01vbm9pZF06ICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNtb25vaWRcbi8vLiBbU2V0b2lkXTogICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3NldG9pZFxuLy8uIFtgQXJyYXlgXTogICAgICAgICAgICAgICNBcnJheVxuLy8uIFtgQXJyYXkyYF06ICAgICAgICAgICAgICNBcnJheTJcbi8vLiBbYEJpbmFyeVR5cGVgXTogICAgICAgICAjQmluYXJ5VHlwZVxuLy8uIFtgRGF0ZWBdOiAgICAgICAgICAgICAgICNEYXRlXG4vLy4gW2BGaW5pdGVOdW1iZXJgXTogICAgICAgI0Zpbml0ZU51bWJlclxuLy8uIFtgR2xvYmFsUmVnRXhwYF06ICAgICAgICNHbG9iYWxSZWdFeHBcbi8vLiBbYEludGVnZXJgXTogICAgICAgICAgICAjSW50ZWdlclxuLy8uIFtgTm9uR2xvYmFsUmVnRXhwYF06ICAgICNOb25HbG9iYWxSZWdFeHBcbi8vLiBbYE51bWJlcmBdOiAgICAgICAgICAgICAjTnVtYmVyXG4vLy4gW2BPYmplY3QuY3JlYXRlYF06ICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2NyZWF0ZVxuLy8uIFtgUmVnRXhwYF06ICAgICAgICAgICAgICNSZWdFeHBcbi8vLiBbYFJlZ2V4RmxhZ3NgXTogICAgICAgICAjUmVnZXhGbGFnc1xuLy8uIFtgU3RyaW5nYF06ICAgICAgICAgICAgICNTdHJpbmdcbi8vLiBbYFN5bnRheEVycm9yYF06ICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TeW50YXhFcnJvclxuLy8uIFtgVHlwZUNsYXNzYF06ICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNUeXBlQ2xhc3Ncbi8vLiBbYFR5cGVFcnJvcmBdOiAgICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9UeXBlRXJyb3Jcbi8vLiBbYFR5cGVWYXJpYWJsZWBdOiAgICAgICAjVHlwZVZhcmlhYmxlXG4vLy4gW2BVbmFyeVR5cGVgXTogICAgICAgICAgI1VuYXJ5VHlwZVxuLy8uIFtgVW5hcnlUeXBlVmFyaWFibGVgXTogICNVbmFyeVR5cGVWYXJpYWJsZVxuLy8uIFtgVW5rbm93bmBdOiAgICAgICAgICAgICNVbmtub3duXG4vLy4gW2BWYWxpZE51bWJlcmBdOiAgICAgICAgI1ZhbGlkTnVtYmVyXG4vLy4gW2BlbnZgXTogICAgICAgICAgICAgICAgI2VudlxuLy8uIFthcmd1bWVudHNdOiAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Z1bmN0aW9ucy9hcmd1bWVudHNcbi8vLiBbZW51bWVyYXRlZCB0eXBlc106ICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbnVtZXJhdGVkX3R5cGVcbi8vLiBbbWF4XTogICAgICAgICAgICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvTUFYX1NBRkVfSU5URUdFUlxuLy8uIFttaW5dOiAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9NSU5fU0FGRV9JTlRFR0VSXG4vLy4gW3JlY29yZCB0eXBlXTogICAgICAgICAgI1JlY29yZFR5cGVcbi8vLiBbc2VtaWdyb3VwXTogICAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TZW1pZ3JvdXBcbi8vLiBbdHlwZSBjbGFzc106ICAgICAgICAgICAjdHlwZS1jbGFzc2VzXG4vLy4gW3R5cGUgdmFyaWFibGVzXTogICAgICAgI1R5cGVWYXJpYWJsZVxuLy8uIFt0eXBlc106ICAgICAgICAgICAgICAgICN0eXBlc1xuIiwiLypcbiAgICAgICAgIF9fX19fX18gICAgX19fICAgIF9fX19fX19fXyAgICBfX18gICBfX18gICAgX19fX19fXyAgICBfX19fX19cbiAgICAgICAgLyAgX19fXy9cXCAgLyAgL1xcICAvX18gICBfX18vXFwgIC8gIC9cXCAvICAvXFwgIC8gIF9fX18vXFwgIC8gIF9fICBcXFxuICAgICAgIC8gIC9cXF9fX1xcLyAvICAvIC8gIFxcXy8gIC9cXF9fXFwvIC8gIC9fLy8gIC8gLyAvICAvXFxfX19cXC8gLyAgL1xcLyAgL1xcXG4gICAgICAvICBfX19fL1xcICAvICAvIC8gICAgLyAgLyAvICAgIC8gIF9fXyAgIC8gLyAvICBfX19fL1xcICAvICAgICAgXy8gL1xuICAgICAvICAvXFxfX19cXC8gLyAgLyAvICAgIC8gIC8gLyAgICAvICAvXFxfLyAgLyAvIC8gIC9cXF9fX1xcLyAvICAvfCAgfFxcXFwvXG4gICAgL19fX19fXy9cXCAgL19fLyAvICAgIC9fXy8gLyAgICAvX18vIC8vX18vIC8gL19fX19fXy9cXCAgL19fLyB8X198IHxcbiAgICBcXF9fX19fX1xcLyAgXFxfX1xcLyAgICAgXFxfX1xcLyAgICAgXFxfX1xcLyBcXF9fXFwvICBcXF9fX19fX1xcLyAgXFxfX1xcLyBcXF9fXFx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuLy8uIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kXCI+PGltZyBhbHQ9XCJGYW50YXN5IExhbmRcIiBzcmM9XCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kL21hc3Rlci9sb2dvLnBuZ1wiIHdpZHRoPVwiNzVcIiBoZWlnaHQ9XCI3NVwiIGFsaWduPVwibGVmdFwiPjwvYT5cbi8vLlxuLy8uICMgc2FuY3R1YXJ5LWVpdGhlclxuLy8uXG4vLy4gVGhlIEVpdGhlciB0eXBlIHJlcHJlc2VudHMgdmFsdWVzIHdpdGggdHdvIHBvc3NpYmlsaXRpZXM6IGEgdmFsdWUgb2YgdHlwZVxuLy8uIGBFaXRoZXIgYSBiYCBpcyBlaXRoZXIgYSBMZWZ0IHdob3NlIHZhbHVlIGlzIG9mIHR5cGUgYGFgIG9yIGEgUmlnaHQgd2hvc2Vcbi8vLiB2YWx1ZSBpcyBvZiB0eXBlIGBiYC5cblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYgKHJlcXVpcmUgKCdzYW5jdHVhcnktc2hvdycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUgKFsnc2FuY3R1YXJ5LXNob3cnLCAnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyddLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeUVpdGhlciA9IGYgKHNlbGYuc2FuY3R1YXJ5U2hvdywgc2VsZi5zYW5jdHVhcnlUeXBlQ2xhc3Nlcyk7XG4gIH1cblxufSAoZnVuY3Rpb24oc2hvdywgWikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBfX2RvY3Rlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyICQgPSBfX2RvY3Rlc3QucmVxdWlyZSAoJ3NhbmN0dWFyeS1kZWYnKTtcbiAgICB2YXIgdHlwZSA9IF9fZG9jdGVzdC5yZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKTtcbiAgICB2YXIgUyA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBTID0gX19kb2N0ZXN0LnJlcXVpcmUgKCdzYW5jdHVhcnknKTtcbiAgICAgIHZhciBFaXRoZXJUeXBlID0gJC5CaW5hcnlUeXBlXG4gICAgICAgICgnc2FuY3R1YXJ5LWVpdGhlci9FaXRoZXInKVxuICAgICAgICAoJycpXG4gICAgICAgIChmdW5jdGlvbih4KSB7IHJldHVybiB0eXBlICh4KSA9PT0gRWl0aGVyWydAQHR5cGUnXTsgfSlcbiAgICAgICAgKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuaXNMZWZ0ID8gW2UudmFsdWVdIDogW107IH0pXG4gICAgICAgIChmdW5jdGlvbihlKSB7IHJldHVybiBlLmlzTGVmdCA/IFtdIDogW2UudmFsdWVdOyB9KTtcbiAgICAgIHZhciBlbnYgPSBaLmNvbmNhdCAoUy5lbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFskLlR5cGVDbGFzcywgRWl0aGVyVHlwZSAoJC5Vbmtub3duKSAoJC5Vbmtub3duKV0pO1xuICAgICAgcmV0dXJuIFMuY3JlYXRlICh7Y2hlY2tUeXBlczogdHJ1ZSwgZW52OiBlbnZ9KTtcbiAgICB9ICgpKTtcbiAgfVxuXG4gIHZhciBFaXRoZXIgPSB7fTtcblxuICB2YXIgTGVmdCRwcm90b3R5cGUgPSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgICAnY29uc3RydWN0b3InOiAgICAgICAgICAgIEVpdGhlcixcbiAgICAnaXNMZWZ0JzogICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ2lzUmlnaHQnOiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnQEBzaG93JzogICAgICAgICAgICAgICAgIExlZnQkcHJvdG90eXBlJHNob3csXG4gICAgJ2ZhbnRhc3ktbGFuZC9tYXAnOiAgICAgICBMZWZ0JHByb3RvdHlwZSRtYXAsXG4gICAgJ2ZhbnRhc3ktbGFuZC9iaW1hcCc6ICAgICBMZWZ0JHByb3RvdHlwZSRiaW1hcCxcbiAgICAnZmFudGFzeS1sYW5kL2FwJzogICAgICAgIExlZnQkcHJvdG90eXBlJGFwLFxuICAgICdmYW50YXN5LWxhbmQvY2hhaW4nOiAgICAgTGVmdCRwcm90b3R5cGUkY2hhaW4sXG4gICAgJ2ZhbnRhc3ktbGFuZC9hbHQnOiAgICAgICBMZWZ0JHByb3RvdHlwZSRhbHQsXG4gICAgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnOiAgICBMZWZ0JHByb3RvdHlwZSRyZWR1Y2UsXG4gICAgJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSc6ICBMZWZ0JHByb3RvdHlwZSR0cmF2ZXJzZSxcbiAgICAnZmFudGFzeS1sYW5kL2V4dGVuZCc6ICAgIExlZnQkcHJvdG90eXBlJGV4dGVuZFxuICAgIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgfTtcblxuICB2YXIgUmlnaHQkcHJvdG90eXBlID0ge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gICAgJ2NvbnN0cnVjdG9yJzogICAgICAgICAgICBFaXRoZXIsXG4gICAgJ2lzTGVmdCc6ICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnaXNSaWdodCc6ICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ0BAc2hvdyc6ICAgICAgICAgICAgICAgICBSaWdodCRwcm90b3R5cGUkc2hvdyxcbiAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgIFJpZ2h0JHByb3RvdHlwZSRtYXAsXG4gICAgJ2ZhbnRhc3ktbGFuZC9iaW1hcCc6ICAgICBSaWdodCRwcm90b3R5cGUkYmltYXAsXG4gICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICBSaWdodCRwcm90b3R5cGUkYXAsXG4gICAgJ2ZhbnRhc3ktbGFuZC9jaGFpbic6ICAgICBSaWdodCRwcm90b3R5cGUkY2hhaW4sXG4gICAgJ2ZhbnRhc3ktbGFuZC9hbHQnOiAgICAgICBSaWdodCRwcm90b3R5cGUkYWx0LFxuICAgICdmYW50YXN5LWxhbmQvcmVkdWNlJzogICAgUmlnaHQkcHJvdG90eXBlJHJlZHVjZSxcbiAgICAnZmFudGFzeS1sYW5kL3RyYXZlcnNlJzogIFJpZ2h0JHByb3RvdHlwZSR0cmF2ZXJzZSxcbiAgICAnZmFudGFzeS1sYW5kL2V4dGVuZCc6ICAgIFJpZ2h0JHByb3RvdHlwZSRleHRlbmRcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIH07XG5cbiAgdmFyIHV0aWwgPVxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcgP1xuICAgIHJlcXVpcmUgKCd1dGlsJykgOlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9O1xuICB2YXIgaW5zcGVjdCA9XG4gICAgdXRpbC5pbnNwZWN0ICE9IG51bGwgJiYgdHlwZW9mIHV0aWwuaW5zcGVjdC5jdXN0b20gPT09ICdzeW1ib2wnID9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmluc3BlY3QuY3VzdG9tIDpcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAnaW5zcGVjdCc7XG4gIExlZnQkcHJvdG90eXBlW2luc3BlY3RdID0gTGVmdCRwcm90b3R5cGUkc2hvdztcbiAgUmlnaHQkcHJvdG90eXBlW2luc3BlY3RdID0gUmlnaHQkcHJvdG90eXBlJHNob3c7XG5cbiAgLy8uIGBFaXRoZXIgYSBiYCBzYXRpc2ZpZXMgdGhlIGZvbGxvd2luZyBbRmFudGFzeSBMYW5kXVtdIHNwZWNpZmljYXRpb25zOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29uc3QgVXNlbGVzcyA9IHJlcXVpcmUgKCdzYW5jdHVhcnktdXNlbGVzcycpXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoayA9PiBrICsgJyAnLnJlcGVhdCAoMTYgLSBrLmxlbmd0aCkgK1xuICAvLy4gLiAgICAgICAgICAgICAoWltrXS50ZXN0IChSaWdodCAoVXNlbGVzcykpID8gJ1xcdTI3MDUgICAnIDpcbiAgLy8uIC4gICAgICAgICAgICAgIFpba10udGVzdCAoUmlnaHQgKFsnZm9vJ10pKSA/ICdcXHUyNzA1ICogJyA6XG4gIC8vLiAuICAgICAgICAgICAgICAvKiBvdGhlcndpc2UgKi8gICAgICAgICAgICAgICAnXFx1Mjc0QyAgICcpKVxuICAvLy4gLiAgICAgICAoUy5rZXlzIChaLmZpbHRlciAoJC50ZXN0IChbXSkgKCQuVHlwZUNsYXNzKSwgWikpKVxuICAvLy4gWyAnU2V0b2lkICAgICAgICAgIOKchSAqICcsICAvLyBpZiDigJhh4oCZIGFuZCDigJhi4oCZIHNhdGlzZnkgU2V0b2lkXG4gIC8vLiAuICdPcmQgICAgICAgICAgICAg4pyFICogJywgIC8vIGlmIOKAmGHigJkgYW5kIOKAmGLigJkgc2F0aXNmeSBPcmRcbiAgLy8uIC4gJ1NlbWlncm91cG9pZCAgICDinYwgICAnLFxuICAvLy4gLiAnQ2F0ZWdvcnkgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdTZW1pZ3JvdXAgICAgICAg4pyFICogJywgIC8vIGlmIOKAmGHigJkgYW5kIOKAmGLigJkgc2F0aXNmeSBTZW1pZ3JvdXBcbiAgLy8uIC4gJ01vbm9pZCAgICAgICAgICDinYwgICAnLFxuICAvLy4gLiAnR3JvdXAgICAgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdGaWx0ZXJhYmxlICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0Z1bmN0b3IgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnQmlmdW5jdG9yICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdQcm9mdW5jdG9yICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0FwcGx5ICAgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnQXBwbGljYXRpdmUgICAgIOKchSAgICcsXG4gIC8vLiAuICdDaGFpbiAgICAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0NoYWluUmVjICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnTW9uYWQgICAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdBbHQgICAgICAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ1BsdXMgICAgICAgICAgICDinYwgICAnLFxuICAvLy4gLiAnQWx0ZXJuYXRpdmUgICAgIOKdjCAgICcsXG4gIC8vLiAuICdGb2xkYWJsZSAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ1RyYXZlcnNhYmxlICAgICDinIUgICAnLFxuICAvLy4gLiAnRXh0ZW5kICAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdDb21vbmFkICAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0NvbnRyYXZhcmlhbnQgICDinYwgICAnIF1cbiAgLy8uIGBgYFxuXG4gIC8vIyBFaXRoZXIgOjogVHlwZVJlcCBFaXRoZXJcbiAgLy8uXG4gIC8vLiBFaXRoZXIgW3R5cGUgcmVwcmVzZW50YXRpdmVdW10uXG5cbiAgLy8jIEVpdGhlci5MZWZ0IDo6IGEgLT4gRWl0aGVyIGEgYlxuICAvLy5cbiAgLy8uIENvbnN0cnVjdHMgYSB2YWx1ZSBvZiB0eXBlIGBFaXRoZXIgYSBiYCBmcm9tIGEgdmFsdWUgb2YgdHlwZSBgYWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJylcbiAgLy8uIExlZnQgKCdzcXJ0IHVuZGVmaW5lZCBmb3IgLTEnKVxuICAvLy4gYGBgXG4gIHZhciBMZWZ0ID0gRWl0aGVyLkxlZnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBsZWZ0ID0gT2JqZWN0LmNyZWF0ZSAoTGVmdCRwcm90b3R5cGUpO1xuICAgIGlmIChaLlNldG9pZC50ZXN0ICh2YWx1ZSkpIHtcbiAgICAgIGxlZnRbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9IExlZnQkcHJvdG90eXBlJGVxdWFscztcbiAgICAgIGlmIChaLk9yZC50ZXN0ICh2YWx1ZSkpIHtcbiAgICAgICAgbGVmdFsnZmFudGFzeS1sYW5kL2x0ZSddID0gTGVmdCRwcm90b3R5cGUkbHRlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoWi5TZW1pZ3JvdXAudGVzdCAodmFsdWUpKSB7XG4gICAgICBsZWZ0WydmYW50YXN5LWxhbmQvY29uY2F0J10gPSBMZWZ0JHByb3RvdHlwZSRjb25jYXQ7XG4gICAgfVxuICAgIGxlZnQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gbGVmdDtcbiAgfTtcblxuICAvLyMgRWl0aGVyLlJpZ2h0IDo6IGIgLT4gRWl0aGVyIGEgYlxuICAvLy5cbiAgLy8uIENvbnN0cnVjdHMgYSB2YWx1ZSBvZiB0eXBlIGBFaXRoZXIgYSBiYCBmcm9tIGEgdmFsdWUgb2YgdHlwZSBgYmAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBSaWdodCAoNDIpXG4gIC8vLiBSaWdodCAoNDIpXG4gIC8vLiBgYGBcbiAgdmFyIFJpZ2h0ID0gRWl0aGVyLlJpZ2h0ID0gZnVuY3Rpb24gUmlnaHQodmFsdWUpIHtcbiAgICB2YXIgcmlnaHQgPSBPYmplY3QuY3JlYXRlIChSaWdodCRwcm90b3R5cGUpO1xuICAgIGlmIChaLlNldG9pZC50ZXN0ICh2YWx1ZSkpIHtcbiAgICAgIHJpZ2h0WydmYW50YXN5LWxhbmQvZXF1YWxzJ10gPSBSaWdodCRwcm90b3R5cGUkZXF1YWxzO1xuICAgICAgaWYgKFouT3JkLnRlc3QgKHZhbHVlKSkge1xuICAgICAgICByaWdodFsnZmFudGFzeS1sYW5kL2x0ZSddID0gUmlnaHQkcHJvdG90eXBlJGx0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFouU2VtaWdyb3VwLnRlc3QgKHZhbHVlKSkge1xuICAgICAgcmlnaHRbJ2ZhbnRhc3ktbGFuZC9jb25jYXQnXSA9IFJpZ2h0JHByb3RvdHlwZSRjb25jYXQ7XG4gICAgfVxuICAgIHJpZ2h0LnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIC8vIyBFaXRoZXIuQEB0eXBlIDo6IFN0cmluZ1xuICAvLy5cbiAgLy8uIEVpdGhlciBbdHlwZSBpZGVudGlmaWVyXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gdHlwZSAoUmlnaHQgKDQyKSlcbiAgLy8uICdzYW5jdHVhcnktZWl0aGVyL0VpdGhlckAxJ1xuICAvLy5cbiAgLy8uID4gdHlwZS5wYXJzZSAodHlwZSAoUmlnaHQgKDQyKSkpXG4gIC8vLiB7bmFtZXNwYWNlOiAnc2FuY3R1YXJ5LWVpdGhlcicsIG5hbWU6ICdFaXRoZXInLCB2ZXJzaW9uOiAxfVxuICAvLy4gYGBgXG4gIEVpdGhlclsnQEB0eXBlJ10gPSAnc2FuY3R1YXJ5LWVpdGhlci9FaXRoZXJAMSc7XG5cbiAgLy8jIEVpdGhlci5mYW50YXN5LWxhbmQvb2YgOjogYiAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gICAtIGBvZiAoRWl0aGVyKSAoeClgIGlzIGVxdWl2YWxlbnQgdG8gYFJpZ2h0ICh4KWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMub2YgKEVpdGhlcikgKDQyKVxuICAvLy4gUmlnaHQgKDQyKVxuICAvLy4gYGBgXG4gIEVpdGhlclsnZmFudGFzeS1sYW5kL29mJ10gPSBSaWdodDtcblxuICBmdW5jdGlvbiBuZXh0KHgpIHsgcmV0dXJuIHt0YWc6IG5leHQsIHZhbHVlOiB4fTsgfVxuICBmdW5jdGlvbiBkb25lKHgpIHsgcmV0dXJuIHt0YWc6IGRvbmUsIHZhbHVlOiB4fTsgfVxuXG4gIC8vIyBFaXRoZXIuZmFudGFzeS1sYW5kL2NoYWluUmVjIDo6ICgoYSAtPiBjLCBiIC0+IGMsIGEpIC0+IEVpdGhlciBkIGMsIGEpIC0+IEVpdGhlciBkIGJcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFouY2hhaW5SZWMgKFxuICAvLy4gLiAgIEVpdGhlcixcbiAgLy8uIC4gICAobmV4dCwgZG9uZSwgeCkgPT5cbiAgLy8uIC4gICAgIHggPD0gMSA/IExlZnQgKCchIScpIDogUmlnaHQgKHggPj0gMTAwMCA/IGRvbmUgKHgpIDogbmV4dCAoeCAqIHgpKSxcbiAgLy8uIC4gICAxXG4gIC8vLiAuIClcbiAgLy8uIExlZnQgKCchIScpXG4gIC8vLlxuICAvLy4gPiBaLmNoYWluUmVjIChcbiAgLy8uIC4gICBFaXRoZXIsXG4gIC8vLiAuICAgKG5leHQsIGRvbmUsIHgpID0+XG4gIC8vLiAuICAgICB4IDw9IDEgPyBMZWZ0ICgnISEnKSA6IFJpZ2h0ICh4ID49IDEwMDAgPyBkb25lICh4KSA6IG5leHQgKHggKiB4KSksXG4gIC8vLiAuICAgMlxuICAvLy4gLiApXG4gIC8vLiBSaWdodCAoNjU1MzYpXG4gIC8vLiBgYGBcbiAgRWl0aGVyWydmYW50YXN5LWxhbmQvY2hhaW5SZWMnXSA9IGZ1bmN0aW9uKGYsIHgpIHtcbiAgICB2YXIgciA9IG5leHQgKHgpO1xuICAgIHdoaWxlIChyLnRhZyA9PT0gbmV4dCkge1xuICAgICAgdmFyIGVpdGhlciA9IGYgKG5leHQsIGRvbmUsIHIudmFsdWUpO1xuICAgICAgaWYgKGVpdGhlci5pc0xlZnQpIHJldHVybiBlaXRoZXI7XG4gICAgICByID0gZWl0aGVyLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gUmlnaHQgKHIudmFsdWUpO1xuICB9O1xuXG4gIC8vIyBFaXRoZXIjQEBzaG93IDo6IChTaG93YWJsZSBhLCBTaG93YWJsZSBiKSA9PiBFaXRoZXIgYSBiIH4+ICgpIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uICAgLSBgc2hvdyAoTGVmdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGAnTGVmdCAoJyArIHNob3cgKHgpICsgJyknYFxuICAvLy4gICAtIGBzaG93IChSaWdodCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGAnUmlnaHQgKCcgKyBzaG93ICh4KSArICcpJ2BcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNob3cgKExlZnQgKCdzcXJ0IHVuZGVmaW5lZCBmb3IgLTEnKSlcbiAgLy8uICdMZWZ0IChcInNxcnQgdW5kZWZpbmVkIGZvciAtMVwiKSdcbiAgLy8uXG4gIC8vLiA+IHNob3cgKFJpZ2h0IChbMSwgMiwgM10pKVxuICAvLy4gJ1JpZ2h0IChbMSwgMiwgM10pJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIExlZnQkcHJvdG90eXBlJHNob3coKSB7XG4gICAgcmV0dXJuICdMZWZ0ICgnICsgc2hvdyAodGhpcy52YWx1ZSkgKyAnKSc7XG4gIH1cbiAgZnVuY3Rpb24gUmlnaHQkcHJvdG90eXBlJHNob3coKSB7XG4gICAgcmV0dXJuICdSaWdodCAoJyArIHNob3cgKHRoaXMudmFsdWUpICsgJyknO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvZXF1YWxzIDo6IChTZXRvaWQgYSwgU2V0b2lkIGIpID0+IEVpdGhlciBhIGIgfj4gRWl0aGVyIGEgYiAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gICAtIGBMZWZ0ICh4KWAgaXMgZXF1YWwgdG8gYExlZnQgKHkpYCBbaWZmXVtdIGB4YCBpcyBlcXVhbCB0byBgeWBcbiAgLy8uICAgICBhY2NvcmRpbmcgdG8gW2BaLmVxdWFsc2BdW11cbiAgLy8uICAgLSBgUmlnaHQgKHgpYCBpcyBlcXVhbCB0byBgUmlnaHQgKHkpYCBbaWZmXVtdIGB4YCBpcyBlcXVhbCB0byBgeWBcbiAgLy8uICAgICBhY2NvcmRpbmcgdG8gW2BaLmVxdWFsc2BdW11cbiAgLy8uICAgLSBgTGVmdCAoeClgIGlzIG5ldmVyIGVxdWFsIHRvIGBSaWdodCAoeSlgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVxdWFscyAoTGVmdCAoWzEsIDIsIDNdKSkgKExlZnQgKFsxLCAyLCAzXSkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmVxdWFscyAoUmlnaHQgKFsxLCAyLCAzXSkpIChSaWdodCAoWzEsIDIsIDNdKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuZXF1YWxzIChMZWZ0IChbMSwgMiwgM10pKSAoUmlnaHQgKFsxLCAyLCAzXSkpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIExlZnQkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlci5pc0xlZnQgJiYgWi5lcXVhbHMgKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBSaWdodCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzUmlnaHQgJiYgWi5lcXVhbHMgKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgfVxuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL2x0ZSA6OiAoT3JkIGEsIE9yZCBiKSA9PiBFaXRoZXIgYSBiIH4+IEVpdGhlciBhIGIgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uICAgLSBgTGVmdCAoeClgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTGVmdCAoeSlgIFtpZmZdW10gYHhgIGlzIGxlc3NcbiAgLy8uICAgICB0aGFuIG9yIGVxdWFsIHRvIGB5YCBhY2NvcmRpbmcgdG8gW2BaLmx0ZWBdW11cbiAgLy8uICAgLSBgUmlnaHQgKHgpYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYFJpZ2h0ICh5KWAgW2lmZl1bXSBgeGAgaXMgbGVzc1xuICAvLy4gICAgIHRoYW4gb3IgZXF1YWwgdG8gYHlgIGFjY29yZGluZyB0byBbYFoubHRlYF1bXVxuICAvLy4gICAtIGBMZWZ0ICh4KWAgaXMgYWx3YXlzIGxlc3MgdGhhbiBgUmlnaHQgKHkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maWx0ZXIgKFMubHRlIChMZWZ0ICgxKSkpIChbTGVmdCAoMCksIExlZnQgKDEpLCBMZWZ0ICgyKV0pXG4gIC8vLiBbTGVmdCAoMCksIExlZnQgKDEpXVxuICAvLy5cbiAgLy8uID4gUy5maWx0ZXIgKFMubHRlIChSaWdodCAoMSkpKSAoW1JpZ2h0ICgwKSwgUmlnaHQgKDEpLCBSaWdodCAoMildKVxuICAvLy4gW1JpZ2h0ICgwKSwgUmlnaHQgKDEpXVxuICAvLy5cbiAgLy8uID4gUy5maWx0ZXIgKFMubHRlIChMZWZ0ICgxKSkpIChbUmlnaHQgKDApLCBSaWdodCAoMSksIFJpZ2h0ICgyKV0pXG4gIC8vLiBbXVxuICAvLy5cbiAgLy8uID4gUy5maWx0ZXIgKFMubHRlIChSaWdodCAoMSkpKSAoW0xlZnQgKDApLCBMZWZ0ICgxKSwgTGVmdCAoMildKVxuICAvLy4gW0xlZnQgKDApLCBMZWZ0ICgxKSwgTGVmdCAoMildXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTGVmdCRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzUmlnaHQgfHwgWi5sdGUgKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBSaWdodCRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzUmlnaHQgJiYgWi5sdGUgKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgfVxuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL2NvbmNhdCA6OiAoU2VtaWdyb3VwIGEsIFNlbWlncm91cCBiKSA9PiBFaXRoZXIgYSBiIH4+IEVpdGhlciBhIGIgLT4gRWl0aGVyIGEgYlxuICAvLy5cbiAgLy8uICAgLSBgY29uY2F0IChMZWZ0ICh4KSkgKExlZnQgKHkpKWAgaXMgZXF1aXZhbGVudCB0b1xuICAvLy4gICAgIGBMZWZ0IChjb25jYXQgKHgpICh5KSlgXG4gIC8vLiAgIC0gYGNvbmNhdCAoUmlnaHQgKHgpKSAoUmlnaHQgKHkpKWAgaXMgZXF1aXZhbGVudCB0b1xuICAvLy4gICAgIGBSaWdodCAoY29uY2F0ICh4KSAoeSkpYFxuICAvLy4gICAtIGBjb25jYXQgKExlZnQgKHgpKSAoUmlnaHQgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgUmlnaHQgKHkpYFxuICAvLy4gICAtIGBjb25jYXQgKFJpZ2h0ICh4KSkgKExlZnQgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgUmlnaHQgKHgpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jb25jYXQgKExlZnQgKCdhYmMnKSkgKExlZnQgKCdkZWYnKSlcbiAgLy8uIExlZnQgKCdhYmNkZWYnKVxuICAvLy5cbiAgLy8uID4gUy5jb25jYXQgKFJpZ2h0IChbMSwgMiwgM10pKSAoUmlnaHQgKFs0LCA1LCA2XSkpXG4gIC8vLiBSaWdodCAoWzEsIDIsIDMsIDQsIDUsIDZdKVxuICAvLy5cbiAgLy8uID4gUy5jb25jYXQgKExlZnQgKCdhYmMnKSkgKFJpZ2h0IChbMSwgMiwgM10pKVxuICAvLy4gUmlnaHQgKFsxLCAyLCAzXSlcbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0IChSaWdodCAoWzEsIDIsIDNdKSkgKExlZnQgKCdhYmMnKSlcbiAgLy8uIFJpZ2h0IChbMSwgMiwgM10pXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTGVmdCRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzTGVmdCA/IExlZnQgKFouY29uY2F0ICh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSkpIDogb3RoZXI7XG4gIH1cbiAgZnVuY3Rpb24gUmlnaHQkcHJvdG90eXBlJGNvbmNhdChvdGhlcikge1xuICAgIHJldHVybiBvdGhlci5pc1JpZ2h0ID8gUmlnaHQgKFouY29uY2F0ICh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSkpIDogdGhpcztcbiAgfVxuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL21hcCA6OiBFaXRoZXIgYSBiIH4+IChiIC0+IGMpIC0+IEVpdGhlciBhIGNcbiAgLy8uXG4gIC8vLiAgIC0gYG1hcCAoZikgKExlZnQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgTGVmdCAoeClgXG4gIC8vLiAgIC0gYG1hcCAoZikgKFJpZ2h0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYFJpZ2h0IChmICh4KSlgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcCAoUy5hZGQgKDEpKSAoTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpKVxuICAvLy4gTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoUy5hZGQgKDEpKSAoUmlnaHQgKDk5KSlcbiAgLy8uIFJpZ2h0ICgxMDApXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTGVmdCRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBSaWdodCRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICByZXR1cm4gUmlnaHQgKGYgKHRoaXMudmFsdWUpKTtcbiAgfVxuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL2JpbWFwIDo6IEVpdGhlciBhIGMgfj4gKGEgLT4gYiwgYyAtPiBkKSAtPiBFaXRoZXIgYiBkXG4gIC8vLlxuICAvLy4gICAtIGBiaW1hcCAoZikgKGcpIChMZWZ0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYExlZnQgKGYgKHgpKWBcbiAgLy8uICAgLSBgYmltYXAgKGYpIChnKSAoUmlnaHQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgUmlnaHQgKGcgKHgpKWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYmltYXAgKFMudG9VcHBlcikgKFMuYWRkICgxKSkgKExlZnQgKCdhYmMnKSlcbiAgLy8uIExlZnQgKCdBQkMnKVxuICAvLy5cbiAgLy8uID4gUy5iaW1hcCAoUy50b1VwcGVyKSAoUy5hZGQgKDEpKSAoUmlnaHQgKDk5KSlcbiAgLy8uIFJpZ2h0ICgxMDApXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTGVmdCRwcm90b3R5cGUkYmltYXAoZiwgZykge1xuICAgIHJldHVybiBMZWZ0IChmICh0aGlzLnZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gUmlnaHQkcHJvdG90eXBlJGJpbWFwKGYsIGcpIHtcbiAgICByZXR1cm4gUmlnaHQgKGcgKHRoaXMudmFsdWUpKTtcbiAgfVxuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL2FwIDo6IEVpdGhlciBhIGIgfj4gRWl0aGVyIGEgKGIgLT4gYykgLT4gRWl0aGVyIGEgY1xuICAvLy5cbiAgLy8uICAgLSBgYXAgKExlZnQgKHgpKSAoTGVmdCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBMZWZ0ICh4KWBcbiAgLy8uICAgLSBgYXAgKExlZnQgKHgpKSAoUmlnaHQgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgTGVmdCAoeClgXG4gIC8vLiAgIC0gYGFwIChSaWdodCAoZikpIChMZWZ0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYExlZnQgKHgpYFxuICAvLy4gICAtIGBhcCAoUmlnaHQgKGYpKSAoUmlnaHQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgUmlnaHQgKGYgKHgpKWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXAgKExlZnQgKCdkaXYgdW5kZWZpbmVkIGZvciAwJykpIChMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJykpXG4gIC8vLiBMZWZ0ICgnZGl2IHVuZGVmaW5lZCBmb3IgMCcpXG4gIC8vLlxuICAvLy4gPiBTLmFwIChMZWZ0ICgnZGl2IHVuZGVmaW5lZCBmb3IgMCcpKSAoUmlnaHQgKDk5KSlcbiAgLy8uIExlZnQgKCdkaXYgdW5kZWZpbmVkIGZvciAwJylcbiAgLy8uXG4gIC8vLiA+IFMuYXAgKFJpZ2h0IChTLmFkZCAoMSkpKSAoTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpKVxuICAvLy4gTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpXG4gIC8vLlxuICAvLy4gPiBTLmFwIChSaWdodCAoUy5hZGQgKDEpKSkgKFJpZ2h0ICg5OSkpXG4gIC8vLiBSaWdodCAoMTAwKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIExlZnQkcHJvdG90eXBlJGFwKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzTGVmdCA/IG90aGVyIDogdGhpcztcbiAgfVxuICBmdW5jdGlvbiBSaWdodCRwcm90b3R5cGUkYXAob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNMZWZ0ID8gb3RoZXIgOiBSaWdodCAob3RoZXIudmFsdWUgKHRoaXMudmFsdWUpKTtcbiAgfVxuXG4gIC8vIyBFaXRoZXIjZmFudGFzeS1sYW5kL2NoYWluIDo6IEVpdGhlciBhIGIgfj4gKGIgLT4gRWl0aGVyIGEgYykgLT4gRWl0aGVyIGEgY1xuICAvLy5cbiAgLy8uICAgLSBgY2hhaW4gKGYpIChMZWZ0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYExlZnQgKHgpYFxuICAvLy4gICAtIGBjaGFpbiAoZikgKFJpZ2h0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYGYgKHgpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29uc3Qgc3FydCA9IG4gPT4gbiA8IDAgPyBMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yICcgKyBzaG93IChuKSlcbiAgLy8uIC4gICAgICAgICAgICAgICAgICAgICAgICAgOiBSaWdodCAoTWF0aC5zcXJ0IChuKSlcbiAgLy8uXG4gIC8vLiA+IFMuY2hhaW4gKHNxcnQpIChMZWZ0ICgnZGl2IHVuZGVmaW5lZCBmb3IgMCcpKVxuICAvLy4gTGVmdCAoJ2RpdiB1bmRlZmluZWQgZm9yIDAnKVxuICAvLy5cbiAgLy8uID4gUy5jaGFpbiAoc3FydCkgKFJpZ2h0ICgtMSkpXG4gIC8vLiBMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJylcbiAgLy8uXG4gIC8vLiA+IFMuY2hhaW4gKHNxcnQpIChSaWdodCAoMjUpKVxuICAvLy4gUmlnaHQgKDUpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTGVmdCRwcm90b3R5cGUkY2hhaW4oZikge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIFJpZ2h0JHByb3RvdHlwZSRjaGFpbihmKSB7XG4gICAgcmV0dXJuIGYgKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvYWx0IDo6IEVpdGhlciBhIGIgfj4gRWl0aGVyIGEgYiAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gICAtIGBhbHQgKExlZnQgKHgpKSAoTGVmdCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBMZWZ0ICh5KWBcbiAgLy8uICAgLSBgYWx0IChMZWZ0ICh4KSkgKFJpZ2h0ICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYFJpZ2h0ICh5KWBcbiAgLy8uICAgLSBgYWx0IChSaWdodCAoeCkpIChMZWZ0ICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYFJpZ2h0ICh4KWBcbiAgLy8uICAgLSBgYWx0IChSaWdodCAoeCkpIChSaWdodCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBSaWdodCAoeClgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFsdCAoTGVmdCAoJ0EnKSkgKExlZnQgKCdCJykpXG4gIC8vLiBMZWZ0ICgnQicpXG4gIC8vLlxuICAvLy4gPiBTLmFsdCAoTGVmdCAoJ0MnKSkgKFJpZ2h0ICgxKSlcbiAgLy8uIFJpZ2h0ICgxKVxuICAvLy5cbiAgLy8uID4gUy5hbHQgKFJpZ2h0ICgyKSkgKExlZnQgKCdEJykpXG4gIC8vLiBSaWdodCAoMilcbiAgLy8uXG4gIC8vLiA+IFMuYWx0IChSaWdodCAoMykpIChSaWdodCAoNCkpXG4gIC8vLiBSaWdodCAoMylcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBMZWZ0JHByb3RvdHlwZSRhbHQob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXI7XG4gIH1cbiAgZnVuY3Rpb24gUmlnaHQkcHJvdG90eXBlJGFsdChvdGhlcikge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvcmVkdWNlIDo6IEVpdGhlciBhIGIgfj4gKChjLCBiKSAtPiBjLCBjKSAtPiBjXG4gIC8vLlxuICAvLy4gICAtIGByZWR1Y2UgKGYpICh4KSAoTGVmdCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGB4YFxuICAvLy4gICAtIGByZWR1Y2UgKGYpICh4KSAoUmlnaHQgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgZiAoeCkgKHkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yZWR1Y2UgKFMuY29uY2F0KSAoWzFdKSAoTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpKVxuICAvLy4gWzFdXG4gIC8vLlxuICAvLy4gPiBTLnJlZHVjZSAoUy5jb25jYXQpIChbMV0pIChSaWdodCAoWzJdKSlcbiAgLy8uIFsxLCAyXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIExlZnQkcHJvdG90eXBlJHJlZHVjZShmLCB4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgZnVuY3Rpb24gUmlnaHQkcHJvdG90eXBlJHJlZHVjZShmLCB4KSB7XG4gICAgcmV0dXJuIGYgKHgsIHRoaXMudmFsdWUpO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvdHJhdmVyc2UgOjogQXBwbGljYXRpdmUgZiA9PiBFaXRoZXIgYSBiIH4+IChUeXBlUmVwIGYsIGIgLT4gZiBjKSAtPiBmIChFaXRoZXIgYSBjKVxuICAvLy5cbiAgLy8uICAgLSBgdHJhdmVyc2UgKEEpIChmKSAoTGVmdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBvZiAoQSkgKExlZnQgKHgpKWBcbiAgLy8uICAgLSBgdHJhdmVyc2UgKEEpIChmKSAoUmlnaHQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgbWFwIChSaWdodCkgKGYgKHgpKWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudHJhdmVyc2UgKEFycmF5KSAoUy53b3JkcykgKExlZnQgKCdzcXJ0IHVuZGVmaW5lZCBmb3IgLTEnKSlcbiAgLy8uIFtMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJyldXG4gIC8vLlxuICAvLy4gPiBTLnRyYXZlcnNlIChBcnJheSkgKFMud29yZHMpIChSaWdodCAoJ2ZvbyBiYXIgYmF6JykpXG4gIC8vLiBbUmlnaHQgKCdmb28nKSwgUmlnaHQgKCdiYXInKSwgUmlnaHQgKCdiYXonKV1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBMZWZ0JHByb3RvdHlwZSR0cmF2ZXJzZSh0eXBlUmVwLCBmKSB7XG4gICAgcmV0dXJuIFoub2YgKHR5cGVSZXAsIHRoaXMpO1xuICB9XG4gIGZ1bmN0aW9uIFJpZ2h0JHByb3RvdHlwZSR0cmF2ZXJzZSh0eXBlUmVwLCBmKSB7XG4gICAgcmV0dXJuIFoubWFwIChSaWdodCwgZiAodGhpcy52YWx1ZSkpO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvZXh0ZW5kIDo6IEVpdGhlciBhIGIgfj4gKEVpdGhlciBhIGIgLT4gYykgLT4gRWl0aGVyIGEgY1xuICAvLy5cbiAgLy8uICAgLSBgZXh0ZW5kIChmKSAoTGVmdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBMZWZ0ICh4KWBcbiAgLy8uICAgLSBgZXh0ZW5kIChmKSAoUmlnaHQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgUmlnaHQgKGYgKFJpZ2h0ICh4KSkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5leHRlbmQgKFMucmVkdWNlIChTLmFkZCkgKDEpKSAoTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpKVxuICAvLy4gTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpXG4gIC8vLlxuICAvLy4gPiBTLmV4dGVuZCAoUy5yZWR1Y2UgKFMuYWRkKSAoMSkpIChSaWdodCAoOTkpKVxuICAvLy4gUmlnaHQgKDEwMClcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBMZWZ0JHByb3RvdHlwZSRleHRlbmQoZikge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIFJpZ2h0JHByb3RvdHlwZSRleHRlbmQoZikge1xuICAgIHJldHVybiBSaWdodCAoZiAodGhpcykpO1xuICB9XG5cbiAgcmV0dXJuIEVpdGhlcjtcblxufSkpO1xuXG4vLy4gW0ZhbnRhc3kgTGFuZF06ICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kXG4vLy4gW2BaLmVxdWFsc2BdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZXF1YWxzXG4vLy4gW2BaLmx0ZWBdOiAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjbHRlXG4vLy4gW2lmZl06ICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lmX2FuZF9vbmx5X2lmXG4vLy4gW3R5cGUgaWRlbnRpZmllcl06ICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzXG4vLy4gW3R5cGUgcmVwcmVzZW50YXRpdmVdOiAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3R5cGUtcmVwcmVzZW50YXRpdmVzXG4iLCIvKlxuICAgICxfX19fX18gIF9fX19fXywgICxfX19fX19fXywsX19fX18sLF9fX19fLCxfX19fX19fX19fICAsX19fX19fX19fXyxcbiAgICB8ICAgICAgXFwvICAgICAgfCAgfCAgICAgICAgfHwgICAgIHx8ICAgICB8fCAgICAgICAgICBcXCB8ICAgICAgICAgIHxcbiAgICB8XywgICAgICAgICAgLF98ICB8XyAgICAgIF98fF8gICAgfHwgICAgX3x8XywgICBfXyAgICB8fF8sICAgX19fX198XG4gICAgICB8ICAgXFwgIC8gICB8ICAgICAvICAgICAgXFwgICBcXCAgIFxcLyAgIC8gICAgfCAgICAgICAgLyAgIHwgICAgICB8XG4gICAgLF98ICAgIHx8ICAgIHxfLCxfLyAgIC9cXCAgIFxcXywgXFwgICAgICAvICAgLF98ICAgX18gICBcXCAsX3wgICBfX198XyxcbiAgICB8ICAgICAgfHwgICAgICB8fCAgICAgfHwgICAgIHwgIHwgICAgfCAgICB8ICAgICAgICAgICB8fCAgICAgICAgICB8XG4gICAgfF9fX19fX3x8X19fX19ffHxfX19fX3x8X19fX198ICB8X19fX3wgICAgfF9fX19fX19fX18vIHxfX19fX19fX19ffFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbi8vLiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZFwiPjxpbWcgYWx0PVwiRmFudGFzeSBMYW5kXCIgc3JjPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZC9tYXN0ZXIvbG9nby5wbmdcIiB3aWR0aD1cIjc1XCIgaGVpZ2h0PVwiNzVcIiBhbGlnbj1cImxlZnRcIj48L2E+XG4vLy5cbi8vLiAjIHNhbmN0dWFyeS1tYXliZVxuLy8uXG4vLy4gVGhlIE1heWJlIHR5cGUgcmVwcmVzZW50cyBvcHRpb25hbCB2YWx1ZXM6IGEgdmFsdWUgb2YgdHlwZSBgTWF5YmUgYWAgaXNcbi8vLiBlaXRoZXIgTm90aGluZyAodGhlIGVtcHR5IHZhbHVlKSBvciBhIEp1c3Qgd2hvc2UgdmFsdWUgaXMgb2YgdHlwZSBgYWAuXG5cbihmdW5jdGlvbihmKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmIChyZXF1aXJlICgnc2FuY3R1YXJ5LXNob3cnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAhPSBudWxsKSB7XG4gICAgZGVmaW5lIChbJ3NhbmN0dWFyeS1zaG93JywgJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnXSwgZik7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zYW5jdHVhcnlNYXliZSA9IGYgKHNlbGYuc2FuY3R1YXJ5U2hvdywgc2VsZi5zYW5jdHVhcnlUeXBlQ2xhc3Nlcyk7XG4gIH1cblxufSAoZnVuY3Rpb24oc2hvdywgWikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBfX2RvY3Rlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyICQgPSBfX2RvY3Rlc3QucmVxdWlyZSAoJ3NhbmN0dWFyeS1kZWYnKTtcbiAgICB2YXIgdHlwZSA9IF9fZG9jdGVzdC5yZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKTtcbiAgICB2YXIgUyA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBTID0gX19kb2N0ZXN0LnJlcXVpcmUgKCdzYW5jdHVhcnknKTtcbiAgICAgIHZhciBNYXliZVR5cGUgPSAkLlVuYXJ5VHlwZVxuICAgICAgICAoJ3NhbmN0dWFyeS1tYXliZS9NYXliZScpXG4gICAgICAgICgnJylcbiAgICAgICAgKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHR5cGUgKHgpID09PSBNYXliZVsnQEB0eXBlJ107IH0pXG4gICAgICAgIChmdW5jdGlvbihtKSB7IHJldHVybiBtLmlzSnVzdCA/IFttLnZhbHVlXSA6IFtdOyB9KTtcbiAgICAgIHZhciBlbnYgPSBaLmNvbmNhdCAoUy5lbnYsIFskLlR5cGVDbGFzcywgTWF5YmVUeXBlICgkLlVua25vd24pXSk7XG4gICAgICByZXR1cm4gUy5jcmVhdGUgKHtjaGVja1R5cGVzOiB0cnVlLCBlbnY6IGVudn0pO1xuICAgIH0gKCkpO1xuICB9XG5cbiAgdmFyIE1heWJlID0ge307XG5cbiAgdmFyIE5vdGhpbmckcHJvdG90eXBlID0ge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gICAgJ2NvbnN0cnVjdG9yJzogICAgICAgICAgICBNYXliZSxcbiAgICAnaXNOb3RoaW5nJzogICAgICAgICAgICAgIHRydWUsXG4gICAgJ2lzSnVzdCc6ICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnQEBzaG93JzogICAgICAgICAgICAgICAgIE5vdGhpbmckcHJvdG90eXBlJHNob3csXG4gICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICBOb3RoaW5nJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICBOb3RoaW5nJHByb3RvdHlwZSRsdGUsXG4gICAgJ2ZhbnRhc3ktbGFuZC9jb25jYXQnOiAgICBOb3RoaW5nJHByb3RvdHlwZSRjb25jYXQsXG4gICAgJ2ZhbnRhc3ktbGFuZC9maWx0ZXInOiAgICBOb3RoaW5nJHByb3RvdHlwZSRmaWx0ZXIsXG4gICAgJ2ZhbnRhc3ktbGFuZC9tYXAnOiAgICAgICBOb3RoaW5nJHByb3RvdHlwZSRtYXAsXG4gICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICBOb3RoaW5nJHByb3RvdHlwZSRhcCxcbiAgICAnZmFudGFzeS1sYW5kL2NoYWluJzogICAgIE5vdGhpbmckcHJvdG90eXBlJGNoYWluLFxuICAgICdmYW50YXN5LWxhbmQvYWx0JzogICAgICAgTm90aGluZyRwcm90b3R5cGUkYWx0LFxuICAgICdmYW50YXN5LWxhbmQvcmVkdWNlJzogICAgTm90aGluZyRwcm90b3R5cGUkcmVkdWNlLFxuICAgICdmYW50YXN5LWxhbmQvdHJhdmVyc2UnOiAgTm90aGluZyRwcm90b3R5cGUkdHJhdmVyc2UsXG4gICAgJ2ZhbnRhc3ktbGFuZC9leHRlbmQnOiAgICBOb3RoaW5nJHByb3RvdHlwZSRleHRlbmRcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIH07XG5cbiAgdmFyIEp1c3QkcHJvdG90eXBlID0ge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGtleS1zcGFjaW5nICovXG4gICAgJ2NvbnN0cnVjdG9yJzogICAgICAgICAgICBNYXliZSxcbiAgICAnaXNOb3RoaW5nJzogICAgICAgICAgICAgIGZhbHNlLFxuICAgICdpc0p1c3QnOiAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnQEBzaG93JzogICAgICAgICAgICAgICAgIEp1c3QkcHJvdG90eXBlJHNob3csXG4gICAgJ2ZhbnRhc3ktbGFuZC9maWx0ZXInOiAgICBKdXN0JHByb3RvdHlwZSRmaWx0ZXIsXG4gICAgJ2ZhbnRhc3ktbGFuZC9tYXAnOiAgICAgICBKdXN0JHByb3RvdHlwZSRtYXAsXG4gICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICBKdXN0JHByb3RvdHlwZSRhcCxcbiAgICAnZmFudGFzeS1sYW5kL2NoYWluJzogICAgIEp1c3QkcHJvdG90eXBlJGNoYWluLFxuICAgICdmYW50YXN5LWxhbmQvYWx0JzogICAgICAgSnVzdCRwcm90b3R5cGUkYWx0LFxuICAgICdmYW50YXN5LWxhbmQvcmVkdWNlJzogICAgSnVzdCRwcm90b3R5cGUkcmVkdWNlLFxuICAgICdmYW50YXN5LWxhbmQvdHJhdmVyc2UnOiAgSnVzdCRwcm90b3R5cGUkdHJhdmVyc2UsXG4gICAgJ2ZhbnRhc3ktbGFuZC9leHRlbmQnOiAgICBKdXN0JHByb3RvdHlwZSRleHRlbmRcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIH07XG5cbiAgdmFyIHV0aWwgPVxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcgP1xuICAgIHJlcXVpcmUgKCd1dGlsJykgOlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9O1xuICB2YXIgaW5zcGVjdCA9XG4gICAgdXRpbC5pbnNwZWN0ICE9IG51bGwgJiYgdHlwZW9mIHV0aWwuaW5zcGVjdC5jdXN0b20gPT09ICdzeW1ib2wnID9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmluc3BlY3QuY3VzdG9tIDpcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAnaW5zcGVjdCc7XG4gIE5vdGhpbmckcHJvdG90eXBlW2luc3BlY3RdID0gTm90aGluZyRwcm90b3R5cGUkc2hvdztcbiAgSnVzdCRwcm90b3R5cGVbaW5zcGVjdF0gPSBKdXN0JHByb3RvdHlwZSRzaG93O1xuXG4gIC8vLiBgTWF5YmUgYWAgc2F0aXNmaWVzIHRoZSBmb2xsb3dpbmcgW0ZhbnRhc3kgTGFuZF1bXSBzcGVjaWZpY2F0aW9uczpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNvbnN0IFVzZWxlc3MgPSByZXF1aXJlICgnc2FuY3R1YXJ5LXVzZWxlc3MnKVxuICAvLy5cbiAgLy8uID4gUy5tYXAgKGsgPT4gayArICcgJy5yZXBlYXQgKDE2IC0gay5sZW5ndGgpICtcbiAgLy8uIC4gICAgICAgICAgICAgKFpba10udGVzdCAoSnVzdCAoVXNlbGVzcykpID8gJ1xcdTI3MDUgICAnIDpcbiAgLy8uIC4gICAgICAgICAgICAgIFpba10udGVzdCAoTm90aGluZykgICAgICAgID8gJ1xcdTI3MDUgKiAnIDpcbiAgLy8uIC4gICAgICAgICAgICAgIC8qIG90aGVyd2lzZSAqLyAgICAgICAgICAgICAgJ1xcdTI3NEMgICAnKSlcbiAgLy8uIC4gICAgICAgKFMua2V5cyAoWi5maWx0ZXIgKCQudGVzdCAoW10pICgkLlR5cGVDbGFzcyksIFopKSlcbiAgLy8uIFsgJ1NldG9pZCAgICAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBzYXRpc2ZpZXMgU2V0b2lkXG4gIC8vLiAuICdPcmQgICAgICAgICAgICAg4pyFICogJywgIC8vIGlmIOKAmGHigJkgc2F0aXNmaWVzIE9yZFxuICAvLy4gLiAnU2VtaWdyb3Vwb2lkICAgIOKdjCAgICcsXG4gIC8vLiAuICdDYXRlZ29yeSAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ1NlbWlncm91cCAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBzYXRpc2ZpZXMgU2VtaWdyb3VwXG4gIC8vLiAuICdNb25vaWQgICAgICAgICAg4pyFICogJywgIC8vIGlmIOKAmGHigJkgc2F0aXNmaWVzIFNlbWlncm91cFxuICAvLy4gLiAnR3JvdXAgICAgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdGaWx0ZXJhYmxlICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0Z1bmN0b3IgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnQmlmdW5jdG9yICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdQcm9mdW5jdG9yICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0FwcGx5ICAgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnQXBwbGljYXRpdmUgICAgIOKchSAgICcsXG4gIC8vLiAuICdDaGFpbiAgICAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0NoYWluUmVjICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnTW9uYWQgICAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdBbHQgICAgICAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ1BsdXMgICAgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnQWx0ZXJuYXRpdmUgICAgIOKchSAgICcsXG4gIC8vLiAuICdGb2xkYWJsZSAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ1RyYXZlcnNhYmxlICAgICDinIUgICAnLFxuICAvLy4gLiAnRXh0ZW5kICAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdDb21vbmFkICAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0NvbnRyYXZhcmlhbnQgICDinYwgICAnIF1cbiAgLy8uIGBgYFxuXG4gIC8vIyBNYXliZSA6OiBUeXBlUmVwIE1heWJlXG4gIC8vLlxuICAvLy4gTWF5YmUgW3R5cGUgcmVwcmVzZW50YXRpdmVdW10uXG5cbiAgLy8jIE1heWJlLk5vdGhpbmcgOjogTWF5YmUgYVxuICAvLy5cbiAgLy8uIFRoZSBlbXB0eSB2YWx1ZSBvZiB0eXBlIGBNYXliZSBhYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IE5vdGhpbmdcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICB2YXIgTm90aGluZyA9IE1heWJlLk5vdGhpbmcgPSBPYmplY3QuY3JlYXRlIChOb3RoaW5nJHByb3RvdHlwZSk7XG5cbiAgLy8jIE1heWJlLkp1c3QgOjogYSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gQ29uc3RydWN0cyBhIHZhbHVlIG9mIHR5cGUgYE1heWJlIGFgIGZyb20gYSB2YWx1ZSBvZiB0eXBlIGBhYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEp1c3QgKDQyKVxuICAvLy4gSnVzdCAoNDIpXG4gIC8vLiBgYGBcbiAgdmFyIEp1c3QgPSBNYXliZS5KdXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIganVzdCA9IE9iamVjdC5jcmVhdGUgKEp1c3QkcHJvdG90eXBlKTtcbiAgICBpZiAoWi5TZXRvaWQudGVzdCAodmFsdWUpKSB7XG4gICAgICBqdXN0WydmYW50YXN5LWxhbmQvZXF1YWxzJ10gPSBKdXN0JHByb3RvdHlwZSRlcXVhbHM7XG4gICAgICBpZiAoWi5PcmQudGVzdCAodmFsdWUpKSB7XG4gICAgICAgIGp1c3RbJ2ZhbnRhc3ktbGFuZC9sdGUnXSA9IEp1c3QkcHJvdG90eXBlJGx0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFouU2VtaWdyb3VwLnRlc3QgKHZhbHVlKSkge1xuICAgICAganVzdFsnZmFudGFzeS1sYW5kL2NvbmNhdCddID0gSnVzdCRwcm90b3R5cGUkY29uY2F0O1xuICAgIH1cbiAgICBqdXN0LnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIGp1c3Q7XG4gIH07XG5cbiAgLy8jIE1heWJlLkBAdHlwZSA6OiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBNYXliZSBbdHlwZSBpZGVudGlmaWVyXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gdHlwZSAoSnVzdCAoNDIpKVxuICAvLy4gJ3NhbmN0dWFyeS1tYXliZS9NYXliZUAxJ1xuICAvLy5cbiAgLy8uID4gdHlwZS5wYXJzZSAodHlwZSAoSnVzdCAoNDIpKSlcbiAgLy8uIHtuYW1lc3BhY2U6ICdzYW5jdHVhcnktbWF5YmUnLCBuYW1lOiAnTWF5YmUnLCB2ZXJzaW9uOiAxfVxuICAvLy4gYGBgXG4gIE1heWJlWydAQHR5cGUnXSA9ICdzYW5jdHVhcnktbWF5YmUvTWF5YmVAMSc7XG5cbiAgLy8jIE1heWJlLmZhbnRhc3ktbGFuZC9lbXB0eSA6OiAoKSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gICAtIGBlbXB0eSAoTWF5YmUpYCBpcyBlcXVpdmFsZW50IHRvIGBOb3RoaW5nYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5lbXB0eSAoTWF5YmUpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgTWF5YmVbJ2ZhbnRhc3ktbGFuZC9lbXB0eSddID0gZnVuY3Rpb24oKSB7IHJldHVybiBOb3RoaW5nOyB9O1xuXG4gIC8vIyBNYXliZS5mYW50YXN5LWxhbmQvb2YgOjogYSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gICAtIGBvZiAoTWF5YmUpICh4KWAgaXMgZXF1aXZhbGVudCB0byBgSnVzdCAoeClgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm9mIChNYXliZSkgKDQyKVxuICAvLy4gSnVzdCAoNDIpXG4gIC8vLiBgYGBcbiAgTWF5YmVbJ2ZhbnRhc3ktbGFuZC9vZiddID0gSnVzdDtcblxuICBmdW5jdGlvbiBuZXh0KHgpIHsgcmV0dXJuIHt0YWc6IG5leHQsIHZhbHVlOiB4fTsgfVxuICBmdW5jdGlvbiBkb25lKHgpIHsgcmV0dXJuIHt0YWc6IGRvbmUsIHZhbHVlOiB4fTsgfVxuXG4gIC8vIyBNYXliZS5mYW50YXN5LWxhbmQvY2hhaW5SZWMgOjogKChhIC0+IGMsIGIgLT4gYywgYSkgLT4gTWF5YmUgYywgYSkgLT4gTWF5YmUgYlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gWi5jaGFpblJlYyAoXG4gIC8vLiAuICAgTWF5YmUsXG4gIC8vLiAuICAgKG5leHQsIGRvbmUsIHgpID0+XG4gIC8vLiAuICAgICB4IDw9IDEgPyBOb3RoaW5nIDogSnVzdCAoeCA+PSAxMDAwID8gZG9uZSAoeCkgOiBuZXh0ICh4ICogeCkpLFxuICAvLy4gLiAgIDFcbiAgLy8uIC4gKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gWi5jaGFpblJlYyAoXG4gIC8vLiAuICAgTWF5YmUsXG4gIC8vLiAuICAgKG5leHQsIGRvbmUsIHgpID0+XG4gIC8vLiAuICAgICB4IDw9IDEgPyBOb3RoaW5nIDogSnVzdCAoeCA+PSAxMDAwID8gZG9uZSAoeCkgOiBuZXh0ICh4ICogeCkpLFxuICAvLy4gLiAgIDJcbiAgLy8uIC4gKVxuICAvLy4gSnVzdCAoNjU1MzYpXG4gIC8vLiBgYGBcbiAgTWF5YmVbJ2ZhbnRhc3ktbGFuZC9jaGFpblJlYyddID0gZnVuY3Rpb24oZiwgeCkge1xuICAgIHZhciByID0gbmV4dCAoeCk7XG4gICAgd2hpbGUgKHIudGFnID09PSBuZXh0KSB7XG4gICAgICB2YXIgbWF5YmUgPSBmIChuZXh0LCBkb25lLCByLnZhbHVlKTtcbiAgICAgIGlmIChtYXliZS5pc05vdGhpbmcpIHJldHVybiBtYXliZTtcbiAgICAgIHIgPSBtYXliZS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIEp1c3QgKHIudmFsdWUpO1xuICB9O1xuXG4gIC8vIyBNYXliZS5mYW50YXN5LWxhbmQvemVybyA6OiAoKSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gICAtIGB6ZXJvIChNYXliZSlgIGlzIGVxdWl2YWxlbnQgdG8gYE5vdGhpbmdgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnplcm8gKE1heWJlKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIE1heWJlWydmYW50YXN5LWxhbmQvemVybyddID0gZnVuY3Rpb24oKSB7IHJldHVybiBOb3RoaW5nOyB9O1xuXG4gIC8vIyBNYXliZSNAQHNob3cgOjogU2hvd2FibGUgYSA9PiBNYXliZSBhIH4+ICgpIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uICAgLSBgc2hvdyAoTm90aGluZylgIGlzIGVxdWl2YWxlbnQgdG8gYCdOb3RoaW5nJ2BcbiAgLy8uICAgLSBgc2hvdyAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGAnSnVzdCAoJyArIHNob3cgKHgpICsgJyknYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gc2hvdyAoTm90aGluZylcbiAgLy8uICdOb3RoaW5nJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAoSnVzdCAoWydmb28nLCAnYmFyJywgJ2JheiddKSlcbiAgLy8uICdKdXN0IChbXCJmb29cIiwgXCJiYXJcIiwgXCJiYXpcIl0pJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE5vdGhpbmckcHJvdG90eXBlJHNob3coKSB7XG4gICAgcmV0dXJuICdOb3RoaW5nJztcbiAgfVxuICBmdW5jdGlvbiBKdXN0JHByb3RvdHlwZSRzaG93KCkge1xuICAgIHJldHVybiAnSnVzdCAoJyArIHNob3cgKHRoaXMudmFsdWUpICsgJyknO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9lcXVhbHMgOjogU2V0b2lkIGEgPT4gTWF5YmUgYSB+PiBNYXliZSBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiAgIC0gYE5vdGhpbmdgIGlzIGVxdWFsIHRvIGBOb3RoaW5nYFxuICAvLy4gICAtIGBKdXN0ICh4KWAgaXMgZXF1YWwgdG8gYEp1c3QgKHkpYCBbaWZmXVtdIGB4YCBpcyBlcXVhbCB0byBgeWBcbiAgLy8uICAgICBhY2NvcmRpbmcgdG8gW2BaLmVxdWFsc2BdW11cbiAgLy8uICAgLSBgTm90aGluZ2AgaXMgbmV2ZXIgZXF1YWwgdG8gYEp1c3QgKHgpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5lcXVhbHMgKE5vdGhpbmcpIChOb3RoaW5nKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMgKEp1c3QgKFsxLCAyLCAzXSkpIChKdXN0IChbMSwgMiwgM10pKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMgKEp1c3QgKFsxLCAyLCAzXSkpIChKdXN0IChbMywgMiwgMV0pKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IFMuZXF1YWxzIChKdXN0IChbMSwgMiwgM10pKSAoTm90aGluZylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTm90aGluZyRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzTm90aGluZztcbiAgfVxuICBmdW5jdGlvbiBKdXN0JHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNKdXN0ICYmIFouZXF1YWxzICh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSk7XG4gIH1cblxuICAvLyMgTWF5YmUjZmFudGFzeS1sYW5kL2x0ZSA6OiBPcmQgYSA9PiBNYXliZSBhIH4+IE1heWJlIGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uICAgLSBgTm90aGluZ2AgaXMgKGxlc3MgdGhhbiBvcikgZXF1YWwgdG8gYE5vdGhpbmdgXG4gIC8vLiAgIC0gYEp1c3QgKHgpYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYEp1c3QgKHkpYCBbaWZmXVtdIGB4YCBpcyBsZXNzXG4gIC8vLiAgICAgdGhhbiBvciBlcXVhbCB0byBgeWAgYWNjb3JkaW5nIHRvIFtgWi5sdGVgXVtdXG4gIC8vLiAgIC0gYE5vdGhpbmdgIGlzIGFsd2F5cyBsZXNzIHRoYW4gYEp1c3QgKHgpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maWx0ZXIgKFMubHRlIChOb3RoaW5nKSkgKFtOb3RoaW5nLCBKdXN0ICgwKSwgSnVzdCAoMSksIEp1c3QgKDIpXSlcbiAgLy8uIFtOb3RoaW5nXVxuICAvLy5cbiAgLy8uID4gUy5maWx0ZXIgKFMubHRlIChKdXN0ICgxKSkpIChbTm90aGluZywgSnVzdCAoMCksIEp1c3QgKDEpLCBKdXN0ICgyKV0pXG4gIC8vLiBbTm90aGluZywgSnVzdCAoMCksIEp1c3QgKDEpXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE5vdGhpbmckcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIEp1c3QkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiBvdGhlci5pc0p1c3QgJiYgWi5sdGUgKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvY29uY2F0IDo6IFNlbWlncm91cCBhID0+IE1heWJlIGEgfj4gTWF5YmUgYSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gICAtIGBjb25jYXQgKE5vdGhpbmcpIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgTm90aGluZ2BcbiAgLy8uICAgLSBgY29uY2F0IChKdXN0ICh4KSkgKEp1c3QgKHkpKWAgaXMgZXF1aXZhbGVudCB0b1xuICAvLy4gICAgIGBKdXN0IChjb25jYXQgKHgpICh5KSlgXG4gIC8vLiAgIC0gYGNvbmNhdCAoTm90aGluZykgKEp1c3QgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgSnVzdCAoeClgXG4gIC8vLiAgIC0gYGNvbmNhdCAoSnVzdCAoeCkpIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgSnVzdCAoeClgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmNvbmNhdCAoTm90aGluZykgKE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdCAoSnVzdCAoWzEsIDIsIDNdKSkgKEp1c3QgKFs0LCA1LCA2XSkpXG4gIC8vLiBKdXN0IChbMSwgMiwgMywgNCwgNSwgNl0pXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdCAoTm90aGluZykgKEp1c3QgKFsxLCAyLCAzXSkpXG4gIC8vLiBKdXN0IChbMSwgMiwgM10pXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdCAoSnVzdCAoWzEsIDIsIDNdKSkgKE5vdGhpbmcpXG4gIC8vLiBKdXN0IChbMSwgMiwgM10pXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTm90aGluZyRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyO1xuICB9XG4gIGZ1bmN0aW9uIEp1c3QkcHJvdG90eXBlJGNvbmNhdChvdGhlcikge1xuICAgIHJldHVybiBvdGhlci5pc0p1c3QgPyBKdXN0IChaLmNvbmNhdCAodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpKSA6IHRoaXM7XG4gIH1cblxuICAvLyMgTWF5YmUjZmFudGFzeS1sYW5kL2ZpbHRlciA6OiBNYXliZSBhIH4+IChhIC0+IEJvb2xlYW4pIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiAgIC0gYGZpbHRlck0gKHApIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgTm90aGluZ2BcbiAgLy8uICAgLSBgZmlsdGVyTSAocCkgKEp1c3QgKHgpKWAgaXMgZXF1aXZhbGVudCB0b1xuICAvLy4gICAgIGBwICh4KSA/IEp1c3QgKHgpIDogTm90aGluZ2BcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZmlsdGVyTSAoaXNGaW5pdGUpIChOb3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5maWx0ZXJNIChpc0Zpbml0ZSkgKEp1c3QgKEluZmluaXR5KSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZmlsdGVyTSAoaXNGaW5pdGUpIChKdXN0IChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikpXG4gIC8vLiBKdXN0ICg5MDA3MTk5MjU0NzQwOTkxKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE5vdGhpbmckcHJvdG90eXBlJGZpbHRlcihwcmVkKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gSnVzdCRwcm90b3R5cGUkZmlsdGVyKHByZWQpIHtcbiAgICByZXR1cm4gcHJlZCAodGhpcy52YWx1ZSkgPyB0aGlzIDogTm90aGluZztcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvbWFwIDo6IE1heWJlIGEgfj4gKGEgLT4gYikgLT4gTWF5YmUgYlxuICAvLy5cbiAgLy8uICAgLSBgbWFwIChmKSAoTm90aGluZylgIGlzIGVxdWl2YWxlbnQgdG8gYE5vdGhpbmdgXG4gIC8vLiAgIC0gYG1hcCAoZikgKEp1c3QgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgSnVzdCAoZiAoeCkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXAgKE1hdGguc3FydCkgKE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoTWF0aC5zcXJ0KSAoSnVzdCAoOSkpXG4gIC8vLiBKdXN0ICgzKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE5vdGhpbmckcHJvdG90eXBlJG1hcChmKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gSnVzdCRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICByZXR1cm4gSnVzdCAoZiAodGhpcy52YWx1ZSkpO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9hcCA6OiBNYXliZSBhIH4+IE1heWJlIChhIC0+IGIpIC0+IE1heWJlIGJcbiAgLy8uXG4gIC8vLiAgIC0gYGFwIChOb3RoaW5nKSAoTm90aGluZylgIGlzIGVxdWl2YWxlbnQgdG8gYE5vdGhpbmdgXG4gIC8vLiAgIC0gYGFwIChOb3RoaW5nKSAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBOb3RoaW5nYFxuICAvLy4gICAtIGBhcCAoSnVzdCAoZikpIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgTm90aGluZ2BcbiAgLy8uICAgLSBgYXAgKEp1c3QgKGYpKSAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBKdXN0IChmICh4KSlgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFwIChOb3RoaW5nKSAoTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuYXAgKE5vdGhpbmcpIChKdXN0ICg5KSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuYXAgKEp1c3QgKE1hdGguc3FydCkpIChOb3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5hcCAoSnVzdCAoTWF0aC5zcXJ0KSkgKEp1c3QgKDkpKVxuICAvLy4gSnVzdCAoMylcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBOb3RoaW5nJHByb3RvdHlwZSRhcChvdGhlcikge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIEp1c3QkcHJvdG90eXBlJGFwKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzSnVzdCA/IEp1c3QgKG90aGVyLnZhbHVlICh0aGlzLnZhbHVlKSkgOiBvdGhlcjtcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvY2hhaW4gOjogTWF5YmUgYSB+PiAoYSAtPiBNYXliZSBiKSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gICAtIGBjaGFpbiAoZikgKE5vdGhpbmcpYCBpcyBlcXVpdmFsZW50IHRvIGBOb3RoaW5nYFxuICAvLy4gICAtIGBjaGFpbiAoZikgKEp1c3QgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgZiAoeClgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb25zdCBoZWFkID0geHMgPT4geHMubGVuZ3RoID09PSAwID8gTm90aGluZyA6IEp1c3QgKHhzWzBdKVxuICAvLy5cbiAgLy8uID4gUy5jaGFpbiAoaGVhZCkgKE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmNoYWluIChoZWFkKSAoSnVzdCAoW10pKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5jaGFpbiAoaGVhZCkgKEp1c3QgKFsnZm9vJywgJ2JhcicsICdiYXonXSkpXG4gIC8vLiBKdXN0ICgnZm9vJylcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBOb3RoaW5nJHByb3RvdHlwZSRjaGFpbihmKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gSnVzdCRwcm90b3R5cGUkY2hhaW4oZikge1xuICAgIHJldHVybiBmICh0aGlzLnZhbHVlKTtcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvYWx0IDo6IE1heWJlIGEgfj4gTWF5YmUgYSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gICAtIGBhbHQgKE5vdGhpbmcpIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgTm90aGluZ2BcbiAgLy8uICAgLSBgYWx0IChOb3RoaW5nKSAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBKdXN0ICh4KWBcbiAgLy8uICAgLSBgYWx0IChKdXN0ICh4KSkgKE5vdGhpbmcpYCBpcyBlcXVpdmFsZW50IHRvIGBKdXN0ICh4KWBcbiAgLy8uICAgLSBgYWx0IChKdXN0ICh4KSkgKEp1c3QgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgSnVzdCAoeClgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFsdCAoTm90aGluZykgKE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmFsdCAoTm90aGluZykgKEp1c3QgKDEpKVxuICAvLy4gSnVzdCAoMSlcbiAgLy8uXG4gIC8vLiA+IFMuYWx0IChKdXN0ICgyKSkgKE5vdGhpbmcpXG4gIC8vLiBKdXN0ICgyKVxuICAvLy5cbiAgLy8uID4gUy5hbHQgKEp1c3QgKDMpKSAoSnVzdCAoNCkpXG4gIC8vLiBKdXN0ICgzKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE5vdGhpbmckcHJvdG90eXBlJGFsdChvdGhlcikge1xuICAgIHJldHVybiBvdGhlcjtcbiAgfVxuICBmdW5jdGlvbiBKdXN0JHByb3RvdHlwZSRhbHQob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvcmVkdWNlIDo6IE1heWJlIGEgfj4gKChiLCBhKSAtPiBiLCBiKSAtPiBiXG4gIC8vLlxuICAvLy4gICAtIGByZWR1Y2UgKGYpICh4KSAoTm90aGluZylgIGlzIGVxdWl2YWxlbnQgdG8gYHhgXG4gIC8vLiAgIC0gYHJlZHVjZSAoZikgKHgpIChKdXN0ICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYGYgKHgpICh5KWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmVkdWNlIChTLmNvbmNhdCkgKCdhYmMnKSAoTm90aGluZylcbiAgLy8uICdhYmMnXG4gIC8vLlxuICAvLy4gPiBTLnJlZHVjZSAoUy5jb25jYXQpICgnYWJjJykgKEp1c3QgKCd4eXonKSlcbiAgLy8uICdhYmN4eXonXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTm90aGluZyRwcm90b3R5cGUkcmVkdWNlKGYsIHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuICBmdW5jdGlvbiBKdXN0JHByb3RvdHlwZSRyZWR1Y2UoZiwgeCkge1xuICAgIHJldHVybiBmICh4LCB0aGlzLnZhbHVlKTtcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvdHJhdmVyc2UgOjogQXBwbGljYXRpdmUgZiA9PiBNYXliZSBhIH4+IChUeXBlUmVwIGYsIGEgLT4gZiBiKSAtPiBmIChNYXliZSBiKVxuICAvLy5cbiAgLy8uICAgLSBgdHJhdmVyc2UgKEEpIChmKSAoTm90aGluZylgIGlzIGVxdWl2YWxlbnQgdG8gYG9mIChBKSAoTm90aGluZylgXG4gIC8vLiAgIC0gYHRyYXZlcnNlIChBKSAoZikgKEp1c3QgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgbWFwIChKdXN0KSAoZiAoeCkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50cmF2ZXJzZSAoQXJyYXkpIChTLndvcmRzKSAoTm90aGluZylcbiAgLy8uIFtOb3RoaW5nXVxuICAvLy5cbiAgLy8uID4gUy50cmF2ZXJzZSAoQXJyYXkpIChTLndvcmRzKSAoSnVzdCAoJ2ZvbyBiYXIgYmF6JykpXG4gIC8vLiBbSnVzdCAoJ2ZvbycpLCBKdXN0ICgnYmFyJyksIEp1c3QgKCdiYXonKV1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBOb3RoaW5nJHByb3RvdHlwZSR0cmF2ZXJzZSh0eXBlUmVwLCBmKSB7XG4gICAgcmV0dXJuIFoub2YgKHR5cGVSZXAsIHRoaXMpO1xuICB9XG4gIGZ1bmN0aW9uIEp1c3QkcHJvdG90eXBlJHRyYXZlcnNlKHR5cGVSZXAsIGYpIHtcbiAgICByZXR1cm4gWi5tYXAgKEp1c3QsIGYgKHRoaXMudmFsdWUpKTtcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvZXh0ZW5kIDo6IE1heWJlIGEgfj4gKE1heWJlIGEgLT4gYikgLT4gTWF5YmUgYlxuICAvLy5cbiAgLy8uICAgLSBgZXh0ZW5kIChmKSAoTm90aGluZylgIGlzIGVxdWl2YWxlbnQgdG8gYE5vdGhpbmdgXG4gIC8vLiAgIC0gYGV4dGVuZCAoZikgKEp1c3QgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgSnVzdCAoZiAoSnVzdCAoeCkpKWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZXh0ZW5kIChTLnJlZHVjZSAoUy5hZGQpICgxKSkgKE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmV4dGVuZCAoUy5yZWR1Y2UgKFMuYWRkKSAoMSkpIChKdXN0ICg5OSkpXG4gIC8vLiBKdXN0ICgxMDApXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTm90aGluZyRwcm90b3R5cGUkZXh0ZW5kKGYpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBKdXN0JHByb3RvdHlwZSRleHRlbmQoZikge1xuICAgIHJldHVybiBKdXN0IChmICh0aGlzKSk7XG4gIH1cblxuICByZXR1cm4gTWF5YmU7XG5cbn0pKTtcblxuLy8uIFtGYW50YXN5IExhbmRdOiAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZFxuLy8uIFtgWi5lcXVhbHNgXTogICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2VxdWFsc1xuLy8uIFtgWi5sdGVgXTogICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2x0ZVxuLy8uIFtpZmZdOiAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JZl9hbmRfb25seV9pZlxuLy8uIFt0eXBlIGlkZW50aWZpZXJdOiAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1pZGVudGlmaWVyc1xuLy8uIFt0eXBlIHJlcHJlc2VudGF0aXZlXTogICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0eXBlLXJlcHJlc2VudGF0aXZlc1xuIiwiICAgICAgIC8qICAgICAgICAgICAgICAgICAgICpcXFxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBcXFxcXG4gICAgIC8vICAgQEAgIEBAICAgICBAQCAgQEAgICBcXFxcXG4gICAgLy8gICAgICBAQCAgICAgICBAQCAgQEAgICAgXFxcXFxuICAgIFxcXFwgICAgICBAQCAgICAgICBAQCAgQEAgICAgLy9cbiAgICAgXFxcXCAgIEBAICBAQCAgQCAgICBAQCBAICAgLy9cbiAgICAgIFxcXFwgICAgICAgICAgLyAgICAgICBAICAvL1xuICAgICAgIFxcKiAgICAgICAgICAgICBAQEBAICAqL1xuXG4vLy4gPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmRcIj48aW1nIGFsdD1cIkZhbnRhc3kgTGFuZFwiIHNyYz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQvbWFzdGVyL2xvZ28ucG5nXCIgd2lkdGg9XCI3NVwiIGhlaWdodD1cIjc1XCIgYWxpZ249XCJsZWZ0XCI+PC9hPlxuLy8uXG4vLy4gIyBzYW5jdHVhcnktcGFpclxuLy8uXG4vLy4gUGFpciBpcyB0aGUgY2Fub25pY2FsIHByb2R1Y3QgdHlwZTogYSB2YWx1ZSBvZiB0eXBlIGBQYWlyIGEgYmAgYWx3YXlzXG4vLy4gY29udGFpbnMgZXhhY3RseSB0d28gdmFsdWVzOiBvbmUgb2YgdHlwZSBgYWA7IG9uZSBvZiB0eXBlIGBiYC5cblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYgKHJlcXVpcmUgKCdzYW5jdHVhcnktc2hvdycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUgKFsnc2FuY3R1YXJ5LXNob3cnLCAnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyddLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeVBhaXIgPSBmIChzZWxmLnNhbmN0dWFyeVNob3csIHNlbGYuc2FuY3R1YXJ5VHlwZUNsYXNzZXMpO1xuICB9XG5cbn0gKGZ1bmN0aW9uKHNob3csIFopIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgX19kb2N0ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHZhciAkID0gX19kb2N0ZXN0LnJlcXVpcmUgKCdzYW5jdHVhcnktZGVmJyk7XG4gICAgdmFyIHR5cGUgPSBfX2RvY3Rlc3QucmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJyk7XG4gICAgdmFyIFMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgUyA9IF9fZG9jdGVzdC5yZXF1aXJlICgnc2FuY3R1YXJ5Jyk7XG4gICAgICB2YXIgUGFpclR5cGUgPSAkLkJpbmFyeVR5cGVcbiAgICAgICAgKCdzYW5jdHVhcnktcGFpci9QYWlyJylcbiAgICAgICAgKCcnKVxuICAgICAgICAoZnVuY3Rpb24oeCkgeyByZXR1cm4gdHlwZSAoeCkgPT09IFBhaXJbJ0BAdHlwZSddOyB9KVxuICAgICAgICAoZnVuY3Rpb24ocCkgeyByZXR1cm4gW3AuZnN0XTsgfSlcbiAgICAgICAgKGZ1bmN0aW9uKHApIHsgcmV0dXJuIFtwLnNuZF07IH0pO1xuICAgICAgdmFyIGVudiA9IFouY29uY2F0IChTLmVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgWyQuVHlwZUNsYXNzLCBQYWlyVHlwZSAoJC5Vbmtub3duKSAoJC5Vbmtub3duKV0pO1xuICAgICAgcmV0dXJuIFMuY3JlYXRlICh7Y2hlY2tUeXBlczogdHJ1ZSwgZW52OiBlbnZ9KTtcbiAgICB9ICgpKTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgICAnY29uc3RydWN0b3InOiAgICAgICAgICAgIFBhaXIsXG4gICAgJ0BAc2hvdyc6ICAgICAgICAgICAgICAgICBQYWlyJHByb3RvdHlwZSRzaG93LFxuICAgICdmYW50YXN5LWxhbmQvY29tcG9zZSc6ICAgUGFpciRwcm90b3R5cGUkY29tcG9zZSxcbiAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgIFBhaXIkcHJvdG90eXBlJG1hcCxcbiAgICAnZmFudGFzeS1sYW5kL2JpbWFwJzogICAgIFBhaXIkcHJvdG90eXBlJGJpbWFwLFxuICAgICdmYW50YXN5LWxhbmQvcmVkdWNlJzogICAgUGFpciRwcm90b3R5cGUkcmVkdWNlLFxuICAgICdmYW50YXN5LWxhbmQvdHJhdmVyc2UnOiAgUGFpciRwcm90b3R5cGUkdHJhdmVyc2UsXG4gICAgJ2ZhbnRhc3ktbGFuZC9leHRlbmQnOiAgICBQYWlyJHByb3RvdHlwZSRleHRlbmQsXG4gICAgJ2ZhbnRhc3ktbGFuZC9leHRyYWN0JzogICBQYWlyJHByb3RvdHlwZSRleHRyYWN0XG4gICAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICB9O1xuXG4gIHZhciB1dGlsID1cbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnID9cbiAgICByZXF1aXJlICgndXRpbCcpIDpcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB7fTtcbiAgcHJvdG90eXBlW1xuICAgIHV0aWwuaW5zcGVjdCAhPSBudWxsICYmIHR5cGVvZiB1dGlsLmluc3BlY3QuY3VzdG9tID09PSAnc3ltYm9sJyA/XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5pbnNwZWN0LmN1c3RvbSA6XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gJ2luc3BlY3QnXG4gIF0gPSBQYWlyJHByb3RvdHlwZSRzaG93O1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gICAgcHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBbdGhpcy5mc3QsIHRoaXMuc25kXVtTeW1ib2wuaXRlcmF0b3JdICgpO1xuICAgIH07XG4gIH1cblxuICAvLy4gYFBhaXIgYSBiYCBzYXRpc2ZpZXMgdGhlIGZvbGxvd2luZyBbRmFudGFzeSBMYW5kXVtdIHNwZWNpZmljYXRpb25zOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29uc3QgVXNlbGVzcyA9IHJlcXVpcmUgKCdzYW5jdHVhcnktdXNlbGVzcycpXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoayA9PiBrICsgJyAnLnJlcGVhdCAoMTYgLSBrLmxlbmd0aCkgK1xuICAvLy4gLiAgICAgICAgICAgICAoWltrXS50ZXN0IChQYWlyIChVc2VsZXNzKSAoVXNlbGVzcykpID8gJ1xcdTI3MDUgICAnIDpcbiAgLy8uIC4gICAgICAgICAgICAgIFpba10udGVzdCAoUGFpciAoWydmb28nXSkgKFsnYmFyJ10pKSA/ICdcXHUyNzA1ICogJyA6XG4gIC8vLiAuICAgICAgICAgICAgICAvKiBvdGhlcndpc2UgKi8gICAgICAgICAgICAgICAgICAgICAgICAnXFx1Mjc0QyAgICcpKVxuICAvLy4gLiAgICAgICAoUy5rZXlzIChaLmZpbHRlciAoJC50ZXN0IChbXSkgKCQuVHlwZUNsYXNzKSwgWikpKVxuICAvLy4gWyAnU2V0b2lkICAgICAgICAgIOKchSAqICcsICAvLyBpZiDigJhh4oCZIGFuZCDigJhi4oCZIHNhdGlzZnkgU2V0b2lkXG4gIC8vLiAuICdPcmQgICAgICAgICAgICAg4pyFICogJywgIC8vIGlmIOKAmGHigJkgYW5kIOKAmGLigJkgc2F0aXNmeSBPcmRcbiAgLy8uIC4gJ1NlbWlncm91cG9pZCAgICDinIUgICAnLFxuICAvLy4gLiAnQ2F0ZWdvcnkgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdTZW1pZ3JvdXAgICAgICAg4pyFICogJywgIC8vIGlmIOKAmGHigJkgYW5kIOKAmGLigJkgc2F0aXNmeSBTZW1pZ3JvdXBcbiAgLy8uIC4gJ01vbm9pZCAgICAgICAgICDinYwgICAnLFxuICAvLy4gLiAnR3JvdXAgICAgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdGaWx0ZXJhYmxlICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0Z1bmN0b3IgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnQmlmdW5jdG9yICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdQcm9mdW5jdG9yICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0FwcGx5ICAgICAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBzYXRpc2ZpZXMgU2VtaWdyb3VwXG4gIC8vLiAuICdBcHBsaWNhdGl2ZSAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0NoYWluICAgICAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBzYXRpc2ZpZXMgU2VtaWdyb3VwXG4gIC8vLiAuICdDaGFpblJlYyAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ01vbmFkICAgICAgICAgICDinYwgICAnLFxuICAvLy4gLiAnQWx0ICAgICAgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdQbHVzICAgICAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0FsdGVybmF0aXZlICAgICDinYwgICAnLFxuICAvLy4gLiAnRm9sZGFibGUgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdUcmF2ZXJzYWJsZSAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0V4dGVuZCAgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnQ29tb25hZCAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdDb250cmF2YXJpYW50ICAg4p2MICAgJyBdXG4gIC8vLiBgYGBcblxuICAvLyMgUGFpciA6OiBhIC0+IGIgLT4gUGFpciBhIGJcbiAgLy8uXG4gIC8vLiBQYWlyJ3Mgc29sZSBkYXRhIGNvbnN0cnVjdG9yLiBBZGRpdGlvbmFsbHksIGl0IHNlcnZlcyBhcyB0aGVcbiAgLy8uIFBhaXIgW3R5cGUgcmVwcmVzZW50YXRpdmVdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBQYWlyICgxKSAoMilcbiAgLy8uIFBhaXIgKDEpICgyKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFBhaXIoZnN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNuZCkge1xuICAgICAgdmFyIHBhaXIgPSBPYmplY3QuY3JlYXRlIChwcm90b3R5cGUpO1xuICAgICAgaWYgKFouU2V0b2lkLnRlc3QgKGZzdCkgJiYgWi5TZXRvaWQudGVzdCAoc25kKSkge1xuICAgICAgICBwYWlyWydmYW50YXN5LWxhbmQvZXF1YWxzJ10gPSBQYWlyJHByb3RvdHlwZSRlcXVhbHM7XG4gICAgICAgIGlmIChaLk9yZC50ZXN0IChmc3QpICYmIFouT3JkLnRlc3QgKHNuZCkpIHtcbiAgICAgICAgICBwYWlyWydmYW50YXN5LWxhbmQvbHRlJ10gPSBQYWlyJHByb3RvdHlwZSRsdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChaLlNlbWlncm91cC50ZXN0IChmc3QpKSB7XG4gICAgICAgIGlmIChaLlNlbWlncm91cC50ZXN0IChzbmQpKSB7XG4gICAgICAgICAgcGFpclsnZmFudGFzeS1sYW5kL2NvbmNhdCddID0gUGFpciRwcm90b3R5cGUkY29uY2F0O1xuICAgICAgICB9XG4gICAgICAgIHBhaXJbJ2ZhbnRhc3ktbGFuZC9hcCddID0gUGFpciRwcm90b3R5cGUkYXA7XG4gICAgICAgIHBhaXJbJ2ZhbnRhc3ktbGFuZC9jaGFpbiddID0gUGFpciRwcm90b3R5cGUkY2hhaW47XG4gICAgICB9XG4gICAgICBwYWlyLmZzdCA9IGZzdDtcbiAgICAgIHBhaXIuc25kID0gc25kO1xuICAgICAgcmV0dXJuIHBhaXI7XG4gICAgfTtcbiAgfVxuXG4gIC8vIyBQYWlyLmZzdCA6OiBQYWlyIGEgYiAtPiBhXG4gIC8vLlxuICAvLy4gYGZzdCAoUGFpciAoeCkgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgeGAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBQYWlyLmZzdCAoUGFpciAoJ2FiYycpIChbMSwgMiwgM10pKVxuICAvLy4gJ2FiYydcbiAgLy8uIGBgYFxuICBQYWlyLmZzdCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuZnN0OyB9O1xuXG4gIC8vIyBQYWlyLnNuZCA6OiBQYWlyIGEgYiAtPiBiXG4gIC8vLlxuICAvLy4gYHNuZCAoUGFpciAoeCkgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgeWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBQYWlyLnNuZCAoUGFpciAoJ2FiYycpIChbMSwgMiwgM10pKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLiBgYGBcbiAgUGFpci5zbmQgPSBmdW5jdGlvbihwKSB7IHJldHVybiBwLnNuZDsgfTtcblxuICAvLyMgUGFpci5zd2FwIDo6IFBhaXIgYSBiIC0+IFBhaXIgYiBhXG4gIC8vLlxuICAvLy4gYHN3YXAgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYFBhaXIgKHkpICh4KWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBQYWlyLnN3YXAgKFBhaXIgKCdhYmMnKSAoWzEsIDIsIDNdKSlcbiAgLy8uIFBhaXIgKFsxLCAyLCAzXSkgKCdhYmMnKVxuICAvLy4gYGBgXG4gIFBhaXIuc3dhcCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIFBhaXIgKHAuc25kKSAocC5mc3QpOyB9O1xuXG4gIC8vIyBQYWlyLkBAdHlwZSA6OiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBQYWlyIFt0eXBlIGlkZW50aWZpZXJdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0eXBlIChQYWlyICgnYWJjJykgKFsxLCAyLCAzXSkpXG4gIC8vLiAnc2FuY3R1YXJ5LXBhaXIvUGFpckAxJ1xuICAvLy5cbiAgLy8uID4gdHlwZS5wYXJzZSAodHlwZSAoUGFpciAoJ2FiYycpIChbMSwgMiwgM10pKSlcbiAgLy8uIHtuYW1lc3BhY2U6ICdzYW5jdHVhcnktcGFpcicsIG5hbWU6ICdQYWlyJywgdmVyc2lvbjogMX1cbiAgLy8uIGBgYFxuICBQYWlyWydAQHR5cGUnXSA9ICdzYW5jdHVhcnktcGFpci9QYWlyQDEnO1xuXG4gIC8vIyBQYWlyI0BAc2hvdyA6OiAoU2hvd2FibGUgYSwgU2hvd2FibGUgYikgPT4gUGFpciBhIGIgfj4gKCkgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gYHNob3cgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG9cbiAgLy8uIGAnUGFpciAoJyArIHNob3cgKHgpICsgJykgKCcgKyBzaG93ICh5KSArICcpJ2AuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBzaG93IChQYWlyICgnYWJjJykgKFsxLCAyLCAzXSkpXG4gIC8vLiAnUGFpciAoXCJhYmNcIikgKFsxLCAyLCAzXSknXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkc2hvdygpIHtcbiAgICByZXR1cm4gJ1BhaXIgKCcgKyBzaG93ICh0aGlzLmZzdCkgKyAnKSAoJyArIHNob3cgKHRoaXMuc25kKSArICcpJztcbiAgfVxuXG4gIC8vIyBQYWlyI2ZhbnRhc3ktbGFuZC9lcXVhbHMgOjogKFNldG9pZCBhLCBTZXRvaWQgYikgPT4gUGFpciBhIGIgfj4gUGFpciBhIGIgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIGBQYWlyICh4KSAoeSlgIGlzIGVxdWFsIHRvIGBQYWlyICh2KSAodylgIFtpZmZdW10gYHhgIGlzIGVxdWFsIHRvIGB2YFxuICAvLy4gYW5kIGB5YCBpcyBlcXVhbCB0byBgd2AgYWNjb3JkaW5nIHRvIFtgWi5lcXVhbHNgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5lcXVhbHMgKFBhaXIgKCdhYmMnKSAoWzEsIDIsIDNdKSkgKFBhaXIgKCdhYmMnKSAoWzEsIDIsIDNdKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuZXF1YWxzIChQYWlyICgnYWJjJykgKFsxLCAyLCAzXSkpIChQYWlyICgnYWJjJykgKFszLCAyLCAxXSkpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFBhaXIkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBaLmVxdWFscyAodGhpcy5mc3QsIG90aGVyLmZzdCkgJiYgWi5lcXVhbHMgKHRoaXMuc25kLCBvdGhlci5zbmQpO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL2x0ZSA6OiAoT3JkIGEsIE9yZCBiKSA9PiBQYWlyIGEgYiB+PiBQYWlyIGEgYiAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gYFBhaXIgKHgpICh5KWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBQYWlyICh2KSAodylgIFtpZmZdW10gYHhgIGlzXG4gIC8vLiBsZXNzIHRoYW4gYHZgIG9yIGB4YCBpcyBlcXVhbCB0byBgdmAgYW5kIGB5YCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgLy8uIGB3YCBhY2NvcmRpbmcgdG8gW2BaLmx0ZWBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbHRlciAoUy5sdGUgKFBhaXIgKCdiJykgKDIpKSlcbiAgLy8uIC4gICAgICAgICAgKFtQYWlyICgnYScpICgxKSwgUGFpciAoJ2EnKSAoMiksIFBhaXIgKCdhJykgKDMpLFxuICAvLy4gLiAgICAgICAgICAgIFBhaXIgKCdiJykgKDEpLCBQYWlyICgnYicpICgyKSwgUGFpciAoJ2InKSAoMyksXG4gIC8vLiAuICAgICAgICAgICAgUGFpciAoJ2MnKSAoMSksIFBhaXIgKCdjJykgKDIpLCBQYWlyICgnYycpICgzKV0pXG4gIC8vLiBbIFBhaXIgKCdhJykgKDEpLFxuICAvLy4gLiBQYWlyICgnYScpICgyKSxcbiAgLy8uIC4gUGFpciAoJ2EnKSAoMyksXG4gIC8vLiAuIFBhaXIgKCdiJykgKDEpLFxuICAvLy4gLiBQYWlyICgnYicpICgyKSBdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIFouZXF1YWxzICh0aGlzLmZzdCwgb3RoZXIuZnN0KSA/IFoubHRlICh0aGlzLnNuZCwgb3RoZXIuc25kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBaLmx0ZSAodGhpcy5mc3QsIG90aGVyLmZzdCk7XG4gIH1cblxuICAvLyMgUGFpciNmYW50YXN5LWxhbmQvY29tcG9zZSA6OiBQYWlyIGEgYiB+PiBQYWlyIGIgYyAtPiBQYWlyIGEgY1xuICAvLy5cbiAgLy8uIGBjb21wb3NlIChQYWlyICh4KSAoeSkpIChQYWlyICh2KSAodykpYCBpcyBlcXVpdmFsZW50IHRvIGBQYWlyICh2KSAoeSlgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jb21wb3NlIChQYWlyICgnYScpICgwKSkgKFBhaXIgKFsxLCAyLCAzXSkgKCdiJykpXG4gIC8vLiBQYWlyIChbMSwgMiwgM10pICgwKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFBhaXIkcHJvdG90eXBlJGNvbXBvc2Uob3RoZXIpIHtcbiAgICByZXR1cm4gUGFpciAodGhpcy5mc3QpIChvdGhlci5zbmQpO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL2NvbmNhdCA6OiAoU2VtaWdyb3VwIGEsIFNlbWlncm91cCBiKSA9PiBQYWlyIGEgYiB+PiBQYWlyIGEgYiAtPiBQYWlyIGEgYlxuICAvLy5cbiAgLy8uIGBjb25jYXQgKFBhaXIgKHgpICh5KSkgKFBhaXIgKHYpICh3KSlgIGlzIGVxdWl2YWxlbnQgdG9cbiAgLy8uIGBQYWlyIChjb25jYXQgKHgpICh2KSkgKGNvbmNhdCAoeSkgKHcpKWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmNvbmNhdCAoUGFpciAoJ2FiYycpIChbMSwgMiwgM10pKSAoUGFpciAoJ3h5eicpIChbNCwgNSwgNl0pKVxuICAvLy4gUGFpciAoJ2FiY3h5eicpIChbMSwgMiwgMywgNCwgNSwgNl0pXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgcmV0dXJuIFBhaXIgKFouY29uY2F0ICh0aGlzLmZzdCwgb3RoZXIuZnN0KSlcbiAgICAgICAgICAgICAgICAoWi5jb25jYXQgKHRoaXMuc25kLCBvdGhlci5zbmQpKTtcbiAgfVxuXG4gIC8vIyBQYWlyI2ZhbnRhc3ktbGFuZC9tYXAgOjogUGFpciBhIGIgfj4gKGIgLT4gYykgLT4gUGFpciBhIGNcbiAgLy8uXG4gIC8vLiBgbWFwIChmKSAoUGFpciAoeCkgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgUGFpciAoeCkgKGYgKHkpKWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcCAoTWF0aC5zcXJ0KSAoUGFpciAoJ2FiYycpICgyNTYpKVxuICAvLy4gUGFpciAoJ2FiYycpICgxNilcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBQYWlyJHByb3RvdHlwZSRtYXAoZikge1xuICAgIHJldHVybiBQYWlyICh0aGlzLmZzdCkgKGYgKHRoaXMuc25kKSk7XG4gIH1cblxuICAvLyMgUGFpciNmYW50YXN5LWxhbmQvYmltYXAgOjogUGFpciBhIGMgfj4gKGEgLT4gYiwgYyAtPiBkKSAtPiBQYWlyIGIgZFxuICAvLy5cbiAgLy8uIGBiaW1hcCAoZikgKGcpIChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBQYWlyIChmICh4KSkgKGcgKHkpKWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmJpbWFwIChTLnRvVXBwZXIpIChNYXRoLnNxcnQpIChQYWlyICgnYWJjJykgKDI1NikpXG4gIC8vLiBQYWlyICgnQUJDJykgKDE2KVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFBhaXIkcHJvdG90eXBlJGJpbWFwKGYsIGcpIHtcbiAgICByZXR1cm4gUGFpciAoZiAodGhpcy5mc3QpKSAoZyAodGhpcy5zbmQpKTtcbiAgfVxuXG4gIC8vIyBQYWlyI2ZhbnRhc3ktbGFuZC9hcCA6OiBTZW1pZ3JvdXAgYSA9PiBQYWlyIGEgYiB+PiBQYWlyIGEgKGIgLT4gYykgLT4gUGFpciBhIGNcbiAgLy8uXG4gIC8vLiBgYXAgKFBhaXIgKHYpIChmKSkgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG9cbiAgLy8uIGBQYWlyIChjb25jYXQgKHYpICh4KSkgKGYgKHkpKWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFwIChQYWlyICgnYWJjJykgKE1hdGguc3FydCkpIChQYWlyICgneHl6JykgKDI1NikpXG4gIC8vLiBQYWlyICgnYWJjeHl6JykgKDE2KVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFBhaXIkcHJvdG90eXBlJGFwKG90aGVyKSB7XG4gICAgcmV0dXJuIFBhaXIgKFouY29uY2F0IChvdGhlci5mc3QsIHRoaXMuZnN0KSkgKG90aGVyLnNuZCAodGhpcy5zbmQpKTtcbiAgfVxuXG4gIC8vIyBQYWlyI2ZhbnRhc3ktbGFuZC9jaGFpbiA6OiBTZW1pZ3JvdXAgYSA9PiBQYWlyIGEgYiB+PiAoYiAtPiBQYWlyIGEgYykgLT4gUGFpciBhIGNcbiAgLy8uXG4gIC8vLiBgY2hhaW4gKGYpIChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvXG4gIC8vLiBgUGFpciAoY29uY2F0ICh4KSAoZnN0IChmICh5KSkpKSAoc25kIChmICh5KSkpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuY2hhaW4gKG4gPT4gUGFpciAoc2hvdyAobikpIChNYXRoLnNxcnQgKG4pKSkgKFBhaXIgKCdhYmMnKSAoMjU2KSlcbiAgLy8uIFBhaXIgKCdhYmMyNTYnKSAoMTYpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkY2hhaW4oZikge1xuICAgIHZhciBvdGhlciA9IGYgKHRoaXMuc25kKTtcbiAgICByZXR1cm4gUGFpciAoWi5jb25jYXQgKHRoaXMuZnN0LCBvdGhlci5mc3QpKSAob3RoZXIuc25kKTtcbiAgfVxuXG4gIC8vIyBQYWlyI2ZhbnRhc3ktbGFuZC9yZWR1Y2UgOjogUGFpciBhIGIgfj4gKChjLCBiKSAtPiBjLCBjKSAtPiBjXG4gIC8vLlxuICAvLy4gYHJlZHVjZSAoZikgKHgpIChQYWlyICh2KSAodykpYCBpcyBlcXVpdmFsZW50IHRvIGBmICh4KSAodylgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yZWR1Y2UgKFMuY29uY2F0KSAoWzEsIDIsIDNdKSAoUGFpciAoJ2FiYycpIChbNCwgNSwgNl0pKVxuICAvLy4gWzEsIDIsIDMsIDQsIDUsIDZdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkcmVkdWNlKGYsIHgpIHtcbiAgICByZXR1cm4gZiAoeCwgdGhpcy5zbmQpO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL3RyYXZlcnNlIDo6IEFwcGxpY2F0aXZlIGYgPT4gUGFpciBhIGIgfj4gKFR5cGVSZXAgZiwgYiAtPiBmIGMpIC0+IGYgKFBhaXIgYSBjKVxuICAvLy5cbiAgLy8uIGB0cmF2ZXJzZSAoXykgKGYpIChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvXG4gIC8vLiBgbWFwIChQYWlyICh4KSkgKGYgKHkpKWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRyYXZlcnNlIChBcnJheSkgKFMud29yZHMpIChQYWlyICgxMjMpICgnZm9vIGJhciBiYXonKSlcbiAgLy8uIFtQYWlyICgxMjMpICgnZm9vJyksIFBhaXIgKDEyMykgKCdiYXInKSwgUGFpciAoMTIzKSAoJ2JheicpXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFBhaXIkcHJvdG90eXBlJHRyYXZlcnNlKHR5cGVSZXAsIGYpIHtcbiAgICByZXR1cm4gWi5tYXAgKFBhaXIgKHRoaXMuZnN0KSwgZiAodGhpcy5zbmQpKTtcbiAgfVxuXG4gIC8vIyBQYWlyI2ZhbnRhc3ktbGFuZC9leHRlbmQgOjogUGFpciBhIGIgfj4gKFBhaXIgYSBiIC0+IGMpIC0+IFBhaXIgYSBjXG4gIC8vLlxuICAvLy4gYGV4dGVuZCAoZikgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG9cbiAgLy8uIGBQYWlyICh4KSAoZiAoUGFpciAoeCkgKHkpKSlgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5leHRlbmQgKFMucmVkdWNlIChTLmFkZCkgKDEpKSAoUGFpciAoJ2FiYycpICg5OSkpXG4gIC8vLiBQYWlyICgnYWJjJykgKDEwMClcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBQYWlyJHByb3RvdHlwZSRleHRlbmQoZikge1xuICAgIHJldHVybiBQYWlyICh0aGlzLmZzdCkgKGYgKHRoaXMpKTtcbiAgfVxuXG4gIC8vIyBQYWlyI2ZhbnRhc3ktbGFuZC9leHRyYWN0IDo6IFBhaXIgYSBiIH4+ICgpIC0+IGJcbiAgLy8uXG4gIC8vLiBgZXh0cmFjdCAoUGFpciAoeCkgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgeWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmV4dHJhY3QgKFBhaXIgKCdhYmMnKSAoWzEsIDIsIDNdKSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFBhaXIkcHJvdG90eXBlJGV4dHJhY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuc25kO1xuICB9XG5cbiAgcmV0dXJuIFBhaXI7XG5cbn0pKTtcblxuLy8uIFtGYW50YXN5IExhbmRdOiAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZFxuLy8uIFtgWi5lcXVhbHNgXTogICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2VxdWFsc1xuLy8uIFtgWi5sdGVgXTogICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2x0ZVxuLy8uIFtpZmZdOiAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JZl9hbmRfb25seV9pZlxuLy8uIFt0eXBlIGlkZW50aWZpZXJdOiAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1pZGVudGlmaWVyc1xuLy8uIFt0eXBlIHJlcHJlc2VudGF0aXZlXTogICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0eXBlLXJlcHJlc2VudGF0aXZlc1xuIiwiLy8uICMgc2FuY3R1YXJ5LXNob3dcbi8vLlxuLy8uIEhhc2tlbGwgaGFzIGEgYHNob3dgIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSBhcHBsaWVkIHRvIGEgY29tcGF0aWJsZSB2YWx1ZSB0b1xuLy8uIHByb2R1Y2UgYSBkZXNjcmlwdGl2ZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhhdCB2YWx1ZS4gVGhlIGlkZWEgaXMgdGhhdFxuLy8uIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gc2hvdWxkLCBpZiBwb3NzaWJsZSwgYmUgYW4gZXhwcmVzc2lvbiB3aGljaCB3b3VsZFxuLy8uIHByb2R1Y2UgdGhlIG9yaWdpbmFsIHZhbHVlIGlmIGV2YWx1YXRlZC5cbi8vLlxuLy8uIFRoaXMgbGlicmFyeSBwcm92aWRlcyBhIHNpbWlsYXIgW2BzaG93YF0oI3Nob3cpIGZ1bmN0aW9uLlxuLy8uXG4vLy4gSW4gZ2VuZXJhbCwgdGhpcyBwcm9wZXJ0eSBzaG91bGQgaG9sZDogYGV2YWwgKHNob3cgKHgpKSA9IHhgLiBJbiBzb21lIGNhc2VzXG4vLy4gcGFyZW5zIGFyZSBuZWNlc3NhcnkgdG8gZW5zdXJlIGNvcnJlY3QgaW50ZXJwcmV0YXRpb24gKGB7fWAsIGZvciBleGFtcGxlLFxuLy8uIGlzIGFuIGVtcHR5IGJsb2NrIHJhdGhlciB0aGFuIGFuIGVtcHR5IG9iamVjdCBpbiBzb21lIGNvbnRleHRzKS4gVGh1cyB0aGVcbi8vLiBwcm9wZXJ0eSBpcyBtb3JlIGFjY3VyYXRlbHkgc3RhdGVkIGBldmFsICgnKCcgKyBzaG93ICh4KSArICcpJykgPSB4YC5cbi8vLlxuLy8uIE9uZSBjYW4gbWFrZSB2YWx1ZXMgb2YgYSBjdXN0b20gdHlwZSBjb21wYXRpYmxlIHdpdGggW2BzaG93YF0oI3Nob3cpIGJ5XG4vLy4gZGVmaW5pbmcgYSBgQEBzaG93YCBtZXRob2QuIEZvciBleGFtcGxlOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vIyBNYXliZSNAQHNob3cgOjogTWF5YmUgYSB+PiAoKSAtPiBTdHJpbmdcbi8vLiAvLy5cbi8vLiAvLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vLiA+IHNob3cgKE5vdGhpbmcpXG4vLy4gLy8uICdOb3RoaW5nJ1xuLy8uIC8vLlxuLy8uIC8vLiA+IHNob3cgKEp1c3QgKFsnZm9vJywgJ2JhcicsICdiYXonXSkpXG4vLy4gLy8uICdKdXN0IChbXCJmb29cIiwgXCJiYXJcIiwgXCJiYXpcIl0pJ1xuLy8uIC8vLiBgYGBcbi8vLiBNYXliZS5wcm90b3R5cGVbJ0BAc2hvdyddID0gZnVuY3Rpb24oKSB7XG4vLy4gICByZXR1cm4gdGhpcy5pc05vdGhpbmcgPyAnTm90aGluZycgOiAnSnVzdCAoJyArIHNob3cgKHRoaXMudmFsdWUpICsgJyknO1xuLy8uIH07XG4vLy4gYGBgXG5cbihmdW5jdGlvbihmKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUoW10sIGYpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc2FuY3R1YXJ5U2hvdyA9IGYoKTtcbiAgfVxuXG59KGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyAgJCRzaG93IDo6IFN0cmluZ1xuICB2YXIgJCRzaG93ID0gJ0BAc2hvdyc7XG5cbiAgLy8gIHNlZW4gOjogQXJyYXkgQW55XG4gIHZhciBzZWVuID0gW107XG5cbiAgLy8gIGVudHJ5IDo6IE9iamVjdCAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIGVudHJ5KG8pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaykge1xuICAgICAgcmV0dXJuIHNob3coaykgKyAnOiAnICsgc2hvdyhvW2tdKTtcbiAgICB9O1xuICB9XG5cbiAgLy8jIHNob3cgOjogU2hvd2FibGUgYSA9PiBhIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFJldHVybnMgYSB1c2VmdWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBEaXNwYXRjaGVzIHRvIHRoZSB2YWx1ZSdzIGBAQHNob3dgIG1ldGhvZCBpZiBwcmVzZW50LlxuICAvLy5cbiAgLy8uIFdoZXJlIHByYWN0aWNhbCwgYHNob3cgKGV2YWwgKCcoJyArIHNob3cgKHgpICsgJyknKSkgPSBzaG93ICh4KWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBzaG93IChudWxsKVxuICAvLy4gJ251bGwnXG4gIC8vLlxuICAvLy4gPiBzaG93ICh1bmRlZmluZWQpXG4gIC8vLiAndW5kZWZpbmVkJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAodHJ1ZSlcbiAgLy8uICd0cnVlJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAobmV3IEJvb2xlYW4gKGZhbHNlKSlcbiAgLy8uICduZXcgQm9vbGVhbiAoZmFsc2UpJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAoLTApXG4gIC8vLiAnLTAnXG4gIC8vLlxuICAvLy4gPiBzaG93IChOYU4pXG4gIC8vLiAnTmFOJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAobmV3IE51bWJlciAoSW5maW5pdHkpKVxuICAvLy4gJ25ldyBOdW1iZXIgKEluZmluaXR5KSdcbiAgLy8uXG4gIC8vLiA+IHNob3cgKCdmb29cXG5cImJhclwiXFxuYmF6XFxuJylcbiAgLy8uICdcImZvb1xcXFxuXFxcXFwiYmFyXFxcXFwiXFxcXG5iYXpcXFxcblwiJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAobmV3IFN0cmluZyAoJycpKVxuICAvLy4gJ25ldyBTdHJpbmcgKFwiXCIpJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gJ1tcImZvb1wiLCBcImJhclwiLCBcImJhelwiXSdcbiAgLy8uXG4gIC8vLiA+IHNob3cgKFtbW1tbMF1dXV1dKVxuICAvLy4gJ1tbW1tbMF1dXV1dJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAoe3g6IFsxLCAyXSwgeTogWzMsIDRdLCB6OiBbNSwgNl19KVxuICAvLy4gJ3tcInhcIjogWzEsIDJdLCBcInlcIjogWzMsIDRdLCBcInpcIjogWzUsIDZdfSdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzaG93KHgpIHtcbiAgICBpZiAoc2Vlbi5pbmRleE9mKHgpID49IDApIHJldHVybiAnPENpcmN1bGFyPic7XG5cbiAgICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSkge1xuXG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/XG4gICAgICAgICAgJ25ldyBCb29sZWFuICgnICsgc2hvdyh4LnZhbHVlT2YoKSkgKyAnKScgOlxuICAgICAgICAgIHgudG9TdHJpbmcoKTtcblxuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/XG4gICAgICAgICAgJ25ldyBOdW1iZXIgKCcgKyBzaG93KHgudmFsdWVPZigpKSArICcpJyA6XG4gICAgICAgICAgMSAvIHggPT09IC1JbmZpbml0eSA/ICctMCcgOiB4LnRvU3RyaW5nKDEwKTtcblxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/XG4gICAgICAgICAgJ25ldyBTdHJpbmcgKCcgKyBzaG93KHgudmFsdWVPZigpKSArICcpJyA6XG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeCk7XG5cbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgICByZXR1cm4gJ25ldyBEYXRlICgnICtcbiAgICAgICAgICAgICAgIHNob3coaXNOYU4oeC52YWx1ZU9mKCkpID8gTmFOIDogeC50b0lTT1N0cmluZygpKSArXG4gICAgICAgICAgICAgICAnKSc7XG5cbiAgICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzpcbiAgICAgICAgcmV0dXJuICduZXcgJyArIHgubmFtZSArICcgKCcgKyBzaG93KHgubWVzc2FnZSkgKyAnKSc7XG5cbiAgICAgIGNhc2UgJ1tvYmplY3QgQXJndW1lbnRzXSc6XG4gICAgICAgIHJldHVybiAnZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9ICgnICtcbiAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh4LCBzaG93KS5qb2luKCcsICcpICtcbiAgICAgICAgICAgICAgICcpJztcblxuICAgICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxuICAgICAgICBzZWVuLnB1c2goeCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuICdbJyArIHgubWFwKHNob3cpLmNvbmNhdChcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHgpXG4gICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGspIHsgcmV0dXJuICEvXlxcZCskLy50ZXN0KGspOyB9KVxuICAgICAgICAgICAgLm1hcChlbnRyeSh4KSlcbiAgICAgICAgICApLmpvaW4oJywgJykgKyAnXSc7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2Vlbi5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAgICBzZWVuLnB1c2goeCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICQkc2hvdyBpbiB4ICYmXG4gICAgICAgICAgICAoeC5jb25zdHJ1Y3RvciA9PSBudWxsIHx8IHguY29uc3RydWN0b3IucHJvdG90eXBlICE9PSB4KSA/XG4gICAgICAgICAgICAgIHhbJCRzaG93XSgpIDpcbiAgICAgICAgICAgICAgJ3snICsgT2JqZWN0LmtleXMoeCkuc29ydCgpLm1hcChlbnRyeSh4KSkuam9pbignLCAnKSArICd9J1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2Vlbi5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU3RyaW5nKHgpO1xuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNob3c7XG5cbn0pKTtcbiIsIi8qXG4gICAgICAgICAgICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAgI1xuICAgICAgICAgICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAgIyMjXG4gICAgICAgICAgICAgICAgICAjIyMjIyAgICAgICAgICAgICAgICAgICMjIyMjXG4gICAgICAgICAgICAgICAgIyMjIyMgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjI1xuICAgICAgICAgICAgICAjIyMjIyAgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAgICAgICAjIyMjIyAgICAgICAgICAgICAgICAgICAgICMjIyMjIyMjIyMjXG4gICAgICAgICAgIyMjIyMgICAgICAgICAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAgICMjIyMjICAgICAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAjIyMjIyAgICAgICAgICAgICAgICAgICAgICAgICMjIyMjXG4gICAgICMjIyMjIyMjIyMjIyAgICAgICAgICAgICAgICAgIyMjXG4gICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAqL1xuXG4vLy4gIyBzYW5jdHVhcnktdHlwZS1jbGFzc2VzXG4vLy5cbi8vLiBUaGUgW0ZhbnRhc3kgTGFuZCBTcGVjaWZpY2F0aW9uXVtGTF0gXCJzcGVjaWZpZXMgaW50ZXJvcGVyYWJpbGl0eSBvZiBjb21tb25cbi8vLiBhbGdlYnJhaWMgc3RydWN0dXJlc1wiIGJ5IGRlZmluaW5nIGEgbnVtYmVyIG9mIHR5cGUgY2xhc3Nlcy4gRm9yIGVhY2ggdHlwZVxuLy8uIGNsYXNzLCBpdCBzdGF0ZXMgbGF3cyB3aGljaCBldmVyeSBtZW1iZXIgb2YgYSB0eXBlIG11c3Qgb2JleSBpbiBvcmRlciBmb3Jcbi8vLiB0aGUgdHlwZSB0byBiZSBhIG1lbWJlciBvZiB0aGUgdHlwZSBjbGFzcy4gSW4gb3JkZXIgZm9yIHRoZSBNYXliZSB0eXBlIHRvXG4vLy4gYmUgY29uc2lkZXJlZCBhIFtGdW5jdG9yXVtdLCBmb3IgZXhhbXBsZSwgZXZlcnkgYE1heWJlIGFgIHZhbHVlIG11c3QgaGF2ZVxuLy8uIGEgYGZhbnRhc3ktbGFuZC9tYXBgIG1ldGhvZCB3aGljaCBvYmV5cyB0aGUgaWRlbnRpdHkgYW5kIGNvbXBvc2l0aW9uIGxhd3MuXG4vLy5cbi8vLiBUaGlzIHByb2plY3QgcHJvdmlkZXM6XG4vLy5cbi8vLiAgIC0gW2BUeXBlQ2xhc3NgXSgjVHlwZUNsYXNzKSwgYSBmdW5jdGlvbiBmb3IgZGVmaW5pbmcgdHlwZSBjbGFzc2VzO1xuLy8uICAgLSBvbmUgYFR5cGVDbGFzc2AgdmFsdWUgZm9yIGVhY2ggRmFudGFzeSBMYW5kIHR5cGUgY2xhc3M7XG4vLy4gICAtIGxhd2Z1bCBGYW50YXN5IExhbmQgbWV0aG9kcyBmb3IgSmF2YVNjcmlwdCdzIGJ1aWx0LWluIHR5cGVzO1xuLy8uICAgLSBvbmUgZnVuY3Rpb24gZm9yIGVhY2ggRmFudGFzeSBMYW5kIG1ldGhvZDsgYW5kXG4vLy4gICAtIHNldmVyYWwgZnVuY3Rpb25zIGRlcml2ZWQgZnJvbSB0aGVzZSBmdW5jdGlvbnMuXG4vLy5cbi8vLiAjIyBUeXBlLWNsYXNzIGhpZXJhcmNoeVxuLy8uXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4vLy4gPHByZT5cbi8vLiAgU2V0b2lkICAgU2VtaWdyb3Vwb2lkICBTZW1pZ3JvdXAgICBGb2xkYWJsZSAgICAgICAgRnVuY3RvciAgICAgIENvbnRyYXZhcmlhbnQgIEZpbHRlcmFibGVcbi8vLiAoZXF1YWxzKSAgICAoY29tcG9zZSkgICAgKGNvbmNhdCkgICAocmVkdWNlKSAgICAgICAgIChtYXApICAgICAgICAoY29udHJhbWFwKSAgICAoZmlsdGVyKVxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICBcXCAgICAgICAgIC8gfCB8IHwgfCBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgXFwgICAgICAgLyAgfCB8IHwgfCAgXFxcbi8vLiAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICBcXCAgICAgLyAgIHwgfCB8IHwgICBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICBcXCAgIC8gICAgfCB8IHwgfCAgICBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgXFwgLyAgICAgfCB8IHwgfCAgICAgXFxcbi8vLiAgICBPcmQgICAgICBDYXRlZ29yeSAgICAgTW9ub2lkICAgICAgICAgVHJhdmVyc2FibGUgfCB8IHwgfCAgICAgIFxcXG4vLy4gICAobHRlKSAgICAgICAoaWQpICAgICAgIChlbXB0eSkgICAgICAgICh0cmF2ZXJzZSkgIC8gfCB8IFxcICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgLyAgfCB8ICBcXCAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgLyAgIC8gXFwgICBcXCAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgIFByb2Z1bmN0b3IgLyAgIFxcIEJpZnVuY3RvciBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAocHJvbWFwKSAvICAgICBcXCAoYmltYXApICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAvICAgICAgIFxcICAgICAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgR3JvdXAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgIFxcICAgICAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAoaW52ZXJ0KSAgICAgICAgICAgICAgIEFsdCAgICAgICAgQXBwbHkgICAgICBFeHRlbmRcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhbHQpICAgICAgICAoYXApICAgICAoZXh0ZW5kKVxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAvICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICAgIFxcICAgICAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgICAgICAgICAvICAgICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGx1cyAgICBBcHBsaWNhdGl2ZSAgICBDaGFpbiAgICAgIENvbW9uYWRcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh6ZXJvKSAgICAgICAob2YpICAgICAgKGNoYWluKSAgICAoZXh0cmFjdClcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgICAgICAgLyBcXCAgICAgICAgIC8gXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXCAgICAgICAvICAgXFwgICAgICAgLyAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgICAvICAgICBcXCAgICAgLyAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgLyAgICAgICBcXCAgIC8gICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXCAvICAgICAgICAgXFwgLyAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBbHRlcm5hdGl2ZSAgICBNb25hZCAgICAgQ2hhaW5SZWNcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjaGFpblJlYylcbi8vLiA8L3ByZT5cbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuLy8uXG4vLy4gIyMgQVBJXG5cbihmdW5jdGlvbihmKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJykpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAhPSBudWxsKSB7XG4gICAgZGVmaW5lKFsnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnXSwgZik7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zYW5jdHVhcnlUeXBlQ2xhc3NlcyA9IGYoc2VsZi5zYW5jdHVhcnlUeXBlSWRlbnRpZmllcnMpO1xuICB9XG5cbn0oZnVuY3Rpb24odHlwZSkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBfX2RvY3Rlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLyogZ2xvYmFsIF9fZG9jdGVzdDpmYWxzZSAqL1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgdmFyIElkZW50aXR5ID0gX19kb2N0ZXN0LnJlcXVpcmUoJy4vdGVzdC9JZGVudGl0eScpO1xuICAgIHZhciBMaXN0ID0gX19kb2N0ZXN0LnJlcXVpcmUoJy4vdGVzdC9MaXN0Jyk7XG4gICAgdmFyIE1heWJlID0gX19kb2N0ZXN0LnJlcXVpcmUoJy4vdGVzdC9NYXliZScpO1xuICAgIHZhciBTdW0gPSBfX2RvY3Rlc3QucmVxdWlyZSgnLi90ZXN0L1N1bScpO1xuICAgIHZhciBUdXBsZSA9IF9fZG9jdGVzdC5yZXF1aXJlKCcuL3Rlc3QvVHVwbGUnKTtcblxuICAgIHZhciBOaWwgPSBMaXN0Lk5pbCwgQ29ucyA9IExpc3QuQ29ucztcbiAgICB2YXIgTm90aGluZyA9IE1heWJlLk5vdGhpbmcsIEp1c3QgPSBNYXliZS5KdXN0O1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgfVxuXG4gIC8vICBjb25jYXRfIDo6IEFycmF5IGEgLT4gQXJyYXkgYSAtPiBBcnJheSBhXG4gIGZ1bmN0aW9uIGNvbmNhdF8oeHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeXMpIHtcbiAgICAgIHJldHVybiB4cy5jb25jYXQoeXMpO1xuICAgIH07XG4gIH1cblxuICAvLyAgY29uc3RhbnQgOjogYSAtPiBiIC0+IGFcbiAgZnVuY3Rpb24gY29uc3RhbnQoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9O1xuICB9XG5cbiAgLy8gIGZvckVhY2hLZXkgOjogKFN0ck1hcCBhLCBTdHJNYXAgYSB+PiBTdHJpbmcgLT4gVW5kZWZpbmVkKSAtPiBVbmRlZmluZWRcbiAgZnVuY3Rpb24gZm9yRWFjaEtleShzdHJNYXAsIGYpIHtcbiAgICBPYmplY3Qua2V5cyhzdHJNYXApLmZvckVhY2goZiwgc3RyTWFwKTtcbiAgfVxuXG4gIC8vICBoYXMgOjogKFN0cmluZywgT2JqZWN0KSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIGhhcyhrLCBvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKTtcbiAgfVxuXG4gIC8vICBpZGVudGl0eSA6OiBhIC0+IGFcbiAgZnVuY3Rpb24gaWRlbnRpdHkoeCkgeyByZXR1cm4geDsgfVxuXG4gIC8vICBwYWlyIDo6IGEgLT4gYiAtPiBBcnJheTIgYSBiXG4gIGZ1bmN0aW9uIHBhaXIoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gW3gsIHldO1xuICAgIH07XG4gIH1cblxuICAvLyAgc2FtZVR5cGUgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gc2FtZVR5cGUoeCwgeSkge1xuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gdHlwZW9mIHkgJiYgdHlwZSh4KSA9PT0gdHlwZSh5KTtcbiAgfVxuXG4gIC8vICB0aHJ1c2ggOjogYSAtPiAoYSAtPiBiKSAtPiBiXG4gIGZ1bmN0aW9uIHRocnVzaCh4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBmKHgpO1xuICAgIH07XG4gIH1cblxuICAvLyAgdHlwZSBJdGVyYXRpb24gYSA9IHsgdmFsdWUgOjogYSwgZG9uZSA6OiBCb29sZWFuIH1cblxuICAvLyAgaXRlcmF0aW9uTmV4dCA6OiBhIC0+IEl0ZXJhdGlvbiBhXG4gIGZ1bmN0aW9uIGl0ZXJhdGlvbk5leHQoeCkgeyByZXR1cm4ge3ZhbHVlOiB4LCBkb25lOiBmYWxzZX07IH1cblxuICAvLyAgaXRlcmF0aW9uRG9uZSA6OiBhIC0+IEl0ZXJhdGlvbiBhXG4gIGZ1bmN0aW9uIGl0ZXJhdGlvbkRvbmUoeCkgeyByZXR1cm4ge3ZhbHVlOiB4LCBkb25lOiB0cnVlfTsgfVxuXG4gIC8vIyBUeXBlQ2xhc3MgOjogKFN0cmluZywgU3RyaW5nLCBBcnJheSBUeXBlQ2xhc3MsIGEgLT4gQm9vbGVhbikgLT4gVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gVGhlIGFyZ3VtZW50cyBhcmU6XG4gIC8vLlxuICAvLy4gICAtIHRoZSBuYW1lIG9mIHRoZSB0eXBlIGNsYXNzLCBwcmVmaXhlZCBieSBpdHMgbnBtIHBhY2thZ2UgbmFtZTtcbiAgLy8uICAgLSB0aGUgZG9jdW1lbnRhdGlvbiBVUkwgb2YgdGhlIHR5cGUgY2xhc3M7XG4gIC8vLiAgIC0gYW4gYXJyYXkgb2YgZGVwZW5kZW5jaWVzOyBhbmRcbiAgLy8uICAgLSBhIHByZWRpY2F0ZSB3aGljaCBhY2NlcHRzIGFueSBKYXZhU2NyaXB0IHZhbHVlIGFuZCByZXR1cm5zIGB0cnVlYFxuICAvLy4gICAgIGlmIHRoZSB2YWx1ZSBzYXRpc2ZpZXMgdGhlIHJlcXVpcmVtZW50cyBvZiB0aGUgdHlwZSBjbGFzczsgYGZhbHNlYFxuICAvLy4gICAgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBFeGFtcGxlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIC8vICAgIGhhc01ldGhvZCA6OiBTdHJpbmcgLT4gYSAtPiBCb29sZWFuXG4gIC8vLiBjb25zdCBoYXNNZXRob2QgPSBuYW1lID0+IHggPT4geCAhPSBudWxsICYmIHR5cGVvZiB4W25hbWVdID09ICdmdW5jdGlvbic7XG4gIC8vLlxuICAvLy4gLy8gICAgRm9vIDo6IFR5cGVDbGFzc1xuICAvLy4gY29uc3QgRm9vID0gWi5UeXBlQ2xhc3MoXG4gIC8vLiAgICdteS1wYWNrYWdlL0ZvbycsXG4gIC8vLiAgICdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNGb28nLFxuICAvLy4gICBbXSxcbiAgLy8uICAgaGFzTWV0aG9kKCdmb28nKVxuICAvLy4gKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBCYXIgOjogVHlwZUNsYXNzXG4gIC8vLiBjb25zdCBCYXIgPSBaLlR5cGVDbGFzcyhcbiAgLy8uICAgJ215LXBhY2thZ2UvQmFyJyxcbiAgLy8uICAgJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI0JhcicsXG4gIC8vLiAgIFtGb29dLFxuICAvLy4gICBoYXNNZXRob2QoJ2JhcicpXG4gIC8vLiApO1xuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gVHlwZXMgd2hvc2UgdmFsdWVzIGhhdmUgYSBgZm9vYCBtZXRob2QgYXJlIG1lbWJlcnMgb2YgdGhlIEZvbyB0eXBlIGNsYXNzLlxuICAvLy4gTWVtYmVycyBvZiB0aGUgRm9vIHR5cGUgY2xhc3Mgd2hvc2UgdmFsdWVzIGhhdmUgYSBgYmFyYCBtZXRob2QgYXJlIGFsc29cbiAgLy8uIG1lbWJlcnMgb2YgdGhlIEJhciB0eXBlIGNsYXNzLlxuICAvLy5cbiAgLy8uIEVhY2ggYFR5cGVDbGFzc2AgdmFsdWUgaGFzIGEgYHRlc3RgIGZpZWxkOiBhIGZ1bmN0aW9uIHdoaWNoIGFjY2VwdHNcbiAgLy8uIGFueSBKYXZhU2NyaXB0IHZhbHVlIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgc2F0aXNmaWVzIHRoZVxuICAvLy4gdHlwZSBjbGFzcydzIHByZWRpY2F0ZSBhbmQgdGhlIHByZWRpY2F0ZXMgb2YgYWxsIHRoZSB0eXBlIGNsYXNzJ3NcbiAgLy8uIGRlcGVuZGVuY2llczsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWVzIG1heSBiZSB1c2VkIHdpdGggW3NhbmN0dWFyeS1kZWZdW3R5cGUtY2xhc3Nlc11cbiAgLy8uIHRvIGRlZmluZSBwYXJhbWV0cmljYWxseSBwb2x5bW9ycGhpYyBmdW5jdGlvbnMgd2hpY2ggdmVyaWZ5IHRoZWlyXG4gIC8vLiB0eXBlLWNsYXNzIGNvbnN0cmFpbnRzIGF0IHJ1biB0aW1lLlxuICBmdW5jdGlvbiBUeXBlQ2xhc3MobmFtZSwgdXJsLCBkZXBlbmRlbmNpZXMsIHRlc3QpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHlwZUNsYXNzKSkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlQ2xhc3MobmFtZSwgdXJsLCBkZXBlbmRlbmNpZXMsIHRlc3QpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudGVzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBkZXBlbmRlbmNpZXMuZXZlcnkoZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50ZXN0KHgpOyB9KSAmJiB0ZXN0KHgpO1xuICAgIH07XG4gIH1cblxuICBUeXBlQ2xhc3NbJ0BAdHlwZSddID0gJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvVHlwZUNsYXNzJztcblxuICAvLyAgZGF0YSBMb2NhdGlvbiA9IENvbnN0cnVjdG9yIHwgVmFsdWVcblxuICAvLyAgQ29uc3RydWN0b3IgOjogTG9jYXRpb25cbiAgdmFyIENvbnN0cnVjdG9yID0gJ0NvbnN0cnVjdG9yJztcblxuICAvLyAgVmFsdWUgOjogTG9jYXRpb25cbiAgdmFyIFZhbHVlID0gJ1ZhbHVlJztcblxuICAvLyAgX2Z1bmNQYXRoIDo6IChCb29sZWFuLCBBcnJheSBTdHJpbmcsIGEpIC0+IE51bGxhYmxlIEZ1bmN0aW9uXG4gIGZ1bmN0aW9uIF9mdW5jUGF0aChhbGxvd0luaGVyaXRlZFByb3BzLCBwYXRoLCBfeCkge1xuICAgIHZhciB4ID0gX3g7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcGF0aC5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICB2YXIgayA9IHBhdGhbaWR4XTtcbiAgICAgIGlmICh4ID09IG51bGwgfHwgIShhbGxvd0luaGVyaXRlZFByb3BzIHx8IGhhcyhrLCB4KSkpIHJldHVybiBudWxsO1xuICAgICAgeCA9IHhba107XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyA/IHggOiBudWxsO1xuICB9XG5cbiAgLy8gIGZ1bmNQYXRoIDo6IChBcnJheSBTdHJpbmcsIGEpIC0+IE51bGxhYmxlIEZ1bmN0aW9uXG4gIGZ1bmN0aW9uIGZ1bmNQYXRoKHBhdGgsIHgpIHtcbiAgICByZXR1cm4gX2Z1bmNQYXRoKHRydWUsIHBhdGgsIHgpO1xuICB9XG5cbiAgLy8gIGltcGxQYXRoIDo6IEFycmF5IFN0cmluZyAtPiBOdWxsYWJsZSBGdW5jdGlvblxuICBmdW5jdGlvbiBpbXBsUGF0aChwYXRoKSB7XG4gICAgcmV0dXJuIF9mdW5jUGF0aChmYWxzZSwgcGF0aCwgaW1wbGVtZW50YXRpb25zKTtcbiAgfVxuXG4gIC8vICBmdW5jdGlvbk5hbWUgOjogRnVuY3Rpb24gLT4gU3RyaW5nXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBoYXMoJ25hbWUnLCBmdW5jdGlvbiBmKCkge30pID9cbiAgICBmdW5jdGlvbiBmdW5jdGlvbk5hbWUoZikgeyByZXR1cm4gZi5uYW1lOyB9IDpcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmKSB7XG4gICAgICB2YXIgbWF0Y2ggPSAvZnVuY3Rpb24gKFxcdyopLy5leGVjKGYpO1xuICAgICAgcmV0dXJuIG1hdGNoID09IG51bGwgPyAnJyA6IG1hdGNoWzFdO1xuICAgIH07XG5cbiAgLy8gICQgOjogKFN0cmluZywgQXJyYXkgVHlwZUNsYXNzLCBTdHJNYXAgKEFycmF5IExvY2F0aW9uKSkgLT4gVHlwZUNsYXNzXG4gIGZ1bmN0aW9uICQoX25hbWUsIGRlcGVuZGVuY2llcywgcmVxdWlyZW1lbnRzKSB7XG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRNZXRob2QoX25hbWUpIHtcbiAgICAgIHZhciBuYW1lID0gJ2ZhbnRhc3ktbGFuZC8nICsgX25hbWU7XG4gICAgICByZXR1cm4gcmVxdWlyZW1lbnRzW19uYW1lXSA9PT0gQ29uc3RydWN0b3IgP1xuICAgICAgICBmdW5jdGlvbih0eXBlUmVwKSB7XG4gICAgICAgICAgdmFyIGYgPSBmdW5jUGF0aChbbmFtZV0sIHR5cGVSZXApO1xuICAgICAgICAgIHJldHVybiBmID09IG51bGwgJiYgdHlwZW9mIHR5cGVSZXAgPT09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgaW1wbFBhdGgoW2Z1bmN0aW9uTmFtZSh0eXBlUmVwKSwgbmFtZV0pIDpcbiAgICAgICAgICAgIGY7XG4gICAgICAgIH0gOlxuICAgICAgICBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgdmFyIGlzUHJvdG90eXBlID0geCAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jb25zdHJ1Y3RvciAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHg7XG4gICAgICAgICAgdmFyIG0gPSBudWxsO1xuICAgICAgICAgIGlmICghaXNQcm90b3R5cGUpIG0gPSBmdW5jUGF0aChbbmFtZV0sIHgpO1xuICAgICAgICAgIGlmIChtID09IG51bGwpICAgIG0gPSBpbXBsUGF0aChbdHlwZSh4KSwgJ3Byb3RvdHlwZScsIG5hbWVdKTtcbiAgICAgICAgICByZXR1cm4gbSAmJiBtLmJpbmQoeCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHZlcnNpb24gPSAnOS4wLjAnOyAgLy8gdXBkYXRlZCBwcm9ncmFtbWF0aWNhbGx5XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZXF1aXJlbWVudHMpO1xuXG4gICAgdmFyIHR5cGVDbGFzcyA9IFR5cGVDbGFzcyhcbiAgICAgICdzYW5jdHVhcnktdHlwZS1jbGFzc2VzLycgKyBfbmFtZSxcbiAgICAgICdodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvdHJlZS92JyArIHZlcnNpb25cbiAgICAgICAgKyAnIycgKyBfbmFtZSxcbiAgICAgIGRlcGVuZGVuY2llcyxcbiAgICAgIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoZnVuY3Rpb24oX25hbWUpIHtcbiAgICAgICAgICB2YXIgYXJnID0gcmVxdWlyZW1lbnRzW19uYW1lXSA9PT0gQ29uc3RydWN0b3IgPyB4LmNvbnN0cnVjdG9yIDogeDtcbiAgICAgICAgICByZXR1cm4gZ2V0Qm91bmRNZXRob2QoX25hbWUpKGFyZykgIT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIHR5cGVDbGFzcy5tZXRob2RzID0ga2V5cy5yZWR1Y2UoZnVuY3Rpb24obWV0aG9kcywgX25hbWUpIHtcbiAgICAgIG1ldGhvZHNbX25hbWVdID0gZ2V0Qm91bmRNZXRob2QoX25hbWUpO1xuICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgfSwge30pO1xuXG4gICAgcmV0dXJuIHR5cGVDbGFzcztcbiAgfVxuXG4gIC8vIyBTZXRvaWQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtTZXRvaWRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTZXRvaWQudGVzdChudWxsKVxuICAvLy4gdHJ1ZVxuICAvLy4gYGBgXG4gIHZhciBTZXRvaWQgPSAkKCdTZXRvaWQnLCBbXSwge2VxdWFsczogVmFsdWV9KTtcblxuICAvLyMgT3JkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbT3JkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gT3JkLnRlc3QoMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IE9yZC50ZXN0KE1hdGguc3FydClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIE9yZCA9ICQoJ09yZCcsIFtTZXRvaWRdLCB7bHRlOiBWYWx1ZX0pO1xuXG4gIC8vIyBTZW1pZ3JvdXBvaWQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtTZW1pZ3JvdXBvaWRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTZW1pZ3JvdXBvaWQudGVzdChNYXRoLnNxcnQpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTZW1pZ3JvdXBvaWQudGVzdCgwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgU2VtaWdyb3Vwb2lkID0gJCgnU2VtaWdyb3Vwb2lkJywgW10sIHtjb21wb3NlOiBWYWx1ZX0pO1xuXG4gIC8vIyBDYXRlZ29yeSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0NhdGVnb3J5XVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ2F0ZWdvcnkudGVzdChNYXRoLnNxcnQpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBDYXRlZ29yeS50ZXN0KDApXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBDYXRlZ29yeSA9ICQoJ0NhdGVnb3J5JywgW1NlbWlncm91cG9pZF0sIHtpZDogQ29uc3RydWN0b3J9KTtcblxuICAvLyMgU2VtaWdyb3VwIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbU2VtaWdyb3VwXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gU2VtaWdyb3VwLnRlc3QoJycpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTZW1pZ3JvdXAudGVzdCgwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgU2VtaWdyb3VwID0gJCgnU2VtaWdyb3VwJywgW10sIHtjb25jYXQ6IFZhbHVlfSk7XG5cbiAgLy8jIE1vbm9pZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW01vbm9pZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IE1vbm9pZC50ZXN0KCcnKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gTW9ub2lkLnRlc3QoMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIE1vbm9pZCA9ICQoJ01vbm9pZCcsIFtTZW1pZ3JvdXBdLCB7ZW1wdHk6IENvbnN0cnVjdG9yfSk7XG5cbiAgLy8jIEdyb3VwIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbR3JvdXBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBHcm91cC50ZXN0KFN1bSgwKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEdyb3VwLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBHcm91cCA9ICQoJ0dyb3VwJywgW01vbm9pZF0sIHtpbnZlcnQ6IFZhbHVlfSk7XG5cbiAgLy8jIEZpbHRlcmFibGUgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtGaWx0ZXJhYmxlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gRmlsdGVyYWJsZS50ZXN0KHt9KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gRmlsdGVyYWJsZS50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgRmlsdGVyYWJsZSA9ICQoJ0ZpbHRlcmFibGUnLCBbXSwge2ZpbHRlcjogVmFsdWV9KTtcblxuICAvLyMgRnVuY3RvciA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0Z1bmN0b3JdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBGdW5jdG9yLnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBGdW5jdG9yLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBGdW5jdG9yID0gJCgnRnVuY3RvcicsIFtdLCB7bWFwOiBWYWx1ZX0pO1xuXG4gIC8vIyBCaWZ1bmN0b3IgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtCaWZ1bmN0b3JdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBCaWZ1bmN0b3IudGVzdChUdXBsZSgnZm9vJywgNjQpKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQmlmdW5jdG9yLnRlc3QoW10pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBCaWZ1bmN0b3IgPSAkKCdCaWZ1bmN0b3InLCBbRnVuY3Rvcl0sIHtiaW1hcDogVmFsdWV9KTtcblxuICAvLyMgUHJvZnVuY3RvciA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW1Byb2Z1bmN0b3JdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBQcm9mdW5jdG9yLnRlc3QoTWF0aC5zcXJ0KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUHJvZnVuY3Rvci50ZXN0KFtdKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgUHJvZnVuY3RvciA9ICQoJ1Byb2Z1bmN0b3InLCBbRnVuY3Rvcl0sIHtwcm9tYXA6IFZhbHVlfSk7XG5cbiAgLy8jIEFwcGx5IDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQXBwbHldW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBBcHBseS50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQXBwbHkudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEFwcGx5ID0gJCgnQXBwbHknLCBbRnVuY3Rvcl0sIHthcDogVmFsdWV9KTtcblxuICAvLyMgQXBwbGljYXRpdmUgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtBcHBsaWNhdGl2ZV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEFwcGxpY2F0aXZlLnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBBcHBsaWNhdGl2ZS50ZXN0KHt9KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQXBwbGljYXRpdmUgPSAkKCdBcHBsaWNhdGl2ZScsIFtBcHBseV0sIHtvZjogQ29uc3RydWN0b3J9KTtcblxuICAvLyMgQ2hhaW4gOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtDaGFpbl1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IENoYWluLnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBDaGFpbi50ZXN0KHt9KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQ2hhaW4gPSAkKCdDaGFpbicsIFtBcHBseV0sIHtjaGFpbjogVmFsdWV9KTtcblxuICAvLyMgQ2hhaW5SZWMgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtDaGFpblJlY11bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IENoYWluUmVjLnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBDaGFpblJlYy50ZXN0KHt9KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQ2hhaW5SZWMgPSAkKCdDaGFpblJlYycsIFtDaGFpbl0sIHtjaGFpblJlYzogQ29uc3RydWN0b3J9KTtcblxuICAvLyMgTW9uYWQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtNb25hZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IE1vbmFkLnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBNb25hZC50ZXN0KHt9KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgTW9uYWQgPSAkKCdNb25hZCcsIFtBcHBsaWNhdGl2ZSwgQ2hhaW5dLCB7fSk7XG5cbiAgLy8jIEFsdCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0FsdF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEFsdC50ZXN0KHt9KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQWx0LnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBBbHQgPSAkKCdBbHQnLCBbRnVuY3Rvcl0sIHthbHQ6IFZhbHVlfSk7XG5cbiAgLy8jIFBsdXMgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtQbHVzXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUGx1cy50ZXN0KHt9KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUGx1cy50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgUGx1cyA9ICQoJ1BsdXMnLCBbQWx0XSwge3plcm86IENvbnN0cnVjdG9yfSk7XG5cbiAgLy8jIEFsdGVybmF0aXZlIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQWx0ZXJuYXRpdmVdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBBbHRlcm5hdGl2ZS50ZXN0KFtdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQWx0ZXJuYXRpdmUudGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEFsdGVybmF0aXZlID0gJCgnQWx0ZXJuYXRpdmUnLCBbQXBwbGljYXRpdmUsIFBsdXNdLCB7fSk7XG5cbiAgLy8jIEZvbGRhYmxlIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbRm9sZGFibGVdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBGb2xkYWJsZS50ZXN0KHt9KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gRm9sZGFibGUudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEZvbGRhYmxlID0gJCgnRm9sZGFibGUnLCBbXSwge3JlZHVjZTogVmFsdWV9KTtcblxuICAvLyMgVHJhdmVyc2FibGUgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtUcmF2ZXJzYWJsZV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFRyYXZlcnNhYmxlLnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBUcmF2ZXJzYWJsZS50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgVHJhdmVyc2FibGUgPSAkKCdUcmF2ZXJzYWJsZScsIFtGdW5jdG9yLCBGb2xkYWJsZV0sIHt0cmF2ZXJzZTogVmFsdWV9KTtcblxuICAvLyMgRXh0ZW5kIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbRXh0ZW5kXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gRXh0ZW5kLnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBFeHRlbmQudGVzdCh7fSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEV4dGVuZCA9ICQoJ0V4dGVuZCcsIFtGdW5jdG9yXSwge2V4dGVuZDogVmFsdWV9KTtcblxuICAvLyMgQ29tb25hZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0NvbW9uYWRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBDb21vbmFkLnRlc3QoSWRlbnRpdHkoMCkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBDb21vbmFkLnRlc3QoW10pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBDb21vbmFkID0gJCgnQ29tb25hZCcsIFtFeHRlbmRdLCB7ZXh0cmFjdDogVmFsdWV9KTtcblxuICAvLyMgQ29udHJhdmFyaWFudCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0NvbnRyYXZhcmlhbnRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBDb250cmF2YXJpYW50LnRlc3QoTWF0aC5zcXJ0KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gQ29udHJhdmFyaWFudC50ZXN0KFtdKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQ29udHJhdmFyaWFudCA9ICQoJ0NvbnRyYXZhcmlhbnQnLCBbXSwge2NvbnRyYW1hcDogVmFsdWV9KTtcblxuICAvLyAgTnVsbCRwcm90b3R5cGUkZXF1YWxzIDo6IE51bGwgfj4gTnVsbCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE51bGwkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIE51bGwkcHJvdG90eXBlJGx0ZSA6OiBOdWxsIH4+IE51bGwgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBOdWxsJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vICBVbmRlZmluZWQkcHJvdG90eXBlJGVxdWFscyA6OiBVbmRlZmluZWQgfj4gVW5kZWZpbmVkIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gVW5kZWZpbmVkJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vICBVbmRlZmluZWQkcHJvdG90eXBlJGx0ZSA6OiBVbmRlZmluZWQgfj4gVW5kZWZpbmVkIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gVW5kZWZpbmVkJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vICBCb29sZWFuJHByb3RvdHlwZSRlcXVhbHMgOjogQm9vbGVhbiB+PiBCb29sZWFuIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gQm9vbGVhbiRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICBlcXVhbHModGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSkgOlxuICAgICAgdGhpcyA9PT0gb3RoZXI7XG4gIH1cblxuICAvLyAgQm9vbGVhbiRwcm90b3R5cGUkbHRlIDo6IEJvb2xlYW4gfj4gQm9vbGVhbiAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEJvb2xlYW4kcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgbHRlKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIHRoaXMgPT09IGZhbHNlIHx8IG90aGVyID09PSB0cnVlO1xuICB9XG5cbiAgLy8gIE51bWJlciRwcm90b3R5cGUkZXF1YWxzIDo6IE51bWJlciB+PiBOdW1iZXIgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBOdW1iZXIkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgZXF1YWxzKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIGlzTmFOKHRoaXMpICYmIGlzTmFOKG90aGVyKSB8fCB0aGlzID09PSBvdGhlcjtcbiAgfVxuXG4gIC8vICBOdW1iZXIkcHJvdG90eXBlJGx0ZSA6OiBOdW1iZXIgfj4gTnVtYmVyIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gTnVtYmVyJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgIGx0ZSh0aGlzLnZhbHVlT2YoKSwgb3RoZXIudmFsdWVPZigpKSA6XG4gICAgICBpc05hTih0aGlzKSB8fCB0aGlzIDw9IG90aGVyO1xuICB9XG5cbiAgLy8gIERhdGUkcHJvdG90eXBlJGVxdWFscyA6OiBEYXRlIH4+IERhdGUgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBEYXRlJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gZXF1YWxzKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpO1xuICB9XG5cbiAgLy8gIERhdGUkcHJvdG90eXBlJGx0ZSA6OiBEYXRlIH4+IERhdGUgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBEYXRlJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gbHRlKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpO1xuICB9XG5cbiAgLy8gIFJlZ0V4cCRwcm90b3R5cGUkZXF1YWxzIDo6IFJlZ0V4cCB+PiBSZWdFeHAgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBSZWdFeHAkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlci5zb3VyY2UgPT09IHRoaXMuc291cmNlICYmXG4gICAgICAgICAgIG90aGVyLmdsb2JhbCA9PT0gdGhpcy5nbG9iYWwgJiZcbiAgICAgICAgICAgb3RoZXIuaWdub3JlQ2FzZSA9PT0gdGhpcy5pZ25vcmVDYXNlICYmXG4gICAgICAgICAgIG90aGVyLm11bHRpbGluZSA9PT0gdGhpcy5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgb3RoZXIuc3RpY2t5ID09PSB0aGlzLnN0aWNreSAmJlxuICAgICAgICAgICBvdGhlci51bmljb2RlID09PSB0aGlzLnVuaWNvZGU7XG4gIH1cblxuICAvLyAgU3RyaW5nJGVtcHR5IDo6ICgpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBTdHJpbmckZW1wdHkoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gIFN0cmluZyRwcm90b3R5cGUkZXF1YWxzIDo6IFN0cmluZyB+PiBTdHJpbmcgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBTdHJpbmckcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgZXF1YWxzKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIHRoaXMgPT09IG90aGVyO1xuICB9XG5cbiAgLy8gIFN0cmluZyRwcm90b3R5cGUkbHRlIDo6IFN0cmluZyB+PiBTdHJpbmcgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBTdHJpbmckcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgbHRlKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIHRoaXMgPD0gb3RoZXI7XG4gIH1cblxuICAvLyAgU3RyaW5nJHByb3RvdHlwZSRjb25jYXQgOjogU3RyaW5nIH4+IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gU3RyaW5nJHByb3RvdHlwZSRjb25jYXQob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcyArIG90aGVyO1xuICB9XG5cbiAgLy8gIEFycmF5JGVtcHR5IDo6ICgpIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gQXJyYXkkZW1wdHkoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgLy8gIEFycmF5JG9mIDo6IGEgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBBcnJheSRvZih4KSB7XG4gICAgcmV0dXJuIFt4XTtcbiAgfVxuXG4gIC8vICBBcnJheSRjaGFpblJlYyA6OiAoKGEgLT4gYywgYiAtPiBjLCBhKSAtPiBBcnJheSBjLCBhKSAtPiBBcnJheSBiXG4gIGZ1bmN0aW9uIEFycmF5JGNoYWluUmVjKGYsIHgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIG5pbCA9IHt9O1xuICAgIHZhciB0b2RvID0ge2hlYWQ6IHgsIHRhaWw6IG5pbH07XG4gICAgd2hpbGUgKHRvZG8gIT09IG5pbCkge1xuICAgICAgdmFyIG1vcmUgPSBuaWw7XG4gICAgICB2YXIgc3RlcHMgPSBmKGl0ZXJhdGlvbk5leHQsIGl0ZXJhdGlvbkRvbmUsIHRvZG8uaGVhZCk7XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBzdGVwcy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICAgIHZhciBzdGVwID0gc3RlcHNbaWR4XTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHN0ZXAudmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vcmUgPSB7aGVhZDogc3RlcC52YWx1ZSwgdGFpbDogbW9yZX07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRvZG8gPSB0b2RvLnRhaWw7XG4gICAgICB3aGlsZSAobW9yZSAhPT0gbmlsKSB7XG4gICAgICAgIHRvZG8gPSB7aGVhZDogbW9yZS5oZWFkLCB0YWlsOiB0b2RvfTtcbiAgICAgICAgbW9yZSA9IG1vcmUudGFpbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBBcnJheSR6ZXJvIDo6ICgpIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gQXJyYXkkemVybygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGVxdWFscyA6OiBBcnJheSBhIH4+IEFycmF5IGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKG90aGVyLmxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIGlmICghZXF1YWxzKHRoaXNbaWR4XSwgb3RoZXJbaWR4XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGx0ZSA6OiBBcnJheSBhIH4+IEFycmF5IGEgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgdHJ1ZTsgaWR4ICs9IDEpIHtcbiAgICAgIGlmIChpZHggPT09IHRoaXMubGVuZ3RoKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChpZHggPT09IG90aGVyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFlcXVhbHModGhpc1tpZHhdLCBvdGhlcltpZHhdKSkgcmV0dXJuIGx0ZSh0aGlzW2lkeF0sIG90aGVyW2lkeF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkY29uY2F0IDo6IEFycmF5IGEgfj4gQXJyYXkgYSAtPiBBcnJheSBhXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRjb25jYXQob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb25jYXQob3RoZXIpO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRmaWx0ZXIgOjogQXJyYXkgYSB+PiAoYSAtPiBCb29sZWFuKSAtPiBBcnJheSBhXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRmaWx0ZXIocHJlZCkge1xuICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBwcmVkKHgpOyB9KTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkbWFwIDo6IEFycmF5IGEgfj4gKGEgLT4gYikgLT4gQXJyYXkgYlxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gZih4KTsgfSk7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGFwIDo6IEFycmF5IGEgfj4gQXJyYXkgKGEgLT4gYikgLT4gQXJyYXkgYlxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkYXAoZnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgZnMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgZm9yICh2YXIgaWR4MiA9IDA7IGlkeDIgPCB0aGlzLmxlbmd0aDsgaWR4MiArPSAxKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGZzW2lkeF0odGhpc1tpZHgyXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRjaGFpbiA6OiBBcnJheSBhIH4+IChhIC0+IEFycmF5IGIpIC0+IEFycmF5IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGNoYWluKGYpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICBmb3IgKHZhciBpZHgyID0gMCwgeHMgPSBmKHRoaXNbaWR4XSk7IGlkeDIgPCB4cy5sZW5ndGg7IGlkeDIgKz0gMSkge1xuICAgICAgICByZXN1bHQucHVzaCh4c1tpZHgyXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGFsdCA6OiBBcnJheSBhIH4+IEFycmF5IGEgLT4gQXJyYXkgYVxuICB2YXIgQXJyYXkkcHJvdG90eXBlJGFsdCA9IEFycmF5JHByb3RvdHlwZSRjb25jYXQ7XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRyZWR1Y2UgOjogQXJyYXkgYSB+PiAoKGIsIGEpIC0+IGIsIGIpIC0+IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJHJlZHVjZShmLCBpbml0aWFsKSB7XG4gICAgdmFyIGFjYyA9IGluaXRpYWw7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdGhpcy5sZW5ndGg7IGlkeCArPSAxKSBhY2MgPSBmKGFjYywgdGhpc1tpZHhdKTtcbiAgICByZXR1cm4gYWNjO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSR0cmF2ZXJzZSA6OiBBcHBsaWNhdGl2ZSBmID0+IEFycmF5IGEgfj4gKFR5cGVSZXAgZiwgYSAtPiBmIGIpIC0+IGYgKEFycmF5IGIpXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSR0cmF2ZXJzZSh0eXBlUmVwLCBmKSB7XG4gICAgdmFyIHhzID0gdGhpcztcbiAgICBmdW5jdGlvbiBnbyhpZHgsIG4pIHtcbiAgICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6IHJldHVybiBvZih0eXBlUmVwLCBbXSk7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIGxpZnQyKHBhaXIsIGYoeHNbaWR4XSksIGYoeHNbaWR4ICsgMV0pKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2YXIgbSA9IE1hdGguZmxvb3IobiAvIDQpICogMjtcbiAgICAgICAgICByZXR1cm4gbGlmdDIoY29uY2F0XywgZ28oaWR4LCBtKSwgZ28oaWR4ICsgbSwgbiAtIG0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoICUgMiA9PT0gMSA/XG4gICAgICBsaWZ0Mihjb25jYXRfLCBtYXAoQXJyYXkkb2YsIGYodGhpc1swXSkpLCBnbygxLCB0aGlzLmxlbmd0aCAtIDEpKSA6XG4gICAgICBnbygwLCB0aGlzLmxlbmd0aCk7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGV4dGVuZCA6OiBBcnJheSBhIH4+IChBcnJheSBhIC0+IGIpIC0+IEFycmF5IGJcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGV4dGVuZChmKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKF8sIGlkeCwgeHMpIHsgcmV0dXJuIGYoeHMuc2xpY2UoaWR4KSk7IH0pO1xuICB9XG5cbiAgLy8gIEFyZ3VtZW50cyRwcm90b3R5cGUkZXF1YWxzIDo6IEFyZ3VtZW50cyB+PiBBcmd1bWVudHMgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBBcmd1bWVudHMkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBBcnJheSRwcm90b3R5cGUkZXF1YWxzLmNhbGwodGhpcywgb3RoZXIpO1xuICB9XG5cbiAgLy8gIEFyZ3VtZW50cyRwcm90b3R5cGUkbHRlIDo6IEFyZ3VtZW50cyB+PiBBcmd1bWVudHMgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBBcmd1bWVudHMkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiBBcnJheSRwcm90b3R5cGUkbHRlLmNhbGwodGhpcywgb3RoZXIpO1xuICB9XG5cbiAgLy8gIEVycm9yJHByb3RvdHlwZSRlcXVhbHMgOjogRXJyb3Igfj4gRXJyb3IgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBFcnJvciRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIGVxdWFscyh0aGlzLm5hbWUsIG90aGVyLm5hbWUpICYmXG4gICAgICAgICAgIGVxdWFscyh0aGlzLm1lc3NhZ2UsIG90aGVyLm1lc3NhZ2UpO1xuICB9XG5cbiAgLy8gIE9iamVjdCRlbXB0eSA6OiAoKSAtPiBTdHJNYXAgYVxuICBmdW5jdGlvbiBPYmplY3QkZW1wdHkoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gIE9iamVjdCR6ZXJvIDo6ICgpIC0+IFN0ck1hcCBhXG4gIGZ1bmN0aW9uIE9iamVjdCR6ZXJvKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJGVxdWFscyA6OiBTdHJNYXAgYSB+PiBTdHJNYXAgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcykuc29ydCgpO1xuICAgIHJldHVybiBlcXVhbHMoa2V5cywgT2JqZWN0LmtleXMob3RoZXIpLnNvcnQoKSkgJiZcbiAgICAgICAgICAga2V5cy5ldmVyeShmdW5jdGlvbihrKSB7IHJldHVybiBlcXVhbHMoc2VsZltrXSwgb3RoZXJba10pOyB9KTtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJGx0ZSA6OiBTdHJNYXAgYSB+PiBTdHJNYXAgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgdmFyIHRoZXNlS2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpLnNvcnQoKTtcbiAgICB2YXIgb3RoZXJLZXlzID0gT2JqZWN0LmtleXMob3RoZXIpLnNvcnQoKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHRoZXNlS2V5cy5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG90aGVyS2V5cy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBrID0gdGhlc2VLZXlzLnNoaWZ0KCk7XG4gICAgICB2YXIgeiA9IG90aGVyS2V5cy5zaGlmdCgpO1xuICAgICAgaWYgKGsgPCB6KSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChrID4geikgcmV0dXJuIGZhbHNlO1xuICAgICAgaWYgKCFlcXVhbHModGhpc1trXSwgb3RoZXJba10pKSByZXR1cm4gbHRlKHRoaXNba10sIG90aGVyW2tdKTtcbiAgICB9XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRjb25jYXQgOjogU3RyTWFwIGEgfj4gU3RyTWFwIGEgLT4gU3RyTWFwIGFcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRjb25jYXQob3RoZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZnVuY3Rpb24gYXNzaWduKGspIHsgcmVzdWx0W2tdID0gdGhpc1trXTsgfVxuICAgIGZvckVhY2hLZXkodGhpcywgYXNzaWduKTtcbiAgICBmb3JFYWNoS2V5KG90aGVyLCBhc3NpZ24pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRmaWx0ZXIgOjogU3RyTWFwIGEgfj4gKGEgLT4gQm9vbGVhbikgLT4gU3RyTWFwIGFcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRmaWx0ZXIocHJlZCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3JFYWNoS2V5KHRoaXMsIGZ1bmN0aW9uKGspIHsgaWYgKHByZWQodGhpc1trXSkpIHJlc3VsdFtrXSA9IHRoaXNba107IH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRtYXAgOjogU3RyTWFwIGEgfj4gKGEgLT4gYikgLT4gU3RyTWFwIGJcbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRtYXAoZikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3JFYWNoS2V5KHRoaXMsIGZ1bmN0aW9uKGspIHsgcmVzdWx0W2tdID0gZih0aGlzW2tdKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJGFwIDo6IFN0ck1hcCBhIH4+IFN0ck1hcCAoYSAtPiBiKSAtPiBTdHJNYXAgYlxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJGFwKG90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvckVhY2hLZXkodGhpcywgZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGhhcyhrLCBvdGhlcikpIHJlc3VsdFtrXSA9IG90aGVyW2tdKHRoaXNba10pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRhbHQgOjogU3RyTWFwIGEgfj4gU3RyTWFwIGEgLT4gU3RyTWFwIGFcbiAgdmFyIE9iamVjdCRwcm90b3R5cGUkYWx0ID0gT2JqZWN0JHByb3RvdHlwZSRjb25jYXQ7XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkcmVkdWNlIDo6IFN0ck1hcCBhIH4+ICgoYiwgYSkgLT4gYiwgYikgLT4gYlxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJHJlZHVjZShmLCBpbml0aWFsKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIHJlZHVjZXIoYWNjLCBrKSB7IHJldHVybiBmKGFjYywgc2VsZltrXSk7IH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykuc29ydCgpLnJlZHVjZShyZWR1Y2VyLCBpbml0aWFsKTtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJHRyYXZlcnNlIDo6IEFwcGxpY2F0aXZlIGYgPT4gU3RyTWFwIGEgfj4gKFR5cGVSZXAgZiwgYSAtPiBmIGIpIC0+IGYgKFN0ck1hcCBiKVxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJHRyYXZlcnNlKHR5cGVSZXAsIGYpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLnJlZHVjZShmdW5jdGlvbihhcHBsaWNhdGl2ZSwgaykge1xuICAgICAgZnVuY3Rpb24gc2V0KG8pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgc2luZ2xldG9uID0ge307IHNpbmdsZXRvbltrXSA9IHY7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdCRwcm90b3R5cGUkY29uY2F0LmNhbGwobywgc2luZ2xldG9uKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaWZ0MihzZXQsIGFwcGxpY2F0aXZlLCBmKHNlbGZba10pKTtcbiAgICB9LCBvZih0eXBlUmVwLCB7fSkpO1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJGlkIDo6ICgpIC0+IGEgLT4gYVxuICBmdW5jdGlvbiBGdW5jdGlvbiRpZCgpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kb2YgOjogYiAtPiAoYSAtPiBiKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRvZih4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKF8pIHsgcmV0dXJuIHg7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kY2hhaW5SZWMgOjogKChhIC0+IGMsIGIgLT4gYywgYSkgLT4gKHogLT4gYyksIGEpIC0+ICh6IC0+IGIpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJGNoYWluUmVjKGYsIHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYSkge1xuICAgICAgdmFyIHN0ZXAgPSBpdGVyYXRpb25OZXh0KHgpO1xuICAgICAgd2hpbGUgKCFzdGVwLmRvbmUpIHtcbiAgICAgICAgc3RlcCA9IGYoaXRlcmF0aW9uTmV4dCwgaXRlcmF0aW9uRG9uZSwgc3RlcC52YWx1ZSkoYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RlcC52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRlcXVhbHMgOjogRnVuY3Rpb24gfj4gRnVuY3Rpb24gLT4gQm9vbGVhblxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyID09PSB0aGlzO1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRjb21wb3NlIDo6IChhIC0+IGIpIH4+IChiIC0+IGMpIC0+IChhIC0+IGMpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRjb21wb3NlKG90aGVyKSB7XG4gICAgdmFyIHNlbWlncm91cG9pZCA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIG90aGVyKHNlbWlncm91cG9pZCh4KSk7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJG1hcCA6OiAoYSAtPiBiKSB+PiAoYiAtPiBjKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICB2YXIgZnVuY3RvciA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYoZnVuY3Rvcih4KSk7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJHByb21hcCA6OiAoYiAtPiBjKSB+PiAoYSAtPiBiLCBjIC0+IGQpIC0+IChhIC0+IGQpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRwcm9tYXAoZiwgZykge1xuICAgIHZhciBwcm9mdW5jdG9yID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gZyhwcm9mdW5jdG9yKGYoeCkpKTsgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkYXAgOjogKGEgLT4gYikgfj4gKGEgLT4gYiAtPiBjKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkYXAoZikge1xuICAgIHZhciBhcHBseSA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYoeCkoYXBwbHkoeCkpOyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRjaGFpbiA6OiAoYSAtPiBiKSB+PiAoYiAtPiBhIC0+IGMpIC0+IChhIC0+IGMpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRjaGFpbihmKSB7XG4gICAgdmFyIGNoYWluID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gZihjaGFpbih4KSkoeCk7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJGV4dGVuZCA6OiBTZW1pZ3JvdXAgYSA9PiAoYSAtPiBiKSB+PiAoKGEgLT4gYikgLT4gYykgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJGV4dGVuZChmKSB7XG4gICAgdmFyIGV4dGVuZCA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBmKGZ1bmN0aW9uKHkpIHsgcmV0dXJuIGV4dGVuZChjb25jYXQoeCwgeSkpOyB9KTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRjb250cmFtYXAgOjogKGIgLT4gYykgfj4gKGEgLT4gYikgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJGNvbnRyYW1hcChmKSB7XG4gICAgdmFyIGNvbnRyYXZhcmlhbnQgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBjb250cmF2YXJpYW50KGYoeCkpOyB9O1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgdmFyIGltcGxlbWVudGF0aW9ucyA9IHtcbiAgICBOdWxsOiB7XG4gICAgICAncHJvdG90eXBlJzoge1xuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgTnVsbCRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgTnVsbCRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBVbmRlZmluZWQ6IHtcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBVbmRlZmluZWQkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIFVuZGVmaW5lZCRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBCb29sZWFuOiB7XG4gICAgICAncHJvdG90eXBlJzoge1xuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgQm9vbGVhbiRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgQm9vbGVhbiRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBOdW1iZXI6IHtcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBOdW1iZXIkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIE51bWJlciRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBEYXRlOiB7XG4gICAgICAncHJvdG90eXBlJzoge1xuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgRGF0ZSRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgRGF0ZSRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBSZWdFeHA6IHtcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBSZWdFeHAkcHJvdG90eXBlJGVxdWFsc1xuICAgICAgfVxuICAgIH0sXG4gICAgU3RyaW5nOiB7XG4gICAgICAnZmFudGFzeS1sYW5kL2VtcHR5JzogICAgICAgICBTdHJpbmckZW1wdHksXG4gICAgICAncHJvdG90eXBlJzoge1xuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgU3RyaW5nJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBTdHJpbmckcHJvdG90eXBlJGx0ZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb25jYXQnOiAgICAgIFN0cmluZyRwcm90b3R5cGUkY29uY2F0XG4gICAgICB9XG4gICAgfSxcbiAgICBBcnJheToge1xuICAgICAgJ2ZhbnRhc3ktbGFuZC9lbXB0eSc6ICAgICAgICAgQXJyYXkkZW1wdHksXG4gICAgICAnZmFudGFzeS1sYW5kL29mJzogICAgICAgICAgICBBcnJheSRvZixcbiAgICAgICdmYW50YXN5LWxhbmQvY2hhaW5SZWMnOiAgICAgIEFycmF5JGNoYWluUmVjLFxuICAgICAgJ2ZhbnRhc3ktbGFuZC96ZXJvJzogICAgICAgICAgQXJyYXkkemVybyxcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBBcnJheSRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgQXJyYXkkcHJvdG90eXBlJGx0ZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb25jYXQnOiAgICAgIEFycmF5JHByb3RvdHlwZSRjb25jYXQsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZmlsdGVyJzogICAgICBBcnJheSRwcm90b3R5cGUkZmlsdGVyLFxuICAgICAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgICAgQXJyYXkkcHJvdG90eXBlJG1hcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICAgIEFycmF5JHByb3RvdHlwZSRhcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jaGFpbic6ICAgICAgIEFycmF5JHByb3RvdHlwZSRjaGFpbixcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hbHQnOiAgICAgICAgIEFycmF5JHByb3RvdHlwZSRhbHQsXG4gICAgICAgICdmYW50YXN5LWxhbmQvcmVkdWNlJzogICAgICBBcnJheSRwcm90b3R5cGUkcmVkdWNlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL3RyYXZlcnNlJzogICAgQXJyYXkkcHJvdG90eXBlJHRyYXZlcnNlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2V4dGVuZCc6ICAgICAgQXJyYXkkcHJvdG90eXBlJGV4dGVuZFxuICAgICAgfVxuICAgIH0sXG4gICAgQXJndW1lbnRzOiB7XG4gICAgICAncHJvdG90eXBlJzoge1xuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgQXJndW1lbnRzJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBBcmd1bWVudHMkcHJvdG90eXBlJGx0ZVxuICAgICAgfVxuICAgIH0sXG4gICAgRXJyb3I6IHtcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBFcnJvciRwcm90b3R5cGUkZXF1YWxzXG4gICAgICB9XG4gICAgfSxcbiAgICBPYmplY3Q6IHtcbiAgICAgICdmYW50YXN5LWxhbmQvZW1wdHknOiAgICAgICAgIE9iamVjdCRlbXB0eSxcbiAgICAgICdmYW50YXN5LWxhbmQvemVybyc6ICAgICAgICAgIE9iamVjdCR6ZXJvLFxuICAgICAgJ3Byb3RvdHlwZSc6IHtcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIE9iamVjdCRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgT2JqZWN0JHByb3RvdHlwZSRsdGUsXG4gICAgICAgICdmYW50YXN5LWxhbmQvY29uY2F0JzogICAgICBPYmplY3QkcHJvdG90eXBlJGNvbmNhdCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9maWx0ZXInOiAgICAgIE9iamVjdCRwcm90b3R5cGUkZmlsdGVyLFxuICAgICAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgICAgT2JqZWN0JHByb3RvdHlwZSRtYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvYXAnOiAgICAgICAgICBPYmplY3QkcHJvdG90eXBlJGFwLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2FsdCc6ICAgICAgICAgT2JqZWN0JHByb3RvdHlwZSRhbHQsXG4gICAgICAgICdmYW50YXN5LWxhbmQvcmVkdWNlJzogICAgICBPYmplY3QkcHJvdG90eXBlJHJlZHVjZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSc6ICAgIE9iamVjdCRwcm90b3R5cGUkdHJhdmVyc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIEZ1bmN0aW9uOiB7XG4gICAgICAnZmFudGFzeS1sYW5kL2lkJzogICAgICAgICAgICBGdW5jdGlvbiRpZCxcbiAgICAgICdmYW50YXN5LWxhbmQvb2YnOiAgICAgICAgICAgIEZ1bmN0aW9uJG9mLFxuICAgICAgJ2ZhbnRhc3ktbGFuZC9jaGFpblJlYyc6ICAgICAgRnVuY3Rpb24kY2hhaW5SZWMsXG4gICAgICAncHJvdG90eXBlJzoge1xuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgRnVuY3Rpb24kcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb21wb3NlJzogICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRjb21wb3NlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgICAgRnVuY3Rpb24kcHJvdG90eXBlJG1hcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9wcm9tYXAnOiAgICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRwcm9tYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvYXAnOiAgICAgICAgICBGdW5jdGlvbiRwcm90b3R5cGUkYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvY2hhaW4nOiAgICAgICBGdW5jdGlvbiRwcm90b3R5cGUkY2hhaW4sXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXh0ZW5kJzogICAgICBGdW5jdGlvbiRwcm90b3R5cGUkZXh0ZW5kLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NvbnRyYW1hcCc6ICAgRnVuY3Rpb24kcHJvdG90eXBlJGNvbnRyYW1hcFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuXG4gIC8vIyBlcXVhbHMgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCBlcXVhbCBhY2NvcmRpbmdcbiAgLy8uIHRvIHRoZSB0eXBlJ3MgW2BmYW50YXN5LWxhbmQvZXF1YWxzYF1bXSBtZXRob2Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZXF1YWxzYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogTnVsbCwgVW5kZWZpbmVkLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIFJlZ0V4cCwgU3RyaW5nLFxuICAvLy4gQXJyYXksIEFyZ3VtZW50cywgRXJyb3IsIE9iamVjdCwgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIFRoZSBhbGdvcml0aG0gc3VwcG9ydHMgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzLiBUd28gYXJyYXlzIGFyZSBlcXVhbFxuICAvLy4gaWYgdGhleSBoYXZlIHRoZSBzYW1lIGluZGV4IHBhdGhzIGFuZCBmb3IgZWFjaCBwYXRoIGhhdmUgZXF1YWwgdmFsdWVzLlxuICAvLy4gVHdvIGFycmF5cyB3aGljaCByZXByZXNlbnQgYFsxLCBbMSwgWzEsIFsxLCBbMSwgLi4uXV1dXV1gLCBmb3IgZXhhbXBsZSxcbiAgLy8uIGFyZSBlcXVhbCBldmVuIGlmIHRoZWlyIGludGVybmFsIHN0cnVjdHVyZXMgZGlmZmVyLiBUd28gb2JqZWN0cyBhcmUgZXF1YWxcbiAgLy8uIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSBwcm9wZXJ0eSBwYXRocyBhbmQgZm9yIGVhY2ggcGF0aCBoYXZlIGVxdWFsIHZhbHVlcy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGVxdWFscygwLCAtMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVxdWFscyhOYU4sIE5hTilcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVxdWFscyhDb25zKCdmb28nLCBDb25zKCdiYXInLCBOaWwpKSwgQ29ucygnZm9vJywgQ29ucygnYmFyJywgTmlsKSkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlcXVhbHMoQ29ucygnZm9vJywgQ29ucygnYmFyJywgTmlsKSksIENvbnMoJ2JhcicsIENvbnMoJ2ZvbycsIE5pbCkpKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgZXF1YWxzID0gKGZ1bmN0aW9uKCkge1xuICAgIC8vICAkcGFpcnMgOjogQXJyYXkgKEFycmF5MiBBbnkgQW55KVxuICAgIHZhciAkcGFpcnMgPSBbXTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBlcXVhbHMoeCwgeSkge1xuICAgICAgaWYgKCFzYW1lVHlwZSh4LCB5KSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyAgVGhpcyBhbGdvcml0aG0gZm9yIGNvbXBhcmluZyBjaXJjdWxhciBkYXRhIHN0cnVjdHVyZXMgd2FzXG4gICAgICAvLyAgc3VnZ2VzdGVkIGluIDxodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MDYyMjc5NC8zMTI3ODU+LlxuICAgICAgaWYgKCRwYWlycy5zb21lKGZ1bmN0aW9uKHApIHsgcmV0dXJuIHBbMF0gPT09IHggJiYgcFsxXSA9PT0geTsgfSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgICRwYWlycy5wdXNoKFt4LCB5XSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gU2V0b2lkLnRlc3QoeCkgJiYgU2V0b2lkLnRlc3QoeSkgJiYgU2V0b2lkLm1ldGhvZHMuZXF1YWxzKHgpKHkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgJHBhaXJzLnBvcCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG5cbiAgLy8jIGx0IDo6IChhLCBiKSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgaXRzIGFyZ3VtZW50cyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmQgdGhlIGZpcnN0IGlzXG4gIC8vLiBsZXNzIHRoYW4gdGhlIHNlY29uZCBhY2NvcmRpbmcgdG8gdGhlIHR5cGUncyBbYGZhbnRhc3ktbGFuZC9sdGVgXVtdXG4gIC8vLiBtZXRob2Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BndGBdKCNndCkgYW5kIFtgZ3RlYF0oI2d0ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBsdCgwLCAwKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGx0KDAsIDEpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBsdCgxLCAwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBsdCh4LCB5KSB7XG4gICAgcmV0dXJuIHNhbWVUeXBlKHgsIHkpICYmICFsdGUoeSwgeCk7XG4gIH1cblxuICAvLyMgbHRlIDo6IChhLCBiKSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgaXRzIGFyZ3VtZW50cyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmQgdGhlIGZpcnN0XG4gIC8vLiBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNlY29uZCBhY2NvcmRpbmcgdG8gdGhlIHR5cGUnc1xuICAvLy4gW2BmYW50YXN5LWxhbmQvbHRlYF1bXSBtZXRob2Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvbHRlYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogTnVsbCwgVW5kZWZpbmVkLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIFN0cmluZywgQXJyYXksXG4gIC8vLiBBcmd1bWVudHMsIGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gVGhlIGFsZ29yaXRobSBzdXBwb3J0cyBjaXJjdWxhciBkYXRhIHN0cnVjdHVyZXMgaW4gdGhlIHNhbWUgbWFubmVyIGFzXG4gIC8vLiBbYGVxdWFsc2BdKCNlcXVhbHMpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbHRgXSgjbHQpLCBbYGd0YF0oI2d0KSwgYW5kIFtgZ3RlYF0oI2d0ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBsdGUoMCwgMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGx0ZSgwLCAxKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gbHRlKDEsIDApXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBsdGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gICRwYWlycyA6OiBBcnJheSAoQXJyYXkyIEFueSBBbnkpXG4gICAgdmFyICRwYWlycyA9IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGx0ZSh4LCB5KSB7XG4gICAgICBpZiAoIXNhbWVUeXBlKHgsIHkpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vICBUaGlzIGFsZ29yaXRobSBmb3IgY29tcGFyaW5nIGNpcmN1bGFyIGRhdGEgc3RydWN0dXJlcyB3YXNcbiAgICAgIC8vICBzdWdnZXN0ZWQgaW4gPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQwNjIyNzk0LzMxMjc4NT4uXG4gICAgICBpZiAoJHBhaXJzLnNvbWUoZnVuY3Rpb24ocCkgeyByZXR1cm4gcFswXSA9PT0geCAmJiBwWzFdID09PSB5OyB9KSkge1xuICAgICAgICByZXR1cm4gZXF1YWxzKHgsIHkpO1xuICAgICAgfVxuXG4gICAgICAkcGFpcnMucHVzaChbeCwgeV0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIE9yZC50ZXN0KHgpICYmIE9yZC50ZXN0KHkpICYmIE9yZC5tZXRob2RzLmx0ZSh4KSh5KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICRwYWlycy5wb3AoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCkpO1xuXG4gIC8vIyBndCA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHRoZSBmaXJzdCBpc1xuICAvLy4gZ3JlYXRlciB0aGFuIHRoZSBzZWNvbmQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlJ3MgW2BmYW50YXN5LWxhbmQvbHRlYF1bXVxuICAvLy4gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbHRgXSgjbHQpIGFuZCBbYGd0ZWBdKCNndGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZ3QoMCwgMClcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBndCgwLCAxKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGd0KDEsIDApXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZ3QoeCwgeSkge1xuICAgIHJldHVybiBsdCh5LCB4KTtcbiAgfVxuXG4gIC8vIyBndGUgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCB0aGUgZmlyc3RcbiAgLy8uIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kIGFjY29yZGluZyB0byB0aGUgdHlwZSdzXG4gIC8vLiBbYGZhbnRhc3ktbGFuZC9sdGVgXVtdIG1ldGhvZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGx0YF0oI2x0KSBhbmQgW2BndGBdKCNndCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBndGUoMCwgMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGd0ZSgwLCAxKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGd0ZSgxLCAwKVxuICAvLy4gdHJ1ZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGd0ZSh4LCB5KSB7XG4gICAgcmV0dXJuIGx0ZSh5LCB4KTtcbiAgfVxuXG4gIC8vIyBtaW4gOjogT3JkIGEgPT4gKGEsIGEpIC0+IGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBzbWFsbGVyIG9mIGl0cyB0d28gYXJndW1lbnRzLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BtYXhgXSgjbWF4KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IG1pbigxMCwgMilcbiAgLy8uIDJcbiAgLy8uXG4gIC8vLiA+IG1pbihuZXcgRGF0ZSgnMTk5OS0xMi0zMScpLCBuZXcgRGF0ZSgnMjAwMC0wMS0wMScpKVxuICAvLy4gbmV3IERhdGUoJzE5OTktMTItMzEnKVxuICAvLy5cbiAgLy8uID4gbWluKCcxMCcsICcyJylcbiAgLy8uICcxMCdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtaW4oeCwgeSkge1xuICAgIHJldHVybiBsdGUoeCwgeSkgPyB4IDogeTtcbiAgfVxuXG4gIC8vIyBtYXggOjogT3JkIGEgPT4gKGEsIGEpIC0+IGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBsYXJnZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1pbmBdKCNtaW4pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbWF4KDEwLCAyKVxuICAvLy4gMTBcbiAgLy8uXG4gIC8vLiA+IG1heChuZXcgRGF0ZSgnMTk5OS0xMi0zMScpLCBuZXcgRGF0ZSgnMjAwMC0wMS0wMScpKVxuICAvLy4gbmV3IERhdGUoJzIwMDAtMDEtMDEnKVxuICAvLy5cbiAgLy8uID4gbWF4KCcxMCcsICcyJylcbiAgLy8uICcyJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1heCh4LCB5KSB7XG4gICAgcmV0dXJuIGx0ZSh4LCB5KSA/IHkgOiB4O1xuICB9XG5cbiAgLy8jIGNvbXBvc2UgOjogU2VtaWdyb3Vwb2lkIGMgPT4gKGMgaiBrLCBjIGkgaikgLT4gYyBpIGtcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9jb21wb3NlYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NvbXBvc2VgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNvbXBvc2UoTWF0aC5zcXJ0LCB4ID0+IHggKyAxKSg5OSlcbiAgLy8uIDEwXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgcmV0dXJuIFNlbWlncm91cG9pZC5tZXRob2RzLmNvbXBvc2UoeSkoeCk7XG4gIH1cblxuICAvLyMgaWQgOjogQ2F0ZWdvcnkgYyA9PiBUeXBlUmVwIGMgLT4gY1xuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2lkYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2lkYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBpZChGdW5jdGlvbikoJ2ZvbycpXG4gIC8vLiAnZm9vJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGlkKHR5cGVSZXApIHtcbiAgICByZXR1cm4gQ2F0ZWdvcnkubWV0aG9kcy5pZCh0eXBlUmVwKSgpO1xuICB9XG5cbiAgLy8jIGNvbmNhdCA6OiBTZW1pZ3JvdXAgYSA9PiAoYSwgYSkgLT4gYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NvbmNhdGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9jb25jYXRgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBTdHJpbmcsIEFycmF5LCBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29uY2F0KCdhYmMnLCAnZGVmJylcbiAgLy8uICdhYmNkZWYnXG4gIC8vLlxuICAvLy4gPiBjb25jYXQoWzEsIDIsIDNdLCBbNCwgNSwgNl0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNSwgNl1cbiAgLy8uXG4gIC8vLiA+IGNvbmNhdCh7eDogMSwgeTogMn0sIHt5OiAzLCB6OiA0fSlcbiAgLy8uIHt4OiAxLCB5OiAzLCB6OiA0fVxuICAvLy5cbiAgLy8uID4gY29uY2F0KENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIE5pbCkpKSwgQ29ucygncXV1eCcsIE5pbCkpXG4gIC8vLiBDb25zKCdmb28nLCBDb25zKCdiYXInLCBDb25zKCdiYXonLCBDb25zKCdxdXV4JywgTmlsKSkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGNvbmNhdCh4LCB5KSB7XG4gICAgcmV0dXJuIFNlbWlncm91cC5tZXRob2RzLmNvbmNhdCh4KSh5KTtcbiAgfVxuXG4gIC8vIyBlbXB0eSA6OiBNb25vaWQgbSA9PiBUeXBlUmVwIG0gLT4gbVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2VtcHR5YF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2VtcHR5YCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogU3RyaW5nLCBBcnJheSwgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGVtcHR5KFN0cmluZylcbiAgLy8uICcnXG4gIC8vLlxuICAvLy4gPiBlbXB0eShBcnJheSlcbiAgLy8uIFtdXG4gIC8vLlxuICAvLy4gPiBlbXB0eShPYmplY3QpXG4gIC8vLiB7fVxuICAvLy5cbiAgLy8uID4gZW1wdHkoTGlzdClcbiAgLy8uIE5pbFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGVtcHR5KHR5cGVSZXApIHtcbiAgICByZXR1cm4gTW9ub2lkLm1ldGhvZHMuZW1wdHkodHlwZVJlcCkoKTtcbiAgfVxuXG4gIC8vIyBpbnZlcnQgOjogR3JvdXAgZyA9PiBnIC0+IGdcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9pbnZlcnRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gaW52ZXJ0KFN1bSg1KSlcbiAgLy8uIFN1bSgtNSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBpbnZlcnQoZ3JvdXApIHtcbiAgICByZXR1cm4gR3JvdXAubWV0aG9kcy5pbnZlcnQoZ3JvdXApKCk7XG4gIH1cblxuICAvLyMgZmlsdGVyIDo6IEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2ZpbHRlcmBdW10uIERpc2NhcmRzIGV2ZXJ5IGVsZW1lbnRcbiAgLy8uIHdoaWNoIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2ZpbHRlcmAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2ByZWplY3RgXSgjcmVqZWN0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGZpbHRlcih4ID0+IHggJSAyID09IDEsIFsxLCAyLCAzXSlcbiAgLy8uIFsxLCAzXVxuICAvLy5cbiAgLy8uID4gZmlsdGVyKHggPT4geCAlIDIgPT0gMSwge3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4ge3g6IDEsIHo6IDN9XG4gIC8vLlxuICAvLy4gPiBmaWx0ZXIoeCA9PiB4ICUgMiA9PSAxLCBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMywgTmlsKSlcbiAgLy8uXG4gIC8vLiA+IGZpbHRlcih4ID0+IHggJSAyID09IDEsIE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBmaWx0ZXIoeCA9PiB4ICUgMiA9PSAxLCBKdXN0KDApKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gZmlsdGVyKHggPT4geCAlIDIgPT0gMSwgSnVzdCgxKSlcbiAgLy8uIEp1c3QoMSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBmaWx0ZXIocHJlZCwgZmlsdGVyYWJsZSkge1xuICAgIHJldHVybiBGaWx0ZXJhYmxlLm1ldGhvZHMuZmlsdGVyKGZpbHRlcmFibGUpKHByZWQpO1xuICB9XG5cbiAgLy8jIHJlamVjdCA6OiBGaWx0ZXJhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbiwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBEaXNjYXJkcyBldmVyeSBlbGVtZW50IHdoaWNoIHNhdGlzZmllcyB0aGUgcHJlZGljYXRlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgZmlsdGVyYF0oI2ZpbHRlcikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiByZWplY3QoeCA9PiB4ICUgMiA9PSAxLCBbMSwgMiwgM10pXG4gIC8vLiBbMl1cbiAgLy8uXG4gIC8vLiA+IHJlamVjdCh4ID0+IHggJSAyID09IDEsIHt4OiAxLCB5OiAyLCB6OiAzfSlcbiAgLy8uIHt5OiAyfVxuICAvLy5cbiAgLy8uID4gcmVqZWN0KHggPT4geCAlIDIgPT0gMSwgQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpKVxuICAvLy4gQ29ucygyLCBOaWwpXG4gIC8vLlxuICAvLy4gPiByZWplY3QoeCA9PiB4ICUgMiA9PSAxLCBOb3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gcmVqZWN0KHggPT4geCAlIDIgPT0gMSwgSnVzdCgwKSlcbiAgLy8uIEp1c3QoMClcbiAgLy8uXG4gIC8vLiA+IHJlamVjdCh4ID0+IHggJSAyID09IDEsIEp1c3QoMSkpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmVqZWN0KHByZWQsIGZpbHRlcmFibGUpIHtcbiAgICByZXR1cm4gZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFwcmVkKHgpOyB9LCBmaWx0ZXJhYmxlKTtcbiAgfVxuXG4gIC8vIyB0YWtlV2hpbGUgOjogRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4sIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRGlzY2FyZHMgdGhlIGZpcnN0IGVsZW1lbnQgd2hpY2ggZG9lcyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLCBhbmQgYWxsXG4gIC8vLiBzdWJzZXF1ZW50IGVsZW1lbnRzLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgZmlsdGVyYF0oI2ZpbHRlcikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bkcm9wV2hpbGVgXSgjZHJvcFdoaWxlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHRha2VXaGlsZShzID0+IC94Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h5JywgJ3h6JywgJ3l4J11cbiAgLy8uXG4gIC8vLiA+IHRha2VXaGlsZShzID0+IC95Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h5J11cbiAgLy8uXG4gIC8vLiA+IHRha2VXaGlsZShzID0+IC96Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRha2VXaGlsZShwcmVkLCBmaWx0ZXJhYmxlKSB7XG4gICAgdmFyIHRha2UgPSB0cnVlO1xuICAgIHJldHVybiBmaWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gdGFrZSA9IHRha2UgJiYgcHJlZCh4KTsgfSwgZmlsdGVyYWJsZSk7XG4gIH1cblxuICAvLyMgZHJvcFdoaWxlIDo6IEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldGFpbnMgdGhlIGZpcnN0IGVsZW1lbnQgd2hpY2ggZG9lcyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLCBhbmQgYWxsXG4gIC8vLiBzdWJzZXF1ZW50IGVsZW1lbnRzLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgZmlsdGVyYF0oI2ZpbHRlcikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B0YWtlV2hpbGVgXSgjdGFrZVdoaWxlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGRyb3BXaGlsZShzID0+IC94Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3l6JywgJ3p4JywgJ3p5J11cbiAgLy8uXG4gIC8vLiA+IGRyb3BXaGlsZShzID0+IC95Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J11cbiAgLy8uXG4gIC8vLiA+IGRyb3BXaGlsZShzID0+IC96Ly50ZXN0KHMpLCBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J10pXG4gIC8vLiBbJ3h5JywgJ3h6JywgJ3l4JywgJ3l6JywgJ3p4JywgJ3p5J11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBkcm9wV2hpbGUocHJlZCwgZmlsdGVyYWJsZSkge1xuICAgIHZhciB0YWtlID0gZmFsc2U7XG4gICAgcmV0dXJuIGZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB0YWtlID0gdGFrZSB8fCAhcHJlZCh4KTsgfSwgZmlsdGVyYWJsZSk7XG4gIH1cblxuICAvLyMgbWFwIDo6IEZ1bmN0b3IgZiA9PiAoYSAtPiBiLCBmIGEpIC0+IGYgYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL21hcGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9tYXBgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSwgT2JqZWN0LCBhbmQgRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBbMSwgNCwgOV0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIHt4OiAxLCB5OiA0LCB6OiA5fSlcbiAgLy8uIHt4OiAxLCB5OiAyLCB6OiAzfVxuICAvLy5cbiAgLy8uID4gbWFwKE1hdGguc3FydCwgcyA9PiBzLmxlbmd0aCkoJ1NhbmN0dWFyeScpXG4gIC8vLiAzXG4gIC8vLlxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBUdXBsZSgnZm9vJywgNjQpKVxuICAvLy4gVHVwbGUoJ2ZvbycsIDgpXG4gIC8vLlxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBOaWwpXG4gIC8vLiBOaWxcbiAgLy8uXG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIENvbnMoMSwgQ29ucyg0LCBDb25zKDksIE5pbCkpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1hcChmLCBmdW5jdG9yKSB7XG4gICAgcmV0dXJuIEZ1bmN0b3IubWV0aG9kcy5tYXAoZnVuY3RvcikoZik7XG4gIH1cblxuICAvLyMgZmxpcCA6OiBGdW5jdG9yIGYgPT4gKGYgKGEgLT4gYiksIGEpIC0+IGYgYlxuICAvLy5cbiAgLy8uIE1hcHMgb3ZlciB0aGUgZ2l2ZW4gZnVuY3Rpb25zLCBhcHBseWluZyBlYWNoIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYG1hcGBdKCNtYXApLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZmxpcCh4ID0+IHkgPT4geCArIHksICchJykoJ2ZvbycpXG4gIC8vLiAnZm9vISdcbiAgLy8uXG4gIC8vLiA+IGZsaXAoW01hdGguZmxvb3IsIE1hdGguY2VpbF0sIDEuNSlcbiAgLy8uIFsxLCAyXVxuICAvLy5cbiAgLy8uID4gZmxpcCh7Zmxvb3I6IE1hdGguZmxvb3IsIGNlaWw6IE1hdGguY2VpbH0sIDEuNSlcbiAgLy8uIHtmbG9vcjogMSwgY2VpbDogMn1cbiAgLy8uXG4gIC8vLiA+IGZsaXAoQ29ucyhNYXRoLmZsb29yLCBDb25zKE1hdGguY2VpbCwgTmlsKSksIDEuNSlcbiAgLy8uIENvbnMoMSwgQ29ucygyLCBOaWwpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZsaXAoZnVuY3RvciwgeCkge1xuICAgIHJldHVybiBGdW5jdG9yLm1ldGhvZHMubWFwKGZ1bmN0b3IpKHRocnVzaCh4KSk7XG4gIH1cblxuICAvLyMgYmltYXAgOjogQmlmdW5jdG9yIGYgPT4gKGEgLT4gYiwgYyAtPiBkLCBmIGEgYykgLT4gZiBiIGRcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9iaW1hcGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBiaW1hcChzID0+IHMudG9VcHBlckNhc2UoKSwgTWF0aC5zcXJ0LCBUdXBsZSgnZm9vJywgNjQpKVxuICAvLy4gVHVwbGUoJ0ZPTycsIDgpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYmltYXAoZiwgZywgYmlmdW5jdG9yKSB7XG4gICAgcmV0dXJuIEJpZnVuY3Rvci5tZXRob2RzLmJpbWFwKGJpZnVuY3RvcikoZiwgZyk7XG4gIH1cblxuICAvLyMgbWFwTGVmdCA6OiBCaWZ1bmN0b3IgZiA9PiAoYSAtPiBiLCBmIGEgYykgLT4gZiBiIGNcbiAgLy8uXG4gIC8vLiBNYXBzIHRoZSBnaXZlbiBmdW5jdGlvbiBvdmVyIHRoZSBsZWZ0IHNpZGUgb2YgYSBCaWZ1bmN0b3IuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBtYXBMZWZ0KE1hdGguc3FydCwgVHVwbGUoNjQsIDkpKVxuICAvLy4gVHVwbGUoOCwgOSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtYXBMZWZ0KGYsIGJpZnVuY3Rvcikge1xuICAgIHJldHVybiBiaW1hcChmLCBpZGVudGl0eSwgYmlmdW5jdG9yKTtcbiAgfVxuXG4gIC8vIyBwcm9tYXAgOjogUHJvZnVuY3RvciBwID0+IChhIC0+IGIsIGMgLT4gZCwgcCBiIGMpIC0+IHAgYSBkXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvcHJvbWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL3Byb21hcGAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gcHJvbWFwKE1hdGguYWJzLCB4ID0+IHggKyAxLCBNYXRoLnNxcnQpKC0xMDApXG4gIC8vLiAxMVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHByb21hcChmLCBnLCBwcm9mdW5jdG9yKSB7XG4gICAgcmV0dXJuIFByb2Z1bmN0b3IubWV0aG9kcy5wcm9tYXAocHJvZnVuY3RvcikoZiwgZyk7XG4gIH1cblxuICAvLyMgYXAgOjogQXBwbHkgZiA9PiAoZiAoYSAtPiBiKSwgZiBhKSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9hcGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9hcGAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5LCBPYmplY3QsIGFuZCBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGFwKFtNYXRoLnNxcnQsIHggPT4geCAqIHhdLCBbMSwgNCwgOSwgMTYsIDI1XSlcbiAgLy8uIFsxLCAyLCAzLCA0LCA1LCAxLCAxNiwgODEsIDI1NiwgNjI1XVxuICAvLy5cbiAgLy8uID4gYXAoe2E6IE1hdGguc3FydCwgYjogeCA9PiB4ICogeH0sIHthOiAxNiwgYjogMTAsIGM6IDF9KVxuICAvLy4ge2E6IDQsIGI6IDEwMH1cbiAgLy8uXG4gIC8vLiA+IGFwKHMgPT4gbiA9PiBzLnNsaWNlKDAsIG4pLCBzID0+IE1hdGguY2VpbChzLmxlbmd0aCAvIDIpKSgnSGFza2VsbCcpXG4gIC8vLiAnSGFzaydcbiAgLy8uXG4gIC8vLiA+IGFwKElkZW50aXR5KE1hdGguc3FydCksIElkZW50aXR5KDY0KSlcbiAgLy8uIElkZW50aXR5KDgpXG4gIC8vLlxuICAvLy4gPiBhcChDb25zKE1hdGguc3FydCwgQ29ucyh4ID0+IHggKiB4LCBOaWwpKSwgQ29ucygxNiwgQ29ucygxMDAsIE5pbCkpKVxuICAvLy4gQ29ucyg0LCBDb25zKDEwLCBDb25zKDI1NiwgQ29ucygxMDAwMCwgTmlsKSkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFwKGFwcGx5RiwgYXBwbHlYKSB7XG4gICAgcmV0dXJuIEFwcGx5Lm1ldGhvZHMuYXAoYXBwbHlYKShhcHBseUYpO1xuICB9XG5cbiAgLy8jIGxpZnQyIDo6IEFwcGx5IGYgPT4gKGEgLT4gYiAtPiBjLCBmIGEsIGYgYikgLT4gZiBjXG4gIC8vLlxuICAvLy4gTGlmdHMgYGEgLT4gYiAtPiBjYCB0byBgQXBwbHkgZiA9PiBmIGEgLT4gZiBiIC0+IGYgY2AgYW5kIHJldHVybnMgdGhlXG4gIC8vLiByZXN1bHQgb2YgYXBwbHlpbmcgdGhpcyB0byB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbWFwYF0oI21hcCkgYW5kIFtgYXBgXSgjYXApLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbGlmdDNgXSgjbGlmdDMpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbGlmdDIoeCA9PiB5ID0+IE1hdGgucG93KHgsIHkpLCBbMTBdLCBbMSwgMiwgM10pXG4gIC8vLiBbMTAsIDEwMCwgMTAwMF1cbiAgLy8uXG4gIC8vLiA+IGxpZnQyKHggPT4geSA9PiBNYXRoLnBvdyh4LCB5KSwgSWRlbnRpdHkoMTApLCBJZGVudGl0eSgzKSlcbiAgLy8uIElkZW50aXR5KDEwMDApXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbGlmdDIoZiwgeCwgeSkge1xuICAgIHJldHVybiBhcChtYXAoZiwgeCksIHkpO1xuICB9XG5cbiAgLy8jIGxpZnQzIDo6IEFwcGx5IGYgPT4gKGEgLT4gYiAtPiBjIC0+IGQsIGYgYSwgZiBiLCBmIGMpIC0+IGYgZFxuICAvLy5cbiAgLy8uIExpZnRzIGBhIC0+IGIgLT4gYyAtPiBkYCB0byBgQXBwbHkgZiA9PiBmIGEgLT4gZiBiIC0+IGYgYyAtPiBmIGRgIGFuZFxuICAvLy4gcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoaXMgdG8gdGhlIGdpdmVuIGFyZ3VtZW50cy5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYG1hcGBdKCNtYXApIGFuZCBbYGFwYF0oI2FwKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGxpZnQyYF0oI2xpZnQyKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGxpZnQzKHggPT4geSA9PiB6ID0+IHggKyB6ICsgeSwgWyc8J10sIFsnPiddLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiBbJzxmb28+JywgJzxiYXI+JywgJzxiYXo+J11cbiAgLy8uXG4gIC8vLiA+IGxpZnQzKHggPT4geSA9PiB6ID0+IHggKyB6ICsgeSwgSWRlbnRpdHkoJzwnKSwgSWRlbnRpdHkoJz4nKSwgSWRlbnRpdHkoJ2JheicpKVxuICAvLy4gSWRlbnRpdHkoJzxiYXo+JylcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBsaWZ0MyhmLCB4LCB5LCB6KSB7XG4gICAgcmV0dXJuIGFwKGFwKG1hcChmLCB4KSwgeSksIHopO1xuICB9XG5cbiAgLy8jIGFwRmlyc3QgOjogQXBwbHkgZiA9PiAoZiBhLCBmIGIpIC0+IGYgYVxuICAvLy5cbiAgLy8uIENvbWJpbmVzIHR3byBlZmZlY3RmdWwgYWN0aW9ucywga2VlcGluZyBvbmx5IHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0LlxuICAvLy4gRXF1aXZhbGVudCB0byBIYXNrZWxsJ3MgYCg8KilgIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbGlmdDJgXSgjbGlmdDIpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgYXBTZWNvbmRgXSgjYXBTZWNvbmQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gYXBGaXJzdChbMSwgMl0sIFszLCA0XSlcbiAgLy8uIFsxLCAxLCAyLCAyXVxuICAvLy5cbiAgLy8uID4gYXBGaXJzdChJZGVudGl0eSgxKSwgSWRlbnRpdHkoMikpXG4gIC8vLiBJZGVudGl0eSgxKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFwRmlyc3QoeCwgeSkge1xuICAgIHJldHVybiBsaWZ0Mihjb25zdGFudCwgeCwgeSk7XG4gIH1cblxuICAvLyMgYXBTZWNvbmQgOjogQXBwbHkgZiA9PiAoZiBhLCBmIGIpIC0+IGYgYlxuICAvLy5cbiAgLy8uIENvbWJpbmVzIHR3byBlZmZlY3RmdWwgYWN0aW9ucywga2VlcGluZyBvbmx5IHRoZSByZXN1bHQgb2YgdGhlIHNlY29uZC5cbiAgLy8uIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGAoKj4pYCBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGxpZnQyYF0oI2xpZnQyKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGFwRmlyc3RgXSgjYXBGaXJzdCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBhcFNlY29uZChbMSwgMl0sIFszLCA0XSlcbiAgLy8uIFszLCA0LCAzLCA0XVxuICAvLy5cbiAgLy8uID4gYXBTZWNvbmQoSWRlbnRpdHkoMSksIElkZW50aXR5KDIpKVxuICAvLy4gSWRlbnRpdHkoMilcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhcFNlY29uZCh4LCB5KSB7XG4gICAgcmV0dXJuIGxpZnQyKGNvbnN0YW50KGlkZW50aXR5KSwgeCwgeSk7XG4gIH1cblxuICAvLyMgb2YgOjogQXBwbGljYXRpdmUgZiA9PiAoVHlwZVJlcCBmLCBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9vZmBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9vZmAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IG9mKEFycmF5LCA0MilcbiAgLy8uIFs0Ml1cbiAgLy8uXG4gIC8vLiA+IG9mKEZ1bmN0aW9uLCA0MikobnVsbClcbiAgLy8uIDQyXG4gIC8vLlxuICAvLy4gPiBvZihMaXN0LCA0MilcbiAgLy8uIENvbnMoNDIsIE5pbClcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBvZih0eXBlUmVwLCB4KSB7XG4gICAgcmV0dXJuIEFwcGxpY2F0aXZlLm1ldGhvZHMub2YodHlwZVJlcCkoeCk7XG4gIH1cblxuICAvLyMgYXBwZW5kIDo6IChBcHBsaWNhdGl2ZSBmLCBTZW1pZ3JvdXAgKGYgYSkpID0+IChhLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBlbmRpbmcgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2Bjb25jYXRgXSgjY29uY2F0KSBhbmQgW2BvZmBdKCNvZikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BwcmVwZW5kYF0oI3ByZXBlbmQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gYXBwZW5kKDMsIFsxLCAyXSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gYXBwZW5kKDMsIENvbnMoMSwgQ29ucygyLCBOaWwpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFwcGVuZCh4LCB4cykge1xuICAgIHJldHVybiBjb25jYXQoeHMsIG9mKHhzLmNvbnN0cnVjdG9yLCB4KSk7XG4gIH1cblxuICAvLyMgcHJlcGVuZCA6OiAoQXBwbGljYXRpdmUgZiwgU2VtaWdyb3VwIChmIGEpKSA9PiAoYSwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgcHJlcGVuZGluZyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHNlY29uZC5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNvbmNhdGBdKCNjb25jYXQpIGFuZCBbYG9mYF0oI29mKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGFwcGVuZGBdKCNhcHBlbmQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gcHJlcGVuZCgxLCBbMiwgM10pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IHByZXBlbmQoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKVxuICAvLy4gQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcHJlcGVuZCh4LCB4cykge1xuICAgIHJldHVybiBjb25jYXQob2YoeHMuY29uc3RydWN0b3IsIHgpLCB4cyk7XG4gIH1cblxuICAvLyMgY2hhaW4gOjogQ2hhaW4gbSA9PiAoYSAtPiBtIGIsIG0gYSkgLT4gbSBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvY2hhaW5gXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvY2hhaW5gIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjaGFpbih4ID0+IFt4LCB4XSwgWzEsIDIsIDNdKVxuICAvLy4gWzEsIDEsIDIsIDIsIDMsIDNdXG4gIC8vLlxuICAvLy4gPiBjaGFpbih4ID0+IHggJSAyID09IDEgPyBvZihMaXN0LCB4KSA6IE5pbCwgQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpKVxuICAvLy4gQ29ucygxLCBDb25zKDMsIE5pbCkpXG4gIC8vLlxuICAvLy4gPiBjaGFpbihuID0+IHMgPT4gcy5zbGljZSgwLCBuKSwgcyA9PiBNYXRoLmNlaWwocy5sZW5ndGggLyAyKSkoJ0hhc2tlbGwnKVxuICAvLy4gJ0hhc2snXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY2hhaW4oZiwgY2hhaW5fKSB7XG4gICAgcmV0dXJuIENoYWluLm1ldGhvZHMuY2hhaW4oY2hhaW5fKShmKTtcbiAgfVxuXG4gIC8vIyBqb2luIDo6IENoYWluIG0gPT4gbSAobSBhKSAtPiBtIGFcbiAgLy8uXG4gIC8vLiBSZW1vdmVzIG9uZSBsZXZlbCBvZiBuZXN0aW5nIGZyb20gYSBuZXN0ZWQgbW9uYWRpYyBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BjaGFpbmBdKCNjaGFpbikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBqb2luKFtbMV0sIFsyXSwgWzNdXSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gam9pbihbW1sxLCAyLCAzXV1dKVxuICAvLy4gW1sxLCAyLCAzXV1cbiAgLy8uXG4gIC8vLiA+IGpvaW4oSWRlbnRpdHkoSWRlbnRpdHkoMSkpKVxuICAvLy4gSWRlbnRpdHkoMSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBqb2luKGNoYWluXykge1xuICAgIHJldHVybiBjaGFpbihpZGVudGl0eSwgY2hhaW5fKTtcbiAgfVxuXG4gIC8vIyBjaGFpblJlYyA6OiBDaGFpblJlYyBtID0+IChUeXBlUmVwIG0sIChhIC0+IGMsIGIgLT4gYywgYSkgLT4gbSBjLCBhKSAtPiBtIGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9jaGFpblJlY2BdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9jaGFpblJlY2AgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY2hhaW5SZWMoXG4gIC8vLiAuICAgQXJyYXksXG4gIC8vLiAuICAgKG5leHQsIGRvbmUsIHMpID0+IHMubGVuZ3RoID09IDIgPyBbcyArICchJywgcyArICc/J10ubWFwKGRvbmUpXG4gIC8vLiAuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbcyArICdvJywgcyArICduJ10ubWFwKG5leHQpLFxuICAvLy4gLiAgICcnXG4gIC8vLiAuIClcbiAgLy8uIFsnb28hJywgJ29vPycsICdvbiEnLCAnb24/JywgJ25vIScsICdubz8nLCAnbm4hJywgJ25uPyddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY2hhaW5SZWModHlwZVJlcCwgZiwgeCkge1xuICAgIHJldHVybiBDaGFpblJlYy5tZXRob2RzLmNoYWluUmVjKHR5cGVSZXApKGYsIHgpO1xuICB9XG5cbiAgLy8jIGFsdCA6OiBBbHQgZiA9PiAoZiBhLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2FsdGBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9hbHRgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gYWx0KFsxLCAyLCAzXSwgWzQsIDUsIDZdKVxuICAvLy4gWzEsIDIsIDMsIDQsIDUsIDZdXG4gIC8vLlxuICAvLy4gPiBhbHQoTm90aGluZywgTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IGFsdChOb3RoaW5nLCBKdXN0KDEpKVxuICAvLy4gSnVzdCgxKVxuICAvLy5cbiAgLy8uID4gYWx0KEp1c3QoMiksIEp1c3QoMykpXG4gIC8vLiBKdXN0KDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYWx0KHgsIHkpIHtcbiAgICByZXR1cm4gQWx0Lm1ldGhvZHMuYWx0KHgpKHkpO1xuICB9XG5cbiAgLy8jIHplcm8gOjogUGx1cyBmID0+IFR5cGVSZXAgZiAtPiBmIGFcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC96ZXJvYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL3plcm9gIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gemVybyhBcnJheSlcbiAgLy8uIFtdXG4gIC8vLlxuICAvLy4gPiB6ZXJvKE9iamVjdClcbiAgLy8uIHt9XG4gIC8vLlxuICAvLy4gPiB6ZXJvKE1heWJlKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHplcm8odHlwZVJlcCkge1xuICAgIHJldHVybiBQbHVzLm1ldGhvZHMuemVybyh0eXBlUmVwKSgpO1xuICB9XG5cbiAgLy8jIHJlZHVjZSA6OiBGb2xkYWJsZSBmID0+ICgoYiwgYSkgLT4gYiwgYiwgZiBhKSAtPiBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvcmVkdWNlYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL3JlZHVjZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiByZWR1Y2UoKHhzLCB4KSA9PiBbeF0uY29uY2F0KHhzKSwgW10sIFsxLCAyLCAzXSlcbiAgLy8uIFszLCAyLCAxXVxuICAvLy5cbiAgLy8uID4gcmVkdWNlKGNvbmNhdCwgJycsIENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIE5pbCkpKSlcbiAgLy8uICdmb29iYXJiYXonXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmVkdWNlKGYsIHgsIGZvbGRhYmxlKSB7XG4gICAgcmV0dXJuIEZvbGRhYmxlLm1ldGhvZHMucmVkdWNlKGZvbGRhYmxlKShmLCB4KTtcbiAgfVxuXG4gIC8vIyBzaXplIDo6IEZvbGRhYmxlIGYgPT4gZiBhIC0+IEludGVnZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gc2l6ZShbXSlcbiAgLy8uIDBcbiAgLy8uXG4gIC8vLiA+IHNpemUoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gM1xuICAvLy5cbiAgLy8uID4gc2l6ZShOaWwpXG4gIC8vLiAwXG4gIC8vLlxuICAvLy4gPiBzaXplKENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIE5pbCkpKSlcbiAgLy8uIDNcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzaXplKGZvbGRhYmxlKSB7XG4gICAgLy8gIEZhc3QgcGF0aCBmb3IgYXJyYXlzLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGZvbGRhYmxlKSkgcmV0dXJuIGZvbGRhYmxlLmxlbmd0aDtcbiAgICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uKG4sIF8pIHsgcmV0dXJuIG4gKyAxOyB9LCAwLCBmb2xkYWJsZSk7XG4gIH1cblxuICAvLyMgZWxlbSA6OiAoU2V0b2lkIGEsIEZvbGRhYmxlIGYpID0+IChhLCBmIGEpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHZhbHVlIGFuZCBhIHN0cnVjdHVyZSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlXG4gIC8vLiB2YWx1ZSBpcyBhbiBlbGVtZW50IG9mIHRoZSBzdHJ1Y3R1cmU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgZXF1YWxzYF0oI2VxdWFscykgYW5kXG4gIC8vLiBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZWxlbSgnYycsIFsnYScsICdiJywgJ2MnXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVsZW0oJ3gnLCBbJ2EnLCAnYicsICdjJ10pXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZWxlbSgzLCB7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlbGVtKDgsIHt4OiAxLCB5OiAyLCB6OiAzfSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBlbGVtKDAsIEp1c3QoMCkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBlbGVtKDAsIEp1c3QoMSkpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZWxlbSgwLCBOb3RoaW5nKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBlbGVtKHgsIGZvbGRhYmxlKSB7XG4gICAgcmV0dXJuIHJlZHVjZShmdW5jdGlvbihiLCB5KSB7IHJldHVybiBiIHx8IGVxdWFscyh4LCB5KTsgfSxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgZm9sZGFibGUpO1xuICB9XG5cbiAgLy8jIGZvbGRNYXAgOjogKE1vbm9pZCBtLCBGb2xkYWJsZSBmKSA9PiAoVHlwZVJlcCBtLCBhIC0+IG0sIGYgYSkgLT4gbVxuICAvLy5cbiAgLy8uIERlY29uc3RydWN0cyBhIGZvbGRhYmxlIGJ5IG1hcHBpbmcgZXZlcnkgZWxlbWVudCB0byBhIG1vbm9pZCBhbmRcbiAgLy8uIGNvbmNhdGVuYXRpbmcgdGhlIHJlc3VsdHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2Bjb25jYXRgXSgjY29uY2F0KSwgW2BlbXB0eWBdKCNlbXB0eSksXG4gIC8vLiBhbmQgW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGZvbGRNYXAoU3RyaW5nLCBmID0+IGYubmFtZSwgW01hdGguc2luLCBNYXRoLmNvcywgTWF0aC50YW5dKVxuICAvLy4gJ3NpbmNvc3RhbidcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBmb2xkTWFwKHR5cGVSZXAsIGYsIGZvbGRhYmxlKSB7XG4gICAgcmV0dXJuIHJlZHVjZShmdW5jdGlvbihtb25vaWQsIHgpIHsgcmV0dXJuIGNvbmNhdChtb25vaWQsIGYoeCkpOyB9LFxuICAgICAgICAgICAgICAgICAgZW1wdHkodHlwZVJlcCksXG4gICAgICAgICAgICAgICAgICBmb2xkYWJsZSk7XG4gIH1cblxuICAvLyMgcmV2ZXJzZSA6OiAoQXBwbGljYXRpdmUgZiwgRm9sZGFibGUgZiwgTW9ub2lkIChmIGEpKSA9PiBmIGEgLT4gZiBhXG4gIC8vLlxuICAvLy4gUmV2ZXJzZXMgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2Bjb25jYXRgXSgjY29uY2F0KSwgW2BlbXB0eWBdKCNlbXB0eSksXG4gIC8vLiBbYG9mYF0oI29mKSwgYW5kIFtgcmVkdWNlYF0oI3JlZHVjZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiByZXZlcnNlKFsxLCAyLCAzXSlcbiAgLy8uIFszLCAyLCAxXVxuICAvLy5cbiAgLy8uID4gcmV2ZXJzZShDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSkpXG4gIC8vLiBDb25zKDMsIENvbnMoMiwgQ29ucygxLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiByZXZlcnNlKGZvbGRhYmxlKSB7XG4gICAgLy8gIEZhc3QgcGF0aCBmb3IgYXJyYXlzLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGZvbGRhYmxlKSkgcmV0dXJuIGZvbGRhYmxlLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIHZhciBGID0gZm9sZGFibGUuY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIHJlZHVjZShmdW5jdGlvbih4cywgeCkgeyByZXR1cm4gY29uY2F0KG9mKEYsIHgpLCB4cyk7IH0sXG4gICAgICAgICAgICAgICAgICBlbXB0eShGKSxcbiAgICAgICAgICAgICAgICAgIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyBzb3J0IDo6IChPcmQgYSwgQXBwbGljYXRpdmUgZiwgRm9sZGFibGUgZiwgTW9ub2lkIChmIGEpKSA9PiBmIGEgLT4gZiBhXG4gIC8vLlxuICAvLy4gUGVyZm9ybXMgYSBbc3RhYmxlIHNvcnRdW10gb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUsXG4gIC8vLiB1c2luZyBbYGx0ZWBdKCNsdGUpIGZvciBjb21wYXJpc29ucy5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLCBbYGNvbmNhdGBdKCNjb25jYXQpLFxuICAvLy4gW2BlbXB0eWBdKCNlbXB0eSksIFtgb2ZgXSgjb2YpLCBhbmQgW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHNvcnRCeWBdKCNzb3J0QnkpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gc29ydChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiBbJ2JhcicsICdiYXonLCAnZm9vJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnQoW0p1c3QoMiksIE5vdGhpbmcsIEp1c3QoMSldKVxuICAvLy4gW05vdGhpbmcsIEp1c3QoMSksIEp1c3QoMildXG4gIC8vLlxuICAvLy4gPiBzb3J0KENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIE5pbCkpKSlcbiAgLy8uIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIENvbnMoJ2ZvbycsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNvcnQoZm9sZGFibGUpIHtcbiAgICByZXR1cm4gc29ydEJ5KGlkZW50aXR5LCBmb2xkYWJsZSk7XG4gIH1cblxuICAvLyMgc29ydEJ5IDo6IChPcmQgYiwgQXBwbGljYXRpdmUgZiwgRm9sZGFibGUgZiwgTW9ub2lkIChmIGEpKSA9PiAoYSAtPiBiLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIFBlcmZvcm1zIGEgW3N0YWJsZSBzb3J0XVtdIG9mIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc3RydWN0dXJlLFxuICAvLy4gdXNpbmcgW2BsdGVgXSgjbHRlKSB0byBjb21wYXJlIHRoZSB2YWx1ZXMgcHJvZHVjZWQgYnkgYXBwbHlpbmcgdGhlXG4gIC8vLiBnaXZlbiBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLCBbYGNvbmNhdGBdKCNjb25jYXQpLFxuICAvLy4gW2BlbXB0eWBdKCNlbXB0eSksIFtgb2ZgXSgjb2YpLCBhbmQgW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHNvcnRgXSgjc29ydCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBzb3J0QnkocyA9PiBzLmxlbmd0aCwgWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddKVxuICAvLy4gWydyZWQnLCAnYmx1ZScsICdncmVlbiddXG4gIC8vLlxuICAvLy4gPiBzb3J0QnkocyA9PiBzLmxlbmd0aCwgWydibGFjaycsICd3aGl0ZSddKVxuICAvLy4gWydibGFjaycsICd3aGl0ZSddXG4gIC8vLlxuICAvLy4gPiBzb3J0QnkocyA9PiBzLmxlbmd0aCwgWyd3aGl0ZScsICdibGFjayddKVxuICAvLy4gWyd3aGl0ZScsICdibGFjayddXG4gIC8vLlxuICAvLy4gPiBzb3J0QnkocyA9PiBzLmxlbmd0aCwgQ29ucygncmVkJywgQ29ucygnZ3JlZW4nLCBDb25zKCdibHVlJywgTmlsKSkpKVxuICAvLy4gQ29ucygncmVkJywgQ29ucygnYmx1ZScsIENvbnMoJ2dyZWVuJywgTmlsKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc29ydEJ5KGYsIGZvbGRhYmxlKSB7XG4gICAgdmFyIHJzID0gcmVkdWNlKGZ1bmN0aW9uKHJzLCB4KSB7XG4gICAgICBycy5wdXNoKHtpZHg6IHJzLmxlbmd0aCwgeDogeCwgZng6IGYoeCl9KTtcbiAgICAgIHJldHVybiBycztcbiAgICB9LCBbXSwgZm9sZGFibGUpO1xuXG4gICAgdmFyIGx0ZV8gPSAoZnVuY3Rpb24ocikge1xuICAgICAgc3dpdGNoICh0eXBlb2YgKHIgJiYgci5meCkpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzogIHJldHVybiBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4IDw9IHkgfHwgeCAhPT0geDsgfTtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzogIHJldHVybiBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4IDw9IHk7IH07XG4gICAgICAgIGRlZmF1bHQ6ICAgICAgICByZXR1cm4gbHRlO1xuICAgICAgfVxuICAgIH0ocnNbMF0pKTtcblxuICAgIHJzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGx0ZV8oYS5meCwgYi5meCkgPyBsdGVfKGIuZngsIGEuZngpID8gYS5pZHggLSBiLmlkeCA6IC0xIDogMTtcbiAgICB9KTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGZvbGRhYmxlKSkge1xuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcnMubGVuZ3RoOyBpZHggKz0gMSkgcnNbaWR4XSA9IHJzW2lkeF0ueDtcbiAgICAgIHJldHVybiBycztcbiAgICB9XG5cbiAgICB2YXIgRiA9IGZvbGRhYmxlLmNvbnN0cnVjdG9yO1xuICAgIHZhciByZXN1bHQgPSBlbXB0eShGKTtcbiAgICBmb3IgKGlkeCA9IDA7IGlkeCA8IHJzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIHJlc3VsdCA9IGNvbmNhdChyZXN1bHQsIG9mKEYsIHJzW2lkeF0ueCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8jIHRyYXZlcnNlIDo6IChBcHBsaWNhdGl2ZSBmLCBUcmF2ZXJzYWJsZSB0KSA9PiAoVHlwZVJlcCBmLCBhIC0+IGYgYiwgdCBhKSAtPiBmICh0IGIpXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvdHJhdmVyc2VgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvdHJhdmVyc2VgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBBcnJheSBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc2VxdWVuY2VgXSgjc2VxdWVuY2UpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gdHJhdmVyc2UoQXJyYXksIHggPT4geCwgW1sxLCAyLCAzXSwgWzQsIDVdXSlcbiAgLy8uIFtbMSwgNF0sIFsxLCA1XSwgWzIsIDRdLCBbMiwgNV0sIFszLCA0XSwgWzMsIDVdXVxuICAvLy5cbiAgLy8uID4gdHJhdmVyc2UoSWRlbnRpdHksIHggPT4gSWRlbnRpdHkoeCArIDEpLCBbMSwgMiwgM10pXG4gIC8vLiBJZGVudGl0eShbMiwgMywgNF0pXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdHJhdmVyc2UodHlwZVJlcCwgZiwgdHJhdmVyc2FibGUpIHtcbiAgICByZXR1cm4gVHJhdmVyc2FibGUubWV0aG9kcy50cmF2ZXJzZSh0cmF2ZXJzYWJsZSkodHlwZVJlcCwgZik7XG4gIH1cblxuICAvLyMgc2VxdWVuY2UgOjogKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChUeXBlUmVwIGYsIHQgKGYgYSkpIC0+IGYgKHQgYSlcbiAgLy8uXG4gIC8vLiBJbnZlcnRzIHRoZSBnaXZlbiBgdCAoZiBhKWAgdG8gcHJvZHVjZSBhbiBgZiAodCBhKWAuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2B0cmF2ZXJzZWBdKCN0cmF2ZXJzZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBzZXF1ZW5jZShBcnJheSwgSWRlbnRpdHkoWzEsIDIsIDNdKSlcbiAgLy8uIFtJZGVudGl0eSgxKSwgSWRlbnRpdHkoMiksIElkZW50aXR5KDMpXVxuICAvLy5cbiAgLy8uID4gc2VxdWVuY2UoSWRlbnRpdHksIFtJZGVudGl0eSgxKSwgSWRlbnRpdHkoMiksIElkZW50aXR5KDMpXSlcbiAgLy8uIElkZW50aXR5KFsxLCAyLCAzXSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzZXF1ZW5jZSh0eXBlUmVwLCB0cmF2ZXJzYWJsZSkge1xuICAgIHJldHVybiB0cmF2ZXJzZSh0eXBlUmVwLCBpZGVudGl0eSwgdHJhdmVyc2FibGUpO1xuICB9XG5cbiAgLy8jIGV4dGVuZCA6OiBFeHRlbmQgdyA9PiAodyBhIC0+IGIsIHcgYSkgLT4gdyBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvZXh0ZW5kYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2V4dGVuZGAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGV4dGVuZChzcyA9PiBzcy5qb2luKCcnKSwgWyd4JywgJ3knLCAneiddKVxuICAvLy4gWyd4eXonLCAneXonLCAneiddXG4gIC8vLlxuICAvLy4gPiBleHRlbmQoZiA9PiBmKFszLCA0XSksIHJldmVyc2UpKFsxLCAyXSlcbiAgLy8uIFs0LCAzLCAyLCAxXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGV4dGVuZChmLCBleHRlbmRfKSB7XG4gICAgcmV0dXJuIEV4dGVuZC5tZXRob2RzLmV4dGVuZChleHRlbmRfKShmKTtcbiAgfVxuXG4gIC8vIyBkdXBsaWNhdGUgOjogRXh0ZW5kIHcgPT4gdyBhIC0+IHcgKHcgYSlcbiAgLy8uXG4gIC8vLiBBZGRzIG9uZSBsZXZlbCBvZiBuZXN0aW5nIHRvIGEgY29tb25hZGljIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGV4dGVuZGBdKCNleHRlbmQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZHVwbGljYXRlKElkZW50aXR5KDEpKVxuICAvLy4gSWRlbnRpdHkoSWRlbnRpdHkoMSkpXG4gIC8vLlxuICAvLy4gPiBkdXBsaWNhdGUoWzFdKVxuICAvLy4gW1sxXV1cbiAgLy8uXG4gIC8vLiA+IGR1cGxpY2F0ZShbMSwgMiwgM10pXG4gIC8vLiBbWzEsIDIsIDNdLCBbMiwgM10sIFszXV1cbiAgLy8uXG4gIC8vLiA+IGR1cGxpY2F0ZShyZXZlcnNlKShbMSwgMl0pKFszLCA0XSlcbiAgLy8uIFs0LCAzLCAyLCAxXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGR1cGxpY2F0ZShleHRlbmRfKSB7XG4gICAgcmV0dXJuIGV4dGVuZChpZGVudGl0eSwgZXh0ZW5kXyk7XG4gIH1cblxuICAvLyMgZXh0cmFjdCA6OiBDb21vbmFkIHcgPT4gdyBhIC0+IGFcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9leHRyYWN0YF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGV4dHJhY3QoSWRlbnRpdHkoNDIpKVxuICAvLy4gNDJcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBleHRyYWN0KGNvbW9uYWQpIHtcbiAgICByZXR1cm4gQ29tb25hZC5tZXRob2RzLmV4dHJhY3QoY29tb25hZCkoKTtcbiAgfVxuXG4gIC8vIyBjb250cmFtYXAgOjogQ29udHJhdmFyaWFudCBmID0+IChiIC0+IGEsIGYgYSkgLT4gZiBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvY29udHJhbWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NvbnRyYW1hcGAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29udHJhbWFwKHMgPT4gcy5sZW5ndGgsIE1hdGguc3FydCkoJ1NhbmN0dWFyeScpXG4gIC8vLiAzXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY29udHJhbWFwKGYsIGNvbnRyYXZhcmlhbnQpIHtcbiAgICByZXR1cm4gQ29udHJhdmFyaWFudC5tZXRob2RzLmNvbnRyYW1hcChjb250cmF2YXJpYW50KShmKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgVHlwZUNsYXNzOiBUeXBlQ2xhc3MsXG4gICAgU2V0b2lkOiBTZXRvaWQsXG4gICAgT3JkOiBPcmQsXG4gICAgU2VtaWdyb3Vwb2lkOiBTZW1pZ3JvdXBvaWQsXG4gICAgQ2F0ZWdvcnk6IENhdGVnb3J5LFxuICAgIFNlbWlncm91cDogU2VtaWdyb3VwLFxuICAgIE1vbm9pZDogTW9ub2lkLFxuICAgIEdyb3VwOiBHcm91cCxcbiAgICBGaWx0ZXJhYmxlOiBGaWx0ZXJhYmxlLFxuICAgIEZ1bmN0b3I6IEZ1bmN0b3IsXG4gICAgQmlmdW5jdG9yOiBCaWZ1bmN0b3IsXG4gICAgUHJvZnVuY3RvcjogUHJvZnVuY3RvcixcbiAgICBBcHBseTogQXBwbHksXG4gICAgQXBwbGljYXRpdmU6IEFwcGxpY2F0aXZlLFxuICAgIENoYWluOiBDaGFpbixcbiAgICBDaGFpblJlYzogQ2hhaW5SZWMsXG4gICAgTW9uYWQ6IE1vbmFkLFxuICAgIEFsdDogQWx0LFxuICAgIFBsdXM6IFBsdXMsXG4gICAgQWx0ZXJuYXRpdmU6IEFsdGVybmF0aXZlLFxuICAgIEZvbGRhYmxlOiBGb2xkYWJsZSxcbiAgICBUcmF2ZXJzYWJsZTogVHJhdmVyc2FibGUsXG4gICAgRXh0ZW5kOiBFeHRlbmQsXG4gICAgQ29tb25hZDogQ29tb25hZCxcbiAgICBDb250cmF2YXJpYW50OiBDb250cmF2YXJpYW50LFxuICAgIGVxdWFsczogZXF1YWxzLFxuICAgIGx0OiBsdCxcbiAgICBsdGU6IGx0ZSxcbiAgICBndDogZ3QsXG4gICAgZ3RlOiBndGUsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXgsXG4gICAgY29tcG9zZTogY29tcG9zZSxcbiAgICBpZDogaWQsXG4gICAgY29uY2F0OiBjb25jYXQsXG4gICAgZW1wdHk6IGVtcHR5LFxuICAgIGludmVydDogaW52ZXJ0LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIHJlamVjdDogcmVqZWN0LFxuICAgIG1hcDogbWFwLFxuICAgIGZsaXA6IGZsaXAsXG4gICAgYmltYXA6IGJpbWFwLFxuICAgIG1hcExlZnQ6IG1hcExlZnQsXG4gICAgcHJvbWFwOiBwcm9tYXAsXG4gICAgYXA6IGFwLFxuICAgIGxpZnQyOiBsaWZ0MixcbiAgICBsaWZ0MzogbGlmdDMsXG4gICAgYXBGaXJzdDogYXBGaXJzdCxcbiAgICBhcFNlY29uZDogYXBTZWNvbmQsXG4gICAgb2Y6IG9mLFxuICAgIGFwcGVuZDogYXBwZW5kLFxuICAgIHByZXBlbmQ6IHByZXBlbmQsXG4gICAgY2hhaW46IGNoYWluLFxuICAgIGpvaW46IGpvaW4sXG4gICAgY2hhaW5SZWM6IGNoYWluUmVjLFxuICAgIGFsdDogYWx0LFxuICAgIHplcm86IHplcm8sXG4gICAgcmVkdWNlOiByZWR1Y2UsXG4gICAgc2l6ZTogc2l6ZSxcbiAgICBlbGVtOiBlbGVtLFxuICAgIGZvbGRNYXA6IGZvbGRNYXAsXG4gICAgcmV2ZXJzZTogcmV2ZXJzZSxcbiAgICBzb3J0OiBzb3J0LFxuICAgIHNvcnRCeTogc29ydEJ5LFxuICAgIHRha2VXaGlsZTogdGFrZVdoaWxlLFxuICAgIGRyb3BXaGlsZTogZHJvcFdoaWxlLFxuICAgIHRyYXZlcnNlOiB0cmF2ZXJzZSxcbiAgICBzZXF1ZW5jZTogc2VxdWVuY2UsXG4gICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgZHVwbGljYXRlOiBkdXBsaWNhdGUsXG4gICAgZXh0cmFjdDogZXh0cmFjdCxcbiAgICBjb250cmFtYXA6IGNvbnRyYW1hcFxuICB9O1xuXG59KSk7XG5cbi8vLiBbQWx0XTogICAgICAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYWx0XG4vLy4gW0FsdGVybmF0aXZlXTogICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FsdGVybmF0aXZlXG4vLy4gW0FwcGxpY2F0aXZlXTogICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGxpY2F0aXZlXG4vLy4gW0FwcGx5XTogICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGx5XG4vLy4gW0JpZnVuY3Rvcl06ICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2JpZnVuY3RvclxuLy8uIFtDYXRlZ29yeV06ICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjYXRlZ29yeVxuLy8uIFtDaGFpbl06ICAgICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpblxuLy8uIFtDaGFpblJlY106ICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbnJlY1xuLy8uIFtDb21vbmFkXTogICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjb21vbmFkXG4vLy4gW0NvbnRyYXZhcmlhbnRdOiAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NvbnRyYXZhcmlhbnRcbi8vLiBbRXh0ZW5kXTogICAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZXh0ZW5kXG4vLy4gW0ZMXTogICAgICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kXG4vLy4gW0ZpbHRlcmFibGVdOiAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2ZpbHRlcmFibGVcbi8vLiBbRm9sZGFibGVdOiAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZm9sZGFibGVcbi8vLiBbRnVuY3Rvcl06ICAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZnVuY3RvclxuLy8uIFtHcm91cF06ICAgICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNncm91cFxuLy8uIFtNb25hZF06ICAgICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNtb25hZFxuLy8uIFtNb25vaWRdOiAgICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNtb25vaWRcbi8vLiBbT3JkXTogICAgICAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjb3JkXG4vLy4gW1BsdXNdOiAgICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3BsdXNcbi8vLiBbUHJvZnVuY3Rvcl06ICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjcHJvZnVuY3RvclxuLy8uIFtTZW1pZ3JvdXBdOiAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZW1pZ3JvdXBcbi8vLiBbU2VtaWdyb3Vwb2lkXTogICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2VtaWdyb3Vwb2lkXG4vLy4gW1NldG9pZF06ICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3NldG9pZFxuLy8uIFtUcmF2ZXJzYWJsZV06ICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0cmF2ZXJzYWJsZVxuLy8uIFtgZmFudGFzeS1sYW5kL2FsdGBdOiAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhbHQtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvYXBgXTogICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2JpbWFwYF06ICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNiaW1hcC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9jaGFpbmBdOiAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW4tbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvY2hhaW5SZWNgXTogIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWlucmVjLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2NvbXBvc2VgXTogICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjb21wb3NlLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2NvbmNhdGBdOiAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjb25jYXQtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvY29udHJhbWFwYF06IHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NvbnRyYW1hcC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9lbXB0eWBdOiAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZW1wdHktbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvZXF1YWxzYF06ICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2VxdWFscy1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9leHRlbmRgXTogICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZXh0ZW5kLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2V4dHJhY3RgXTogICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNleHRyYWN0LW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2ZpbHRlcmBdOiAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNmaWx0ZXItbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvaWRgXTogICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2lkLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2ludmVydGBdOiAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNpbnZlcnQtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvbHRlYF06ICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2x0ZS1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9tYXBgXTogICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjbWFwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL29mYF06ICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNvZi1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9wcm9tYXBgXTogICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjcHJvbWFwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL3JlZHVjZWBdOiAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNyZWR1Y2UtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvdHJhdmVyc2VgXTogIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNlLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL3plcm9gXTogICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN6ZXJvLW1ldGhvZFxuLy8uIFtzdGFibGUgc29ydF06ICAgICAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Tb3J0aW5nX2FsZ29yaXRobSNTdGFiaWxpdHlcbi8vLiBbdHlwZS1jbGFzc2VzXTogICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnktZGVmI3R5cGUtY2xhc3Nlc1xuIiwiLypcbiAgICAgICAgQEBAQEBAQCAgICAgICAgICAgIEBAQEBAQEAgICAgICAgICBAQFxuICAgICAgQEAgICAgICAgQEAgICAgICAgIEBAICAgICAgIEBAICAgICAgQEBAXG4gICAgQEAgICBAQEAgQEAgIEBAICAgIEBAICAgQEBAIEBAICBAQCAgIEBAQEBAQCBAQCAgIEBAQCAgQEAgQEBAICAgICAgQEBAQFxuICAgQEAgIEBAICAgQEBAICAgQEAgIEBAICBAQCAgIEBAQCAgIEBAICAgQEBAICAgQEAgICBAQEAgIEBAQCAgIEBAICBAQEAgICBAQFxuICAgQEAgIEBAICAgQEBAICAgQEAgIEBAICBAQCAgIEBAQCAgIEBAICAgQEBAICAgQEAgICBAQEAgIEBAQCAgIEBAICBAQEBAQEBAQFxuICAgQEAgIEBAICAgQEBAICBAQCAgIEBAICBAQCAgIEBAQCAgQEAgICAgQEBAICAgQEAgICBAQEAgIEBAQCAgIEBAICBAQEBcbiAgICBAQCAgIEBAQCBAQEBAQCAgICAgQEAgICBAQEAgQEBAQEAgICAgICBAQEAgICAgQEBAIEBAICBAQEBAQEAgICAgICBAQEBAQFxuICAgICAgQEAgICAgICAgICAgICAgICAgIEBAICAgICAgICAgICAgICAgICAgICAgICAgICAgQEAgIEBAXG4gICAgICAgIEBAQEBAQEAgICAgICAgICAgICBAQEBAQEBAICAgICAgICAgICAgICAgQEBAQEAgICAgQEBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuLy8uICMgc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnNcbi8vLlxuLy8uIEEgdHlwZSBpcyBhIHNldCBvZiB2YWx1ZXMuIEJvb2xlYW4sIGZvciBleGFtcGxlLCBpcyB0aGUgdHlwZSBjb21wcmlzaW5nXG4vLy4gYHRydWVgIGFuZCBgZmFsc2VgLiBBIHZhbHVlIG1heSBiZSBhIG1lbWJlciBvZiBtdWx0aXBsZSB0eXBlcyAoYDQyYCBpcyBhXG4vLy4gbWVtYmVyIG9mIE51bWJlciwgUG9zaXRpdmVOdW1iZXIsIEludGVnZXIsIGFuZCBtYW55IG90aGVyIHR5cGVzKS5cbi8vLlxuLy8uIEluIGNlcnRhaW4gc2l0dWF0aW9ucyBpdCBpcyB1c2VmdWwgdG8gZGl2aWRlIEphdmFTY3JpcHQgdmFsdWVzIGludG9cbi8vLiBub24tb3ZlcmxhcHBpbmcgdHlwZXMuIFRoZSBsYW5ndWFnZSBwcm92aWRlcyB0d28gY29uc3RydWN0cyBmb3IgdGhpc1xuLy8uIHB1cnBvc2U6IHRoZSBbYHR5cGVvZmBdWzFdIG9wZXJhdG9yIGFuZCBbYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXVsyXS5cbi8vLiBFYWNoIGhhcyBwcm9zIGFuZCBjb25zLCBidXQgbmVpdGhlciBzdXBwb3J0cyB1c2VyLWRlZmluZWQgdHlwZXMuXG4vLy5cbi8vLiBUaGlzIHBhY2thZ2Ugc3BlY2lmaWVzIGFuIFthbGdvcml0aG1dWzNdIGZvciBkZXJpdmluZyBhIF90eXBlIGlkZW50aWZpZXJfXG4vLy4gZnJvbSBhbnkgSmF2YVNjcmlwdCB2YWx1ZSwgYW5kIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGFsZ29yaXRobS5cbi8vLiBBdXRob3JzIG9mIGFsZ2VicmFpYyBkYXRhIHR5cGVzIG1heSBmb2xsb3cgdGhpcyBzcGVjaWZpY2F0aW9uIGluIG9yZGVyIHRvXG4vLy4gbWFrZSB0aGVpciBkYXRhIHR5cGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgYWxnb3JpdGhtLlxuLy8uXG4vLy4gIyMjIEFsZ29yaXRobVxuLy8uXG4vLy4gMS4gIFRha2UgYW55IEphdmFTY3JpcHQgdmFsdWUgYHhgLlxuLy8uXG4vLy4gMi4gIElmIGB4YCBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGdvIHRvIHN0ZXAgNi5cbi8vLlxuLy8uIDMuICBJZiBgeC5jb25zdHJ1Y3RvcmAgZXZhbHVhdGVzIHRvIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgZ28gdG8gc3RlcCA2LlxuLy8uXG4vLy4gNC4gIElmIGB4LmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0geGAsIGdvIHRvIHN0ZXAgNi4gVGhpcyBjaGVjayBwcmV2ZW50cyBhXG4vLy4gICAgIHByb3RvdHlwZSBvYmplY3QgZnJvbSBiZWluZyBjb25zaWRlcmVkIGEgbWVtYmVyIG9mIGl0cyBhc3NvY2lhdGVkIHR5cGUuXG4vLy5cbi8vLiA1LiAgSWYgYHR5cGVvZiB4LmNvbnN0cnVjdG9yWydAQHR5cGUnXWAgZXZhbHVhdGVzIHRvIGAnc3RyaW5nJ2AsIHJldHVyblxuLy8uICAgICB0aGUgdmFsdWUgb2YgYHguY29uc3RydWN0b3JbJ0BAdHlwZSddYC5cbi8vLlxuLy8uIDYuICBSZXR1cm4gdGhlIFtgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BdWzJdIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuLy8uICAgICB3aXRob3V0IHRoZSBsZWFkaW5nIGAnW29iamVjdCAnYCBhbmQgdHJhaWxpbmcgYCddJ2AuXG4vLy5cbi8vLiAjIyMgQ29tcGF0aWJpbGl0eVxuLy8uXG4vLy4gRm9yIGFuIGFsZ2VicmFpYyBkYXRhIHR5cGUgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBbYWxnb3JpdGhtXVszXTpcbi8vLlxuLy8uICAgLSBldmVyeSBtZW1iZXIgb2YgdGhlIHR5cGUgbXVzdCBoYXZlIGEgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBwb2ludGluZ1xuLy8uICAgICB0byBhbiBvYmplY3Qga25vd24gYXMgdGhlIF90eXBlIHJlcHJlc2VudGF0aXZlXztcbi8vLlxuLy8uICAgLSB0aGUgdHlwZSByZXByZXNlbnRhdGl2ZSBtdXN0IGhhdmUgYSBgQEB0eXBlYCBwcm9wZXJ0eTsgYW5kXG4vLy5cbi8vLiAgIC0gdGhlIHR5cGUgcmVwcmVzZW50YXRpdmUncyBgQEB0eXBlYCBwcm9wZXJ0eSAodGhlIF90eXBlIGlkZW50aWZpZXJfKVxuLy8uICAgICBtdXN0IGJlIGEgc3RyaW5nIHByaW1pdGl2ZSwgaWRlYWxseSBgJzxucG0tcGFja2FnZS1uYW1lPi88dHlwZS1uYW1lPidgLlxuLy8uXG4vLy4gRm9yIGV4YW1wbGU6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gIElkZW50aXR5IDo6IGEgLT4gSWRlbnRpdHkgYVxuLy8uIGZ1bmN0aW9uIElkZW50aXR5KHgpIHtcbi8vLiAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJZGVudGl0eSkpIHJldHVybiBuZXcgSWRlbnRpdHkoeCk7XG4vLy4gICB0aGlzLnZhbHVlID0geDtcbi8vLiB9XG4vLy5cbi8vLiBJZGVudGl0eVsnQEB0eXBlJ10gPSAnbXktcGFja2FnZS9JZGVudGl0eSc7XG4vLy4gYGBgXG4vLy5cbi8vLiBOb3RlIHRoYXQgYnkgdXNpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBpcyBzZXRcbi8vLiBpbXBsaWNpdGx5IGZvciBlYWNoIHZhbHVlIGNyZWF0ZWQuIENvbnN0cnVjdG9yIGZ1bmN0aW9ucyBhcmUgY29udmVuaWVudCBmb3Jcbi8vLiB0aGlzIHJlYXNvbiwgYnV0IGFyZSBub3QgcmVxdWlyZWQuIFRoaXMgZGVmaW5pdGlvbiBpcyBhbHNvIHZhbGlkOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vICBJZGVudGl0eVR5cGVSZXAgOjogVHlwZVJlcCBJZGVudGl0eVxuLy8uIHZhciBJZGVudGl0eVR5cGVSZXAgPSB7XG4vLy4gICAnQEB0eXBlJzogJ215LXBhY2thZ2UvSWRlbnRpdHknXG4vLy4gfTtcbi8vLlxuLy8uIC8vICBJZGVudGl0eSA6OiBhIC0+IElkZW50aXR5IGFcbi8vLiBmdW5jdGlvbiBJZGVudGl0eSh4KSB7XG4vLy4gICByZXR1cm4ge2NvbnN0cnVjdG9yOiBJZGVudGl0eVR5cGVSZXAsIHZhbHVlOiB4fTtcbi8vLiB9XG4vLy4gYGBgXG4vLy5cbi8vLiAjIyMgVXNhZ2Vcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiB2YXIgSWRlbnRpdHkgPSByZXF1aXJlKCdteS1wYWNrYWdlJykuSWRlbnRpdHk7XG4vLy4gdmFyIHR5cGUgPSByZXF1aXJlKCdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycycpO1xuLy8uXG4vLy4gdHlwZShudWxsKTsgICAgICAgICAvLyA9PiAnTnVsbCdcbi8vLiB0eXBlKHRydWUpOyAgICAgICAgIC8vID0+ICdCb29sZWFuJ1xuLy8uIHR5cGUoWzEsIDIsIDNdKTsgICAgLy8gPT4gJ0FycmF5J1xuLy8uIHR5cGUoSWRlbnRpdHkpOyAgICAgLy8gPT4gJ0Z1bmN0aW9uJ1xuLy8uIHR5cGUoSWRlbnRpdHkoMCkpOyAgLy8gPT4gJ215LXBhY2thZ2UvSWRlbnRpdHknXG4vLy4gYGBgXG4vLy5cbi8vLlxuLy8uIFsxXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3R5cGVvZlxuLy8uIFsyXTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L3RvU3RyaW5nXG4vLy4gWzNdOiAjYWxnb3JpdGhtXG5cbihmdW5jdGlvbihmKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUoW10sIGYpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc2FuY3R1YXJ5VHlwZUlkZW50aWZpZXJzID0gZigpO1xuICB9XG5cbn0oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vICAkJHR5cGUgOjogU3RyaW5nXG4gIHZhciAkJHR5cGUgPSAnQEB0eXBlJztcblxuICAvLyAgdHlwZSA6OiBBbnkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHR5cGUoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiZcbiAgICAgICAgICAgeC5jb25zdHJ1Y3RvciAhPSBudWxsICYmXG4gICAgICAgICAgIHguY29uc3RydWN0b3IucHJvdG90eXBlICE9PSB4ICYmXG4gICAgICAgICAgIHR5cGVvZiB4LmNvbnN0cnVjdG9yWyQkdHlwZV0gPT09ICdzdHJpbmcnID9cbiAgICAgIHguY29uc3RydWN0b3JbJCR0eXBlXSA6XG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkuc2xpY2UoJ1tvYmplY3QgJy5sZW5ndGgsIC0nXScubGVuZ3RoKTtcbiAgfVxuXG4gIHJldHVybiB0eXBlO1xuXG59KSk7XG4iLCIvKlxuICAgICAgICBAQEBAQEBAICAgICAgICAgICAgQEBAQEBAQCAgICAgICAgIEBAXG4gICAgICBAQCAgICAgICBAQCAgICAgICAgQEAgICAgICAgQEAgICAgICBAQEBcbiAgICBAQCAgIEBAQCBAQCAgQEAgICAgQEAgICBAQEAgQEAgIEBAICAgQEBAQEBAIEBAICAgQEBAICBAQCBAQEAgICAgICBAQEBAXG4gICBAQCAgQEAgICBAQEAgICBAQCAgQEAgIEBAICAgQEBAICAgQEAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQCAgIEBAXG4gICBAQCAgQEAgICBAQEAgICBAQCAgQEAgIEBAICAgQEBAICAgQEAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQEBAQEBAXG4gICBAQCAgQEAgICBAQEAgIEBAICAgQEAgIEBAICAgQEBAICBAQCAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQFxuICAgIEBAICAgQEBAIEBAQEBAICAgICBAQCAgIEBAQCBAQEBAQCAgICAgIEBAQCAgICBAQEAgQEAgIEBAQEBAQCAgICAgIEBAQEBAXG4gICAgICBAQCAgICAgICAgICAgICAgICAgQEAgICAgICAgICAgICAgICAgICAgICAgICAgICBAQCAgQEBcbiAgICAgICAgQEBAQEBAQCAgICAgICAgICAgIEBAQEBAQEAgICAgICAgICAgICAgICBAQEBAQCAgICBAQFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vLy4gIyBzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVyc1xuLy8uXG4vLy4gQSB0eXBlIGlzIGEgc2V0IG9mIHZhbHVlcy4gQm9vbGVhbiwgZm9yIGV4YW1wbGUsIGlzIHRoZSB0eXBlIGNvbXByaXNpbmdcbi8vLiBgdHJ1ZWAgYW5kIGBmYWxzZWAuIEEgdmFsdWUgbWF5IGJlIGEgbWVtYmVyIG9mIG11bHRpcGxlIHR5cGVzIChgNDJgIGlzIGFcbi8vLiBtZW1iZXIgb2YgTnVtYmVyLCBQb3NpdGl2ZU51bWJlciwgSW50ZWdlciwgYW5kIG1hbnkgb3RoZXIgdHlwZXMpLlxuLy8uXG4vLy4gSW4gY2VydGFpbiBzaXR1YXRpb25zIGl0IGlzIHVzZWZ1bCB0byBkaXZpZGUgSmF2YVNjcmlwdCB2YWx1ZXMgaW50b1xuLy8uIG5vbi1vdmVybGFwcGluZyB0eXBlcy4gVGhlIGxhbmd1YWdlIHByb3ZpZGVzIHR3byBjb25zdHJ1Y3RzIGZvciB0aGlzXG4vLy4gcHVycG9zZTogdGhlIFtgdHlwZW9mYF1bMV0gb3BlcmF0b3IgYW5kIFtgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BdWzJdLlxuLy8uIEVhY2ggaGFzIHByb3MgYW5kIGNvbnMsIGJ1dCBuZWl0aGVyIHN1cHBvcnRzIHVzZXItZGVmaW5lZCB0eXBlcy5cbi8vLlxuLy8uIHNhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzIGNvbXByaXNlczpcbi8vLlxuLy8uICAgLSBhbiBucG0gYW5kIGJyb3dzZXIgLWNvbXBhdGlibGUgcGFja2FnZSBmb3IgZGVyaXZpbmcgdGhlXG4vLy4gICAgIF90eXBlIGlkZW50aWZpZXJfIG9mIGEgSmF2YVNjcmlwdCB2YWx1ZTsgYW5kXG4vLy4gICAtIGEgc3BlY2lmaWNhdGlvbiB3aGljaCBhdXRob3JzIG1heSBmb2xsb3cgdG8gc3BlY2lmeSB0eXBlXG4vLy4gICAgIGlkZW50aWZpZXJzIGZvciB0aGVpciB0eXBlcy5cbi8vLlxuLy8uICMjIyBTcGVjaWZpY2F0aW9uXG4vLy5cbi8vLiBGb3IgYSB0eXBlIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYWxnb3JpdGhtOlxuLy8uXG4vLy4gICAtIGV2ZXJ5IG1lbWJlciBvZiB0aGUgdHlwZSBNVVNUIGhhdmUgYSBgY29uc3RydWN0b3JgIHByb3BlcnR5XG4vLy4gICAgIHBvaW50aW5nIHRvIGFuIG9iamVjdCBrbm93biBhcyB0aGUgX3R5cGUgcmVwcmVzZW50YXRpdmVfO1xuLy8uXG4vLy4gICAtIHRoZSB0eXBlIHJlcHJlc2VudGF0aXZlIE1VU1QgaGF2ZSBhIGBAQHR5cGVgIHByb3BlcnR5XG4vLy4gICAgICh0aGUgX3R5cGUgaWRlbnRpZmllcl8pOyBhbmRcbi8vLlxuLy8uICAgLSB0aGUgdHlwZSBpZGVudGlmaWVyIE1VU1QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlIGFuZCBTSE9VTEQgaGF2ZVxuLy8uICAgICBmb3JtYXQgYCc8bmFtZXNwYWNlPi88bmFtZT5bQDx2ZXJzaW9uPl0nYCwgd2hlcmU6XG4vLy5cbi8vLiAgICAgICAtIGA8bmFtZXNwYWNlPmAgTVVTVCBjb25zaXN0IG9mIG9uZSBvciBtb3JlIGNoYXJhY3RlcnMsIGFuZFxuLy8uICAgICAgICAgU0hPVUxEIGVxdWFsIHRoZSBuYW1lIG9mIHRoZSBucG0gcGFja2FnZSB3aGljaCBkZWZpbmVzIHRoZVxuLy8uICAgICAgICAgdHlwZSAoaW5jbHVkaW5nIFtzY29wZV1bM10gd2hlcmUgYXBwcm9wcmlhdGUpO1xuLy8uXG4vLy4gICAgICAgLSBgPG5hbWU+YCBNVVNUIGNvbnNpc3Qgb2Ygb25lIG9yIG1vcmUgY2hhcmFjdGVycywgYW5kIFNIT1VMRFxuLy8uICAgICAgICAgYmUgdGhlIHVuaXF1ZSBuYW1lIG9mIHRoZSB0eXBlOyBhbmRcbi8vLlxuLy8uICAgICAgIC0gYDx2ZXJzaW9uPmAgTVVTVCBjb25zaXN0IG9mIG9uZSBvciBtb3JlIGRpZ2l0cywgYW5kIFNIT1VMRFxuLy8uICAgICAgICAgcmVwcmVzZW50IHRoZSB2ZXJzaW9uIG9mIHRoZSB0eXBlLlxuLy8uXG4vLy4gSWYgdGhlIHR5cGUgaWRlbnRpZmllciBkb2VzIG5vdCBjb25mb3JtIHRvIHRoZSBmb3JtYXQgc3BlY2lmaWVkIGFib3ZlLFxuLy8uIGl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgZW50aXJlIHN0cmluZyByZXByZXNlbnRzIHRoZSBfbmFtZV8gb2YgdGhlIHR5cGU7XG4vLy4gX25hbWVzcGFjZV8gd2lsbCBiZSBgbnVsbGAgYW5kIF92ZXJzaW9uXyB3aWxsIGJlIGAwYC5cbi8vLlxuLy8uIElmIHRoZSBfdmVyc2lvbl8gaXMgbm90IGdpdmVuLCBpdCBpcyBhc3N1bWVkIHRvIGJlIGAwYC5cbi8vLlxuLy8uIEZvciBleGFtcGxlOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vICBJZGVudGl0eSA6OiBhIC0+IElkZW50aXR5IGFcbi8vLiBmdW5jdGlvbiBJZGVudGl0eSh4KSB7XG4vLy4gICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSWRlbnRpdHkpKSByZXR1cm4gbmV3IElkZW50aXR5KHgpO1xuLy8uICAgdGhpcy52YWx1ZSA9IHg7XG4vLy4gfVxuLy8uXG4vLy4gSWRlbnRpdHlbJ0BAdHlwZSddID0gJ215LXBhY2thZ2UvSWRlbnRpdHknO1xuLy8uIGBgYFxuLy8uXG4vLy4gTm90ZSB0aGF0IGJ5IHVzaW5nIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgaXMgc2V0XG4vLy4gaW1wbGljaXRseSBmb3IgZWFjaCB2YWx1ZSBjcmVhdGVkLiBDb25zdHJ1Y3RvciBmdW5jdGlvbnMgYXJlIGNvbnZlbmllbnQgZm9yXG4vLy4gdGhpcyByZWFzb24sIGJ1dCBhcmUgbm90IHJlcXVpcmVkLiBUaGlzIGRlZmluaXRpb24gaXMgYWxzbyB2YWxpZDpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgSWRlbnRpdHlUeXBlUmVwIDo6IFR5cGVSZXAgSWRlbnRpdHlcbi8vLiB2YXIgSWRlbnRpdHlUeXBlUmVwID0ge1xuLy8uICAgJ0BAdHlwZSc6ICdteS1wYWNrYWdlL0lkZW50aXR5J1xuLy8uIH07XG4vLy5cbi8vLiAvLyAgSWRlbnRpdHkgOjogYSAtPiBJZGVudGl0eSBhXG4vLy4gZnVuY3Rpb24gSWRlbnRpdHkoeCkge1xuLy8uICAgcmV0dXJuIHtjb25zdHJ1Y3RvcjogSWRlbnRpdHlUeXBlUmVwLCB2YWx1ZTogeH07XG4vLy4gfVxuLy8uIGBgYFxuXG4oZnVuY3Rpb24oZikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZigpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCAhPSBudWxsKSB7XG4gICAgZGVmaW5lKFtdLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeVR5cGVJZGVudGlmaWVycyA9IGYoKTtcbiAgfVxuXG59KGZ1bmN0aW9uKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyAgJCR0eXBlIDo6IFN0cmluZ1xuICB2YXIgJCR0eXBlID0gJ0BAdHlwZSc7XG5cbiAgLy8gIHBhdHRlcm4gOjogUmVnRXhwXG4gIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cChcbiAgICAnXidcbiAgKyAnKFtcXFxcc1xcXFxTXSspJyAgIC8vICA8bmFtZXNwYWNlPlxuICArICcvJyAgICAgICAgICAgICAvLyAgU09MSURVUyAoVSswMDJGKVxuICArICcoW1xcXFxzXFxcXFNdKz8pJyAgLy8gIDxuYW1lPlxuICArICcoPzonICAgICAgICAgICAvLyAgb3B0aW9uYWwgbm9uLWNhcHR1cmluZyBncm91cCB7XG4gICsgICAnQCcgICAgICAgICAgIC8vICAgIENPTU1FUkNJQUwgQVQgKFUrMDA0MClcbiAgKyAgICcoWzAtOV0rKScgICAgLy8gICAgPHZlcnNpb24+XG4gICsgJyk/JyAgICAgICAgICAgIC8vICB9XG4gICsgJyQnXG4gICk7XG5cbiAgLy8uICMjIyBVc2FnZVxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIGNvbnN0IHR5cGUgPSByZXF1aXJlKCdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycycpO1xuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBmdW5jdGlvbiBJZGVudGl0eSh4KSB7XG4gIC8vLiAuICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIElkZW50aXR5KSkgcmV0dXJuIG5ldyBJZGVudGl0eSh4KTtcbiAgLy8uIC4gICB0aGlzLnZhbHVlID0geDtcbiAgLy8uIC4gfVxuICAvLy4gLiBJZGVudGl0eVsnQEB0eXBlJ10gPSAnbXktcGFja2FnZS9JZGVudGl0eUAxJztcbiAgLy8uXG4gIC8vLiA+IHR5cGUucGFyc2UodHlwZShJZGVudGl0eSgwKSkpXG4gIC8vLiB7bmFtZXNwYWNlOiAnbXktcGFja2FnZScsIG5hbWU6ICdJZGVudGl0eScsIHZlcnNpb246IDF9XG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiAjIyMgQVBJXG4gIC8vLlxuICAvLyMgdHlwZSA6OiBBbnkgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gVGFrZXMgYW55IHZhbHVlIGFuZCByZXR1cm5zIGEgc3RyaW5nIHdoaWNoIGlkZW50aWZpZXMgaXRzIHR5cGUuIElmIHRoZVxuICAvLy4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIFtzcGVjaWZpY2F0aW9uXVs0XSwgdGhlIGN1c3RvbSB0eXBlIGlkZW50aWZpZXIgaXNcbiAgLy8uIHJldHVybmVkLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gdHlwZShudWxsKVxuICAvLy4gJ051bGwnXG4gIC8vLlxuICAvLy4gPiB0eXBlKHRydWUpXG4gIC8vLiAnQm9vbGVhbidcbiAgLy8uXG4gIC8vLiA+IHR5cGUoSWRlbnRpdHkoMCkpXG4gIC8vLiAnbXktcGFja2FnZS9JZGVudGl0eUAxJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHR5cGUoeCkge1xuICAgIHJldHVybiB4ICE9IG51bGwgJiZcbiAgICAgICAgICAgeC5jb25zdHJ1Y3RvciAhPSBudWxsICYmXG4gICAgICAgICAgIHguY29uc3RydWN0b3IucHJvdG90eXBlICE9PSB4ICYmXG4gICAgICAgICAgIHR5cGVvZiB4LmNvbnN0cnVjdG9yWyQkdHlwZV0gPT09ICdzdHJpbmcnID9cbiAgICAgIHguY29uc3RydWN0b3JbJCR0eXBlXSA6XG4gICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkuc2xpY2UoJ1tvYmplY3QgJy5sZW5ndGgsIC0nXScubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIyB0eXBlLnBhcnNlIDo6IFN0cmluZyAtPiB7IG5hbWVzcGFjZSA6OiBOdWxsYWJsZSBTdHJpbmcsIG5hbWUgOjogU3RyaW5nLCB2ZXJzaW9uIDo6IE51bWJlciB9XG4gIC8vLlxuICAvLy4gVGFrZXMgYW55IHN0cmluZyBhbmQgcGFyc2VzIGl0IGFjY29yZGluZyB0byB0aGUgW3NwZWNpZmljYXRpb25dWzRdLFxuICAvLy4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGBuYW1lc3BhY2VgLCBgbmFtZWAsIGFuZCBgdmVyc2lvbmAgZmllbGRzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gdHlwZS5wYXJzZSgnbXktcGFja2FnZS9MaXN0QDInKVxuICAvLy4ge25hbWVzcGFjZTogJ215LXBhY2thZ2UnLCBuYW1lOiAnTGlzdCcsIHZlcnNpb246IDJ9XG4gIC8vLlxuICAvLy4gPiB0eXBlLnBhcnNlKCdub25zZW5zZSEnKVxuICAvLy4ge25hbWVzcGFjZTogbnVsbCwgbmFtZTogJ25vbnNlbnNlIScsIHZlcnNpb246IDB9XG4gIC8vLlxuICAvLy4gPiB0eXBlLnBhcnNlKElkZW50aXR5WydAQHR5cGUnXSlcbiAgLy8uIHtuYW1lc3BhY2U6ICdteS1wYWNrYWdlJywgbmFtZTogJ0lkZW50aXR5JywgdmVyc2lvbjogMX1cbiAgLy8uIGBgYFxuICB0eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2Uocykge1xuICAgIHZhciBncm91cHMgPSBwYXR0ZXJuLmV4ZWMocyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWVzcGFjZTogZ3JvdXBzID09IG51bGwgfHwgZ3JvdXBzWzFdID09IG51bGwgPyBudWxsIDogZ3JvdXBzWzFdLFxuICAgICAgbmFtZTogICAgICBncm91cHMgPT0gbnVsbCAgICAgICAgICAgICAgICAgICAgICA/IHMgICAgOiBncm91cHNbMl0sXG4gICAgICB2ZXJzaW9uOiAgIGdyb3VwcyA9PSBudWxsIHx8IGdyb3Vwc1szXSA9PSBudWxsID8gMCAgICA6IE51bWJlcihncm91cHNbM10pXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gdHlwZTtcblxufSkpO1xuXG4vLy4gWzFdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvdHlwZW9mXG4vLy4gWzJdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdG9TdHJpbmdcbi8vLiBbM106IGh0dHBzOi8vZG9jcy5ucG1qcy5jb20vbWlzYy9zY29wZVxuLy8uIFs0XTogI3NwZWNpZmljYXRpb25cbiIsIi8qICAgICMjIyMjIyNcbiAgICMjIyMgICAgICMjIyNcbiAjIyMjICAgIyMjICAgIyMjI1xuIyMjIyMgICAjIyMjIyMjIyMjIyAgIHNhbmN0dWFyeVxuIyMjIyMjIyMgICAjIyMjIyMjIyAgIG5vdW5cbiMjIyMjIyMjIyMjICAgIyMjIyMgICAxIFsgbWFzcyBub3VuIF0gcmVmdWdlIGZyb20gdW5zYWZlIEphdmFTY3JpcHRcbiAjIyMjICAgIyMjICAgIyMjI1xuICAgIyMjIyAgICAgIyMjI1xuICAgICAgIyMjIyMjIyAgICAqL1xuXG4vLy4gIyBTYW5jdHVhcnlcbi8vLlxuLy8uIFshW25wbV0oaHR0cHM6Ly9pbWcuc2hpZWxkcy5pby9ucG0vdi9zYW5jdHVhcnkuc3ZnKV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2FuY3R1YXJ5KVxuLy8uIFshW0NpcmNsZUNJXShodHRwczovL2ltZy5zaGllbGRzLmlvL2NpcmNsZWNpL3Byb2plY3QvZ2l0aHViL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnkvbWFzdGVyLnN2ZyldKGh0dHBzOi8vY2lyY2xlY2kuY29tL2doL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnkvdHJlZS9tYXN0ZXIpXG4vLy4gWyFbR2l0dGVyXShodHRwczovL2ltZy5zaGllbGRzLmlvL2dpdHRlci9yb29tL2JhZGdlcy9zaGllbGRzLnN2ZyldKGh0dHBzOi8vZ2l0dGVyLmltL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnkpXG4vLy5cbi8vLiBTYW5jdHVhcnkgaXMgYSBKYXZhU2NyaXB0IGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgbGlicmFyeSBpbnNwaXJlZCBieVxuLy8uIFtIYXNrZWxsXVtdIGFuZCBbUHVyZVNjcmlwdF1bXS4gSXQncyBzdHJpY3RlciB0aGFuIFtSYW1kYV1bXSwgYW5kXG4vLy4gcHJvdmlkZXMgYSBzaW1pbGFyIHN1aXRlIG9mIGZ1bmN0aW9ucy5cbi8vLlxuLy8uIFNhbmN0dWFyeSBwcm9tb3RlcyBwcm9ncmFtcyBjb21wb3NlZCBvZiBzaW1wbGUsIHB1cmUgZnVuY3Rpb25zLiBTdWNoXG4vLy4gcHJvZ3JhbXMgYXJlIGVhc2llciB0byBjb21wcmVoZW5kLCB0ZXN0LCBhbmQgbWFpbnRhaW4gJm5kYXNoOyB0aGV5IGFyZVxuLy8uIGFsc28gYSBwbGVhc3VyZSB0byB3cml0ZS5cbi8vLlxuLy8uIFNhbmN0dWFyeSBwcm92aWRlcyB0d28gZGF0YSB0eXBlcywgW01heWJlXVtdIGFuZCBbRWl0aGVyXVtdLCBib3RoIG9mXG4vLy4gd2hpY2ggYXJlIGNvbXBhdGlibGUgd2l0aCBbRmFudGFzeSBMYW5kXVtdLiBUaGFua3MgdG8gdGhlc2UgZGF0YSB0eXBlc1xuLy8uIGV2ZW4gU2FuY3R1YXJ5IGZ1bmN0aW9ucyB3aGljaCBtYXkgZmFpbCwgc3VjaCBhcyBbYGhlYWRgXSgjaGVhZCksIGFyZVxuLy8uIGNvbXBvc2FibGUuXG4vLy5cbi8vLiBTYW5jdHVhcnkgbWFrZXMgaXQgcG9zc2libGUgdG8gd3JpdGUgc2FmZSBjb2RlIHdpdGhvdXQgbnVsbCBjaGVja3MuXG4vLy4gSW4gSmF2YVNjcmlwdCBpdCdzIHRyaXZpYWwgdG8gaW50cm9kdWNlIGEgcG9zc2libGUgcnVuLXRpbWUgdHlwZSBlcnJvcjpcbi8vLlxuLy8uICAgICB3b3Jkc1swXS50b1VwcGVyQ2FzZSgpXG4vLy5cbi8vLiBJZiBgd29yZHNgIGlzIGBbXWAgd2UnbGwgZ2V0IGEgZmFtaWxpYXIgZXJyb3IgYXQgcnVuLXRpbWU6XG4vLy5cbi8vLiAgICAgVHlwZUVycm9yOiBDYW5ub3QgcmVhZCBwcm9wZXJ0eSAndG9VcHBlckNhc2UnIG9mIHVuZGVmaW5lZFxuLy8uXG4vLy4gU2FuY3R1YXJ5IGdpdmVzIHVzIGEgZmlnaHRpbmcgY2hhbmNlIG9mIGF2b2lkaW5nIHN1Y2ggZXJyb3JzLiBXZSBtaWdodFxuLy8uIHdyaXRlOlxuLy8uXG4vLy4gICAgIFMubWFwIChTLnRvVXBwZXIpIChTLmhlYWQgKHdvcmRzKSlcbi8vLlxuLy8uIFNhbmN0dWFyeSBpcyBkZXNpZ25lZCB0byB3b3JrIGluIE5vZGUuanMgYW5kIGluIEVTNS1jb21wYXRpYmxlIGJyb3dzZXJzLlxuLy8uXG4vLy4gIyMgUmFtZGFcbi8vLlxuLy8uIFtSYW1kYV1bXSBwcm92aWRlcyBzZXZlcmFsIGZ1bmN0aW9ucyB3aGljaCByZXR1cm4gcHJvYmxlbWF0aWMgdmFsdWVzXG4vLy4gc3VjaCBhcyBgdW5kZWZpbmVkYCwgYEluZmluaXR5YCwgb3IgYE5hTmAgd2hlbiBhcHBsaWVkIHRvIHVuc3VpdGFibGVcbi8vLiBpbnB1dHMuIFRoZXNlIGFyZSBrbm93biBhcyBbcGFydGlhbCBmdW5jdGlvbnNdW10uIFBhcnRpYWwgZnVuY3Rpb25zXG4vLy4gbmVjZXNzaXRhdGUgdGhlIHVzZSBvZiBndWFyZHMgb3IgbnVsbCBjaGVja3MuIEluIG9yZGVyIHRvIHNhZmVseSB1c2Vcbi8vLiBgUi5oZWFkYCwgZm9yIGV4YW1wbGUsIG9uZSBtdXN0IGVuc3VyZSB0aGF0IHRoZSBhcnJheSBpcyBub24tZW1wdHk6XG4vLy5cbi8vLiAgICAgaWYgKFIuaXNFbXB0eSAoeHMpKSB7XG4vLy4gICAgICAgLy8gLi4uXG4vLy4gICAgIH0gZWxzZSB7XG4vLy4gICAgICAgcmV0dXJuIGYgKFIuaGVhZCAoeHMpKTtcbi8vLiAgICAgfVxuLy8uXG4vLy4gVXNpbmcgdGhlIE1heWJlIHR5cGUgcmVuZGVycyBzdWNoIGd1YXJkcyAoYW5kIG51bGwgY2hlY2tzKSB1bm5lY2Vzc2FyeS5cbi8vLiBDaGFuZ2luZyBmdW5jdGlvbnMgc3VjaCBhcyBgUi5oZWFkYCB0byByZXR1cm4gTWF5YmUgdmFsdWVzIHdhcyBwcm9wb3NlZFxuLy8uIGluIFtyYW1kYS9yYW1kYSM2ODNdW10sIGJ1dCB3YXMgY29uc2lkZXJlZCB0b28gbXVjaCBvZiBhIHN0cmV0Y2ggZm9yXG4vLy4gSmF2YVNjcmlwdCBwcm9ncmFtbWVycy4gU2FuY3R1YXJ5IHdhcyByZWxlYXNlZCB0aGUgZm9sbG93aW5nIG1vbnRoLFxuLy8uIGluIEphbnVhcnkgMjAxNSwgYXMgYSBjb21wYW5pb24gbGlicmFyeSB0byBSYW1kYS5cbi8vLlxuLy8uIEluIGFkZGl0aW9uIHRvIGJyb2FkZW5pbmcgaW4gc2NvcGUgaW4gdGhlIHllYXJzIHNpbmNlIGl0cyByZWxlYXNlLFxuLy8uIFNhbmN0dWFyeSdzIHBoaWxvc29waHkgaGFzIGRpdmVyZ2VkIGZyb20gUmFtZGEncyBpbiBzZXZlcmFsIHJlc3BlY3RzLlxuLy8uXG4vLy4gIyMjIFRvdGFsaXR5XG4vLy5cbi8vLiBFdmVyeSBTYW5jdHVhcnkgZnVuY3Rpb24gaXMgZGVmaW5lZCBmb3IgZXZlcnkgdmFsdWUgd2hpY2ggaXMgYSBtZW1iZXIgb2Zcbi8vLiB0aGUgZnVuY3Rpb24ncyBpbnB1dCB0eXBlLiBTdWNoIGZ1bmN0aW9ucyBhcmUga25vd24gYXMgW3RvdGFsIGZ1bmN0aW9uc11bXS5cbi8vLiBSYW1kYSwgb24gdGhlIG90aGVyIGhhbmQsIGNvbnRhaW5zIGEgbnVtYmVyIG9mIFtwYXJ0aWFsIGZ1bmN0aW9uc11bXS5cbi8vLlxuLy8uICMjIyBJbmZvcm1hdGlvbiBwcmVzZXJ2YXRpb25cbi8vLlxuLy8uIENlcnRhaW4gU2FuY3R1YXJ5IGZ1bmN0aW9ucyBwcmVzZXJ2ZSBtb3JlIGluZm9ybWF0aW9uIHRoYW4gdGhlaXIgUmFtZGFcbi8vLiBjb3VudGVycGFydHMuIEV4YW1wbGVzOlxuLy8uXG4vLy4gICAgIHw+IFIudGFpbCAoW10pICAgICAgICAgICAgICAgICAgICAgIHw+IFMudGFpbCAoW10pXG4vLy4gICAgIFtdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGhpbmdcbi8vLlxuLy8uICAgICB8PiBSLnRhaWwgKFsnZm9vJ10pICAgICAgICAgICAgICAgICB8PiBTLnRhaWwgKFsnZm9vJ10pXG4vLy4gICAgIFtdICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEp1c3QgKFtdKVxuLy8uXG4vLy4gICAgIHw+IFIucmVwbGFjZSAoL154LykgKCcnKSAoJ2FiYycpICAgIHw+IFMuc3RyaXBQcmVmaXggKCd4JykgKCdhYmMnKVxuLy8uICAgICAnYWJjJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb3RoaW5nXG4vLy5cbi8vLiAgICAgfD4gUi5yZXBsYWNlICgvXngvKSAoJycpICgneGFiYycpICAgfD4gUy5zdHJpcFByZWZpeCAoJ3gnKSAoJ3hhYmMnKVxuLy8uICAgICAnYWJjJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKdXN0ICgnYWJjJylcbi8vLlxuLy8uICMjIyBJbnZhcmlhbnRzXG4vLy5cbi8vLiBTYW5jdHVhcnkgcGVyZm9ybXMgcmlnb3JvdXMgW3R5cGUgY2hlY2tpbmddW10gb2YgaW5wdXRzIGFuZCBvdXRwdXRzLCBhbmRcbi8vLiB0aHJvd3MgYSBkZXNjcmlwdGl2ZSBlcnJvciBpZiBhIHR5cGUgZXJyb3IgaXMgZW5jb3VudGVyZWQuIFRoaXMgYWxsb3dzIGJ1Z3Ncbi8vLiB0byBiZSBjYXVnaHQgYW5kIGZpeGVkIGVhcmx5IGluIHRoZSBkZXZlbG9wbWVudCBjeWNsZS5cbi8vLlxuLy8uIFJhbWRhIG9wZXJhdGVzIG9uIHRoZSBbZ2FyYmFnZSBpbiwgZ2FyYmFnZSBvdXRdW0dJR09dIHByaW5jaXBhbC4gRnVuY3Rpb25zXG4vLy4gYXJlIGRvY3VtZW50ZWQgdG8gdGFrZSBhcmd1bWVudHMgb2YgcGFydGljdWxhciB0eXBlcywgYnV0IHRoZXNlIGludmFyaWFudHNcbi8vLiBhcmUgbm90IGVuZm9yY2VkLiBUaGUgcHJvYmxlbSB3aXRoIHRoaXMgYXBwcm9hY2ggaW4gYSBsYW5ndWFnZSBhc1xuLy8uIHBlcm1pc3NpdmUgYXMgSmF2YVNjcmlwdCBpcyB0aGF0IHRoZXJlJ3Mgbm8gZ3VhcmFudGVlIHRoYXQgZ2FyYmFnZSBpbnB1dFxuLy8uIHdpbGwgcHJvZHVjZSBnYXJiYWdlIG91dHB1dCAoW3JhbWRhL3JhbWRhIzE0MTNdW10pLiBSYW1kYSBwZXJmb3JtcyBhZCBob2Ncbi8vLiB0eXBlIGNoZWNraW5nIGluIHNvbWUgc3VjaCBjYXNlcyAoW3JhbWRhL3JhbWRhIzE0MTldW10pLlxuLy8uXG4vLy4gU2FuY3R1YXJ5IGNhbiBiZSBjb25maWd1cmVkIHRvIG9wZXJhdGUgaW4gZ2FyYmFnZSBpbiwgZ2FyYmFnZSBvdXQgbW9kZS5cbi8vLiBSYW1kYSBjYW5ub3QgYmUgY29uZmlndXJlZCB0byBlbmZvcmNlIGl0cyBpbnZhcmlhbnRzLlxuLy8uXG4vLy4gIyMjIEN1cnJ5aW5nXG4vLy5cbi8vLiBTYW5jdHVhcnkgZnVuY3Rpb25zIGFyZSBjdXJyaWVkLiBUaGVyZSBpcywgZm9yIGV4YW1wbGUsIGV4YWN0bHkgb25lIHdheSB0b1xuLy8uIGFwcGx5IGBTLnJlZHVjZWAgdG8gYFMuYWRkYCwgYDBgLCBhbmQgYHhzYDpcbi8vLlxuLy8uICAgLSBgUy5yZWR1Y2UgKFMuYWRkKSAoMCkgKHhzKWBcbi8vLlxuLy8uIFJhbWRhIGZ1bmN0aW9ucyBhcmUgYWxzbyBjdXJyaWVkLCBidXQgaW4gYSBjb21wbGV4IG1hbm5lci4gVGhlcmUgYXJlIGZvdXJcbi8vLiB3YXlzIHRvIGFwcGx5IGBSLnJlZHVjZWAgdG8gYFIuYWRkYCwgYDBgLCBhbmQgYHhzYDpcbi8vLlxuLy8uICAgLSBgUi5yZWR1Y2UgKFIuYWRkKSAoMCkgKHhzKWBcbi8vLiAgIC0gYFIucmVkdWNlIChSLmFkZCkgKDAsIHhzKWBcbi8vLiAgIC0gYFIucmVkdWNlIChSLmFkZCwgMCkgKHhzKWBcbi8vLiAgIC0gYFIucmVkdWNlIChSLmFkZCwgMCwgeHMpYFxuLy8uXG4vLy4gUmFtZGEgc3VwcG9ydHMgYWxsIHRoZXNlIGZvcm1zIGJlY2F1c2UgY3VycmllZCBmdW5jdGlvbnMgZW5hYmxlIHBhcnRpYWxcbi8vLiBhcHBsaWNhdGlvbiwgb25lIG9mIHRoZSBsaWJyYXJ5J3MgdGVuZXRzLCBidXQgYGYoeCkoeSkoeilgIGlzIGNvbnNpZGVyZWRcbi8vLiB0b28gdW5mYW1pbGlhciBhbmQgdG9vIHVuYXR0cmFjdGl2ZSB0byBhcHBlYWwgdG8gSmF2YVNjcmlwdCBwcm9ncmFtbWVycy5cbi8vLlxuLy8uIFNhbmN0dWFyeSdzIGRldmVsb3BlcnMgcHJlZmVyIGEgc2ltcGxlLCB1bmZhbWlsaWFyIGNvbnN0cnVjdCB0byBhIGNvbXBsZXgsXG4vLy4gZmFtaWxpYXIgb25lLiBGYW1pbGlhcml0eSBjYW4gYmUgYWNxdWlyZWQ7IGNvbXBsZXhpdHkgaXMgaW50cmluc2ljLlxuLy8uXG4vLy4gVGhlIGxhY2sgb2YgYnJlYXRoaW5nIHJvb20gaW4gYGYoeCkoeSkoeilgIGltcGFpcnMgcmVhZGFiaWxpdHkuIFRoZSBzaW1wbGVcbi8vLiBzb2x1dGlvbiB0byB0aGlzIHByb2JsZW0sIHByb3Bvc2VkIGluIFsjNDM4XVtdLCBpcyB0byBpbmNsdWRlIGEgc3BhY2Ugd2hlblxuLy8uIGFwcGx5aW5nIGEgZnVuY3Rpb246IGBmICh4KSAoeSkgKHopYC5cbi8vLlxuLy8uIFJhbWRhIGFsc28gcHJvdmlkZXMgYSBzcGVjaWFsIHBsYWNlaG9sZGVyIHZhbHVlLCBbYFIuX19gXVtdLCB3aGljaCByZW1vdmVzXG4vLy4gdGhlIHJlc3RyaWN0aW9uIHRoYXQgYSBmdW5jdGlvbiBtdXN0IGJlIGFwcGxpZWQgdG8gaXRzIGFyZ3VtZW50cyBpbiBvcmRlci5cbi8vLiBUaGUgZm9sbG93aW5nIGV4cHJlc3Npb25zIGFyZSBlcXVpdmFsZW50OlxuLy8uXG4vLy4gICAtIGBSLnJlZHVjZSAoUi5fXywgMCwgeHMpIChSLmFkZClgXG4vLy4gICAtIGBSLnJlZHVjZSAoUi5hZGQsIFIuX18sIHhzKSAoMClgXG4vLy4gICAtIGBSLnJlZHVjZSAoUi5fXywgMCkgKFIuYWRkKSAoeHMpYFxuLy8uICAgLSBgUi5yZWR1Y2UgKFIuX18sIDApIChSLmFkZCwgeHMpYFxuLy8uICAgLSBgUi5yZWR1Y2UgKFIuX18sIFIuX18sIHhzKSAoUi5hZGQpICgwKWBcbi8vLiAgIC0gYFIucmVkdWNlIChSLl9fLCBSLl9fLCB4cykgKFIuYWRkLCAwKWBcbi8vLlxuLy8uICMjIyBWYXJpYWRpYyBmdW5jdGlvbnNcbi8vLlxuLy8uIFJhbWRhIHByb3ZpZGVzIHNldmVyYWwgZnVuY3Rpb25zIHdoaWNoIHRha2UgYW55IG51bWJlciBvZiBhcmd1bWVudHMuIFRoZXNlXG4vLy4gYXJlIGtub3duIGFzIFt2YXJpYWRpYyBmdW5jdGlvbnNdW10uIEFkZGl0aW9uYWxseSwgUmFtZGEgcHJvdmlkZXMgc2V2ZXJhbFxuLy8uIGZ1bmN0aW9ucyB3aGljaCB0YWtlIHZhcmlhZGljIGZ1bmN0aW9ucyBhcyBhcmd1bWVudHMuIEFsdGhvdWdoIG5hdHVyYWwgaW5cbi8vLiBhIGR5bmFtaWNhbGx5IHR5cGVkIGxhbmd1YWdlLCB2YXJpYWRpYyBmdW5jdGlvbnMgYXJlIGF0IG9kZHMgd2l0aCB0aGUgdHlwZVxuLy8uIG5vdGF0aW9uIFJhbWRhIGFuZCBTYW5jdHVhcnkgYm90aCB1c2UsIGxlYWRpbmcgdG8gc29tZSBpbmRlY2lwaGVyYWJsZSB0eXBlXG4vLy4gc2lnbmF0dXJlcyBzdWNoIGFzIHRoaXMgb25lOlxuLy8uXG4vLy4gICAgIFIubGlmdCA6OiAoKi4uLiAtPiAqLi4uKSAtPiAoWypdLi4uIC0+IFsqXSlcbi8vLlxuLy8uIFNhbmN0dWFyeSBoYXMgbm8gdmFyaWFkaWMgZnVuY3Rpb25zLCBub3IgYW55IGZ1bmN0aW9ucyB3aGljaCB0YWtlIHZhcmlhZGljXG4vLy4gZnVuY3Rpb25zIGFzIGFyZ3VtZW50cy4gU2FuY3R1YXJ5IHByb3ZpZGVzIHR3byBcImxpZnRcIiBmdW5jdGlvbnMsIGVhY2ggd2l0aFxuLy8uIGEgaGVscGZ1bCB0eXBlIHNpZ25hdHVyZTpcbi8vLlxuLy8uICAgICBTLmxpZnQyIDo6IEFwcGx5IGYgPT4gKGEgLT4gYiAtPiBjKSAtPiBmIGEgLT4gZiBiIC0+IGYgY1xuLy8uICAgICBTLmxpZnQzIDo6IEFwcGx5IGYgPT4gKGEgLT4gYiAtPiBjIC0+IGQpIC0+IGYgYSAtPiBmIGIgLT4gZiBjIC0+IGYgZFxuLy8uXG4vLy4gIyMjIEltcGxpY2l0IGNvbnRleHRcbi8vLlxuLy8uIFJhbWRhIHByb3ZpZGVzIFtgUi5iaW5kYF1bXSBhbmQgW2BSLmludm9rZXJgXVtdIGZvciB3b3JraW5nIHdpdGggbWV0aG9kcy5cbi8vLiBBZGRpdGlvbmFsbHksIG1hbnkgUmFtZGEgZnVuY3Rpb25zIHVzZSBgRnVuY3Rpb24jY2FsbGAgb3IgYEZ1bmN0aW9uI2FwcGx5YFxuLy8uIHRvIHByZXNlcnZlIGNvbnRleHQuIFNhbmN0dWFyeSBtYWtlcyBubyBhbGxvd2FuY2VzIGZvciBgdGhpc2AuXG4vLy5cbi8vLiAjIyMgVHJhbnNkdWNlcnNcbi8vLlxuLy8uIFNldmVyYWwgUmFtZGEgZnVuY3Rpb25zIGFjdCBhcyB0cmFuc2R1Y2Vycy4gU2FuY3R1YXJ5IHByb3ZpZGVzIG5vIHN1cHBvcnRcbi8vLiBmb3IgdHJhbnNkdWNlcnMuXG4vLy5cbi8vLiAjIyMgTW9kdWxhcml0eVxuLy8uXG4vLy4gV2hlcmVhcyBSYW1kYSBoYXMgbm8gZGVwZW5kZW5jaWVzLCBTYW5jdHVhcnkgaGFzIGEgbW9kdWxhciBkZXNpZ246XG4vLy4gW3NhbmN0dWFyeS1kZWZdW10gcHJvdmlkZXMgdHlwZSBjaGVja2luZywgW3NhbmN0dWFyeS10eXBlLWNsYXNzZXNdW11cbi8vLiBwcm92aWRlcyBGYW50YXN5IExhbmQgZnVuY3Rpb25zIGFuZCB0eXBlIGNsYXNzZXMsIFtzYW5jdHVhcnktc2hvd11bXVxuLy8uIHByb3ZpZGVzIHN0cmluZyByZXByZXNlbnRhdGlvbnMsIGFuZCBhbGdlYnJhaWMgZGF0YSB0eXBlcyBhcmUgcHJvdmlkZWRcbi8vLiBieSBbc2FuY3R1YXJ5LWVpdGhlcl1bXSwgW3NhbmN0dWFyeS1tYXliZV1bXSwgYW5kIFtzYW5jdHVhcnktcGFpcl1bXS5cbi8vLiBOb3Qgb25seSBkb2VzIHRoaXMgYXBwcm9hY2ggcmVkdWNlIHRoZSBjb21wbGV4aXR5IG9mIFNhbmN0dWFyeSBpdHNlbGYsXG4vLy4gYnV0IGl0IGFsbG93cyB0aGVzZSBjb21wb25lbnRzIHRvIGJlIHJldXNlZCBpbiBvdGhlciBjb250ZXh0cy5cbi8vLlxuLy8uICMjIFR5cGVzXG4vLy5cbi8vLiBTYW5jdHVhcnkgdXNlcyBIYXNrZWxsLWxpa2UgdHlwZSBzaWduYXR1cmVzIHRvIGRlc2NyaWJlIHRoZSB0eXBlcyBvZlxuLy8uIHZhbHVlcywgaW5jbHVkaW5nIGZ1bmN0aW9ucy4gYCdmb28nYCwgZm9yIGV4YW1wbGUsIGlzIGEgbWVtYmVyIG9mIGBTdHJpbmdgO1xuLy8uIGBbMSwgMiwgM11gIGlzIGEgbWVtYmVyIG9mIGBBcnJheSBOdW1iZXJgLiBUaGUgZG91YmxlIGNvbG9uIChgOjpgKSBpcyB1c2VkXG4vLy4gdG8gbWVhbiBcImlzIGEgbWVtYmVyIG9mXCIsIHNvIG9uZSBjb3VsZCB3cml0ZTpcbi8vLlxuLy8uICAgICAnZm9vJyA6OiBTdHJpbmdcbi8vLiAgICAgWzEsIDIsIDNdIDo6IEFycmF5IE51bWJlclxuLy8uXG4vLy4gQW4gaWRlbnRpZmllciBtYXkgYXBwZWFyIHRvIHRoZSBsZWZ0IG9mIHRoZSBkb3VibGUgY29sb246XG4vLy5cbi8vLiAgICAgTWF0aC5QSSA6OiBOdW1iZXJcbi8vLlxuLy8uIFRoZSBhcnJvdyAoYC0+YCkgaXMgdXNlZCB0byBleHByZXNzIGEgZnVuY3Rpb24ncyB0eXBlOlxuLy8uXG4vLy4gICAgIE1hdGguYWJzIDo6IE51bWJlciAtPiBOdW1iZXJcbi8vLlxuLy8uIFRoYXQgc3RhdGVzIHRoYXQgYE1hdGguYWJzYCBpcyBhIHVuYXJ5IGZ1bmN0aW9uIHdoaWNoIHRha2VzIGFuIGFyZ3VtZW50XG4vLy4gb2YgdHlwZSBgTnVtYmVyYCBhbmQgcmV0dXJucyBhIHZhbHVlIG9mIHR5cGUgYE51bWJlcmAuXG4vLy5cbi8vLiBTb21lIGZ1bmN0aW9ucyBhcmUgcGFyYW1ldHJpY2FsbHkgcG9seW1vcnBoaWM6IHRoZWlyIHR5cGVzIGFyZSBub3QgZml4ZWQuXG4vLy4gVHlwZSB2YXJpYWJsZXMgYXJlIHVzZWQgaW4gdGhlIHJlcHJlc2VudGF0aW9ucyBvZiBzdWNoIGZ1bmN0aW9uczpcbi8vLlxuLy8uICAgICBTLkkgOjogYSAtPiBhXG4vLy5cbi8vLiBgYWAgaXMgYSB0eXBlIHZhcmlhYmxlLiBUeXBlIHZhcmlhYmxlcyBhcmUgbm90IGNhcGl0YWxpemVkLCBzbyB0aGV5XG4vLy4gYXJlIGRpZmZlcmVudGlhYmxlIGZyb20gdHlwZSBpZGVudGlmaWVycyAod2hpY2ggYXJlIGFsd2F5cyBjYXBpdGFsaXplZCkuXG4vLy4gQnkgY29udmVudGlvbiB0eXBlIHZhcmlhYmxlcyBoYXZlIHNpbmdsZS1jaGFyYWN0ZXIgbmFtZXMuIFRoZSBzaWduYXR1cmVcbi8vLiBhYm92ZSBzdGF0ZXMgdGhhdCBgUy5JYCB0YWtlcyBhIHZhbHVlIG9mIGFueSB0eXBlIGFuZCByZXR1cm5zIGEgdmFsdWUgb2Zcbi8vLiB0aGUgc2FtZSB0eXBlLiBTb21lIHNpZ25hdHVyZXMgZmVhdHVyZSBtdWx0aXBsZSB0eXBlIHZhcmlhYmxlczpcbi8vLlxuLy8uICAgICBTLksgOjogYSAtPiBiIC0+IGFcbi8vLlxuLy8uIEl0IG11c3QgYmUgcG9zc2libGUgdG8gcmVwbGFjZSBhbGwgb2NjdXJyZW5jZXMgb2YgYGFgIHdpdGggYSBjb25jcmV0ZSB0eXBlLlxuLy8uIFRoZSBzYW1lIGFwcGxpZXMgZm9yIGVhY2ggb3RoZXIgdHlwZSB2YXJpYWJsZS4gRm9yIHRoZSBmdW5jdGlvbiBhYm92ZSwgdGhlXG4vLy4gdHlwZXMgd2l0aCB3aGljaCBgYWAgYW5kIGBiYCBhcmUgcmVwbGFjZWQgbWF5IGJlIGRpZmZlcmVudCwgYnV0IG5lZWRuJ3QgYmUuXG4vLy5cbi8vLiBTaW5jZSBhbGwgU2FuY3R1YXJ5IGZ1bmN0aW9ucyBhcmUgY3VycmllZCAodGhleSBhY2NlcHQgdGhlaXIgYXJndW1lbnRzXG4vLy4gb25lIGF0IGEgdGltZSksIGEgYmluYXJ5IGZ1bmN0aW9uIGlzIHJlcHJlc2VudGVkIGFzIGEgdW5hcnkgZnVuY3Rpb24gd2hpY2hcbi8vLiByZXR1cm5zIGEgdW5hcnkgZnVuY3Rpb246IGAqIC0+ICogLT4gKmAuIFRoaXMgYWxpZ25zIG5lYXRseSB3aXRoIEhhc2tlbGwsXG4vLy4gd2hpY2ggdXNlcyBjdXJyaWVkIGZ1bmN0aW9ucyBleGNsdXNpdmVseS4gSW4gSmF2YVNjcmlwdCwgdGhvdWdoLCB3ZSBtYXlcbi8vLiB3aXNoIHRvIHJlcHJlc2VudCB0aGUgdHlwZXMgb2YgZnVuY3Rpb25zIHdpdGggYXJpdGllcyBsZXNzIHRoYW4gb3IgZ3JlYXRlclxuLy8uIHRoYW4gb25lLiBUaGUgZ2VuZXJhbCBmb3JtIGlzIGAoPGlucHV0LXR5cGVzPikgLT4gPG91dHB1dC10eXBlPmAsIHdoZXJlXG4vLy4gYDxpbnB1dC10eXBlcz5gIGNvbXByaXNlcyB6ZXJvIG9yIG1vcmUgY29tbWHigJNzcGFjZSAoPGNvZGU+LCA8L2NvZGU+KVxuLy8uIC1zZXBhcmF0ZWQgdHlwZSByZXByZXNlbnRhdGlvbnM6XG4vLy5cbi8vLiAgIC0gYCgpIC0+IFN0cmluZ2Bcbi8vLiAgIC0gYChhLCBiKSAtPiBhYFxuLy8uICAgLSBgKGEsIGIsIGMpIC0+IGRgXG4vLy5cbi8vLiBgTnVtYmVyIC0+IE51bWJlcmAgY2FuIHRodXMgYmUgc2VlbiBhcyBzaG9ydGhhbmQgZm9yIGAoTnVtYmVyKSAtPiBOdW1iZXJgLlxuLy8uXG4vLy4gVGhlIHF1ZXN0aW9uIG1hcmsgKGA/YCkgaXMgdXNlZCB0byByZXByZXNlbnQgdHlwZXMgd2hpY2ggaW5jbHVkZSBgbnVsbGBcbi8vLiBhbmQgYHVuZGVmaW5lZGAgYXMgbWVtYmVycy4gYFN0cmluZz9gLCBmb3IgZXhhbXBsZSwgcmVwcmVzZW50cyB0aGUgdHlwZVxuLy8uIGNvbXByaXNpbmcgYG51bGxgLCBgdW5kZWZpbmVkYCwgYW5kIGFsbCBzdHJpbmdzLlxuLy8uXG4vLy4gU2FuY3R1YXJ5IGVtYnJhY2VzIHR5cGVzLiBKYXZhU2NyaXB0IGRvZXNuJ3Qgc3VwcG9ydCBhbGdlYnJhaWMgZGF0YSB0eXBlcyxcbi8vLiBidXQgdGhlc2UgY2FuIGJlIHNpbXVsYXRlZCBieSBwcm92aWRpbmcgYSBncm91cCBvZiBkYXRhIGNvbnN0cnVjdG9ycyB3aGljaFxuLy8uIHJldHVybiB2YWx1ZXMgd2l0aCB0aGUgc2FtZSBzZXQgb2YgbWV0aG9kcy4gQSB2YWx1ZSBvZiB0aGUgRWl0aGVyIHR5cGUsIGZvclxuLy8uIGV4YW1wbGUsIGlzIGNyZWF0ZWQgdmlhIHRoZSBMZWZ0IGNvbnN0cnVjdG9yIG9yIHRoZSBSaWdodCBjb25zdHJ1Y3Rvci5cbi8vLlxuLy8uIEl0J3MgbmVjZXNzYXJ5IHRvIGV4dGVuZCBIYXNrZWxsJ3Mgbm90YXRpb24gdG8gZGVzY3JpYmUgaW1wbGljaXQgYXJndW1lbnRzXG4vLy4gdG8gdGhlICptZXRob2RzKiBwcm92aWRlZCBieSBTYW5jdHVhcnkncyB0eXBlcy4gSW4gYHgubWFwKHkpYCwgZm9yIGV4YW1wbGUsXG4vLy4gdGhlIGBtYXBgIG1ldGhvZCB0YWtlcyBhbiBpbXBsaWNpdCBhcmd1bWVudCBgeGAgaW4gYWRkaXRpb24gdG8gdGhlIGV4cGxpY2l0XG4vLy4gYXJndW1lbnQgYHlgLiBUaGUgdHlwZSBvZiB0aGUgdmFsdWUgdXBvbiB3aGljaCBhIG1ldGhvZCBpcyBpbnZva2VkIGFwcGVhcnNcbi8vLiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzaWduYXR1cmUsIHNlcGFyYXRlZCBmcm9tIHRoZSBhcmd1bWVudHMgYW5kIHJldHVyblxuLy8uIHZhbHVlIGJ5IGEgc3F1aWdnbHkgYXJyb3cgKGB+PmApLiBUaGUgdHlwZSBvZiB0aGUgYGZhbnRhc3ktbGFuZC9tYXBgIG1ldGhvZFxuLy8uIG9mIHRoZSBNYXliZSB0eXBlIGlzIHdyaXR0ZW4gYE1heWJlIGEgfj4gKGEgLT4gYikgLT4gTWF5YmUgYmAuIE9uZSBjb3VsZFxuLy8uIHJlYWQgdGhpcyBhczpcbi8vLlxuLy8uIF9XaGVuIHRoZSBgZmFudGFzeS1sYW5kL21hcGAgbWV0aG9kIGlzIGludm9rZWQgb24gYSB2YWx1ZSBvZiB0eXBlIGBNYXliZSBhYFxuLy8uIChmb3IgYW55IHR5cGUgYGFgKSB3aXRoIGFuIGFyZ3VtZW50IG9mIHR5cGUgYGEgLT4gYmAgKGZvciBhbnkgdHlwZSBgYmApLFxuLy8uIGl0IHJldHVybnMgYSB2YWx1ZSBvZiB0eXBlIGBNYXliZSBiYC5fXG4vLy5cbi8vLiBUaGUgc3F1aWdnbHkgYXJyb3cgaXMgYWxzbyB1c2VkIHdoZW4gcmVwcmVzZW50aW5nIG5vbi1mdW5jdGlvbiBwcm9wZXJ0aWVzLlxuLy8uIGBNYXliZSBhIH4+IEJvb2xlYW5gLCBmb3IgZXhhbXBsZSwgcmVwcmVzZW50cyBhIEJvb2xlYW4gcHJvcGVydHkgb2YgYSB2YWx1ZVxuLy8uIG9mIHR5cGUgYE1heWJlIGFgLlxuLy8uXG4vLy4gU2FuY3R1YXJ5IHN1cHBvcnRzIHR5cGUgY2xhc3NlczogY29uc3RyYWludHMgb24gdHlwZSB2YXJpYWJsZXMuIFdoZXJlYXNcbi8vLiBgYSAtPiBhYCBpbXBsaWNpdGx5IHN1cHBvcnRzIGV2ZXJ5IHR5cGUsIGBGdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gZiBhIC0+XG4vLy4gZiBiYCByZXF1aXJlcyB0aGF0IGBmYCBiZSBhIHR5cGUgd2hpY2ggc2F0aXNmaWVzIHRoZSByZXF1aXJlbWVudHMgb2YgdGhlXG4vLy4gRnVuY3RvciB0eXBlIGNsYXNzLiBUeXBlLWNsYXNzIGNvbnN0cmFpbnRzIGFwcGVhciBhdCB0aGUgYmVnaW5uaW5nIG9mIGFcbi8vLiB0eXBlIHNpZ25hdHVyZSwgc2VwYXJhdGVkIGZyb20gdGhlIHJlc3Qgb2YgdGhlIHNpZ25hdHVyZSBieSBhIGZhdCBhcnJvd1xuLy8uIChgPT5gKS5cbi8vLlxuLy8uICMjIFR5cGUgY2hlY2tpbmdcbi8vLlxuLy8uIFNhbmN0dWFyeSBmdW5jdGlvbnMgYXJlIGRlZmluZWQgdmlhIFtzYW5jdHVhcnktZGVmXVtdIHRvIHByb3ZpZGUgcnVuLXRpbWVcbi8vLiB0eXBlIGNoZWNraW5nLiBUaGlzIGlzIHRyZW1lbmRvdXNseSB1c2VmdWwgZHVyaW5nIGRldmVsb3BtZW50OiB0eXBlIGVycm9yc1xuLy8uIGFyZSByZXBvcnRlZCBpbW1lZGlhdGVseSwgYXZvaWRpbmcgY2lyY3VpdG91cyBzdGFjayB0cmFjZXMgKGF0IGJlc3QpIGFuZFxuLy8uIHNpbGVudCBmYWlsdXJlcyBkdWUgdG8gdHlwZSBjb2VyY2lvbiAoYXQgd29yc3QpLiBGb3IgZXhhbXBsZTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBTLmFkZCAoMikgKHRydWUpO1xuLy8uIC8vICEgVHlwZUVycm9yOiBJbnZhbGlkIHZhbHVlXG4vLy4gLy9cbi8vLiAvLyAgIGFkZCA6OiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlclxuLy8uIC8vICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eXl5cbi8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4vLy4gLy9cbi8vLiAvLyAgIDEpICB0cnVlIDo6IEJvb2xlYW5cbi8vLiAvL1xuLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmEZpbml0ZU51bWJlcuKAmS5cbi8vLiAvL1xuLy8uIC8vICAgU2VlIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYjRmluaXRlTnVtYmVyIGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgc2FuY3R1YXJ5LWRlZi9GaW5pdGVOdW1iZXIgdHlwZS5cbi8vLiBgYGBcbi8vLlxuLy8uIENvbXBhcmUgdGhpcyB0byB0aGUgYmVoYXZpb3VyIG9mIFJhbWRhJ3MgdW5jaGVja2VkIGVxdWl2YWxlbnQ6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gUi5hZGQgKDIpICh0cnVlKTtcbi8vLiAvLyA9PiAzXG4vLy4gYGBgXG4vLy5cbi8vLiBUaGVyZSBpcyBhIHBlcmZvcm1hbmNlIGNvc3QgdG8gcnVuLXRpbWUgdHlwZSBjaGVja2luZy4gVHlwZSBjaGVja2luZyBpc1xuLy8uIGRpc2FibGVkIGJ5IGRlZmF1bHQgaWYgYHByb2Nlc3MuZW52Lk5PREVfRU5WYCBpcyBgJ3Byb2R1Y3Rpb24nYC4gSWYgdGhpc1xuLy8uIHJ1bGUgaXMgdW5zdWl0YWJsZSBmb3IgYSBnaXZlbiBwcm9ncmFtLCBvbmUgbWF5IHVzZSBbYGNyZWF0ZWBdKCNjcmVhdGUpXG4vLy4gdG8gY3JlYXRlIGEgU2FuY3R1YXJ5IG1vZHVsZSBiYXNlZCBvbiBhIGRpZmZlcmVudCBydWxlLiBGb3IgZXhhbXBsZTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBjb25zdCBTID0gc2FuY3R1YXJ5LmNyZWF0ZSAoe1xuLy8uICAgY2hlY2tUeXBlczogbG9jYWxTdG9yYWdlLmdldEl0ZW0gKCdTQU5DVFVBUllfQ0hFQ0tfVFlQRVMnKSA9PT0gJ3RydWUnLFxuLy8uICAgZW52OiBzYW5jdHVhcnkuZW52LFxuLy8uIH0pO1xuLy8uIGBgYFxuLy8uXG4vLy4gT2NjYXNpb25hbGx5IG9uZSBtYXkgd2lzaCB0byBwZXJmb3JtIGFuIG9wZXJhdGlvbiB3aGljaCBpcyBub3QgdHlwZSBzYWZlLFxuLy8uIHN1Y2ggYXMgbWFwcGluZyBvdmVyIGFuIG9iamVjdCB3aXRoIGhldGVyb2dlbmVvdXMgdmFsdWVzLiBUaGlzIGlzIHBvc3NpYmxlXG4vLy4gdmlhIHNlbGVjdGl2ZSB1c2Ugb2YgW2B1bmNoZWNrZWRgXSgjdW5jaGVja2VkKSBmdW5jdGlvbnMuXG4vLy5cbi8vLiAjIyBJbnN0YWxsYXRpb25cbi8vLlxuLy8uIGBucG0gaW5zdGFsbCBzYW5jdHVhcnlgIHdpbGwgaW5zdGFsbCBTYW5jdHVhcnkgZm9yIHVzZSBpbiBOb2RlLmpzLlxuLy8uXG4vLy4gUnVubmluZyBTYW5jdHVhcnkgaW4gdGhlIGJyb3dzZXIgaXMgbW9yZSBpbnZvbHZlZC4gT25lIG11c3QgaW5jbHVkZSBhXG4vLy4gYDxzY3JpcHQ+YCBmb3IgZWFjaCBkZXBlbmRlbmN5IGluIGFkZGl0aW9uIHRvIG9uZSBmb3IgU2FuY3R1YXJ5IGl0c2VsZjpcbi8vLlxuLy8uIGBgYGh0bWxcbi8vLiA8c2NyaXB0IHNyYz1cInZlbmRvci9zYW5jdHVhcnktc2hvdy5qc1wiPjwvc2NyaXB0PlxuLy8uIDxzY3JpcHQgc3JjPVwidmVuZG9yL3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzLmpzXCI+PC9zY3JpcHQ+XG4vLy4gPHNjcmlwdCBzcmM9XCJ2ZW5kb3Ivc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy5qc1wiPjwvc2NyaXB0PlxuLy8uIDxzY3JpcHQgc3JjPVwidmVuZG9yL3NhbmN0dWFyeS1laXRoZXIuanNcIj48L3NjcmlwdD5cbi8vLiA8c2NyaXB0IHNyYz1cInZlbmRvci9zYW5jdHVhcnktbWF5YmUuanNcIj48L3NjcmlwdD5cbi8vLiA8c2NyaXB0IHNyYz1cInZlbmRvci9zYW5jdHVhcnktcGFpci5qc1wiPjwvc2NyaXB0PlxuLy8uIDxzY3JpcHQgc3JjPVwidmVuZG9yL3NhbmN0dWFyeS1kZWYuanNcIj48L3NjcmlwdD5cbi8vLiA8c2NyaXB0IHNyYz1cInZlbmRvci9zYW5jdHVhcnkuanNcIj48L3NjcmlwdD5cbi8vLiBgYGBcbi8vLlxuLy8uIFRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IG9uZSBzaG91bGQgdXNlIHRoZSBkZXBlbmRlbmN5IHZlcnNpb25zIHNwZWNpZmllZFxuLy8uIGluIF9fcGFja2FnZS5qc29uX18uXG4vLy5cbi8vLiBGb3IgY29udmVuaWVuY2Ugb25lIGNvdWxkIGRlZmluZSBhbGlhc2VzIGZvciB2YXJpb3VzIG1vZHVsZXM6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gY29uc3QgUyA9IHdpbmRvdy5zYW5jdHVhcnk7XG4vLy4gY29uc3QgJCA9IHdpbmRvdy5zYW5jdHVhcnlEZWY7XG4vLy4gLy8gLi4uXG4vLy4gYGBgXG4vLy5cbi8vLiAjIyBBUElcblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYgKHJlcXVpcmUgKCdzYW5jdHVhcnktZGVmJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LWVpdGhlcicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJ3NhbmN0dWFyeS1tYXliZScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJ3NhbmN0dWFyeS1wYWlyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LXNob3cnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUgKFsnc2FuY3R1YXJ5LWRlZicsXG4gICAgICAgICAgICAgJ3NhbmN0dWFyeS1laXRoZXInLFxuICAgICAgICAgICAgICdzYW5jdHVhcnktbWF5YmUnLFxuICAgICAgICAgICAgICdzYW5jdHVhcnktcGFpcicsXG4gICAgICAgICAgICAgJ3NhbmN0dWFyeS1zaG93JyxcbiAgICAgICAgICAgICAnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycsXG4gICAgICAgICAgICAgJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJ10sXG4gICAgICAgICAgICBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeSA9IGYgKHNlbGYuc2FuY3R1YXJ5RGVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYW5jdHVhcnlFaXRoZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNhbmN0dWFyeU1heWJlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYW5jdHVhcnlQYWlyLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYW5jdHVhcnlTaG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYW5jdHVhcnlUeXBlQ2xhc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2FuY3R1YXJ5VHlwZUlkZW50aWZpZXJzKTtcbiAgfVxuXG59IChmdW5jdGlvbigkLCBFaXRoZXIsIE1heWJlLCBQYWlyLCBzaG93LCBaLCB0eXBlKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIF9fZG9jdGVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICAgIHZhciBEZXNjZW5kaW5nID0gX19kb2N0ZXN0LnJlcXVpcmUgKCdzYW5jdHVhcnktZGVzY2VuZGluZycpO1xuICAgIHZhciBOaWwgPSAoX19kb2N0ZXN0LnJlcXVpcmUgKCcuL3Rlc3QvaW50ZXJuYWwvTGlzdCcpKS5OaWw7XG4gICAgdmFyIENvbnMgPSAoX19kb2N0ZXN0LnJlcXVpcmUgKCcuL3Rlc3QvaW50ZXJuYWwvTGlzdCcpKS5Db25zO1xuICAgIHZhciBTdW0gPSBfX2RvY3Rlc3QucmVxdWlyZSAoJy4vdGVzdC9pbnRlcm5hbC9TdW0nKTtcbiAgICB2YXIgUyA9IChmdW5jdGlvbihTKSB7XG4gICAgICAvLyAgRGVzY2VuZGluZ1R5cGUgOjogVHlwZSAtPiBUeXBlXG4gICAgICB2YXIgRGVzY2VuZGluZ1R5cGUgPSAkLlVuYXJ5VHlwZVxuICAgICAgICAoJ3NhbmN0dWFyeS9EZXNjZW5kaW5nJylcbiAgICAgICAgKCcnKVxuICAgICAgICAodHlwZUVxIChEZXNjZW5kaW5nWydAQHR5cGUnXSkpXG4gICAgICAgIChCIChvZiAoQXJyYXkpKSAoWi5leHRyYWN0KSk7XG5cbiAgICAgIHZhciBTXyA9IFMuY3JlYXRlICh7XG4gICAgICAgIGNoZWNrVHlwZXM6IHRydWUsXG4gICAgICAgIGVudjogUy5lbnYuY29uY2F0IChbXG4gICAgICAgICAgRGVzY2VuZGluZ1R5cGUgKCQuVW5rbm93biksXG4gICAgICAgICAgKF9fZG9jdGVzdC5yZXF1aXJlICgnLi90ZXN0L2ludGVybmFsL0xpc3QnKSkuVHlwZSAoJC5Vbmtub3duKSxcbiAgICAgICAgICBTdW0uVHlwZVxuICAgICAgICBdKVxuICAgICAgfSk7XG4gICAgICBTXy5lbnYgPSBTLmVudjsgIC8vIHNlZSBTLmVudiBkb2N0ZXN0XG4gICAgICByZXR1cm4gU187XG4gICAgfSAocmVxdWlyZSAoJy4nKSkpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgfVxuXG4gIC8vICBMZWZ0IDo6IGEgLT4gRWl0aGVyIGEgYlxuICB2YXIgTGVmdCA9IEVpdGhlci5MZWZ0O1xuXG4gIC8vICBSaWdodCA6OiBiIC0+IEVpdGhlciBhIGJcbiAgdmFyIFJpZ2h0ID0gRWl0aGVyLlJpZ2h0O1xuXG4gIC8vICBOb3RoaW5nIDo6IE1heWJlIGFcbiAgdmFyIE5vdGhpbmcgPSBNYXliZS5Ob3RoaW5nO1xuXG4gIC8vICBKdXN0IDo6IGEgLT4gTWF5YmUgYVxuICB2YXIgSnVzdCA9IE1heWJlLkp1c3Q7XG5cbiAgLy8gIEIgOjogKGIgLT4gYykgLT4gKGEgLT4gYikgLT4gYSAtPiBjXG4gIGZ1bmN0aW9uIEIoZikge1xuICAgIHJldHVybiBmdW5jdGlvbihnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gZiAoZyAoeCkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIEMgOjogKGEgLT4gYiAtPiBjKSAtPiBiIC0+IGEgLT4gY1xuICBmdW5jdGlvbiBDKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIGYgKHgpICh5KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIC8vICBGbiA6OiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICBmdW5jdGlvbiBGbih4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiAkLkZ1bmN0aW9uIChbeCwgeV0pO1xuICAgIH07XG4gIH1cblxuICAvLyAgZ2V0XyA6OiBTdHJpbmcgLT4gYSAtPiBNYXliZSBiXG4gIGZ1bmN0aW9uIGdldF8oa2V5KSB7XG4gICAgcmV0dXJuIEIgKGZ1bmN0aW9uKG9iaikgeyByZXR1cm4ga2V5IGluIG9iaiA/IEp1c3QgKG9ialtrZXldKSA6IE5vdGhpbmc7IH0pXG4gICAgICAgICAgICAgKHRvT2JqZWN0KTtcbiAgfVxuXG4gIC8vICBpbnZva2UwIDo6IFN0cmluZyAtPiBhIC0+IGJcbiAgZnVuY3Rpb24gaW52b2tlMChuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRhcmdldCkge1xuICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXSAoKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIGludm9rZTEgOjogU3RyaW5nIC0+IGEgLT4gYiAtPiBjXG4gIGZ1bmN0aW9uIGludm9rZTEobmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRbbmFtZV0gKHgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHRvT2JqZWN0IDo6IGEgLT4gT2JqZWN0XG4gIGZ1bmN0aW9uIHRvT2JqZWN0KHgpIHtcbiAgICByZXR1cm4geCA9PSBudWxsID8gT2JqZWN0LmNyZWF0ZSAobnVsbCkgOiBPYmplY3QgKHgpO1xuICB9XG5cbiAgLy8gIHR5cGVFcSA6OiBTdHJpbmcgLT4gYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIHR5cGVFcSh0eXBlSWRlbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGUgKHgpID09PSB0eXBlSWRlbnQ7XG4gICAgfTtcbiAgfVxuXG4gIC8vICB2YWx1ZSA6OiB7IHZhbHVlIDo6IGEgfSAtPiBhXG4gIGZ1bmN0aW9uIHZhbHVlKHIpIHtcbiAgICByZXR1cm4gci52YWx1ZTtcbiAgfVxuXG4gIC8vICA6OiBUeXBlXG4gIHZhciBhID0gJC5UeXBlVmFyaWFibGUgKCdhJyk7XG4gIHZhciBiID0gJC5UeXBlVmFyaWFibGUgKCdiJyk7XG4gIHZhciBjID0gJC5UeXBlVmFyaWFibGUgKCdjJyk7XG4gIHZhciBkID0gJC5UeXBlVmFyaWFibGUgKCdkJyk7XG4gIHZhciBlID0gJC5UeXBlVmFyaWFibGUgKCdlJyk7XG4gIHZhciBnID0gJC5UeXBlVmFyaWFibGUgKCdnJyk7XG4gIHZhciBsID0gJC5UeXBlVmFyaWFibGUgKCdsJyk7XG4gIHZhciByID0gJC5UeXBlVmFyaWFibGUgKCdyJyk7XG5cbiAgLy8gIDo6IFR5cGUgLT4gVHlwZVxuICB2YXIgZiA9ICQuVW5hcnlUeXBlVmFyaWFibGUgKCdmJyk7XG4gIHZhciBtID0gJC5VbmFyeVR5cGVWYXJpYWJsZSAoJ20nKTtcbiAgdmFyIHQgPSAkLlVuYXJ5VHlwZVZhcmlhYmxlICgndCcpO1xuICB2YXIgdyA9ICQuVW5hcnlUeXBlVmFyaWFibGUgKCd3Jyk7XG5cbiAgLy8gIDo6IFR5cGUgLT4gVHlwZSAtPiBUeXBlXG4gIHZhciBwID0gJC5CaW5hcnlUeXBlVmFyaWFibGUgKCdwJyk7XG4gIHZhciBzID0gJC5CaW5hcnlUeXBlVmFyaWFibGUgKCdzJyk7XG5cbiAgLy8gICRFaXRoZXIgOjogVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgdmFyICRFaXRoZXIgPSAkLkJpbmFyeVR5cGVcbiAgICAoJ3NhbmN0dWFyeS9FaXRoZXInKVxuICAgICgnaHR0cHM6Ly9naXRodWIuY29tL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnktZWl0aGVyJylcbiAgICAodHlwZUVxICgnc2FuY3R1YXJ5LWVpdGhlci9FaXRoZXJAMScpKVxuICAgIChlaXRoZXIgKG9mIChBcnJheSkpIChLIChbXSkpKVxuICAgIChlaXRoZXIgKEsgKFtdKSkgKG9mIChBcnJheSkpKTtcblxuICAvLyAgJE1heWJlIDo6IFR5cGUgLT4gVHlwZVxuICB2YXIgJE1heWJlID0gJC5VbmFyeVR5cGVcbiAgICAoJ3NhbmN0dWFyeS9NYXliZScpXG4gICAgKCdodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1tYXliZScpXG4gICAgKHR5cGVFcSAoJ3NhbmN0dWFyeS1tYXliZS9NYXliZUAxJykpXG4gICAgKG1heWJlIChbXSkgKG9mIChBcnJheSkpKTtcblxuICAvLyAgJFBhaXIgOjogVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgdmFyICRQYWlyID0gJC5CaW5hcnlUeXBlXG4gICAgKCdzYW5jdHVhcnkvUGFpcicpXG4gICAgKCdodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1wYWlyJylcbiAgICAodHlwZUVxICgnc2FuY3R1YXJ5LXBhaXIvUGFpckAxJykpXG4gICAgKGZ1bmN0aW9uKHBhaXIpIHsgcmV0dXJuIFtwYWlyLmZzdF07IH0pXG4gICAgKGZ1bmN0aW9uKHBhaXIpIHsgcmV0dXJuIFtwYWlyLnNuZF07IH0pO1xuXG4gIC8vICBUeXBlUmVwIDo6IFR5cGUgLT4gVHlwZVxuICB2YXIgVHlwZVJlcCA9ICQuVW5hcnlUeXBlXG4gICAgKCdzYW5jdHVhcnkvVHlwZVJlcCcpXG4gICAgKCdodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3R5cGUtcmVwcmVzZW50YXRpdmVzJylcbiAgICAoZnVuY3Rpb24oeCkge1xuICAgICAgIHJldHVybiAkLkFueUZ1bmN0aW9uLl90ZXN0ICh4KSB8fFxuICAgICAgICAgICAgICB4ICE9IG51bGwgJiYgJC5TdHJpbmcuX3Rlc3QgKHhbJ0BAdHlwZSddKTtcbiAgICAgfSlcbiAgICAoSyAoW10pKTtcblxuICAvLyAgT3B0aW9ucyA6OiBUeXBlXG4gIHZhciBPcHRpb25zID0gJC5SZWNvcmRUeXBlICh7Y2hlY2tUeXBlczogJC5Cb29sZWFuLCBlbnY6ICQuQXJyYXkgKCQuQW55KX0pO1xuXG4gIHZhciBfID0ge307XG5cbiAgLy8uICMjIyBDb25maWd1cmVcblxuICAvLyMgY3JlYXRlIDo6IHsgY2hlY2tUeXBlcyA6OiBCb29sZWFuLCBlbnYgOjogQXJyYXkgVHlwZSB9IC0+IE1vZHVsZVxuICAvLy5cbiAgLy8uIFRha2VzIGFuIG9wdGlvbnMgcmVjb3JkIGFuZCByZXR1cm5zIGEgU2FuY3R1YXJ5IG1vZHVsZS4gYGNoZWNrVHlwZXNgXG4gIC8vLiBzcGVjaWZpZXMgd2hldGhlciB0byBlbmFibGUgdHlwZSBjaGVja2luZy4gVGhlIG1vZHVsZSdzIHBvbHltb3JwaGljXG4gIC8vLiBmdW5jdGlvbnMgKHN1Y2ggYXMgW2BJYF0oI0kpKSByZXF1aXJlIGVhY2ggdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGFcbiAgLy8uIHR5cGUgdmFyaWFibGUgdG8gYmUgYSBtZW1iZXIgb2YgYXQgbGVhc3Qgb25lIHR5cGUgaW4gdGhlIGVudmlyb25tZW50LlxuICAvLy5cbiAgLy8uIEEgd2VsbC10eXBlZCBhcHBsaWNhdGlvbiBvZiBhIFNhbmN0dWFyeSBmdW5jdGlvbiB3aWxsIHByb2R1Y2UgdGhlIHNhbWVcbiAgLy8uIHJlc3VsdCByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdHlwZSBjaGVja2luZyBpcyBlbmFibGVkLiBJZiB0eXBlIGNoZWNraW5nXG4gIC8vLiBpcyBlbmFibGVkLCBhIGJhZGx5IHR5cGVkIGFwcGxpY2F0aW9uIHdpbGwgcHJvZHVjZSBhbiBleGNlcHRpb24gd2l0aCBhXG4gIC8vLiBkZXNjcmlwdGl2ZSBlcnJvciBtZXNzYWdlLlxuICAvLy5cbiAgLy8uIFRoZSBmb2xsb3dpbmcgc25pcHBldCBkZW1vbnN0cmF0ZXMgZGVmaW5pbmcgYSBjdXN0b20gdHlwZSBhbmQgdXNpbmdcbiAgLy8uIGBjcmVhdGVgIHRvIHByb2R1Y2UgYSBTYW5jdHVhcnkgbW9kdWxlIHdoaWNoIGlzIGF3YXJlIG9mIHRoYXQgdHlwZTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiBjb25zdCB7Y3JlYXRlLCBlbnZ9ID0gcmVxdWlyZSAoJ3NhbmN0dWFyeScpO1xuICAvLy4gY29uc3QgJCA9IHJlcXVpcmUgKCdzYW5jdHVhcnktZGVmJyk7XG4gIC8vLiBjb25zdCB0eXBlID0gcmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJyk7XG4gIC8vLlxuICAvLy4gLy8gICAgSWRlbnRpdHkgOjogYSAtPiBJZGVudGl0eSBhXG4gIC8vLiBjb25zdCBJZGVudGl0eSA9IHggPT4ge1xuICAvLy4gICBjb25zdCBpZGVudGl0eSA9IE9iamVjdC5jcmVhdGUgKElkZW50aXR5JHByb3RvdHlwZSk7XG4gIC8vLiAgIGlkZW50aXR5LnZhbHVlID0geDtcbiAgLy8uICAgcmV0dXJuIGlkZW50aXR5O1xuICAvLy4gfTtcbiAgLy8uXG4gIC8vLiBJZGVudGl0eVsnQEB0eXBlJ10gPSAnbXktcGFja2FnZS9JZGVudGl0eUAxJztcbiAgLy8uXG4gIC8vLiBjb25zdCBJZGVudGl0eSRwcm90b3R5cGUgPSB7XG4gIC8vLiAgICdjb25zdHJ1Y3Rvcic6IElkZW50aXR5LFxuICAvLy4gICAnQEBzaG93JzogZnVuY3Rpb24oKSB7IHJldHVybiBgSWRlbnRpdHkgKCR7Uy5zaG93ICh0aGlzLnZhbHVlKX0pYDsgfSxcbiAgLy8uICAgJ2ZhbnRhc3ktbGFuZC9tYXAnOiBmdW5jdGlvbihmKSB7IHJldHVybiBJZGVudGl0eSAoZiAodGhpcy52YWx1ZSkpOyB9LFxuICAvLy4gfTtcbiAgLy8uXG4gIC8vLiAvLyAgICBJZGVudGl0eVR5cGUgOjogVHlwZSAtPiBUeXBlXG4gIC8vLiBjb25zdCBJZGVudGl0eVR5cGUgPSAkLlVuYXJ5VHlwZVxuICAvLy4gICAoSWRlbnRpdHlbJ0BAdHlwZSddKVxuICAvLy4gICAoJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI0lkZW50aXR5JylcbiAgLy8uICAgKHggPT4gdHlwZSAoeCkgPT09IElkZW50aXR5WydAQHR5cGUnXSlcbiAgLy8uICAgKGlkZW50aXR5ID0+IFtpZGVudGl0eS52YWx1ZV0pO1xuICAvLy5cbiAgLy8uIGNvbnN0IFMgPSBjcmVhdGUgKHtcbiAgLy8uICAgY2hlY2tUeXBlczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcbiAgLy8uICAgZW52OiBlbnYuY29uY2F0IChbSWRlbnRpdHlUeXBlICgkLlVua25vd24pXSksXG4gIC8vLiB9KTtcbiAgLy8uXG4gIC8vLiBTLm1hcCAoUy5zdWIgKDEpKSAoSWRlbnRpdHkgKDQzKSk7XG4gIC8vLiAvLyA9PiBJZGVudGl0eSAoNDIpXG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGVudmBdKCNlbnYpLlxuICBmdW5jdGlvbiBjcmVhdGUob3B0cykge1xuICAgIHZhciBkZWYgPSAkLmNyZWF0ZSAob3B0cyk7XG4gICAgdmFyIFMgPSB7XG4gICAgICBlbnY6IG9wdHMuZW52LFxuICAgICAgaXM6IGRlZiAoJ2lzJykgKHt9KSAoWyQuVHlwZSwgJC5BbnksICQuQm9vbGVhbl0pICgkLnRlc3QgKG9wdHMuZW52KSksXG4gICAgICBNYXliZVR5cGU6ICRNYXliZSxcbiAgICAgIE1heWJlOiBNYXliZSxcbiAgICAgIE5vdGhpbmc6IE5vdGhpbmcsXG4gICAgICBFaXRoZXJUeXBlOiAkRWl0aGVyLFxuICAgICAgRWl0aGVyOiBFaXRoZXIsXG4gICAgICBQYWlyVHlwZTogJFBhaXJcbiAgICB9O1xuICAgIChPYmplY3Qua2V5cyAoXykpLmZvckVhY2ggKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIFNbbmFtZV0gPSBkZWYgKG5hbWUpIChfW25hbWVdLmNvbnN0cykgKF9bbmFtZV0udHlwZXMpIChfW25hbWVdLmltcGwpO1xuICAgIH0pO1xuICAgIFMudW5jaGVja2VkID0gb3B0cy5jaGVja1R5cGVzID8gY3JlYXRlICh7Y2hlY2tUeXBlczogZmFsc2UsIGVudjogb3B0cy5lbnZ9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogUztcbiAgICByZXR1cm4gUztcbiAgfVxuICBfLmNyZWF0ZSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbT3B0aW9ucywgJC5PYmplY3RdLFxuICAgIGltcGw6IGNyZWF0ZVxuICB9O1xuXG4gIC8vIyBlbnYgOjogQXJyYXkgVHlwZVxuICAvLy5cbiAgLy8uIFRoZSBTYW5jdHVhcnkgbW9kdWxlJ3MgZW52aXJvbm1lbnQgKGAoUy5jcmVhdGUgKHtjaGVja1R5cGVzLCBlbnZ9KSkuZW52YFxuICAvLy4gaXMgYSByZWZlcmVuY2UgdG8gYGVudmApLiBVc2VmdWwgaW4gY29uanVuY3Rpb24gd2l0aCBbYGNyZWF0ZWBdKCNjcmVhdGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5lbnZcbiAgLy8uIFsgJC5BbnlGdW5jdGlvbixcbiAgLy8uIC4gJC5Bcmd1bWVudHMsXG4gIC8vLiAuICQuQXJyYXkgKCQuVW5rbm93biksXG4gIC8vLiAuICQuQm9vbGVhbixcbiAgLy8uIC4gJC5EYXRlLFxuICAvLy4gLiAkLkVycm9yLFxuICAvLy4gLiAkLkh0bWxFbGVtZW50LFxuICAvLy4gLiAkLk51bGwsXG4gIC8vLiAuICQuTnVtYmVyLFxuICAvLy4gLiAkLk9iamVjdCxcbiAgLy8uIC4gJC5SZWdFeHAsXG4gIC8vLiAuICQuU3RyTWFwICgkLlVua25vd24pLFxuICAvLy4gLiAkLlN0cmluZyxcbiAgLy8uIC4gJC5TeW1ib2wsXG4gIC8vLiAuICQuVW5kZWZpbmVkLFxuICAvLy4gLiAkLkZpbml0ZU51bWJlcixcbiAgLy8uIC4gJC5Ob25aZXJvRmluaXRlTnVtYmVyLFxuICAvLy4gLiBTLkVpdGhlclR5cGUgKCQuVW5rbm93bikgKCQuVW5rbm93biksXG4gIC8vLiAuICQuRnVuY3Rpb24gKFskLlVua25vd24sICQuVW5rbm93bl0pLFxuICAvLy4gLiAkLkdsb2JhbFJlZ0V4cCxcbiAgLy8uIC4gJC5Ob25HbG9iYWxSZWdFeHAsXG4gIC8vLiAuICQuSW50ZWdlcixcbiAgLy8uIC4gJC5Ob25OZWdhdGl2ZUludGVnZXIsXG4gIC8vLiAuIFMuTWF5YmVUeXBlICgkLlVua25vd24pLFxuICAvLy4gLiAkLkFycmF5MiAoJC5Vbmtub3duKSAoJC5Vbmtub3duKSxcbiAgLy8uIC4gUy5QYWlyVHlwZSAoJC5Vbmtub3duKSAoJC5Vbmtub3duKSxcbiAgLy8uIC4gJC5SZWdleEZsYWdzLFxuICAvLy4gLiAkLlR5cGUsXG4gIC8vLiAuICQuVHlwZUNsYXNzLFxuICAvLy4gLiAkLlZhbGlkRGF0ZSxcbiAgLy8uIC4gJC5WYWxpZE51bWJlciBdXG4gIC8vLiBgYGBcblxuICAvLyMgdW5jaGVja2VkIDo6IE1vZHVsZVxuICAvLy5cbiAgLy8uIEEgY29tcGxldGUgU2FuY3R1YXJ5IG1vZHVsZSB3aGljaCBwZXJmb3JtcyBubyB0eXBlIGNoZWNraW5nLiBUaGlzIGlzXG4gIC8vLiB1c2VmdWwgYXMgaXQgcGVybWl0cyBvcGVyYXRpb25zIHdoaWNoIFNhbmN0dWFyeSdzIHR5cGUgY2hlY2tpbmcgd291bGRcbiAgLy8uIGRpc2FsbG93LCBzdWNoIGFzIG1hcHBpbmcgb3ZlciBhbiBvYmplY3Qgd2l0aCBoZXRlcm9nZW5lb3VzIHZhbHVlcy5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGNyZWF0ZWBdKCNjcmVhdGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy51bmNoZWNrZWQubWFwIChTLnNob3cpICh7eDogJ2ZvbycsIHk6IHRydWUsIHo6IDQyfSlcbiAgLy8uIHt4OiAnXCJmb29cIicsIHk6ICd0cnVlJywgejogJzQyJ31cbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIE9wdGluZyBvdXQgb2YgdHlwZSBjaGVja2luZyBtYXkgY2F1c2UgdHlwZSBlcnJvcnMgdG8gZ28gdW5ub3RpY2VkLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy51bmNoZWNrZWQuYWRkICgyKSAoJzInKVxuICAvLy4gJzIyJ1xuICAvLy4gYGBgXG5cbiAgLy8uICMjIyBDbGFzc2lmeVxuXG4gIC8vIyB0eXBlIDo6IEFueSAtPiB7IG5hbWVzcGFjZSA6OiBNYXliZSBTdHJpbmcsIG5hbWUgOjogU3RyaW5nLCB2ZXJzaW9uIDo6IE5vbk5lZ2F0aXZlSW50ZWdlciB9XG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIFt0eXBlIGlkZW50aWZpZXJdW10gb2YgdGhlIGdpdmVuIHZhbHVlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50eXBlIChTLkp1c3QgKDQyKSlcbiAgLy8uIHtuYW1lc3BhY2U6IEp1c3QgKCdzYW5jdHVhcnktbWF5YmUnKSwgbmFtZTogJ01heWJlJywgdmVyc2lvbjogMX1cbiAgLy8uXG4gIC8vLiA+IFMudHlwZSAoWzEsIDIsIDNdKVxuICAvLy4ge25hbWVzcGFjZTogTm90aGluZywgbmFtZTogJ0FycmF5JywgdmVyc2lvbjogMH1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0eXBlXyh4KSB7XG4gICAgdmFyIHIgPSB0eXBlLnBhcnNlICh0eXBlICh4KSk7XG4gICAgci5uYW1lc3BhY2UgPSB0b01heWJlIChyLm5hbWVzcGFjZSk7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgXy50eXBlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkFueSxcbiAgICAgICAgICAgICQuUmVjb3JkVHlwZSAoe25hbWVzcGFjZTogJE1heWJlICgkLlN0cmluZyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAkLlN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246ICQuTm9uTmVnYXRpdmVJbnRlZ2VyfSldLFxuICAgIGltcGw6IHR5cGVfXG4gIH07XG5cbiAgLy8jIGlzIDo6IFR5cGUgLT4gQW55IC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG1lbWJlciBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gIC8vLiBTZWUgW2AkLnRlc3RgXVtdIGZvciBkZXRhaWxzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pcyAoJC5BcnJheSAoJC5JbnRlZ2VyKSkgKFsxLCAyLCAzXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuaXMgKCQuQXJyYXkgKCQuSW50ZWdlcikpIChbMSwgMiwgMy4xNF0pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG5cbiAgLy8uICMjIyBTaG93YWJsZVxuXG4gIC8vIyBzaG93IDo6IEFueSAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBBbGlhcyBvZiBbYHNob3dgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zaG93ICgtMClcbiAgLy8uICctMCdcbiAgLy8uXG4gIC8vLiA+IFMuc2hvdyAoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gJ1tcImZvb1wiLCBcImJhclwiLCBcImJhelwiXSdcbiAgLy8uXG4gIC8vLiA+IFMuc2hvdyAoe3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4gJ3tcInhcIjogMSwgXCJ5XCI6IDIsIFwielwiOiAzfSdcbiAgLy8uXG4gIC8vLiA+IFMuc2hvdyAoUy5MZWZ0IChTLlJpZ2h0IChTLkp1c3QgKFMuTm90aGluZykpKSlcbiAgLy8uICdMZWZ0IChSaWdodCAoSnVzdCAoTm90aGluZykpKSdcbiAgLy8uIGBgYFxuICBfLnNob3cgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuQW55LCAkLlN0cmluZ10sXG4gICAgaW1wbDogc2hvd1xuICB9O1xuXG4gIC8vLiAjIyMgRmFudGFzeSBMYW5kXG4gIC8vLlxuICAvLy4gU2FuY3R1YXJ5IGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgW0ZhbnRhc3kgTGFuZF1bXSBzcGVjaWZpY2F0aW9uLlxuXG4gIC8vIyBlcXVhbHMgOjogU2V0b2lkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmVxdWFsc2BdW10gd2hpY2ggcmVxdWlyZXMgdHdvIGFyZ3VtZW50cyBvZiB0aGVcbiAgLy8uIHNhbWUgdHlwZS5cbiAgLy8uXG4gIC8vLiBUbyBjb21wYXJlIHZhbHVlcyBvZiBkaWZmZXJlbnQgdHlwZXMgZmlyc3QgdXNlIFtgY3JlYXRlYF0oI2NyZWF0ZSkgdG9cbiAgLy8uIGNyZWF0ZSBhIFNhbmN0dWFyeSBtb2R1bGUgd2l0aCB0eXBlIGNoZWNraW5nIGRpc2FibGVkLCB0aGVuIHVzZSB0aGF0XG4gIC8vLiBtb2R1bGUncyBgZXF1YWxzYCBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZXF1YWxzICgwKSAoLTApXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmVxdWFscyAoTmFOKSAoTmFOKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMgKFMuSnVzdCAoWzEsIDIsIDNdKSkgKFMuSnVzdCAoWzEsIDIsIDNdKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuZXF1YWxzIChTLkp1c3QgKFsxLCAyLCAzXSkpIChTLkp1c3QgKFsxLCAyLCA0XSkpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIF8uZXF1YWxzID0ge1xuICAgIGNvbnN0czoge2E6IFtaLlNldG9pZF19LFxuICAgIHR5cGVzOiBbYSwgYSwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouZXF1YWxzKVxuICB9O1xuXG4gIC8vIyBsdCA6OiBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIFtpZmZdW10gdGhlICpzZWNvbmQqIGFyZ3VtZW50IGlzIGxlc3MgdGhhbiB0aGUgZmlyc3RcbiAgLy8uIGFjY29yZGluZyB0byBbYFoubHRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maWx0ZXIgKFMubHQgKDMpKSAoWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gWzEsIDJdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbHQoeSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gWi5sdCAoeCwgeSk7XG4gICAgfTtcbiAgfVxuICBfLmx0ID0ge1xuICAgIGNvbnN0czoge2E6IFtaLk9yZF19LFxuICAgIHR5cGVzOiBbYSwgYSwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBsdFxuICB9O1xuXG4gIC8vIyBsdGUgOjogT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSAqc2Vjb25kKiBhcmd1bWVudCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG9cbiAgLy8uIHRoZSBmaXJzdCBhY2NvcmRpbmcgdG8gW2BaLmx0ZWBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbHRlciAoUy5sdGUgKDMpKSAoWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbHRlKHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFoubHRlICh4LCB5KTtcbiAgICB9O1xuICB9XG4gIF8ubHRlID0ge1xuICAgIGNvbnN0czoge2E6IFtaLk9yZF19LFxuICAgIHR5cGVzOiBbYSwgYSwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBsdGVcbiAgfTtcblxuICAvLyMgZ3QgOjogT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSAqc2Vjb25kKiBhcmd1bWVudCBpcyBncmVhdGVyIHRoYW4gdGhlIGZpcnN0XG4gIC8vLiBhY2NvcmRpbmcgdG8gW2BaLmd0YF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZmlsdGVyIChTLmd0ICgzKSkgKFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIFs0LCA1XVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGd0KHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFouZ3QgKHgsIHkpO1xuICAgIH07XG4gIH1cbiAgXy5ndCA9IHtcbiAgICBjb25zdHM6IHthOiBbWi5PcmRdfSxcbiAgICB0eXBlczogW2EsIGEsICQuQm9vbGVhbl0sXG4gICAgaW1wbDogZ3RcbiAgfTtcblxuICAvLyMgZ3RlIDo6IE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgKnNlY29uZCogYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsXG4gIC8vLiB0byB0aGUgZmlyc3QgYWNjb3JkaW5nIHRvIFtgWi5ndGVgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maWx0ZXIgKFMuZ3RlICgzKSkgKFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIFszLCA0LCA1XVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGd0ZSh5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBaLmd0ZSAoeCwgeSk7XG4gICAgfTtcbiAgfVxuICBfLmd0ZSA9IHtcbiAgICBjb25zdHM6IHthOiBbWi5PcmRdfSxcbiAgICB0eXBlczogW2EsIGEsICQuQm9vbGVhbl0sXG4gICAgaW1wbDogZ3RlXG4gIH07XG5cbiAgLy8jIG1pbiA6OiBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHNtYWxsZXIgb2YgaXRzIHR3byBhcmd1bWVudHMgKGFjY29yZGluZyB0byBbYFoubHRlYF1bXSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BtYXhgXSgjbWF4KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWluICgxMCkgKDIpXG4gIC8vLiAyXG4gIC8vLlxuICAvLy4gPiBTLm1pbiAobmV3IERhdGUgKCcxOTk5LTEyLTMxJykpIChuZXcgRGF0ZSAoJzIwMDAtMDEtMDEnKSlcbiAgLy8uIG5ldyBEYXRlICgnMTk5OS0xMi0zMScpXG4gIC8vLlxuICAvLy4gPiBTLm1pbiAoJzEwJykgKCcyJylcbiAgLy8uICcxMCdcbiAgLy8uIGBgYFxuICBfLm1pbiA9IHtcbiAgICBjb25zdHM6IHthOiBbWi5PcmRdfSxcbiAgICB0eXBlczogW2EsIGEsIGFdLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5taW4pXG4gIH07XG5cbiAgLy8jIG1heCA6OiBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIGxhcmdlciBvZiBpdHMgdHdvIGFyZ3VtZW50cyAoYWNjb3JkaW5nIHRvIFtgWi5sdGVgXVtdKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1pbmBdKCNtaW4pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXggKDEwKSAoMilcbiAgLy8uIDEwXG4gIC8vLlxuICAvLy4gPiBTLm1heCAobmV3IERhdGUgKCcxOTk5LTEyLTMxJykpIChuZXcgRGF0ZSAoJzIwMDAtMDEtMDEnKSlcbiAgLy8uIG5ldyBEYXRlICgnMjAwMC0wMS0wMScpXG4gIC8vLlxuICAvLy4gPiBTLm1heCAoJzEwJykgKCcyJylcbiAgLy8uICcyJ1xuICAvLy4gYGBgXG4gIF8ubWF4ID0ge1xuICAgIGNvbnN0czoge2E6IFtaLk9yZF19LFxuICAgIHR5cGVzOiBbYSwgYSwgYV0sXG4gICAgaW1wbDogY3VycnkyIChaLm1heClcbiAgfTtcblxuICAvLyMgaWQgOjogQ2F0ZWdvcnkgYyA9PiBUeXBlUmVwIGMgLT4gY1xuICAvLy5cbiAgLy8uIFtUeXBlLXNhZmVdW3NhbmN0dWFyeS1kZWZdIHZlcnNpb24gb2YgW2BaLmlkYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaWQgKEZ1bmN0aW9uKSAoNDIpXG4gIC8vLiA0MlxuICAvLy4gYGBgXG4gIF8uaWQgPSB7XG4gICAgY29uc3RzOiB7YzogW1ouQ2F0ZWdvcnldfSxcbiAgICB0eXBlczogW1R5cGVSZXAgKGMpLCBjXSxcbiAgICBpbXBsOiBaLmlkXG4gIH07XG5cbiAgLy8jIGNvbmNhdCA6OiBTZW1pZ3JvdXAgYSA9PiBhIC0+IGEgLT4gYVxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouY29uY2F0YF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuY29uY2F0ICgnYWJjJykgKCdkZWYnKVxuICAvLy4gJ2FiY2RlZidcbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0IChbMSwgMiwgM10pIChbNCwgNSwgNl0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNSwgNl1cbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0ICh7eDogMSwgeTogMn0pICh7eTogMywgejogNH0pXG4gIC8vLiB7eDogMSwgeTogMywgejogNH1cbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0IChTLkp1c3QgKFsxLCAyLCAzXSkpIChTLkp1c3QgKFs0LCA1LCA2XSkpXG4gIC8vLiBKdXN0IChbMSwgMiwgMywgNCwgNSwgNl0pXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdCAoU3VtICgxOCkpIChTdW0gKDI0KSlcbiAgLy8uIFN1bSAoNDIpXG4gIC8vLiBgYGBcbiAgXy5jb25jYXQgPSB7XG4gICAgY29uc3RzOiB7YTogW1ouU2VtaWdyb3VwXX0sXG4gICAgdHlwZXM6IFthLCBhLCBhXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouY29uY2F0KVxuICB9O1xuXG4gIC8vIyBlbXB0eSA6OiBNb25vaWQgYSA9PiBUeXBlUmVwIGEgLT4gYVxuICAvLy5cbiAgLy8uIFtUeXBlLXNhZmVdW3NhbmN0dWFyeS1kZWZdIHZlcnNpb24gb2YgW2BaLmVtcHR5YF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZW1wdHkgKFN0cmluZylcbiAgLy8uICcnXG4gIC8vLlxuICAvLy4gPiBTLmVtcHR5IChBcnJheSlcbiAgLy8uIFtdXG4gIC8vLlxuICAvLy4gPiBTLmVtcHR5IChPYmplY3QpXG4gIC8vLiB7fVxuICAvLy5cbiAgLy8uID4gUy5lbXB0eSAoU3VtKVxuICAvLy4gU3VtICgwKVxuICAvLy4gYGBgXG4gIF8uZW1wdHkgPSB7XG4gICAgY29uc3RzOiB7YTogW1ouTW9ub2lkXX0sXG4gICAgdHlwZXM6IFtUeXBlUmVwIChhKSwgYV0sXG4gICAgaW1wbDogWi5lbXB0eVxuICB9O1xuXG4gIC8vIyBpbnZlcnQgOjogR3JvdXAgZyA9PiBnIC0+IGdcbiAgLy8uXG4gIC8vLiBbVHlwZS1zYWZlXVtzYW5jdHVhcnktZGVmXSB2ZXJzaW9uIG9mIFtgWi5pbnZlcnRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pbnZlcnQgKFN1bSAoNSkpXG4gIC8vLiBTdW0gKC01KVxuICAvLy4gYGBgXG4gIF8uaW52ZXJ0ID0ge1xuICAgIGNvbnN0czoge2c6IFtaLkdyb3VwXX0sXG4gICAgdHlwZXM6IFtnLCBnXSxcbiAgICBpbXBsOiBaLmludmVydFxuICB9O1xuXG4gIC8vIyBmaWx0ZXIgOjogRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmZpbHRlcmBdW10uIERpc2NhcmRzIGV2ZXJ5IGVsZW1lbnQgd2hpY2ggZG9lcyBub3RcbiAgLy8uIHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHJlamVjdGBdKCNyZWplY3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maWx0ZXIgKFMub2RkKSAoWzEsIDIsIDNdKVxuICAvLy4gWzEsIDNdXG4gIC8vLlxuICAvLy4gPiBTLmZpbHRlciAoUy5vZGQpICh7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiB7eDogMSwgejogM31cbiAgLy8uXG4gIC8vLiA+IFMuZmlsdGVyIChTLm9kZCkgKFMuTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZmlsdGVyIChTLm9kZCkgKFMuSnVzdCAoMCkpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmZpbHRlciAoUy5vZGQpIChTLkp1c3QgKDEpKVxuICAvLy4gSnVzdCAoMSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBmaWx0ZXIocHJlZCkge1xuICAgIHJldHVybiBmdW5jdGlvbihmaWx0ZXJhYmxlKSB7XG4gICAgICByZXR1cm4gWi5maWx0ZXIgKHByZWQsIGZpbHRlcmFibGUpO1xuICAgIH07XG4gIH1cbiAgXy5maWx0ZXIgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRmlsdGVyYWJsZV19LFxuICAgIHR5cGVzOiBbJC5QcmVkaWNhdGUgKGEpLCBmIChhKSwgZiAoYSldLFxuICAgIGltcGw6IGZpbHRlclxuICB9O1xuXG4gIC8vIyByZWplY3QgOjogRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLnJlamVjdGBdW10uIERpc2NhcmRzIGV2ZXJ5IGVsZW1lbnQgd2hpY2ggc2F0aXNmaWVzXG4gIC8vLiB0aGUgcHJlZGljYXRlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZmlsdGVyYF0oI2ZpbHRlcikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlamVjdCAoUy5vZGQpIChbMSwgMiwgM10pXG4gIC8vLiBbMl1cbiAgLy8uXG4gIC8vLiA+IFMucmVqZWN0IChTLm9kZCkgKHt4OiAxLCB5OiAyLCB6OiAzfSlcbiAgLy8uIHt5OiAyfVxuICAvLy5cbiAgLy8uID4gUy5yZWplY3QgKFMub2RkKSAoUy5Ob3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5yZWplY3QgKFMub2RkKSAoUy5KdXN0ICgwKSlcbiAgLy8uIEp1c3QgKDApXG4gIC8vLlxuICAvLy4gPiBTLnJlamVjdCAoUy5vZGQpIChTLkp1c3QgKDEpKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIF8ucmVqZWN0ID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZpbHRlcmFibGVdfSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlIChhKSwgZiAoYSksIGYgKGEpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFoucmVqZWN0KVxuICB9O1xuXG4gIC8vIyB0YWtlV2hpbGUgOjogRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLnRha2VXaGlsZWBdW10uIERpc2NhcmRzIHRoZSBmaXJzdCBlbGVtZW50IHdoaWNoXG4gIC8vLiBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUsIGFuZCBhbGwgc3Vic2VxdWVudCBlbGVtZW50cy5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGRyb3BXaGlsZWBdKCNkcm9wV2hpbGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50YWtlV2hpbGUgKFMub2RkKSAoWzMsIDMsIDMsIDcsIDYsIDMsIDUsIDRdKVxuICAvLy4gWzMsIDMsIDMsIDddXG4gIC8vLlxuICAvLy4gPiBTLnRha2VXaGlsZSAoUy5ldmVuKSAoWzMsIDMsIDMsIDcsIDYsIDMsIDUsIDRdKVxuICAvLy4gW11cbiAgLy8uIGBgYFxuICBfLnRha2VXaGlsZSA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5GaWx0ZXJhYmxlXX0sXG4gICAgdHlwZXM6IFskLlByZWRpY2F0ZSAoYSksIGYgKGEpLCBmIChhKV0sXG4gICAgaW1wbDogY3VycnkyIChaLnRha2VXaGlsZSlcbiAgfTtcblxuICAvLyMgZHJvcFdoaWxlIDo6IEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gZiBhXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5kcm9wV2hpbGVgXVtdLiBSZXRhaW5zIHRoZSBmaXJzdCBlbGVtZW50IHdoaWNoXG4gIC8vLiBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUsIGFuZCBhbGwgc3Vic2VxdWVudCBlbGVtZW50cy5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHRha2VXaGlsZWBdKCN0YWtlV2hpbGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5kcm9wV2hpbGUgKFMub2RkKSAoWzMsIDMsIDMsIDcsIDYsIDMsIDUsIDRdKVxuICAvLy4gWzYsIDMsIDUsIDRdXG4gIC8vLlxuICAvLy4gPiBTLmRyb3BXaGlsZSAoUy5ldmVuKSAoWzMsIDMsIDMsIDcsIDYsIDMsIDUsIDRdKVxuICAvLy4gWzMsIDMsIDMsIDcsIDYsIDMsIDUsIDRdXG4gIC8vLiBgYGBcbiAgXy5kcm9wV2hpbGUgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRmlsdGVyYWJsZV19LFxuICAgIHR5cGVzOiBbJC5QcmVkaWNhdGUgKGEpLCBmIChhKSwgZiAoYSldLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5kcm9wV2hpbGUpXG4gIH07XG5cbiAgLy8jIG1hcCA6OiBGdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFoubWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwIChNYXRoLnNxcnQpIChbMSwgNCwgOV0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IFMubWFwIChNYXRoLnNxcnQpICh7eDogMSwgeTogNCwgejogOX0pXG4gIC8vLiB7eDogMSwgeTogMiwgejogM31cbiAgLy8uXG4gIC8vLiA+IFMubWFwIChNYXRoLnNxcnQpIChTLkp1c3QgKDkpKVxuICAvLy4gSnVzdCAoMylcbiAgLy8uXG4gIC8vLiA+IFMubWFwIChNYXRoLnNxcnQpIChTLlJpZ2h0ICg5KSlcbiAgLy8uIFJpZ2h0ICgzKVxuICAvLy5cbiAgLy8uID4gUy5tYXAgKE1hdGguc3FydCkgKFMuUGFpciAoOTk5ODAwMDEpICg5OTk4MDAwMSkpXG4gIC8vLiBQYWlyICg5OTk4MDAwMSkgKDk5OTkpXG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBSZXBsYWNpbmcgYEZ1bmN0b3IgZiA9PiBmYCB3aXRoIGBGdW5jdGlvbiB4YCBwcm9kdWNlcyB0aGUgQiBjb21iaW5hdG9yXG4gIC8vLiBmcm9tIGNvbWJpbmF0b3J5IGxvZ2ljIChpLmUuIFtgY29tcG9zZWBdKCNjb21wb3NlKSk6XG4gIC8vLlxuICAvLy4gICAgIEZ1bmN0b3IgZiA9PiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gIC8vLiAgICAgKGEgLT4gYikgLT4gRnVuY3Rpb24geCBhIC0+IEZ1bmN0aW9uIHggYlxuICAvLy4gICAgIChhIC0+IGMpIC0+IEZ1bmN0aW9uIHggYSAtPiBGdW5jdGlvbiB4IGNcbiAgLy8uICAgICAoYiAtPiBjKSAtPiBGdW5jdGlvbiB4IGIgLT4gRnVuY3Rpb24geCBjXG4gIC8vLiAgICAgKGIgLT4gYykgLT4gRnVuY3Rpb24gYSBiIC0+IEZ1bmN0aW9uIGEgY1xuICAvLy4gICAgIChiIC0+IGMpIC0+IChhIC0+IGIpIC0+IChhIC0+IGMpXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcCAoTWF0aC5zcXJ0KSAoUy5hZGQgKDEpKSAoOTkpXG4gIC8vLiAxMFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1hcChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZ1bmN0b3IpIHtcbiAgICAgIHJldHVybiBaLm1hcCAoZiwgZnVuY3Rvcik7XG4gICAgfTtcbiAgfVxuICBfLm1hcCA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5GdW5jdG9yXX0sXG4gICAgdHlwZXM6IFtGbiAoYSkgKGIpLCBmIChhKSwgZiAoYildLFxuICAgIGltcGw6IG1hcFxuICB9O1xuXG4gIC8vIyBmbGlwIDo6IEZ1bmN0b3IgZiA9PiBmIChhIC0+IGIpIC0+IGEgLT4gZiBiXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5mbGlwYF1bXS4gTWFwcyBvdmVyIHRoZSBnaXZlbiBmdW5jdGlvbnMsIGFwcGx5aW5nXG4gIC8vLiBlYWNoIHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBSZXBsYWNpbmcgYEZ1bmN0b3IgZiA9PiBmYCB3aXRoIGBGdW5jdGlvbiB4YCBwcm9kdWNlcyB0aGUgQyBjb21iaW5hdG9yXG4gIC8vLiBmcm9tIGNvbWJpbmF0b3J5IGxvZ2ljOlxuICAvLy5cbiAgLy8uICAgICBGdW5jdG9yIGYgPT4gZiAoYSAtPiBiKSAtPiBhIC0+IGYgYlxuICAvLy4gICAgIEZ1bmN0aW9uIHggKGEgLT4gYikgLT4gYSAtPiBGdW5jdGlvbiB4IGJcbiAgLy8uICAgICBGdW5jdGlvbiB4IChhIC0+IGMpIC0+IGEgLT4gRnVuY3Rpb24geCBjXG4gIC8vLiAgICAgRnVuY3Rpb24geCAoYiAtPiBjKSAtPiBiIC0+IEZ1bmN0aW9uIHggY1xuICAvLy4gICAgIEZ1bmN0aW9uIGEgKGIgLT4gYykgLT4gYiAtPiBGdW5jdGlvbiBhIGNcbiAgLy8uICAgICAoYSAtPiBiIC0+IGMpIC0+IGIgLT4gYSAtPiBjXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZsaXAgKFMuY29uY2F0KSAoJyEnKSAoJ2ZvbycpXG4gIC8vLiAnZm9vISdcbiAgLy8uXG4gIC8vLiA+IFMuZmxpcCAoW01hdGguZmxvb3IsIE1hdGguY2VpbF0pICgxLjUpXG4gIC8vLiBbMSwgMl1cbiAgLy8uXG4gIC8vLiA+IFMuZmxpcCAoe2Zsb29yOiBNYXRoLmZsb29yLCBjZWlsOiBNYXRoLmNlaWx9KSAoMS41KVxuICAvLy4ge2Zsb29yOiAxLCBjZWlsOiAyfVxuICAvLy5cbiAgLy8uID4gUy5mbGlwIChDb25zIChNYXRoLmZsb29yKSAoQ29ucyAoTWF0aC5jZWlsKSAoTmlsKSkpICgxLjUpXG4gIC8vLiBDb25zICgxKSAoQ29ucyAoMikgKE5pbCkpXG4gIC8vLiBgYGBcbiAgXy5mbGlwID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZ1bmN0b3JdfSxcbiAgICB0eXBlczogW2YgKEZuIChhKSAoYikpLCBhLCBmIChiKV0sXG4gICAgaW1wbDogY3VycnkyIChaLmZsaXApXG4gIH07XG5cbiAgLy8jIGJpbWFwIDo6IEJpZnVuY3RvciBmID0+IChhIC0+IGIpIC0+IChjIC0+IGQpIC0+IGYgYSBjIC0+IGYgYiBkXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5iaW1hcGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmJpbWFwIChTLnRvVXBwZXIpIChNYXRoLnNxcnQpIChTLlBhaXIgKCdmb28nKSAoNjQpKVxuICAvLy4gUGFpciAoJ0ZPTycpICg4KVxuICAvLy5cbiAgLy8uID4gUy5iaW1hcCAoUy50b1VwcGVyKSAoTWF0aC5zcXJ0KSAoUy5MZWZ0ICgnZm9vJykpXG4gIC8vLiBMZWZ0ICgnRk9PJylcbiAgLy8uXG4gIC8vLiA+IFMuYmltYXAgKFMudG9VcHBlcikgKE1hdGguc3FydCkgKFMuUmlnaHQgKDY0KSlcbiAgLy8uIFJpZ2h0ICg4KVxuICAvLy4gYGBgXG4gIF8uYmltYXAgPSB7XG4gICAgY29uc3RzOiB7cDogW1ouQmlmdW5jdG9yXX0sXG4gICAgdHlwZXM6IFtGbiAoYSkgKGIpLCBGbiAoYykgKGQpLCBwIChhKSAoYyksIHAgKGIpIChkKV0sXG4gICAgaW1wbDogY3VycnkzIChaLmJpbWFwKVxuICB9O1xuXG4gIC8vIyBtYXBMZWZ0IDo6IEJpZnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSBjIC0+IGYgYiBjXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5tYXBMZWZ0YF1bXS4gTWFwcyB0aGUgZ2l2ZW4gZnVuY3Rpb24gb3ZlciB0aGUgbGVmdFxuICAvLy4gc2lkZSBvZiBhIEJpZnVuY3Rvci5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwTGVmdCAoUy50b1VwcGVyKSAoUy5QYWlyICgnZm9vJykgKDY0KSlcbiAgLy8uIFBhaXIgKCdGT08nKSAoNjQpXG4gIC8vLlxuICAvLy4gPiBTLm1hcExlZnQgKFMudG9VcHBlcikgKFMuTGVmdCAoJ2ZvbycpKVxuICAvLy4gTGVmdCAoJ0ZPTycpXG4gIC8vLlxuICAvLy4gPiBTLm1hcExlZnQgKFMudG9VcHBlcikgKFMuUmlnaHQgKDY0KSlcbiAgLy8uIFJpZ2h0ICg2NClcbiAgLy8uIGBgYFxuICBfLm1hcExlZnQgPSB7XG4gICAgY29uc3RzOiB7cDogW1ouQmlmdW5jdG9yXX0sXG4gICAgdHlwZXM6IFtGbiAoYSkgKGIpLCBwIChhKSAoYyksIHAgKGIpIChjKV0sXG4gICAgaW1wbDogY3VycnkyIChaLm1hcExlZnQpXG4gIH07XG5cbiAgLy8jIHByb21hcCA6OiBQcm9mdW5jdG9yIHAgPT4gKGEgLT4gYikgLT4gKGMgLT4gZCkgLT4gcCBiIGMgLT4gcCBhIGRcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLnByb21hcGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnByb21hcCAoTWF0aC5hYnMpIChTLmFkZCAoMSkpIChNYXRoLnNxcnQpICgtMTAwKVxuICAvLy4gMTFcbiAgLy8uIGBgYFxuICBfLnByb21hcCA9IHtcbiAgICBjb25zdHM6IHtwOiBbWi5Qcm9mdW5jdG9yXX0sXG4gICAgdHlwZXM6IFtGbiAoYSkgKGIpLCBGbiAoYykgKGQpLCBwIChiKSAoYyksIHAgKGEpIChkKV0sXG4gICAgaW1wbDogY3VycnkzIChaLnByb21hcClcbiAgfTtcblxuICAvLyMgYWx0IDo6IEFsdCBmID0+IGYgYSAtPiBmIGEgLT4gZiBhXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5hbHRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hbHQgKFMuTm90aGluZykgKFMuSnVzdCAoMSkpXG4gIC8vLiBKdXN0ICgxKVxuICAvLy5cbiAgLy8uID4gUy5hbHQgKFMuSnVzdCAoMikpIChTLkp1c3QgKDMpKVxuICAvLy4gSnVzdCAoMilcbiAgLy8uXG4gIC8vLiA+IFMuYWx0IChTLkxlZnQgKCdYJykpIChTLlJpZ2h0ICgxKSlcbiAgLy8uIFJpZ2h0ICgxKVxuICAvLy5cbiAgLy8uID4gUy5hbHQgKFMuUmlnaHQgKDIpKSAoUy5SaWdodCAoMykpXG4gIC8vLiBSaWdodCAoMilcbiAgLy8uIGBgYFxuICBfLmFsdCA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5BbHRdfSxcbiAgICB0eXBlczogW2YgKGEpLCBmIChhKSwgZiAoYSldLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5hbHQpXG4gIH07XG5cbiAgLy8jIHplcm8gOjogUGx1cyBmID0+IFR5cGVSZXAgZiAtPiBmIGFcbiAgLy8uXG4gIC8vLiBbVHlwZS1zYWZlXVtzYW5jdHVhcnktZGVmXSB2ZXJzaW9uIG9mIFtgWi56ZXJvYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuemVybyAoQXJyYXkpXG4gIC8vLiBbXVxuICAvLy5cbiAgLy8uID4gUy56ZXJvIChPYmplY3QpXG4gIC8vLiB7fVxuICAvLy5cbiAgLy8uID4gUy56ZXJvIChTLk1heWJlKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIF8uemVybyA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5QbHVzXX0sXG4gICAgdHlwZXM6IFtUeXBlUmVwICgkLlR5cGVWYXJpYWJsZSAoJ2YnKSksIGYgKGEpXSxcbiAgICBpbXBsOiBaLnplcm9cbiAgfTtcblxuICAvLyMgcmVkdWNlIDo6IEZvbGRhYmxlIGYgPT4gKGIgLT4gYSAtPiBiKSAtPiBiIC0+IGYgYSAtPiBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBjdXJyaWVkIGJpbmFyeSBmdW5jdGlvbiwgYW4gaW5pdGlhbCB2YWx1ZSwgYW5kIGEgW0ZvbGRhYmxlXVtdLFxuICAvLy4gYW5kIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIHRoZSBpbml0aWFsIHZhbHVlIGFuZCB0aGUgRm9sZGFibGUncyBmaXJzdFxuICAvLy4gdmFsdWUsIHRoZW4gYXBwbGllcyB0aGUgZnVuY3Rpb24gdG8gdGhlIHJlc3VsdCBvZiB0aGUgcHJldmlvdXNcbiAgLy8uIGFwcGxpY2F0aW9uIGFuZCB0aGUgRm9sZGFibGUncyBzZWNvbmQgdmFsdWUuIFJlcGVhdHMgdGhpcyBwcm9jZXNzXG4gIC8vLiB1bnRpbCBlYWNoIG9mIHRoZSBGb2xkYWJsZSdzIHZhbHVlcyBoYXMgYmVlbiB1c2VkLiBSZXR1cm5zIHRoZSBpbml0aWFsXG4gIC8vLiB2YWx1ZSBpZiB0aGUgRm9sZGFibGUgaXMgZW1wdHk7IHRoZSByZXN1bHQgb2YgdGhlIGZpbmFsIGFwcGxpY2F0aW9uXG4gIC8vLiBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlZHVjZSAoUy5hZGQpICgwKSAoWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gMTVcbiAgLy8uXG4gIC8vLiA+IFMucmVkdWNlICh4cyA9PiB4ID0+IFMucHJlcGVuZCAoeCkgKHhzKSkgKFtdKSAoWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gWzUsIDQsIDMsIDIsIDFdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmVkdWNlKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaW5pdGlhbCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGZvbGRhYmxlKSB7XG4gICAgICAgIHJldHVybiBaLnJlZHVjZSAoZnVuY3Rpb24oeSwgeCkgeyByZXR1cm4gZiAoeSkgKHgpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZm9sZGFibGUpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8ucmVkdWNlID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFtGbiAoYSkgKEZuIChiKSAoYSkpLCBhLCBmIChiKSwgYV0sXG4gICAgaW1wbDogcmVkdWNlXG4gIH07XG5cbiAgLy8jIHRyYXZlcnNlIDo6IChBcHBsaWNhdGl2ZSBmLCBUcmF2ZXJzYWJsZSB0KSA9PiBUeXBlUmVwIGYgLT4gKGEgLT4gZiBiKSAtPiB0IGEgLT4gZiAodCBiKVxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFoudHJhdmVyc2VgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50cmF2ZXJzZSAoQXJyYXkpIChTLndvcmRzKSAoUy5KdXN0ICgnZm9vIGJhciBiYXonKSlcbiAgLy8uIFtKdXN0ICgnZm9vJyksIEp1c3QgKCdiYXInKSwgSnVzdCAoJ2JheicpXVxuICAvLy5cbiAgLy8uID4gUy50cmF2ZXJzZSAoQXJyYXkpIChTLndvcmRzKSAoUy5Ob3RoaW5nKVxuICAvLy4gW05vdGhpbmddXG4gIC8vLlxuICAvLy4gPiBTLnRyYXZlcnNlIChTLk1heWJlKSAoUy5wYXJzZUludCAoMTYpKSAoWydBJywgJ0InLCAnQyddKVxuICAvLy4gSnVzdCAoWzEwLCAxMSwgMTJdKVxuICAvLy5cbiAgLy8uID4gUy50cmF2ZXJzZSAoUy5NYXliZSkgKFMucGFyc2VJbnQgKDE2KSkgKFsnQScsICdCJywgJ0MnLCAnWCddKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy50cmF2ZXJzZSAoUy5NYXliZSkgKFMucGFyc2VJbnQgKDE2KSkgKHthOiAnQScsIGI6ICdCJywgYzogJ0MnfSlcbiAgLy8uIEp1c3QgKHthOiAxMCwgYjogMTEsIGM6IDEyfSlcbiAgLy8uXG4gIC8vLiA+IFMudHJhdmVyc2UgKFMuTWF5YmUpIChTLnBhcnNlSW50ICgxNikpICh7YTogJ0EnLCBiOiAnQicsIGM6ICdDJywgeDogJ1gnfSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBfLnRyYXZlcnNlID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFwcGxpY2F0aXZlXSwgdDogW1ouVHJhdmVyc2FibGVdfSxcbiAgICB0eXBlczogW1R5cGVSZXAgKCQuVHlwZVZhcmlhYmxlICgnZicpKSwgRm4gKGEpIChmIChiKSksIHQgKGEpLCBmICh0IChiKSldLFxuICAgIGltcGw6IGN1cnJ5MyAoWi50cmF2ZXJzZSlcbiAgfTtcblxuICAvLyMgc2VxdWVuY2UgOjogKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IFR5cGVSZXAgZiAtPiB0IChmIGEpIC0+IGYgKHQgYSlcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLnNlcXVlbmNlYF1bXS4gSW52ZXJ0cyB0aGUgZ2l2ZW4gYHQgKGYgYSlgXG4gIC8vLiB0byBwcm9kdWNlIGFuIGBmICh0IGEpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc2VxdWVuY2UgKEFycmF5KSAoUy5KdXN0IChbMSwgMiwgM10pKVxuICAvLy4gW0p1c3QgKDEpLCBKdXN0ICgyKSwgSnVzdCAoMyldXG4gIC8vLlxuICAvLy4gPiBTLnNlcXVlbmNlIChTLk1heWJlKSAoW1MuSnVzdCAoMSksIFMuSnVzdCAoMiksIFMuSnVzdCAoMyldKVxuICAvLy4gSnVzdCAoWzEsIDIsIDNdKVxuICAvLy5cbiAgLy8uID4gUy5zZXF1ZW5jZSAoUy5NYXliZSkgKFtTLkp1c3QgKDEpLCBTLkp1c3QgKDIpLCBTLk5vdGhpbmddKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5zZXF1ZW5jZSAoUy5NYXliZSkgKHthOiBTLkp1c3QgKDEpLCBiOiBTLkp1c3QgKDIpLCBjOiBTLkp1c3QgKDMpfSlcbiAgLy8uIEp1c3QgKHthOiAxLCBiOiAyLCBjOiAzfSlcbiAgLy8uXG4gIC8vLiA+IFMuc2VxdWVuY2UgKFMuTWF5YmUpICh7YTogUy5KdXN0ICgxKSwgYjogUy5KdXN0ICgyKSwgYzogUy5Ob3RoaW5nfSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBfLnNlcXVlbmNlID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFwcGxpY2F0aXZlXSwgdDogW1ouVHJhdmVyc2FibGVdfSxcbiAgICB0eXBlczogW1R5cGVSZXAgKCQuVHlwZVZhcmlhYmxlICgnZicpKSwgdCAoZiAoYSkpLCBmICh0IChhKSldLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5zZXF1ZW5jZSlcbiAgfTtcblxuICAvLyMgYXAgOjogQXBwbHkgZiA9PiBmIChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXAgKFtNYXRoLnNxcnQsIHggPT4geCAqIHhdKSAoWzEsIDQsIDksIDE2LCAyNV0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNSwgMSwgMTYsIDgxLCAyNTYsIDYyNV1cbiAgLy8uXG4gIC8vLiA+IFMuYXAgKHt4OiBNYXRoLnNxcnQsIHk6IFMuYWRkICgxKSwgejogUy5zdWIgKDEpfSkgKHt3OiA0LCB4OiA0LCB5OiA0fSlcbiAgLy8uIHt4OiAyLCB5OiA1fVxuICAvLy5cbiAgLy8uID4gUy5hcCAoUy5KdXN0IChNYXRoLnNxcnQpKSAoUy5KdXN0ICg2NCkpXG4gIC8vLiBKdXN0ICg4KVxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gUmVwbGFjaW5nIGBBcHBseSBmID0+IGZgIHdpdGggYEZ1bmN0aW9uIHhgIHByb2R1Y2VzIHRoZSBTIGNvbWJpbmF0b3JcbiAgLy8uIGZyb20gY29tYmluYXRvcnkgbG9naWM6XG4gIC8vLlxuICAvLy4gICAgIEFwcGx5IGYgPT4gZiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gIC8vLiAgICAgRnVuY3Rpb24geCAoYSAtPiBiKSAtPiBGdW5jdGlvbiB4IGEgLT4gRnVuY3Rpb24geCBiXG4gIC8vLiAgICAgRnVuY3Rpb24geCAoYSAtPiBjKSAtPiBGdW5jdGlvbiB4IGEgLT4gRnVuY3Rpb24geCBjXG4gIC8vLiAgICAgRnVuY3Rpb24geCAoYiAtPiBjKSAtPiBGdW5jdGlvbiB4IGIgLT4gRnVuY3Rpb24geCBjXG4gIC8vLiAgICAgRnVuY3Rpb24gYSAoYiAtPiBjKSAtPiBGdW5jdGlvbiBhIGIgLT4gRnVuY3Rpb24gYSBjXG4gIC8vLiAgICAgKGEgLT4gYiAtPiBjKSAtPiAoYSAtPiBiKSAtPiAoYSAtPiBjKVxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hcCAocyA9PiBuID0+IHMuc2xpY2UgKDAsIG4pKSAocyA9PiBNYXRoLmNlaWwgKHMubGVuZ3RoIC8gMikpICgnSGFza2VsbCcpXG4gIC8vLiAnSGFzaydcbiAgLy8uIGBgYFxuICBfLmFwID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFwcGx5XX0sXG4gICAgdHlwZXM6IFtmIChGbiAoYSkgKGIpKSwgZiAoYSksIGYgKGIpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouYXApXG4gIH07XG5cbiAgLy8jIGxpZnQyIDo6IEFwcGx5IGYgPT4gKGEgLT4gYiAtPiBjKSAtPiBmIGEgLT4gZiBiIC0+IGYgY1xuICAvLy5cbiAgLy8uIFByb21vdGVzIGEgY3VycmllZCBiaW5hcnkgZnVuY3Rpb24gdG8gYSBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiB0d29cbiAgLy8uIFtBcHBseV1bXXMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmxpZnQyIChTLmFkZCkgKFMuSnVzdCAoMikpIChTLkp1c3QgKDMpKVxuICAvLy4gSnVzdCAoNSlcbiAgLy8uXG4gIC8vLiA+IFMubGlmdDIgKFMuYWRkKSAoUy5KdXN0ICgyKSkgKFMuTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMubGlmdDIgKFMuYW5kKSAoUy5KdXN0ICh0cnVlKSkgKFMuSnVzdCAodHJ1ZSkpXG4gIC8vLiBKdXN0ICh0cnVlKVxuICAvLy5cbiAgLy8uID4gUy5saWZ0MiAoUy5hbmQpIChTLkp1c3QgKHRydWUpKSAoUy5KdXN0IChmYWxzZSkpXG4gIC8vLiBKdXN0IChmYWxzZSlcbiAgLy8uIGBgYFxuICBfLmxpZnQyID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFwcGx5XX0sXG4gICAgdHlwZXM6IFtGbiAoYSkgKEZuIChiKSAoYykpLCBmIChhKSwgZiAoYiksIGYgKGMpXSxcbiAgICBpbXBsOiBjdXJyeTMgKFoubGlmdDIpXG4gIH07XG5cbiAgLy8jIGxpZnQzIDo6IEFwcGx5IGYgPT4gKGEgLT4gYiAtPiBjIC0+IGQpIC0+IGYgYSAtPiBmIGIgLT4gZiBjIC0+IGYgZFxuICAvLy5cbiAgLy8uIFByb21vdGVzIGEgY3VycmllZCB0ZXJuYXJ5IGZ1bmN0aW9uIHRvIGEgZnVuY3Rpb24gd2hpY2ggb3BlcmF0ZXMgb24gdGhyZWVcbiAgLy8uIFtBcHBseV1bXXMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmxpZnQzIChTLnJlZHVjZSkgKFMuSnVzdCAoUy5hZGQpKSAoUy5KdXN0ICgwKSkgKFMuSnVzdCAoWzEsIDIsIDNdKSlcbiAgLy8uIEp1c3QgKDYpXG4gIC8vLlxuICAvLy4gPiBTLmxpZnQzIChTLnJlZHVjZSkgKFMuSnVzdCAoUy5hZGQpKSAoUy5KdXN0ICgwKSkgKFMuTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBfLmxpZnQzID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFwcGx5XX0sXG4gICAgdHlwZXM6IFtGbiAoYSkgKEZuIChiKSAoRm4gKGMpIChkKSkpLCBmIChhKSwgZiAoYiksIGYgKGMpLCBmIChkKV0sXG4gICAgaW1wbDogY3Vycnk0IChaLmxpZnQzKVxuICB9O1xuXG4gIC8vIyBhcEZpcnN0IDo6IEFwcGx5IGYgPT4gZiBhIC0+IGYgYiAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmFwRmlyc3RgXVtdLiBDb21iaW5lcyB0d28gZWZmZWN0ZnVsIGFjdGlvbnMsXG4gIC8vLiBrZWVwaW5nIG9ubHkgdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QuIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGAoPCopYFxuICAvLy4gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcFNlY29uZGBdKCNhcFNlY29uZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFwRmlyc3QgKFsxLCAyXSkgKFszLCA0XSlcbiAgLy8uIFsxLCAxLCAyLCAyXVxuICAvLy5cbiAgLy8uID4gUy5hcEZpcnN0IChTLkp1c3QgKDEpKSAoUy5KdXN0ICgyKSlcbiAgLy8uIEp1c3QgKDEpXG4gIC8vLiBgYGBcbiAgXy5hcEZpcnN0ID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFwcGx5XX0sXG4gICAgdHlwZXM6IFtmIChhKSwgZiAoYiksIGYgKGEpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouYXBGaXJzdClcbiAgfTtcblxuICAvLyMgYXBTZWNvbmQgOjogQXBwbHkgZiA9PiBmIGEgLT4gZiBiIC0+IGYgYlxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouYXBTZWNvbmRgXVtdLiBDb21iaW5lcyB0d28gZWZmZWN0ZnVsIGFjdGlvbnMsXG4gIC8vLiBrZWVwaW5nIG9ubHkgdGhlIHJlc3VsdCBvZiB0aGUgc2Vjb25kLiBFcXVpdmFsZW50IHRvIEhhc2tlbGwncyBgKCo+KWBcbiAgLy8uIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgYXBGaXJzdGBdKCNhcEZpcnN0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXBTZWNvbmQgKFsxLCAyXSkgKFszLCA0XSlcbiAgLy8uIFszLCA0LCAzLCA0XVxuICAvLy5cbiAgLy8uID4gUy5hcFNlY29uZCAoUy5KdXN0ICgxKSkgKFMuSnVzdCAoMikpXG4gIC8vLiBKdXN0ICgyKVxuICAvLy4gYGBgXG4gIF8uYXBTZWNvbmQgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbHldfSxcbiAgICB0eXBlczogW2YgKGEpLCBmIChiKSwgZiAoYildLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5hcFNlY29uZClcbiAgfTtcblxuICAvLyMgb2YgOjogQXBwbGljYXRpdmUgZiA9PiBUeXBlUmVwIGYgLT4gYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLm9mYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMub2YgKEFycmF5KSAoNDIpXG4gIC8vLiBbNDJdXG4gIC8vLlxuICAvLy4gPiBTLm9mIChGdW5jdGlvbikgKDQyKSAobnVsbClcbiAgLy8uIDQyXG4gIC8vLlxuICAvLy4gPiBTLm9mIChTLk1heWJlKSAoNDIpXG4gIC8vLiBKdXN0ICg0MilcbiAgLy8uXG4gIC8vLiA+IFMub2YgKFMuRWl0aGVyKSAoNDIpXG4gIC8vLiBSaWdodCAoNDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gb2YodHlwZVJlcCkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gWi5vZiAodHlwZVJlcCwgeCk7XG4gICAgfTtcbiAgfVxuICBfLm9mID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFwcGxpY2F0aXZlXX0sXG4gICAgdHlwZXM6IFtUeXBlUmVwICgkLlR5cGVWYXJpYWJsZSAoJ2YnKSksIGEsIGYgKGEpXSxcbiAgICBpbXBsOiBvZlxuICB9O1xuXG4gIC8vIyBjaGFpbiA6OiBDaGFpbiBtID0+IChhIC0+IG0gYikgLT4gbSBhIC0+IG0gYlxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouY2hhaW5gXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jaGFpbiAoeCA9PiBbeCwgeF0pIChbMSwgMiwgM10pXG4gIC8vLiBbMSwgMSwgMiwgMiwgMywgM11cbiAgLy8uXG4gIC8vLiA+IFMuY2hhaW4gKG4gPT4gcyA9PiBzLnNsaWNlICgwLCBuKSkgKHMgPT4gTWF0aC5jZWlsIChzLmxlbmd0aCAvIDIpKSAoJ3NsaWNlJylcbiAgLy8uICdzbGknXG4gIC8vLlxuICAvLy4gPiBTLmNoYWluIChTLnBhcnNlSW50ICgxMCkpIChTLkp1c3QgKCcxMjMnKSlcbiAgLy8uIEp1c3QgKDEyMylcbiAgLy8uXG4gIC8vLiA+IFMuY2hhaW4gKFMucGFyc2VJbnQgKDEwKSkgKFMuSnVzdCAoJ1hYWCcpKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIF8uY2hhaW4gPSB7XG4gICAgY29uc3RzOiB7bTogW1ouQ2hhaW5dfSxcbiAgICB0eXBlczogW0ZuIChhKSAobSAoYikpLCBtIChhKSwgbSAoYildLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5jaGFpbilcbiAgfTtcblxuICAvLyMgam9pbiA6OiBDaGFpbiBtID0+IG0gKG0gYSkgLT4gbSBhXG4gIC8vLlxuICAvLy4gW1R5cGUtc2FmZV1bc2FuY3R1YXJ5LWRlZl0gdmVyc2lvbiBvZiBbYFouam9pbmBdW10uXG4gIC8vLiBSZW1vdmVzIG9uZSBsZXZlbCBvZiBuZXN0aW5nIGZyb20gYSBuZXN0ZWQgbW9uYWRpYyBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmpvaW4gKFtbMV0sIFsyXSwgWzNdXSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gUy5qb2luIChbW1sxLCAyLCAzXV1dKVxuICAvLy4gW1sxLCAyLCAzXV1cbiAgLy8uXG4gIC8vLiA+IFMuam9pbiAoUy5KdXN0IChTLkp1c3QgKDEpKSlcbiAgLy8uIEp1c3QgKDEpXG4gIC8vLlxuICAvLy4gPiBTLmpvaW4gKFMuUGFpciAoJ2ZvbycpIChTLlBhaXIgKCdiYXInKSAoJ2JheicpKSlcbiAgLy8uIFBhaXIgKCdmb29iYXInKSAoJ2JheicpXG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBSZXBsYWNpbmcgYENoYWluIG0gPT4gbWAgd2l0aCBgRnVuY3Rpb24geGAgcHJvZHVjZXMgdGhlIFcgY29tYmluYXRvclxuICAvLy4gZnJvbSBjb21iaW5hdG9yeSBsb2dpYzpcbiAgLy8uXG4gIC8vLiAgICAgQ2hhaW4gbSA9PiBtIChtIGEpIC0+IG0gYVxuICAvLy4gICAgIEZ1bmN0aW9uIHggKEZ1bmN0aW9uIHggYSkgLT4gRnVuY3Rpb24geCBhXG4gIC8vLiAgICAgKHggLT4geCAtPiBhKSAtPiAoeCAtPiBhKVxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5qb2luIChTLmNvbmNhdCkgKCdhYmMnKVxuICAvLy4gJ2FiY2FiYydcbiAgLy8uIGBgYFxuICBfLmpvaW4gPSB7XG4gICAgY29uc3RzOiB7bTogW1ouQ2hhaW5dfSxcbiAgICB0eXBlczogW20gKG0gKGEpKSwgbSAoYSldLFxuICAgIGltcGw6IFouam9pblxuICB9O1xuXG4gIC8vIyBjaGFpblJlYyA6OiBDaGFpblJlYyBtID0+IFR5cGVSZXAgbSAtPiAoYSAtPiBtIChFaXRoZXIgYSBiKSkgLT4gYSAtPiBtIGJcbiAgLy8uXG4gIC8vLiBQZXJmb3JtcyBhIFtgY2hhaW5gXSgjY2hhaW4pLWxpa2UgY29tcHV0YXRpb24gd2l0aCBjb25zdGFudCBzdGFjayB1c2FnZS5cbiAgLy8uIFNpbWlsYXIgdG8gW2BaLmNoYWluUmVjYF1bXSwgYnV0IGN1cnJpZWQgYW5kIG1vcmUgY29udmVuaWVudCBkdWUgdG8gdGhlXG4gIC8vLiB1c2Ugb2YgdGhlIEVpdGhlciB0eXBlIHRvIGluZGljYXRlIGNvbXBsZXRpb24gKHZpYSBhIFJpZ2h0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuY2hhaW5SZWMgKEFycmF5KVxuICAvLy4gLiAgICAgICAgICAgIChzID0+IHMubGVuZ3RoID09PSAyID8gUy5tYXAgKFMuUmlnaHQpIChbcyArICchJywgcyArICc/J10pXG4gIC8vLiAuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBTLm1hcCAoUy5MZWZ0KSAoW3MgKyAnbycsIHMgKyAnbiddKSlcbiAgLy8uIC4gICAgICAgICAgICAoJycpXG4gIC8vLiBbJ29vIScsICdvbz8nLCAnb24hJywgJ29uPycsICdubyEnLCAnbm8/JywgJ25uIScsICdubj8nXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGNoYWluUmVjKHR5cGVSZXApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIFouY2hhaW5SZWMgKHR5cGVSZXAsIHN0ZXAsIHgpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIHN0ZXAobmV4dCwgZG9uZSwgeCkge1xuICAgICAgICByZXR1cm4gWi5tYXAgKGVpdGhlciAobmV4dCkgKGRvbmUpLCBmICh4KSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBfLmNoYWluUmVjID0ge1xuICAgIGNvbnN0czoge206IFtaLkNoYWluUmVjXX0sXG4gICAgdHlwZXM6IFtUeXBlUmVwICgkLlR5cGVWYXJpYWJsZSAoJ20nKSksXG4gICAgICAgICAgICBGbiAoYSkgKG0gKCRFaXRoZXIgKGEpIChiKSkpLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIG0gKGIpXSxcbiAgICBpbXBsOiBjaGFpblJlY1xuICB9O1xuXG4gIC8vIyBleHRlbmQgOjogRXh0ZW5kIHcgPT4gKHcgYSAtPiBiKSAtPiB3IGEgLT4gdyBiXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5leHRlbmRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5leHRlbmQgKFMuam9pbldpdGggKCcnKSkgKFsneCcsICd5JywgJ3onXSlcbiAgLy8uIFsneHl6JywgJ3l6JywgJ3onXVxuICAvLy5cbiAgLy8uID4gUy5leHRlbmQgKGYgPT4gZiAoWzMsIDRdKSkgKFMucmV2ZXJzZSkgKFsxLCAyXSlcbiAgLy8uIFs0LCAzLCAyLCAxXVxuICAvLy4gYGBgXG4gIF8uZXh0ZW5kID0ge1xuICAgIGNvbnN0czoge3c6IFtaLkV4dGVuZF19LFxuICAgIHR5cGVzOiBbRm4gKHcgKGEpKSAoYiksIHcgKGEpLCB3IChiKV0sXG4gICAgaW1wbDogY3VycnkyIChaLmV4dGVuZClcbiAgfTtcblxuICAvLyMgZHVwbGljYXRlIDo6IEV4dGVuZCB3ID0+IHcgYSAtPiB3ICh3IGEpXG4gIC8vLlxuICAvLy4gW1R5cGUtc2FmZV1bc2FuY3R1YXJ5LWRlZl0gdmVyc2lvbiBvZiBbYFouZHVwbGljYXRlYF1bXS5cbiAgLy8uIEFkZHMgb25lIGxldmVsIG9mIG5lc3RpbmcgdG8gYSBjb21vbmFkaWMgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5kdXBsaWNhdGUgKFMuSnVzdCAoMSkpXG4gIC8vLiBKdXN0IChKdXN0ICgxKSlcbiAgLy8uXG4gIC8vLiA+IFMuZHVwbGljYXRlIChbMV0pXG4gIC8vLiBbWzFdXVxuICAvLy5cbiAgLy8uID4gUy5kdXBsaWNhdGUgKFsxLCAyLCAzXSlcbiAgLy8uIFtbMSwgMiwgM10sIFsyLCAzXSwgWzNdXVxuICAvLy5cbiAgLy8uID4gUy5kdXBsaWNhdGUgKFMucmV2ZXJzZSkgKFsxLCAyXSkgKFszLCA0XSlcbiAgLy8uIFs0LCAzLCAyLCAxXVxuICAvLy4gYGBgXG4gIF8uZHVwbGljYXRlID0ge1xuICAgIGNvbnN0czoge3c6IFtaLkV4dGVuZF19LFxuICAgIHR5cGVzOiBbdyAoYSksIHcgKHcgKGEpKV0sXG4gICAgaW1wbDogWi5kdXBsaWNhdGVcbiAgfTtcblxuICAvLyMgZXh0cmFjdCA6OiBDb21vbmFkIHcgPT4gdyBhIC0+IGFcbiAgLy8uXG4gIC8vLiBbVHlwZS1zYWZlXVtzYW5jdHVhcnktZGVmXSB2ZXJzaW9uIG9mIFtgWi5leHRyYWN0YF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZXh0cmFjdCAoUy5QYWlyICgnZm9vJykgKCdiYXInKSlcbiAgLy8uICdiYXInXG4gIC8vLiBgYGBcbiAgXy5leHRyYWN0ID0ge1xuICAgIGNvbnN0czoge3c6IFtaLkNvbW9uYWRdfSxcbiAgICB0eXBlczogW3cgKGEpLCBhXSxcbiAgICBpbXBsOiBaLmV4dHJhY3RcbiAgfTtcblxuICAvLyMgY29udHJhbWFwIDo6IENvbnRyYXZhcmlhbnQgZiA9PiAoYiAtPiBhKSAtPiBmIGEgLT4gZiBiXG4gIC8vLlxuICAvLy4gW1R5cGUtc2FmZV1bc2FuY3R1YXJ5LWRlZl0gdmVyc2lvbiBvZiBbYFouY29udHJhbWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuY29udHJhbWFwIChzID0+IHMubGVuZ3RoKSAoTWF0aC5zcXJ0KSAoJ1NhbmN0dWFyeScpXG4gIC8vLiAzXG4gIC8vLiBgYGBcbiAgXy5jb250cmFtYXAgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQ29udHJhdmFyaWFudF19LFxuICAgIHR5cGVzOiBbRm4gKGIpIChhKSwgZiAoYSksIGYgKGIpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouY29udHJhbWFwKVxuICB9O1xuXG4gIC8vLiAjIyMgQ29tYmluYXRvclxuXG4gIC8vIyBJIDo6IGEgLT4gYVxuICAvLy5cbiAgLy8uIFRoZSBJIGNvbWJpbmF0b3IuIFJldHVybnMgaXRzIGFyZ3VtZW50LiBFcXVpdmFsZW50IHRvIEhhc2tlbGwncyBgaWRgXG4gIC8vLiBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuSSAoJ2ZvbycpXG4gIC8vLiAnZm9vJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIEkoeCkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIF8uSSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbYSwgYV0sXG4gICAgaW1wbDogSVxuICB9O1xuXG4gIC8vIyBLIDo6IGEgLT4gYiAtPiBhXG4gIC8vLlxuICAvLy4gVGhlIEsgY29tYmluYXRvci4gVGFrZXMgdHdvIHZhbHVlcyBhbmQgcmV0dXJucyB0aGUgZmlyc3QuIEVxdWl2YWxlbnQgdG9cbiAgLy8uIEhhc2tlbGwncyBgY29uc3RgIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5LICgnZm9vJykgKCdiYXInKVxuICAvLy4gJ2ZvbydcbiAgLy8uXG4gIC8vLiA+IFMubWFwIChTLksgKDQyKSkgKFMucmFuZ2UgKDApICg1KSlcbiAgLy8uIFs0MiwgNDIsIDQyLCA0MiwgNDJdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gSyh4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gIH1cbiAgXy5LID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFthLCBiLCBhXSxcbiAgICBpbXBsOiBLXG4gIH07XG5cbiAgLy8jIFQgOjogYSAtPiAoYSAtPiBiKSAtPiBiXG4gIC8vLlxuICAvLy4gVGhlIFQgKFt0aHJ1c2hdW10pIGNvbWJpbmF0b3IuIFRha2VzIGEgdmFsdWUgYW5kIGEgZnVuY3Rpb24sIGFuZCByZXR1cm5zXG4gIC8vLiB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byB0aGUgdmFsdWUuIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzXG4gIC8vLiBgKCYpYCBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuVCAoNDIpIChTLmFkZCAoMSkpXG4gIC8vLiA0M1xuICAvLy5cbiAgLy8uID4gUy5tYXAgKFMuVCAoMTAwKSkgKFtTLmFkZCAoMSksIE1hdGguc3FydF0pXG4gIC8vLiBbMTAxLCAxMF1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBUKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGYgKHgpO1xuICAgIH07XG4gIH1cbiAgXy5UID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFthLCBGbiAoYSkgKGIpLCBiXSxcbiAgICBpbXBsOiBUXG4gIH07XG5cbiAgLy8uICMjIyBGdW5jdGlvblxuXG4gIC8vIyBjdXJyeTIgOjogKChhLCBiKSAtPiBjKSAtPiBhIC0+IGIgLT4gY1xuICAvLy5cbiAgLy8uIEN1cnJpZXMgdGhlIGdpdmVuIGJpbmFyeSBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwIChTLmN1cnJ5MiAoTWF0aC5wb3cpICgxMCkpIChbMSwgMiwgM10pXG4gIC8vLiBbMTAsIDEwMCwgMTAwMF1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjdXJyeTIoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gZiAoeCwgeSk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5jdXJyeTIgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuRnVuY3Rpb24gKFthLCBiLCBjXSksIGEsIGIsIGNdLFxuICAgIGltcGw6IGN1cnJ5MlxuICB9O1xuXG4gIC8vIyBjdXJyeTMgOjogKChhLCBiLCBjKSAtPiBkKSAtPiBhIC0+IGIgLT4gYyAtPiBkXG4gIC8vLlxuICAvLy4gQ3VycmllcyB0aGUgZ2l2ZW4gdGVybmFyeSBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNvbnN0IHJlcGxhY2VTdHJpbmcgPSBTLmN1cnJ5MyAoKHdoYXQsIHJlcGxhY2VtZW50LCBzdHJpbmcpID0+XG4gIC8vLiAuICAgc3RyaW5nLnJlcGxhY2UgKHdoYXQsIHJlcGxhY2VtZW50KVxuICAvLy4gLiApXG4gIC8vLlxuICAvLy4gPiByZXBsYWNlU3RyaW5nICgnYmFuYW5hJykgKCdvcmFuZ2UnKSAoJ2JhbmFuYSBpY2VjcmVhbScpXG4gIC8vLiAnb3JhbmdlIGljZWNyZWFtJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGN1cnJ5MyhmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgICAgcmV0dXJuIGYgKHgsIHksIHopO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uY3VycnkzID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkZ1bmN0aW9uIChbYSwgYiwgYywgZF0pLCBhLCBiLCBjLCBkXSxcbiAgICBpbXBsOiBjdXJyeTNcbiAgfTtcblxuICAvLyMgY3Vycnk0IDo6ICgoYSwgYiwgYywgZCkgLT4gZSkgLT4gYSAtPiBiIC0+IGMgLT4gZCAtPiBlXG4gIC8vLlxuICAvLy4gQ3VycmllcyB0aGUgZ2l2ZW4gcXVhdGVybmFyeSBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNvbnN0IGNyZWF0ZVJlY3QgPSBTLmN1cnJ5NCAoKHgsIHksIHdpZHRoLCBoZWlnaHQpID0+XG4gIC8vLiAuICAgKHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSlcbiAgLy8uIC4gKVxuICAvLy5cbiAgLy8uID4gY3JlYXRlUmVjdCAoMCkgKDApICgxMCkgKDEwKVxuICAvLy4ge3g6IDAsIHk6IDAsIHdpZHRoOiAxMCwgaGVpZ2h0OiAxMH1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjdXJyeTQoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih3KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgICAgICByZXR1cm4gZiAodywgeCwgeSwgeik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLmN1cnJ5NCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5GdW5jdGlvbiAoW2EsIGIsIGMsIGQsIGVdKSwgYSwgYiwgYywgZCwgZV0sXG4gICAgaW1wbDogY3Vycnk0XG4gIH07XG5cbiAgLy8jIGN1cnJ5NSA6OiAoKGEsIGIsIGMsIGQsIGUpIC0+IGYpIC0+IGEgLT4gYiAtPiBjIC0+IGQgLT4gZSAtPiBmXG4gIC8vLlxuICAvLy4gQ3VycmllcyB0aGUgZ2l2ZW4gcXVpbmFyeSBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNvbnN0IHRvVXJsID0gUy5jdXJyeTUgKChwcm90b2NvbCwgY3JlZHMsIGhvc3RuYW1lLCBwb3J0LCBwYXRobmFtZSkgPT5cbiAgLy8uIC4gICBwcm90b2NvbCArICcvLycgK1xuICAvLy4gLiAgIFMubWF5YmUgKCcnKSAoUy5mbGlwIChTLmNvbmNhdCkgKCdAJykpIChjcmVkcykgK1xuICAvLy4gLiAgIGhvc3RuYW1lICtcbiAgLy8uIC4gICBTLm1heWJlICgnJykgKFMuY29uY2F0ICgnOicpKSAocG9ydCkgK1xuICAvLy4gLiAgIHBhdGhuYW1lXG4gIC8vLiAuIClcbiAgLy8uXG4gIC8vLiA+IHRvVXJsICgnaHR0cHM6JykgKFMuTm90aGluZykgKCdleGFtcGxlLmNvbScpIChTLkp1c3QgKCc0NDMnKSkgKCcvZm9vL2JhcicpXG4gIC8vLiAnaHR0cHM6Ly9leGFtcGxlLmNvbTo0NDMvZm9vL2JhcidcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjdXJyeTUoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oeikge1xuICAgICAgICAgICAgICByZXR1cm4gZiAodiwgdywgeCwgeSwgeik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5jdXJyeTUgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuRnVuY3Rpb24gKFthLCBiLCBjLCBkLCBlLCByXSksIGEsIGIsIGMsIGQsIGUsIHJdLFxuICAgIGltcGw6IGN1cnJ5NVxuICB9O1xuXG4gIC8vLiAjIyMgQ29tcG9zaXRpb25cblxuICAvLyMgY29tcG9zZSA6OiBTZW1pZ3JvdXBvaWQgcyA9PiBzIGIgYyAtPiBzIGEgYiAtPiBzIGEgY1xuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouY29tcG9zZWBdW10uXG4gIC8vLlxuICAvLy4gV2hlbiBzcGVjaWFsaXplZCB0byBGdW5jdGlvbiwgYGNvbXBvc2VgIGNvbXBvc2VzIHR3byB1bmFyeSBmdW5jdGlvbnMsXG4gIC8vLiBmcm9tIHJpZ2h0IHRvIGxlZnQgKHRoaXMgaXMgdGhlIEIgY29tYmluYXRvciBmcm9tIGNvbWJpbmF0b3J5IGxvZ2ljKS5cbiAgLy8uXG4gIC8vLiBUaGUgZ2VuZXJhbGl6ZWQgdHlwZSBzaWduYXR1cmUgaW5kaWNhdGVzIHRoYXQgYGNvbXBvc2VgIGlzIGNvbXBhdGlibGVcbiAgLy8uIHdpdGggYW55IFtTZW1pZ3JvdXBvaWRdW10uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BwaXBlYF0oI3BpcGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jb21wb3NlIChNYXRoLnNxcnQpIChTLmFkZCAoMSkpICg5OSlcbiAgLy8uIDEwXG4gIC8vLiBgYGBcbiAgXy5jb21wb3NlID0ge1xuICAgIGNvbnN0czoge3M6IFtaLlNlbWlncm91cG9pZF19LFxuICAgIHR5cGVzOiBbcyAoYikgKGMpLCBzIChhKSAoYiksIHMgKGEpIChjKV0sXG4gICAgaW1wbDogY3VycnkyIChaLmNvbXBvc2UpXG4gIH07XG5cbiAgLy8jIHBpcGUgOjogRm9sZGFibGUgZiA9PiBmIChBbnkgLT4gQW55KSAtPiBhIC0+IGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHNlcXVlbmNlIG9mIGZ1bmN0aW9ucyBhc3N1bWVkIHRvIGJlIHVuYXJ5IGFuZCBhIHZhbHVlIG9mIGFueVxuICAvLy4gdHlwZSwgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgc2VxdWVuY2Ugb2YgdHJhbnNmb3JtYXRpb25zXG4gIC8vLiB0byB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBJbiBnZW5lcmFsIHRlcm1zLCBgcGlwZWAgcGVyZm9ybXMgbGVmdC10by1yaWdodCBjb21wb3NpdGlvbiBvZiBhIHNlcXVlbmNlXG4gIC8vLiBvZiBmdW5jdGlvbnMuIGBwaXBlIChbZiwgZywgaF0pICh4KWAgaXMgZXF1aXZhbGVudCB0byBgaCAoZyAoZiAoeCkpKWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnBpcGUgKFtTLmFkZCAoMSksIE1hdGguc3FydCwgUy5zdWIgKDEpXSkgKDk5KVxuICAvLy4gOVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBpcGUoZnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHJlZHVjZSAoVCkgKHgpIChmcyk7XG4gICAgfTtcbiAgfVxuICBfLnBpcGUgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRm9sZGFibGVdfSxcbiAgICB0eXBlczogW2YgKEZuICgkLkFueSkgKCQuQW55KSksIGEsIGJdLFxuICAgIGltcGw6IHBpcGVcbiAgfTtcblxuICAvLyMgcGlwZUsgOjogKEZvbGRhYmxlIGYsIENoYWluIG0pID0+IGYgKEFueSAtPiBtIEFueSkgLT4gbSBhIC0+IG0gYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgc2VxdWVuY2Ugb2YgZnVuY3Rpb25zIGFzc3VtZWQgdG8gYmUgdW5hcnkgd2hpY2ggcmV0dXJuIHZhbHVlc1xuICAvLy4gd2l0aCBhIFtDaGFpbl1bXSwgYW5kIGEgdmFsdWUgb2YgdGhhdCBDaGFpbiwgYW5kIHJldHVybnMgdGhlIHJlc3VsdFxuICAvLy4gb2YgYXBwbHlpbmcgdGhlIHNlcXVlbmNlIG9mIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBJbiBnZW5lcmFsIHRlcm1zLCBgcGlwZUtgIHBlcmZvcm1zIGxlZnQtdG8tcmlnaHQgW0tsZWlzbGldW10gY29tcG9zaXRpb25cbiAgLy8uIG9mIGFuIHNlcXVlbmNlIG9mIGZ1bmN0aW9ucy4gYHBpcGVLIChbZiwgZywgaF0pICh4KWAgaXMgZXF1aXZhbGVudCB0b1xuICAvLy4gYGNoYWluIChoKSAoY2hhaW4gKGcpIChjaGFpbiAoZikgKHgpKSlgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5waXBlSyAoW1MudGFpbCwgUy50YWlsLCBTLmhlYWRdKSAoUy5KdXN0IChbMSwgMiwgMywgNF0pKVxuICAvLy4gSnVzdCAoMylcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwaXBlSyhmcykge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gWi5yZWR1Y2UgKGZ1bmN0aW9uKHgsIGYpIHsgcmV0dXJuIFouY2hhaW4gKGYsIHgpOyB9LCB4LCBmcyk7XG4gICAgfTtcbiAgfVxuICBfLnBpcGVLID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZvbGRhYmxlXSwgbTogW1ouQ2hhaW5dfSxcbiAgICB0eXBlczogW2YgKEZuICgkLkFueSkgKG0gKCQuQW55KSkpLCBtIChhKSwgbSAoYildLFxuICAgIGltcGw6IHBpcGVLXG4gIH07XG5cbiAgLy8jIG9uIDo6IChiIC0+IGIgLT4gYykgLT4gKGEgLT4gYikgLT4gYSAtPiBhIC0+IGNcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGJpbmFyeSBmdW5jdGlvbiBgZmAsIGEgdW5hcnkgZnVuY3Rpb24gYGdgLCBhbmQgdHdvXG4gIC8vLiB2YWx1ZXMgYHhgIGFuZCBgeWAuIFJldHVybnMgYGYgKGcgKHgpKSAoZyAoeSkpYC5cbiAgLy8uXG4gIC8vLiBUaGlzIGlzIHRoZSBQIGNvbWJpbmF0b3IgZnJvbSBjb21iaW5hdG9yeSBsb2dpYy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMub24gKFMuY29uY2F0KSAoUy5yZXZlcnNlKSAoWzEsIDIsIDNdKSAoWzQsIDUsIDZdKVxuICAvLy4gWzMsIDIsIDEsIDYsIDUsIDRdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gb24oZikge1xuICAgIHJldHVybiBmdW5jdGlvbihnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgICAgIHJldHVybiBmIChnICh4KSkgKGcgKHkpKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLm9uID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtGbiAoYikgKEZuIChiKSAoYykpLCBGbiAoYSkgKGIpLCBhLCBhLCBjXSxcbiAgICBpbXBsOiBvblxuICB9O1xuXG4gIC8vLiAjIyMgUGFpciB0eXBlXG4gIC8vLlxuICAvLy4gUGFpciBpcyB0aGUgY2Fub25pY2FsIHByb2R1Y3QgdHlwZTogYSB2YWx1ZSBvZiB0eXBlIGBQYWlyIGEgYmAgYWx3YXlzXG4gIC8vLiBjb250YWlucyBleGFjdGx5IHR3byB2YWx1ZXM6IG9uZSBvZiB0eXBlIGBhYDsgb25lIG9mIHR5cGUgYGJgLlxuICAvLy5cbiAgLy8uIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBwcm92aWRlZCBieSBbc2FuY3R1YXJ5LXBhaXJdW10uXG5cbiAgLy8jIFBhaXJUeXBlIDo6IFR5cGUgLT4gVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gQSBbYEJpbmFyeVR5cGVgXVtCaW5hcnlUeXBlXSBmb3IgdXNlIHdpdGggW3NhbmN0dWFyeS1kZWZdW10uXG5cbiAgLy8jIFBhaXIgOjogYSAtPiBiIC0+IFBhaXIgYSBiXG4gIC8vLlxuICAvLy4gUGFpcidzIHNvbGUgZGF0YSBjb25zdHJ1Y3Rvci4gQWRkaXRpb25hbGx5LCBpdCBzZXJ2ZXMgYXMgdGhlXG4gIC8vLiBQYWlyIFt0eXBlIHJlcHJlc2VudGF0aXZlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5QYWlyICgnZm9vJykgKDQyKVxuICAvLy4gUGFpciAoJ2ZvbycpICg0MilcbiAgLy8uIGBgYFxuICBfLlBhaXIgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW2EsIGIsICRQYWlyIChhKSAoYildLFxuICAgIGltcGw6IFBhaXJcbiAgfTtcblxuICAvLyMgZnN0IDo6IFBhaXIgYSBiIC0+IGFcbiAgLy8uXG4gIC8vLiBgZnN0IChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGB4YC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZnN0IChTLlBhaXIgKCdmb28nKSAoNDIpKVxuICAvLy4gJ2ZvbydcbiAgLy8uIGBgYFxuICBfLmZzdCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJFBhaXIgKGEpIChiKSwgYV0sXG4gICAgaW1wbDogUGFpci5mc3RcbiAgfTtcblxuICAvLyMgc25kIDo6IFBhaXIgYSBiIC0+IGJcbiAgLy8uXG4gIC8vLiBgc25kIChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGB5YC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc25kIChTLlBhaXIgKCdmb28nKSAoNDIpKVxuICAvLy4gNDJcbiAgLy8uIGBgYFxuICBfLnNuZCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJFBhaXIgKGEpIChiKSwgYl0sXG4gICAgaW1wbDogUGFpci5zbmRcbiAgfTtcblxuICAvLyMgc3dhcCA6OiBQYWlyIGEgYiAtPiBQYWlyIGIgYVxuICAvLy5cbiAgLy8uIGBzd2FwIChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBQYWlyICh5KSAoeClgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zd2FwIChTLlBhaXIgKCdmb28nKSAoNDIpKVxuICAvLy4gUGFpciAoNDIpICgnZm9vJylcbiAgLy8uIGBgYFxuICBfLnN3YXAgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyRQYWlyIChhKSAoYiksICRQYWlyIChiKSAoYSldLFxuICAgIGltcGw6IFBhaXIuc3dhcFxuICB9O1xuXG4gIC8vLiAjIyMgTWF5YmUgdHlwZVxuICAvLy5cbiAgLy8uIFRoZSBNYXliZSB0eXBlIHJlcHJlc2VudHMgb3B0aW9uYWwgdmFsdWVzOiBhIHZhbHVlIG9mIHR5cGUgYE1heWJlIGFgIGlzXG4gIC8vLiBlaXRoZXIgTm90aGluZyAodGhlIGVtcHR5IHZhbHVlKSBvciBhIEp1c3Qgd2hvc2UgdmFsdWUgaXMgb2YgdHlwZSBgYWAuXG4gIC8vLlxuICAvLy4gVGhlIGltcGxlbWVudGF0aW9uIGlzIHByb3ZpZGVkIGJ5IFtzYW5jdHVhcnktbWF5YmVdW10uXG5cbiAgLy8jIE1heWJlVHlwZSA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBBIFtgVW5hcnlUeXBlYF1bVW5hcnlUeXBlXSBmb3IgdXNlIHdpdGggW3NhbmN0dWFyeS1kZWZdW10uXG5cbiAgLy8jIE1heWJlIDo6IFR5cGVSZXAgTWF5YmVcbiAgLy8uXG4gIC8vLiBNYXliZSBbdHlwZSByZXByZXNlbnRhdGl2ZV1bXS5cblxuICAvLyMgTm90aGluZyA6OiBNYXliZSBhXG4gIC8vLlxuICAvLy4gVGhlIGVtcHR5IHZhbHVlIG9mIHR5cGUgYE1heWJlIGFgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5Ob3RoaW5nXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcblxuICAvLyMgSnVzdCA6OiBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RzIGEgdmFsdWUgb2YgdHlwZSBgTWF5YmUgYWAgZnJvbSBhIHZhbHVlIG9mIHR5cGUgYGFgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5KdXN0ICg0MilcbiAgLy8uIEp1c3QgKDQyKVxuICAvLy4gYGBgXG4gIF8uSnVzdCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbYSwgJE1heWJlIChhKV0sXG4gICAgaW1wbDogSnVzdFxuICB9O1xuXG4gIC8vIyBpc05vdGhpbmcgOjogTWF5YmUgYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIE1heWJlIGlzIE5vdGhpbmc7IGBmYWxzZWAgaWYgaXQgaXMgYSBKdXN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pc05vdGhpbmcgKFMuTm90aGluZylcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuaXNOb3RoaW5nIChTLkp1c3QgKDQyKSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaXNOb3RoaW5nKG1heWJlKSB7XG4gICAgcmV0dXJuIG1heWJlLmlzTm90aGluZztcbiAgfVxuICBfLmlzTm90aGluZyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJE1heWJlIChhKSwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBpc05vdGhpbmdcbiAgfTtcblxuICAvLyMgaXNKdXN0IDo6IE1heWJlIGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBNYXliZSBpcyBhIEp1c3Q7IGBmYWxzZWAgaWYgaXQgaXMgTm90aGluZy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaXNKdXN0IChTLkp1c3QgKDQyKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuaXNKdXN0IChTLk5vdGhpbmcpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGlzSnVzdChtYXliZSkge1xuICAgIHJldHVybiBtYXliZS5pc0p1c3Q7XG4gIH1cbiAgXy5pc0p1c3QgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyRNYXliZSAoYSksICQuQm9vbGVhbl0sXG4gICAgaW1wbDogaXNKdXN0XG4gIH07XG5cbiAgLy8jIGZyb21NYXliZSA6OiBhIC0+IE1heWJlIGEgLT4gYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgZGVmYXVsdCB2YWx1ZSBhbmQgYSBNYXliZSwgYW5kIHJldHVybnMgdGhlIE1heWJlJ3MgdmFsdWVcbiAgLy8uIGlmIHRoZSBNYXliZSBpcyBhIEp1c3Q7IHRoZSBkZWZhdWx0IHZhbHVlIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGZyb21NYXliZV9gXSgjZnJvbU1heWJlXykgYW5kXG4gIC8vLiBbYG1heWJlVG9OdWxsYWJsZWBdKCNtYXliZVRvTnVsbGFibGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5mcm9tTWF5YmUgKDApIChTLkp1c3QgKDQyKSlcbiAgLy8uIDQyXG4gIC8vLlxuICAvLy4gPiBTLmZyb21NYXliZSAoMCkgKFMuTm90aGluZylcbiAgLy8uIDBcbiAgLy8uIGBgYFxuICBfLmZyb21NYXliZSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbYSwgJE1heWJlIChhKSwgYV0sXG4gICAgaW1wbDogQyAobWF5YmUpIChJKVxuICB9O1xuXG4gIC8vIyBmcm9tTWF5YmVfIDo6ICgoKSAtPiBhKSAtPiBNYXliZSBhIC0+IGFcbiAgLy8uXG4gIC8vLiBWYXJpYW50IG9mIFtgZnJvbU1heWJlYF0oI2Zyb21NYXliZSkgd2hpY2ggdGFrZXMgYSB0aHVuayBzbyB0aGUgZGVmYXVsdFxuICAvLy4gdmFsdWUgaXMgb25seSBjb21wdXRlZCBpZiByZXF1aXJlZC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGZ1bmN0aW9uIGZpYihuKSB7IHJldHVybiBuIDw9IDEgPyBuIDogZmliIChuIC0gMikgKyBmaWIgKG4gLSAxKTsgfVxuICAvLy5cbiAgLy8uID4gUy5mcm9tTWF5YmVfICgoKSA9PiBmaWIgKDMwKSkgKFMuSnVzdCAoMTAwMDAwMCkpXG4gIC8vLiAxMDAwMDAwXG4gIC8vLlxuICAvLy4gPiBTLmZyb21NYXliZV8gKCgpID0+IGZpYiAoMzApKSAoUy5Ob3RoaW5nKVxuICAvLy4gODMyMDQwXG4gIC8vLiBgYGBcbiAgXy5mcm9tTWF5YmVfID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlRodW5rIChhKSwgJE1heWJlIChhKSwgYV0sXG4gICAgaW1wbDogQyAobWF5YmVfKSAoSSlcbiAgfTtcblxuICAvLyMgbWF5YmVUb051bGxhYmxlIDo6IE1heWJlIGEgLT4gTnVsbGFibGUgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIGdpdmVuIE1heWJlJ3MgdmFsdWUgaWYgdGhlIE1heWJlIGlzIGEgSnVzdDsgYG51bGxgIG90aGVyd2lzZS5cbiAgLy8uIFtOdWxsYWJsZV1bXSBpcyBkZWZpbmVkIGluIFtzYW5jdHVhcnktZGVmXVtdLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZnJvbU1heWJlYF0oI2Zyb21NYXliZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1heWJlVG9OdWxsYWJsZSAoUy5KdXN0ICg0MikpXG4gIC8vLiA0MlxuICAvLy5cbiAgLy8uID4gUy5tYXliZVRvTnVsbGFibGUgKFMuTm90aGluZylcbiAgLy8uIG51bGxcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtYXliZVRvTnVsbGFibGUobWF5YmUpIHtcbiAgICByZXR1cm4gbWF5YmUuaXNKdXN0ID8gbWF5YmUudmFsdWUgOiBudWxsO1xuICB9XG4gIF8ubWF5YmVUb051bGxhYmxlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskTWF5YmUgKGEpLCAkLk51bGxhYmxlIChhKV0sXG4gICAgaW1wbDogbWF5YmVUb051bGxhYmxlXG4gIH07XG5cbiAgLy8jIHRvTWF5YmUgOjogYT8gLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgdmFsdWUgYW5kIHJldHVybnMgTm90aGluZyBpZiB0aGUgdmFsdWUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgO1xuICAvLy4gSnVzdCB0aGUgdmFsdWUgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50b01heWJlIChudWxsKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy50b01heWJlICg0MilcbiAgLy8uIEp1c3QgKDQyKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRvTWF5YmUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgPyBOb3RoaW5nIDogSnVzdCAoeCk7XG4gIH1cbiAgXy50b01heWJlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFthLCAkTWF5YmUgKGEpXSxcbiAgICBpbXBsOiB0b01heWJlXG4gIH07XG5cbiAgLy8jIG1heWJlIDo6IGIgLT4gKGEgLT4gYikgLT4gTWF5YmUgYSAtPiBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYSBmdW5jdGlvbiwgYW5kIGEgTWF5YmUuIElmIHRoZSBNYXliZSBpc1xuICAvLy4gYSBKdXN0LCB0aGUgcmV0dXJuIHZhbHVlIGlzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvXG4gIC8vLiB0aGUgSnVzdCdzIHZhbHVlLiBPdGhlcndpc2UsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyByZXR1cm5lZC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1heWJlX2BdKCNtYXliZV8pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXliZSAoMCkgKFMucHJvcCAoJ2xlbmd0aCcpKSAoUy5KdXN0ICgncmVmdWdlJykpXG4gIC8vLiA2XG4gIC8vLlxuICAvLy4gPiBTLm1heWJlICgwKSAoUy5wcm9wICgnbGVuZ3RoJykpIChTLk5vdGhpbmcpXG4gIC8vLiAwXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbWF5YmUoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obWF5YmUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlLmlzSnVzdCA/IGYgKG1heWJlLnZhbHVlKSA6IHg7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5tYXliZSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbYiwgRm4gKGEpIChiKSwgJE1heWJlIChhKSwgYl0sXG4gICAgaW1wbDogbWF5YmVcbiAgfTtcblxuICAvLyMgbWF5YmVfIDo6ICgoKSAtPiBiKSAtPiAoYSAtPiBiKSAtPiBNYXliZSBhIC0+IGJcbiAgLy8uXG4gIC8vLiBWYXJpYW50IG9mIFtgbWF5YmVgXSgjbWF5YmUpIHdoaWNoIHRha2VzIGEgdGh1bmsgc28gdGhlIGRlZmF1bHQgdmFsdWVcbiAgLy8uIGlzIG9ubHkgY29tcHV0ZWQgaWYgcmVxdWlyZWQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBmdW5jdGlvbiBmaWIobikgeyByZXR1cm4gbiA8PSAxID8gbiA6IGZpYiAobiAtIDIpICsgZmliIChuIC0gMSk7IH1cbiAgLy8uXG4gIC8vLiA+IFMubWF5YmVfICgoKSA9PiBmaWIgKDMwKSkgKE1hdGguc3FydCkgKFMuSnVzdCAoMTAwMDAwMCkpXG4gIC8vLiAxMDAwXG4gIC8vLlxuICAvLy4gPiBTLm1heWJlXyAoKCkgPT4gZmliICgzMCkpIChNYXRoLnNxcnQpIChTLk5vdGhpbmcpXG4gIC8vLiA4MzIwNDBcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtYXliZV8odGh1bmspIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1heWJlKSB7XG4gICAgICAgIHJldHVybiBtYXliZS5pc0p1c3QgPyBmIChtYXliZS52YWx1ZSkgOiB0aHVuayAoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLm1heWJlXyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5UaHVuayAoYiksIEZuIChhKSAoYiksICRNYXliZSAoYSksIGJdLFxuICAgIGltcGw6IG1heWJlX1xuICB9O1xuXG4gIC8vIyBqdXN0cyA6OiAoRmlsdGVyYWJsZSBmLCBGdW5jdG9yIGYpID0+IGYgKE1heWJlIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIERpc2NhcmRzIGVhY2ggZWxlbWVudCB3aGljaCBpcyBOb3RoaW5nLCBhbmQgdW53cmFwcyBlYWNoIGVsZW1lbnQgd2hpY2ggaXNcbiAgLy8uIGEgSnVzdC4gUmVsYXRlZCB0byBIYXNrZWxsJ3MgYGNhdE1heWJlc2AgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsZWZ0c2BdKCNsZWZ0cykgYW5kIFtgcmlnaHRzYF0oI3JpZ2h0cykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmp1c3RzIChbUy5KdXN0ICgnZm9vJyksIFMuTm90aGluZywgUy5KdXN0ICgnYmF6JyldKVxuICAvLy4gWydmb28nLCAnYmF6J11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBqdXN0cyhtYXliZXMpIHtcbiAgICByZXR1cm4gbWFwICh2YWx1ZSkgKGZpbHRlciAoaXNKdXN0KSAobWF5YmVzKSk7XG4gIH1cbiAgXy5qdXN0cyA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5GaWx0ZXJhYmxlLCBaLkZ1bmN0b3JdfSxcbiAgICB0eXBlczogW2YgKCRNYXliZSAoYSkpLCBmIChhKV0sXG4gICAgaW1wbDoganVzdHNcbiAgfTtcblxuICAvLyMgbWFwTWF5YmUgOjogKEZpbHRlcmFibGUgZiwgRnVuY3RvciBmKSA9PiAoYSAtPiBNYXliZSBiKSAtPiBmIGEgLT4gZiBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBmdW5jdGlvbiBhbmQgYSBzdHJ1Y3R1cmUsIGFwcGxpZXMgdGhlIGZ1bmN0aW9uIHRvIGVhY2ggZWxlbWVudFxuICAvLy4gb2YgdGhlIHN0cnVjdHVyZSwgYW5kIHJldHVybnMgdGhlIFwic3VjY2Vzc2Z1bFwiIHJlc3VsdHMuIElmIHRoZSByZXN1bHQgb2ZcbiAgLy8uIGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byBhbiBlbGVtZW50IGlzIE5vdGhpbmcsIHRoZSByZXN1bHQgaXMgZGlzY2FyZGVkO1xuICAvLy4gaWYgdGhlIHJlc3VsdCBpcyBhIEp1c3QsIHRoZSBKdXN0J3MgdmFsdWUgaXMgaW5jbHVkZWQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcE1heWJlIChTLmhlYWQpIChbW10sIFsxLCAyLCAzXSwgW10sIFs0LCA1LCA2XSwgW11dKVxuICAvLy4gWzEsIDRdXG4gIC8vLlxuICAvLy4gPiBTLm1hcE1heWJlIChTLmhlYWQpICh7eDogWzEsIDIsIDNdLCB5OiBbXSwgejogWzQsIDUsIDZdfSlcbiAgLy8uIHt4OiAxLCB6OiA0fVxuICAvLy4gYGBgXG4gIF8ubWFwTWF5YmUgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRmlsdGVyYWJsZSwgWi5GdW5jdG9yXX0sXG4gICAgdHlwZXM6IFtGbiAoYSkgKCRNYXliZSAoYikpLCBmIChhKSwgZiAoYildLFxuICAgIGltcGw6IEIgKEIgKGp1c3RzKSkgKG1hcClcbiAgfTtcblxuICAvLyMgZW5jYXNlIDo6IChhIC0+IGIpIC0+IGEgLT4gTWF5YmUgYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgdW5hcnkgZnVuY3Rpb24gYGZgIHdoaWNoIG1heSB0aHJvdyBhbmQgYSB2YWx1ZSBgeGAgb2YgYW55IHR5cGUsXG4gIC8vLiBhbmQgYXBwbGllcyBgZmAgdG8gYHhgIGluc2lkZSBhIGB0cnlgIGJsb2NrLiBJZiBhbiBleGNlcHRpb24gaXMgY2F1Z2h0LFxuICAvLy4gdGhlIHJldHVybiB2YWx1ZSBpcyBOb3RoaW5nOyBvdGhlcndpc2UgdGhlIHJldHVybiB2YWx1ZSBpcyBKdXN0IHRoZVxuICAvLy4gcmVzdWx0IG9mIGFwcGx5aW5nIGBmYCB0byBgeGAuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BlbmNhc2VFaXRoZXJgXSgjZW5jYXNlRWl0aGVyKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZW5jYXNlIChldmFsKSAoJzEgKyAxJylcbiAgLy8uIEp1c3QgKDIpXG4gIC8vLlxuICAvLy4gPiBTLmVuY2FzZSAoZXZhbCkgKCcxICsnKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGVuY2FzZShmKSB7XG4gICAgcmV0dXJuIEIgKGVpdGhlclRvTWF5YmUpIChlbmNhc2VFaXRoZXIgKEkpIChmKSk7XG4gIH1cbiAgXy5lbmNhc2UgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW0ZuIChhKSAoYiksIGEsICRNYXliZSAoYildLFxuICAgIGltcGw6IGVuY2FzZVxuICB9O1xuXG4gIC8vIyBlbmNhc2UyIDo6IChhIC0+IGIgLT4gYykgLT4gYSAtPiBiIC0+IE1heWJlIGNcbiAgLy8uXG4gIC8vLiBCaW5hcnkgdmVyc2lvbiBvZiBbYGVuY2FzZWBdKCNlbmNhc2UpLlxuICBfLmVuY2FzZTIgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW0ZuIChhKSAoRm4gKGIpIChjKSksIGEsIGIsICRNYXliZSAoYyldLFxuICAgIGltcGw6IEIgKEIgKEIgKGVpdGhlclRvTWF5YmUpKSkgKGVuY2FzZUVpdGhlcjIgKEkpKVxuICB9O1xuXG4gIC8vIyBlbmNhc2UzIDo6IChhIC0+IGIgLT4gYyAtPiBkKSAtPiBhIC0+IGIgLT4gYyAtPiBNYXliZSBkXG4gIC8vLlxuICAvLy4gVGVybmFyeSB2ZXJzaW9uIG9mIFtgZW5jYXNlYF0oI2VuY2FzZSkuXG4gIF8uZW5jYXNlMyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKGEpIChGbiAoYikgKEZuIChjKSAoZCkpKSwgYSwgYiwgYywgJE1heWJlIChkKV0sXG4gICAgaW1wbDogQiAoQiAoQiAoQiAoZWl0aGVyVG9NYXliZSkpKSkgKGVuY2FzZUVpdGhlcjMgKEkpKVxuICB9O1xuXG4gIC8vIyBtYXliZVRvRWl0aGVyIDo6IGEgLT4gTWF5YmUgYiAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gQ29udmVydHMgYSBNYXliZSB0byBhbiBFaXRoZXIuIE5vdGhpbmcgYmVjb21lcyBhIExlZnQgKGNvbnRhaW5pbmcgdGhlXG4gIC8vLiBmaXJzdCBhcmd1bWVudCk7IGEgSnVzdCBiZWNvbWVzIGEgUmlnaHQuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BlaXRoZXJUb01heWJlYF0oI2VpdGhlclRvTWF5YmUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXliZVRvRWl0aGVyICgnRXhwZWN0aW5nIGFuIGludGVnZXInKSAoUy5wYXJzZUludCAoMTApICgneHl6JykpXG4gIC8vLiBMZWZ0ICgnRXhwZWN0aW5nIGFuIGludGVnZXInKVxuICAvLy5cbiAgLy8uID4gUy5tYXliZVRvRWl0aGVyICgnRXhwZWN0aW5nIGFuIGludGVnZXInKSAoUy5wYXJzZUludCAoMTApICgnNDInKSlcbiAgLy8uIFJpZ2h0ICg0MilcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtYXliZVRvRWl0aGVyKHgpIHtcbiAgICByZXR1cm4gbWF5YmUgKExlZnQgKHgpKSAoUmlnaHQpO1xuICB9XG4gIF8ubWF5YmVUb0VpdGhlciA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbYSwgJE1heWJlIChiKSwgJEVpdGhlciAoYSkgKGIpXSxcbiAgICBpbXBsOiBtYXliZVRvRWl0aGVyXG4gIH07XG5cbiAgLy8uICMjIyBFaXRoZXIgdHlwZVxuICAvLy5cbiAgLy8uIFRoZSBFaXRoZXIgdHlwZSByZXByZXNlbnRzIHZhbHVlcyB3aXRoIHR3byBwb3NzaWJpbGl0aWVzOiBhIHZhbHVlIG9mIHR5cGVcbiAgLy8uIGBFaXRoZXIgYSBiYCBpcyBlaXRoZXIgYSBMZWZ0IHdob3NlIHZhbHVlIGlzIG9mIHR5cGUgYGFgIG9yIGEgUmlnaHQgd2hvc2VcbiAgLy8uIHZhbHVlIGlzIG9mIHR5cGUgYGJgLlxuICAvLy5cbiAgLy8uIFRoZSBpbXBsZW1lbnRhdGlvbiBpcyBwcm92aWRlZCBieSBbc2FuY3R1YXJ5LWVpdGhlcl1bXS5cblxuICAvLyMgRWl0aGVyVHlwZSA6OiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIEEgW2BCaW5hcnlUeXBlYF1bQmluYXJ5VHlwZV0gZm9yIHVzZSB3aXRoIFtzYW5jdHVhcnktZGVmXVtdLlxuXG4gIC8vIyBFaXRoZXIgOjogVHlwZVJlcCBFaXRoZXJcbiAgLy8uXG4gIC8vLiBFaXRoZXIgW3R5cGUgcmVwcmVzZW50YXRpdmVdW10uXG5cbiAgLy8jIExlZnQgOjogYSAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gQ29uc3RydWN0cyBhIHZhbHVlIG9mIHR5cGUgYEVpdGhlciBhIGJgIGZyb20gYSB2YWx1ZSBvZiB0eXBlIGBhYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuTGVmdCAoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpXG4gIC8vLiBMZWZ0ICgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJylcbiAgLy8uIGBgYFxuICBfLkxlZnQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW2EsICRFaXRoZXIgKGEpIChiKV0sXG4gICAgaW1wbDogTGVmdFxuICB9O1xuXG4gIC8vIyBSaWdodCA6OiBiIC0+IEVpdGhlciBhIGJcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RzIGEgdmFsdWUgb2YgdHlwZSBgRWl0aGVyIGEgYmAgZnJvbSBhIHZhbHVlIG9mIHR5cGUgYGJgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5SaWdodCAoNDIpXG4gIC8vLiBSaWdodCAoNDIpXG4gIC8vLiBgYGBcbiAgXy5SaWdodCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbYiwgJEVpdGhlciAoYSkgKGIpXSxcbiAgICBpbXBsOiBSaWdodFxuICB9O1xuXG4gIC8vIyBpc0xlZnQgOjogRWl0aGVyIGEgYiAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIEVpdGhlciBpcyBhIExlZnQ7IGBmYWxzZWAgaWYgaXQgaXMgYSBSaWdodC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaXNMZWZ0IChTLkxlZnQgKCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuaXNMZWZ0IChTLlJpZ2h0ICg0MikpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGlzTGVmdChlaXRoZXIpIHtcbiAgICByZXR1cm4gZWl0aGVyLmlzTGVmdDtcbiAgfVxuICBfLmlzTGVmdCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJEVpdGhlciAoYSkgKGIpLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGlzTGVmdFxuICB9O1xuXG4gIC8vIyBpc1JpZ2h0IDo6IEVpdGhlciBhIGIgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBFaXRoZXIgaXMgYSBSaWdodDsgYGZhbHNlYCBpZiBpdCBpcyBhIExlZnQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmlzUmlnaHQgKFMuUmlnaHQgKDQyKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuaXNSaWdodCAoUy5MZWZ0ICgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJykpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGlzUmlnaHQoZWl0aGVyKSB7XG4gICAgcmV0dXJuIGVpdGhlci5pc1JpZ2h0O1xuICB9XG4gIF8uaXNSaWdodCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJEVpdGhlciAoYSkgKGIpLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGlzUmlnaHRcbiAgfTtcblxuICAvLyMgZnJvbUVpdGhlciA6OiBiIC0+IEVpdGhlciBhIGIgLT4gYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgZGVmYXVsdCB2YWx1ZSBhbmQgYW4gRWl0aGVyLCBhbmQgcmV0dXJucyB0aGUgUmlnaHQgdmFsdWVcbiAgLy8uIGlmIHRoZSBFaXRoZXIgaXMgYSBSaWdodDsgdGhlIGRlZmF1bHQgdmFsdWUgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5mcm9tRWl0aGVyICgwKSAoUy5SaWdodCAoNDIpKVxuICAvLy4gNDJcbiAgLy8uXG4gIC8vLiA+IFMuZnJvbUVpdGhlciAoMCkgKFMuTGVmdCAoNDIpKVxuICAvLy4gMFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZyb21FaXRoZXIoeCkge1xuICAgIHJldHVybiBlaXRoZXIgKEsgKHgpKSAoSSk7XG4gIH1cbiAgXy5mcm9tRWl0aGVyID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtiLCAkRWl0aGVyIChhKSAoYiksIGJdLFxuICAgIGltcGw6IGZyb21FaXRoZXJcbiAgfTtcblxuICAvLyMgdG9FaXRoZXIgOjogYSAtPiBiPyAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gQ29udmVydHMgYW4gYXJiaXRyYXJ5IHZhbHVlIHRvIGFuIEVpdGhlcjogYSBMZWZ0IGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGBcbiAgLy8uIG9yIGB1bmRlZmluZWRgOyBhIFJpZ2h0IG90aGVyd2lzZS4gVGhlIGZpcnN0IGFyZ3VtZW50IHNwZWNpZmllcyB0aGVcbiAgLy8uIHZhbHVlIG9mIHRoZSBMZWZ0IGluIHRoZSBcImZhaWx1cmVcIiBjYXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50b0VpdGhlciAoJ1hZWicpIChudWxsKVxuICAvLy4gTGVmdCAoJ1hZWicpXG4gIC8vLlxuICAvLy4gPiBTLnRvRWl0aGVyICgnWFlaJykgKCdBQkMnKVxuICAvLy4gUmlnaHQgKCdBQkMnKVxuICAvLy5cbiAgLy8uID4gUy5tYXAgKFMucHJvcCAoJzAnKSlcbiAgLy8uIC4gICAgICAgKFMudG9FaXRoZXIgKCdJbnZhbGlkIHByb3RvY29sJylcbiAgLy8uIC4gICAgICAgICAgICAgICAgICAgKCdmdHA6Ly9leGFtcGxlLmNvbS8nLm1hdGNoICgvXmh0dHBzPzovKSkpXG4gIC8vLiBMZWZ0ICgnSW52YWxpZCBwcm90b2NvbCcpXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoUy5wcm9wICgnMCcpKVxuICAvLy4gLiAgICAgICAoUy50b0VpdGhlciAoJ0ludmFsaWQgcHJvdG9jb2wnKVxuICAvLy4gLiAgICAgICAgICAgICAgICAgICAoJ2h0dHBzOi8vZXhhbXBsZS5jb20vJy5tYXRjaCAoL15odHRwcz86LykpKVxuICAvLy4gUmlnaHQgKCdodHRwczonKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRvRWl0aGVyKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHkgPT0gbnVsbCA/IExlZnQgKHgpIDogUmlnaHQgKHkpO1xuICAgIH07XG4gIH1cbiAgXy50b0VpdGhlciA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbYSwgYiwgJEVpdGhlciAoYSkgKGIpXSxcbiAgICBpbXBsOiB0b0VpdGhlclxuICB9O1xuXG4gIC8vIyBlaXRoZXIgOjogKGEgLT4gYykgLT4gKGIgLT4gYykgLT4gRWl0aGVyIGEgYiAtPiBjXG4gIC8vLlxuICAvLy4gVGFrZXMgdHdvIGZ1bmN0aW9ucyBhbmQgYW4gRWl0aGVyLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mXG4gIC8vLiBhcHBseWluZyB0aGUgZmlyc3QgZnVuY3Rpb24gdG8gdGhlIExlZnQncyB2YWx1ZSwgaWYgdGhlIEVpdGhlclxuICAvLy4gaXMgYSBMZWZ0LCBvciB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBzZWNvbmQgZnVuY3Rpb24gdG8gdGhlXG4gIC8vLiBSaWdodCdzIHZhbHVlLCBpZiB0aGUgRWl0aGVyIGlzIGEgUmlnaHQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVpdGhlciAoUy50b1VwcGVyKSAoUy5zaG93KSAoUy5MZWZ0ICgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJykpXG4gIC8vLiAnQ0FOTk9UIERJVklERSBCWSBaRVJPJ1xuICAvLy5cbiAgLy8uID4gUy5laXRoZXIgKFMudG9VcHBlcikgKFMuc2hvdykgKFMuUmlnaHQgKDQyKSlcbiAgLy8uICc0MidcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBlaXRoZXIobCkge1xuICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZWl0aGVyKSB7XG4gICAgICAgIHJldHVybiAoZWl0aGVyLmlzTGVmdCA/IGwgOiByKSAoZWl0aGVyLnZhbHVlKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLmVpdGhlciA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKGEpIChjKSwgRm4gKGIpIChjKSwgJEVpdGhlciAoYSkgKGIpLCBjXSxcbiAgICBpbXBsOiBlaXRoZXJcbiAgfTtcblxuICAvLyMgbGVmdHMgOjogKEZpbHRlcmFibGUgZiwgRnVuY3RvciBmKSA9PiBmIChFaXRoZXIgYSBiKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBEaXNjYXJkcyBlYWNoIGVsZW1lbnQgd2hpY2ggaXMgYSBSaWdodCwgYW5kIHVud3JhcHMgZWFjaCBlbGVtZW50IHdoaWNoIGlzXG4gIC8vLiBhIExlZnQuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2ByaWdodHNgXSgjcmlnaHRzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubGVmdHMgKFtTLlJpZ2h0ICgyMCksIFMuTGVmdCAoJ2ZvbycpLCBTLlJpZ2h0ICgxMCksIFMuTGVmdCAoJ2JhcicpXSlcbiAgLy8uIFsnZm9vJywgJ2JhciddXG4gIC8vLiBgYGBcbiAgXy5sZWZ0cyA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5GaWx0ZXJhYmxlLCBaLkZ1bmN0b3JdfSxcbiAgICB0eXBlczogW2YgKCRFaXRoZXIgKGEpIChiKSksIGYgKGEpXSxcbiAgICBpbXBsOiBCIChtYXAgKHZhbHVlKSkgKGZpbHRlciAoaXNMZWZ0KSlcbiAgfTtcblxuICAvLyMgcmlnaHRzIDo6IChGaWx0ZXJhYmxlIGYsIEZ1bmN0b3IgZikgPT4gZiAoRWl0aGVyIGEgYikgLT4gZiBiXG4gIC8vLlxuICAvLy4gRGlzY2FyZHMgZWFjaCBlbGVtZW50IHdoaWNoIGlzIGEgTGVmdCwgYW5kIHVud3JhcHMgZWFjaCBlbGVtZW50IHdoaWNoIGlzXG4gIC8vLiBhIFJpZ2h0LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbGVmdHNgXSgjbGVmdHMpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yaWdodHMgKFtTLlJpZ2h0ICgyMCksIFMuTGVmdCAoJ2ZvbycpLCBTLlJpZ2h0ICgxMCksIFMuTGVmdCAoJ2JhcicpXSlcbiAgLy8uIFsyMCwgMTBdXG4gIC8vLiBgYGBcbiAgXy5yaWdodHMgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRmlsdGVyYWJsZSwgWi5GdW5jdG9yXX0sXG4gICAgdHlwZXM6IFtmICgkRWl0aGVyIChhKSAoYikpLCBmIChiKV0sXG4gICAgaW1wbDogQiAobWFwICh2YWx1ZSkpIChmaWx0ZXIgKGlzUmlnaHQpKVxuICB9O1xuXG4gIC8vIyB0YWdCeSA6OiAoYSAtPiBCb29sZWFuKSAtPiBhIC0+IEVpdGhlciBhIGFcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSB2YWx1ZSwgYW5kIHJldHVybnMgYSBSaWdodCBvZiB0aGUgdmFsdWUgaWYgaXRcbiAgLy8uIHNhdGlzZmllcyB0aGUgcHJlZGljYXRlOyBhIExlZnQgb2YgdGhlIHZhbHVlIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudGFnQnkgKFMub2RkKSAoMClcbiAgLy8uIExlZnQgKDApXG4gIC8vXG4gIC8vLiA+IFMudGFnQnkgKFMub2RkKSAoMSlcbiAgLy8uIFJpZ2h0ICgxKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRhZ0J5KHByZWQpIHtcbiAgICByZXR1cm4gaWZFbHNlIChwcmVkKSAoUmlnaHQpIChMZWZ0KTtcbiAgfVxuICBfLnRhZ0J5ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlByZWRpY2F0ZSAoYSksIGEsICRFaXRoZXIgKGEpIChhKV0sXG4gICAgaW1wbDogdGFnQnlcbiAgfTtcblxuICAvLyMgZW5jYXNlRWl0aGVyIDo6IChFcnJvciAtPiBsKSAtPiAoYSAtPiByKSAtPiBhIC0+IEVpdGhlciBsIHJcbiAgLy8uXG4gIC8vLiBUYWtlcyB0d28gdW5hcnkgZnVuY3Rpb25zLCBgZmAgYW5kIGBnYCwgdGhlIHNlY29uZCBvZiB3aGljaCBtYXkgdGhyb3csXG4gIC8vLiBhbmQgYSB2YWx1ZSBgeGAgb2YgYW55IHR5cGUuIEFwcGxpZXMgYGdgIHRvIGB4YCBpbnNpZGUgYSBgdHJ5YCBibG9jay5cbiAgLy8uIElmIGFuIGV4Y2VwdGlvbiBpcyBjYXVnaHQsIHRoZSByZXR1cm4gdmFsdWUgaXMgYSBMZWZ0IGNvbnRhaW5pbmcgdGhlXG4gIC8vLiByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZSBjYXVnaHQgRXJyb3Igb2JqZWN0OyBvdGhlcndpc2UgdGhlIHJldHVyblxuICAvLy4gdmFsdWUgaXMgYSBSaWdodCBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGdgIHRvIGB4YC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGVuY2FzZWBdKCNlbmNhc2UpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5lbmNhc2VFaXRoZXIgKFMuSSkgKEpTT04ucGFyc2UpICgnW1wiZm9vXCIsXCJiYXJcIixcImJhelwiXScpXG4gIC8vLiBSaWdodCAoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy5cbiAgLy8uID4gUy5lbmNhc2VFaXRoZXIgKFMuSSkgKEpTT04ucGFyc2UpICgnWycpXG4gIC8vLiBMZWZ0IChuZXcgU3ludGF4RXJyb3IgKCdVbmV4cGVjdGVkIGVuZCBvZiBKU09OIGlucHV0JykpXG4gIC8vLlxuICAvLy4gPiBTLmVuY2FzZUVpdGhlciAoUy5wcm9wICgnbWVzc2FnZScpKSAoSlNPTi5wYXJzZSkgKCdbJylcbiAgLy8uIExlZnQgKCdVbmV4cGVjdGVkIGVuZCBvZiBKU09OIGlucHV0JylcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBlbmNhc2VFaXRoZXIoZikge1xuICAgIHJldHVybiBmdW5jdGlvbihnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBSaWdodCAoZyAoeCkpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gTGVmdCAoZiAoZXJyKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLmVuY2FzZUVpdGhlciA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKCQuRXJyb3IpIChsKSwgRm4gKGEpIChyKSwgYSwgJEVpdGhlciAobCkgKHIpXSxcbiAgICBpbXBsOiBlbmNhc2VFaXRoZXJcbiAgfTtcblxuICAvLyMgZW5jYXNlRWl0aGVyMiA6OiAoRXJyb3IgLT4gbCkgLT4gKGEgLT4gYiAtPiByKSAtPiBhIC0+IGIgLT4gRWl0aGVyIGwgclxuICAvLy5cbiAgLy8uIEJpbmFyeSB2ZXJzaW9uIG9mIFtgZW5jYXNlRWl0aGVyYF0oI2VuY2FzZUVpdGhlcikuXG4gIGZ1bmN0aW9uIGVuY2FzZUVpdGhlcjIoZikge1xuICAgIHJldHVybiBmdW5jdGlvbihnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gUmlnaHQgKGcgKHgpICh5KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gTGVmdCAoZiAoZXJyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uZW5jYXNlRWl0aGVyMiA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKCQuRXJyb3IpIChsKSwgRm4gKGEpIChGbiAoYikgKHIpKSwgYSwgYiwgJEVpdGhlciAobCkgKHIpXSxcbiAgICBpbXBsOiBlbmNhc2VFaXRoZXIyXG4gIH07XG5cbiAgLy8jIGVuY2FzZUVpdGhlcjMgOjogKEVycm9yIC0+IGwpIC0+IChhIC0+IGIgLT4gYyAtPiByKSAtPiBhIC0+IGIgLT4gYyAtPiBFaXRoZXIgbCByXG4gIC8vLlxuICAvLy4gVGVybmFyeSB2ZXJzaW9uIG9mIFtgZW5jYXNlRWl0aGVyYF0oI2VuY2FzZUVpdGhlcikuXG4gIGZ1bmN0aW9uIGVuY2FzZUVpdGhlcjMoZikge1xuICAgIHJldHVybiBmdW5jdGlvbihnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gUmlnaHQgKGcgKHgpICh5KSAoeikpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBMZWZ0IChmIChlcnIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uZW5jYXNlRWl0aGVyMyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKCQuRXJyb3IpIChsKSxcbiAgICAgICAgICAgIEZuIChhKSAoRm4gKGIpIChGbiAoYykgKHIpKSksXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgYixcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICAkRWl0aGVyIChsKSAocildLFxuICAgIGltcGw6IGVuY2FzZUVpdGhlcjNcbiAgfTtcblxuICAvLyMgZWl0aGVyVG9NYXliZSA6OiBFaXRoZXIgYSBiIC0+IE1heWJlIGJcbiAgLy8uXG4gIC8vLiBDb252ZXJ0cyBhbiBFaXRoZXIgdG8gYSBNYXliZS4gQSBMZWZ0IGJlY29tZXMgTm90aGluZzsgYSBSaWdodCBiZWNvbWVzXG4gIC8vLiBhIEp1c3QuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BtYXliZVRvRWl0aGVyYF0oI21heWJlVG9FaXRoZXIpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5laXRoZXJUb01heWJlIChTLkxlZnQgKCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZWl0aGVyVG9NYXliZSAoUy5SaWdodCAoNDIpKVxuICAvLy4gSnVzdCAoNDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZWl0aGVyVG9NYXliZShlaXRoZXIpIHtcbiAgICByZXR1cm4gZWl0aGVyLmlzTGVmdCA/IE5vdGhpbmcgOiBKdXN0IChlaXRoZXIudmFsdWUpO1xuICB9XG4gIF8uZWl0aGVyVG9NYXliZSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJEVpdGhlciAoYSkgKGIpLCAkTWF5YmUgKGIpXSxcbiAgICBpbXBsOiBlaXRoZXJUb01heWJlXG4gIH07XG5cbiAgLy8uICMjIyBMb2dpY1xuXG4gIC8vIyBhbmQgOjogQm9vbGVhbiAtPiBCb29sZWFuIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBCb29sZWFuIFwiYW5kXCIuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFuZCAoZmFsc2UpIChmYWxzZSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmFuZCAoZmFsc2UpICh0cnVlKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IFMuYW5kICh0cnVlKSAoZmFsc2UpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5hbmQgKHRydWUpICh0cnVlKVxuICAvLy4gdHJ1ZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFuZCh4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB4ICYmIHk7XG4gICAgfTtcbiAgfVxuICBfLmFuZCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5Cb29sZWFuLCAkLkJvb2xlYW4sICQuQm9vbGVhbl0sXG4gICAgaW1wbDogYW5kXG4gIH07XG5cbiAgLy8jIG9yIDo6IEJvb2xlYW4gLT4gQm9vbGVhbiAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gQm9vbGVhbiBcIm9yXCIuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm9yIChmYWxzZSkgKGZhbHNlKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IFMub3IgKGZhbHNlKSAodHJ1ZSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMub3IgKHRydWUpIChmYWxzZSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMub3IgKHRydWUpICh0cnVlKVxuICAvLy4gdHJ1ZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG9yKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHggfHwgeTtcbiAgICB9O1xuICB9XG4gIF8ub3IgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuQm9vbGVhbiwgJC5Cb29sZWFuLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IG9yXG4gIH07XG5cbiAgLy8jIG5vdCA6OiBCb29sZWFuIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBCb29sZWFuIFwibm90XCIuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bjb21wbGVtZW50YF0oI2NvbXBsZW1lbnQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5ub3QgKGZhbHNlKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5ub3QgKHRydWUpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG5vdCh4KSB7XG4gICAgcmV0dXJuICF4O1xuICB9XG4gIF8ubm90ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkJvb2xlYW4sICQuQm9vbGVhbl0sXG4gICAgaW1wbDogbm90XG4gIH07XG5cbiAgLy8jIGNvbXBsZW1lbnQgOjogKGEgLT4gQm9vbGVhbikgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB1bmFyeSBwcmVkaWNhdGUgYW5kIGEgdmFsdWUgb2YgYW55IHR5cGUsIGFuZCByZXR1cm5zIHRoZSBsb2dpY2FsXG4gIC8vLiBuZWdhdGlvbiBvZiBhcHBseWluZyB0aGUgcHJlZGljYXRlIHRvIHRoZSB2YWx1ZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG5vdGBdKCNub3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gTnVtYmVyLmlzSW50ZWdlciAoNDIpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmNvbXBsZW1lbnQgKE51bWJlci5pc0ludGVnZXIpICg0MilcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgXy5jb21wbGVtZW50ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlByZWRpY2F0ZSAoYSksIGEsICQuQm9vbGVhbl0sXG4gICAgaW1wbDogQiAobm90KVxuICB9O1xuXG4gIC8vIyBpZkVsc2UgOjogKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYikgLT4gKGEgLT4gYikgLT4gYSAtPiBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB1bmFyeSBwcmVkaWNhdGUsIGEgdW5hcnkgXCJpZlwiIGZ1bmN0aW9uLCBhIHVuYXJ5IFwiZWxzZVwiXG4gIC8vLiBmdW5jdGlvbiwgYW5kIGEgdmFsdWUgb2YgYW55IHR5cGUsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgLy8uIGFwcGx5aW5nIHRoZSBcImlmXCIgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGlmIHRoZSB2YWx1ZSBzYXRpc2ZpZXNcbiAgLy8uIHRoZSBwcmVkaWNhdGU7IHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIFwiZWxzZVwiIGZ1bmN0aW9uIHRvIHRoZVxuICAvLy4gdmFsdWUgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgd2hlbmBdKCN3aGVuKSBhbmQgW2B1bmxlc3NgXSgjdW5sZXNzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaWZFbHNlICh4ID0+IHggPCAwKSAoTWF0aC5hYnMpIChNYXRoLnNxcnQpICgtMSlcbiAgLy8uIDFcbiAgLy8uXG4gIC8vLiA+IFMuaWZFbHNlICh4ID0+IHggPCAwKSAoTWF0aC5hYnMpIChNYXRoLnNxcnQpICgxNilcbiAgLy8uIDRcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBpZkVsc2UocHJlZCkge1xuICAgIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICAgIHJldHVybiAocHJlZCAoeCkgPyBmIDogZykgKHgpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uaWZFbHNlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlByZWRpY2F0ZSAoYSksIEZuIChhKSAoYiksIEZuIChhKSAoYiksIGEsIGJdLFxuICAgIGltcGw6IGlmRWxzZVxuICB9O1xuXG4gIC8vIyB3aGVuIDo6IChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgdW5hcnkgcHJlZGljYXRlLCBhIHVuYXJ5IGZ1bmN0aW9uLCBhbmQgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYW5kXG4gIC8vLiByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvIHRoZSB2YWx1ZSBpZiB0aGUgdmFsdWVcbiAgLy8uIHNhdGlzZmllcyB0aGUgcHJlZGljYXRlOyB0aGUgdmFsdWUgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdW5sZXNzYF0oI3VubGVzcykgYW5kIFtgaWZFbHNlYF0oI2lmRWxzZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLndoZW4gKHggPT4geCA+PSAwKSAoTWF0aC5zcXJ0KSAoMTYpXG4gIC8vLiA0XG4gIC8vLlxuICAvLy4gPiBTLndoZW4gKHggPT4geCA+PSAwKSAoTWF0aC5zcXJ0KSAoLTEpXG4gIC8vLiAtMVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHdoZW4ocHJlZCkge1xuICAgIHJldHVybiBDIChpZkVsc2UgKHByZWQpKSAoSSk7XG4gIH1cbiAgXy53aGVuID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlByZWRpY2F0ZSAoYSksIEZuIChhKSAoYSksIGEsIGFdLFxuICAgIGltcGw6IHdoZW5cbiAgfTtcblxuICAvLyMgdW5sZXNzIDo6IChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgdW5hcnkgcHJlZGljYXRlLCBhIHVuYXJ5IGZ1bmN0aW9uLCBhbmQgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYW5kXG4gIC8vLiByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvIHRoZSB2YWx1ZSBpZiB0aGUgdmFsdWVcbiAgLy8uIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZTsgdGhlIHZhbHVlIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHdoZW5gXSgjd2hlbikgYW5kIFtgaWZFbHNlYF0oI2lmRWxzZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnVubGVzcyAoeCA9PiB4IDwgMCkgKE1hdGguc3FydCkgKDE2KVxuICAvLy4gNFxuICAvLy5cbiAgLy8uID4gUy51bmxlc3MgKHggPT4geCA8IDApIChNYXRoLnNxcnQpICgtMSlcbiAgLy8uIC0xXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdW5sZXNzKHByZWQpIHtcbiAgICByZXR1cm4gaWZFbHNlIChwcmVkKSAoSSk7XG4gIH1cbiAgXy51bmxlc3MgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlIChhKSwgRm4gKGEpIChhKSwgYSwgYV0sXG4gICAgaW1wbDogdW5sZXNzXG4gIH07XG5cbiAgLy8jIGFsbFBhc3MgOjogRm9sZGFibGUgZiA9PiBmIChhIC0+IEJvb2xlYW4pIC0+IGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RydWN0dXJlIGNvbnRhaW5pbmcgemVybyBvciBtb3JlIHByZWRpY2F0ZXMsIGFuZCBhIHZhbHVlXG4gIC8vLiBvZiBhbnkgdHlwZS4gUmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgdmFsdWUgc2F0aXNmaWVzIGFsbCBvZiB0aGVcbiAgLy8uIHByZWRpY2F0ZXMuIE5vbmUgb2YgdGhlIHN1YnNlcXVlbnQgcHJlZGljYXRlcyB3aWxsIGJlIGFwcGxpZWQgYWZ0ZXJcbiAgLy8uIHRoZSBmaXJzdCBwcmVkaWNhdGUgbm90IHNhdGlzZmllZC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYWxsUGFzcyAoW1MudGVzdCAoL3EvKSwgUy50ZXN0ICgvdS8pLCBTLnRlc3QgKC9pLyldKSAoJ3F1aWVzc2VuY2UnKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5hbGxQYXNzIChbUy50ZXN0ICgvcS8pLCBTLnRlc3QgKC91LyksIFMudGVzdCAoL2kvKV0pICgnZmlzc2lwYXJvdXMnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhbGxQYXNzKHByZWRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBaLnJlZHVjZSAoZnVuY3Rpb24oYiwgcCkgeyByZXR1cm4gYiAmJiBwICh4KTsgfSwgdHJ1ZSwgcHJlZHMpO1xuICAgIH07XG4gIH1cbiAgXy5hbGxQYXNzID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFtmICgkLlByZWRpY2F0ZSAoYSkpLCBhLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGFsbFBhc3NcbiAgfTtcblxuICAvLyMgYW55UGFzcyA6OiBGb2xkYWJsZSBmID0+IGYgKGEgLT4gQm9vbGVhbikgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdHJ1Y3R1cmUgY29udGFpbmluZyB6ZXJvIG9yIG1vcmUgcHJlZGljYXRlcywgYW5kIGEgdmFsdWVcbiAgLy8uIG9mIGFueSB0eXBlLiBSZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSB2YWx1ZSBzYXRpc2ZpZXMgYW55IG9mIHRoZVxuICAvLy4gcHJlZGljYXRlcy4gTm9uZSBvZiB0aGUgc3Vic2VxdWVudCBwcmVkaWNhdGVzIHdpbGwgYmUgYXBwbGllZCBhZnRlclxuICAvLy4gdGhlIGZpcnN0IHByZWRpY2F0ZSBzYXRpc2ZpZWQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFueVBhc3MgKFtTLnRlc3QgKC9xLyksIFMudGVzdCAoL3UvKSwgUy50ZXN0ICgvaS8pXSkgKCdpbmNhbmRlc2NlbnQnKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5hbnlQYXNzIChbUy50ZXN0ICgvcS8pLCBTLnRlc3QgKC91LyksIFMudGVzdCAoL2kvKV0pICgnZW1wYXRoeScpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFueVBhc3MocHJlZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFoucmVkdWNlIChmdW5jdGlvbihiLCBwKSB7IHJldHVybiBiIHx8IHAgKHgpOyB9LCBmYWxzZSwgcHJlZHMpO1xuICAgIH07XG4gIH1cbiAgXy5hbnlQYXNzID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFtmICgkLlByZWRpY2F0ZSAoYSkpLCBhLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGFueVBhc3NcbiAgfTtcblxuICAvLy4gIyMjIEFycmF5XG5cbiAgLy8jIHNsaWNlIDo6IEludGVnZXIgLT4gSW50ZWdlciAtPiBBcnJheSBhIC0+IE1heWJlIChBcnJheSBhKVxuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RhcnQgaW5kZXggYGlgLCBhbiBlbmQgaW5kZXggYGpgLCBhbmQgYW4gYXJyYXksIGFuZCByZXR1cm5zXG4gIC8vLiBKdXN0IHRoZSBgW2ksailgIHNsaWNlIG9mIHRoZSBhcnJheSBpZiBwb3NzaWJsZTsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLiBBIG5lZ2F0aXZlIGluZGV4IHJlcHJlc2VudHMgYW4gb2Zmc2V0IGZyb20gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B0YWtlYF0oI3Rha2UpLCBbYGRyb3BgXSgjZHJvcCksIFtgdGFrZUxhc3RgXSgjdGFrZUxhc3QpLFxuICAvLy4gYW5kIFtgZHJvcExhc3RgXSgjZHJvcExhc3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zbGljZSAoMSkgKDMpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gSnVzdCAoWydiJywgJ2MnXSlcbiAgLy8uXG4gIC8vLiA+IFMuc2xpY2UgKC0zKSAoLTEpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gSnVzdCAoWydjJywgJ2QnXSlcbiAgLy8uXG4gIC8vLiA+IFMuc2xpY2UgKDEpICg2KSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzbGljZShzdGFydCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlbmQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgICB2YXIgZnJvbUlkeCA9IHN0YXJ0IDwgMCA/IHN0YXJ0ICsgeHMubGVuZ3RoIDogc3RhcnQ7XG4gICAgICAgIHZhciB0b0lkeCA9IGVuZCA8IDAgPyBlbmQgKyB4cy5sZW5ndGggOiBlbmQ7XG5cbiAgICAgICAgcmV0dXJuIE1hdGguYWJzIChzdGFydCkgPD0geHMubGVuZ3RoICYmXG4gICAgICAgICAgICAgICBNYXRoLmFicyAoZW5kKSA8PSB4cy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgIGZyb21JZHggPD0gdG9JZHggP1xuICAgICAgICAgICAgICAgICBKdXN0ICh4cy5zbGljZSAoZnJvbUlkeCwgdG9JZHgpKSA6XG4gICAgICAgICAgICAgICAgIE5vdGhpbmc7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5zbGljZSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5JbnRlZ2VyLCAkLkludGVnZXIsICQuQXJyYXkgKGEpLCAkTWF5YmUgKCQuQXJyYXkgKGEpKV0sXG4gICAgaW1wbDogc2xpY2VcbiAgfTtcblxuICAvLyMgYXQgOjogSW50ZWdlciAtPiBBcnJheSBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgdGhlIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGFycmF5IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggaWZcbiAgLy8uIHRoZSBpbmRleCBpcyB3aXRoaW4gdGhlIGFycmF5J3MgYm91bmRzOyBOb3RoaW5nIG90aGVyd2lzZS4gQSBuZWdhdGl2ZVxuICAvLy4gaW5kZXggcmVwcmVzZW50cyBhbiBvZmZzZXQgZnJvbSB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXQgKDIpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gSnVzdCAoJ2MnKVxuICAvLy5cbiAgLy8uID4gUy5hdCAoNSkgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmF0ICgtMikgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0ICgnZCcpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYXQobikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgdmFyIGlkeCA9IG4gPCAwID8geHMubGVuZ3RoICsgbiA6IG47XG4gICAgICByZXR1cm4gaWR4IDwgMCB8fCBpZHggPj0geHMubGVuZ3RoID8gTm90aGluZyA6IEp1c3QgKHhzW2lkeF0pO1xuICAgIH07XG4gIH1cbiAgXy5hdCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5JbnRlZ2VyLCAkLkFycmF5IChhKSwgJE1heWJlIChhKV0sXG4gICAgaW1wbDogYXRcbiAgfTtcblxuICAvLyMgaGVhZCA6OiBBcnJheSBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGFycmF5IGlmIHRoZSBhcnJheSBjb250YWluc1xuICAvLy4gYXQgbGVhc3Qgb25lIGVsZW1lbnQ7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5oZWFkIChbMSwgMiwgM10pXG4gIC8vLiBKdXN0ICgxKVxuICAvLy5cbiAgLy8uID4gUy5oZWFkIChbXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBoZWFkKHhzKSB7XG4gICAgcmV0dXJuIHhzLmxlbmd0aCA+IDAgPyBKdXN0ICh4c1swXSkgOiBOb3RoaW5nO1xuICB9XG4gIF8uaGVhZCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5BcnJheSAoYSksICRNYXliZSAoYSldLFxuICAgIGltcGw6IGhlYWRcbiAgfTtcblxuICAvLyMgbGFzdCA6OiBBcnJheSBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gYXJyYXkgaWYgdGhlIGFycmF5IGNvbnRhaW5zXG4gIC8vLiBhdCBsZWFzdCBvbmUgZWxlbWVudDsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmxhc3QgKFsxLCAyLCAzXSlcbiAgLy8uIEp1c3QgKDMpXG4gIC8vLlxuICAvLy4gPiBTLmxhc3QgKFtdKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGxhc3QoeHMpIHtcbiAgICByZXR1cm4geHMubGVuZ3RoID4gMCA/IEp1c3QgKHhzW3hzLmxlbmd0aCAtIDFdKSA6IE5vdGhpbmc7XG4gIH1cbiAgXy5sYXN0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkFycmF5IChhKSwgJE1heWJlIChhKV0sXG4gICAgaW1wbDogbGFzdFxuICB9O1xuXG4gIC8vIyB0YWlsIDo6IEFycmF5IGEgLT4gTWF5YmUgKEFycmF5IGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IGFsbCBidXQgdGhlIGZpcnN0IG9mIHRoZSBnaXZlbiBhcnJheSdzIGVsZW1lbnRzIGlmIHRoZVxuICAvLy4gYXJyYXkgY29udGFpbnMgYXQgbGVhc3Qgb25lIGVsZW1lbnQ7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50YWlsIChbMSwgMiwgM10pXG4gIC8vLiBKdXN0IChbMiwgM10pXG4gIC8vLlxuICAvLy4gPiBTLnRhaWwgKFtdKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRhaWwoeHMpIHtcbiAgICByZXR1cm4geHMubGVuZ3RoID4gMCA/IEp1c3QgKHhzLnNsaWNlICgxKSkgOiBOb3RoaW5nO1xuICB9XG4gIF8udGFpbCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5BcnJheSAoYSksICRNYXliZSAoJC5BcnJheSAoYSkpXSxcbiAgICBpbXBsOiB0YWlsXG4gIH07XG5cbiAgLy8jIGluaXQgOjogQXJyYXkgYSAtPiBNYXliZSAoQXJyYXkgYSlcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgYWxsIGJ1dCB0aGUgbGFzdCBvZiB0aGUgZ2l2ZW4gYXJyYXkncyBlbGVtZW50cyBpZiB0aGVcbiAgLy8uIGFycmF5IGNvbnRhaW5zIGF0IGxlYXN0IG9uZSBlbGVtZW50OyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaW5pdCAoWzEsIDIsIDNdKVxuICAvLy4gSnVzdCAoWzEsIDJdKVxuICAvLy5cbiAgLy8uID4gUy5pbml0IChbXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBpbml0KHhzKSB7XG4gICAgcmV0dXJuIHhzLmxlbmd0aCA+IDAgPyBKdXN0ICh4cy5zbGljZSAoMCwgLTEpKSA6IE5vdGhpbmc7XG4gIH1cbiAgXy5pbml0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkFycmF5IChhKSwgJE1heWJlICgkLkFycmF5IChhKSldLFxuICAgIGltcGw6IGluaXRcbiAgfTtcblxuICAvLyMgdGFrZSA6OiBJbnRlZ2VyIC0+IEFycmF5IGEgLT4gTWF5YmUgKEFycmF5IGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IHRoZSBmaXJzdCBOIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheSBpZiBOIGlzIGdyZWF0ZXJcbiAgLy8uIHRoYW4gb3IgZXF1YWwgdG8gemVybyBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5O1xuICAvLy4gTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRha2UgKDIpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gSnVzdCAoWydhJywgJ2InXSlcbiAgLy8uXG4gIC8vLiA+IFMudGFrZSAoNSkgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0IChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy5cbiAgLy8uID4gUy50YWtlICg2KSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0YWtlKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIHJldHVybiBuID49IDAgJiYgbiA8PSB4cy5sZW5ndGggPyBKdXN0ICh4cy5zbGljZSAoMCwgbikpIDogTm90aGluZztcbiAgICB9O1xuICB9XG4gIF8udGFrZSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5JbnRlZ2VyLCAkLkFycmF5IChhKSwgJE1heWJlICgkLkFycmF5IChhKSldLFxuICAgIGltcGw6IHRha2VcbiAgfTtcblxuICAvLyMgdGFrZUxhc3QgOjogSW50ZWdlciAtPiBBcnJheSBhIC0+IE1heWJlIChBcnJheSBhKVxuICAvLy5cbiAgLy8uIFJldHVybnMgSnVzdCB0aGUgbGFzdCBOIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheSBpZiBOIGlzIGdyZWF0ZXJcbiAgLy8uIHRoYW4gb3IgZXF1YWwgdG8gemVybyBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5O1xuICAvLy4gTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRha2VMYXN0ICgyKSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QgKFsnZCcsICdlJ10pXG4gIC8vLlxuICAvLy4gPiBTLnRha2VMYXN0ICg1KSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLlxuICAvLy4gPiBTLnRha2VMYXN0ICg2KSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0YWtlTGFzdChuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHhzKSB7XG4gICAgICByZXR1cm4gbiA+PSAwICYmIG4gPD0geHMubGVuZ3RoID8gSnVzdCAoeHMuc2xpY2UgKHhzLmxlbmd0aCAtIG4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IE5vdGhpbmc7XG4gICAgfTtcbiAgfVxuICBfLnRha2VMYXN0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkludGVnZXIsICQuQXJyYXkgKGEpLCAkTWF5YmUgKCQuQXJyYXkgKGEpKV0sXG4gICAgaW1wbDogdGFrZUxhc3RcbiAgfTtcblxuICAvLyMgZHJvcCA6OiBJbnRlZ2VyIC0+IEFycmF5IGEgLT4gTWF5YmUgKEFycmF5IGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IGFsbCBidXQgdGhlIGZpcnN0IE4gZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5IGlmIE4gaXNcbiAgLy8uIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZlxuICAvLy4gdGhlIGFycmF5OyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZHJvcCAoMikgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0IChbJ2MnLCAnZCcsICdlJ10pXG4gIC8vLlxuICAvLy4gPiBTLmRyb3AgKDUpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gSnVzdCAoW10pXG4gIC8vLlxuICAvLy4gPiBTLmRyb3AgKDYpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGRyb3Aobikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgcmV0dXJuIG4gPj0gMCAmJiBuIDw9IHhzLmxlbmd0aCA/IEp1c3QgKHhzLnNsaWNlIChuKSkgOiBOb3RoaW5nO1xuICAgIH07XG4gIH1cbiAgXy5kcm9wID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkludGVnZXIsICQuQXJyYXkgKGEpLCAkTWF5YmUgKCQuQXJyYXkgKGEpKV0sXG4gICAgaW1wbDogZHJvcFxuICB9O1xuXG4gIC8vIyBkcm9wTGFzdCA6OiBJbnRlZ2VyIC0+IEFycmF5IGEgLT4gTWF5YmUgKEFycmF5IGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IGFsbCBidXQgdGhlIGxhc3QgTiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXkgaWYgTiBpc1xuICAvLy4gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8gYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mXG4gIC8vLiB0aGUgYXJyYXk7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5kcm9wTGFzdCAoMikgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0IChbJ2EnLCAnYicsICdjJ10pXG4gIC8vLlxuICAvLy4gPiBTLmRyb3BMYXN0ICg1KSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QgKFtdKVxuICAvLy5cbiAgLy8uID4gUy5kcm9wTGFzdCAoNikgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZHJvcExhc3Qobikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgcmV0dXJuIG4gPj0gMCAmJiBuIDw9IHhzLmxlbmd0aCA/IEp1c3QgKHhzLnNsaWNlICgwLCB4cy5sZW5ndGggLSBuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBOb3RoaW5nO1xuICAgIH07XG4gIH1cbiAgXy5kcm9wTGFzdCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5JbnRlZ2VyLCAkLkFycmF5IChhKSwgJE1heWJlICgkLkFycmF5IChhKSldLFxuICAgIGltcGw6IGRyb3BMYXN0XG4gIH07XG5cbiAgLy8jIHNpemUgOjogRm9sZGFibGUgZiA9PiBmIGEgLT4gSW50ZWdlclxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zaXplIChbXSlcbiAgLy8uIDBcbiAgLy8uXG4gIC8vLiA+IFMuc2l6ZSAoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gM1xuICAvLy5cbiAgLy8uID4gUy5zaXplIChOaWwpXG4gIC8vLiAwXG4gIC8vLlxuICAvLy4gPiBTLnNpemUgKENvbnMgKCdmb28nKSAoQ29ucyAoJ2JhcicpIChDb25zICgnYmF6JykgKE5pbCkpKSlcbiAgLy8uIDNcbiAgLy8uXG4gIC8vLiA+IFMuc2l6ZSAoUy5Ob3RoaW5nKVxuICAvLy4gMFxuICAvLy5cbiAgLy8uID4gUy5zaXplIChTLkp1c3QgKCdxdXV4JykpXG4gIC8vLiAxXG4gIC8vLlxuICAvLy4gPiBTLnNpemUgKFMuUGFpciAoJ2lnbm9yZWQhJykgKCdjb3VudGVkIScpKVxuICAvLy4gMVxuICAvLy4gYGBgXG4gIF8uc2l6ZSA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5Gb2xkYWJsZV19LFxuICAgIHR5cGVzOiBbZiAoYSksICQuSW50ZWdlcl0sXG4gICAgaW1wbDogWi5zaXplXG4gIH07XG5cbiAgLy8jIGFwcGVuZCA6OiAoQXBwbGljYXRpdmUgZiwgU2VtaWdyb3VwIChmIGEpKSA9PiBhIC0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwZW5kaW5nIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgc2Vjb25kLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgcHJlcGVuZGBdKCNwcmVwZW5kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXBwZW5kICgzKSAoWzEsIDJdKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLlxuICAvLy4gPiBTLmFwcGVuZCAoMykgKENvbnMgKDEpIChDb25zICgyKSAoTmlsKSkpXG4gIC8vLiBDb25zICgxKSAoQ29ucyAoMikgKENvbnMgKDMpIChOaWwpKSlcbiAgLy8uXG4gIC8vLiA+IFMuYXBwZW5kIChbMV0pIChTLk5vdGhpbmcpXG4gIC8vLiBKdXN0IChbMV0pXG4gIC8vLlxuICAvLy4gPiBTLmFwcGVuZCAoWzNdKSAoUy5KdXN0IChbMSwgMl0pKVxuICAvLy4gSnVzdCAoWzEsIDIsIDNdKVxuICAvLy4gYGBgXG4gIF8uYXBwZW5kID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFwcGxpY2F0aXZlLCBaLlNlbWlncm91cF19LFxuICAgIHR5cGVzOiBbYSwgZiAoYSksIGYgKGEpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouYXBwZW5kKVxuICB9O1xuXG4gIC8vIyBwcmVwZW5kIDo6IChBcHBsaWNhdGl2ZSBmLCBTZW1pZ3JvdXAgKGYgYSkpID0+IGEgLT4gZiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHJlc3VsdCBvZiBwcmVwZW5kaW5nIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgc2Vjb25kLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgYXBwZW5kYF0oI2FwcGVuZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnByZXBlbmQgKDEpIChbMiwgM10pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IFMucHJlcGVuZCAoMSkgKENvbnMgKDIpIChDb25zICgzKSAoTmlsKSkpXG4gIC8vLiBDb25zICgxKSAoQ29ucyAoMikgKENvbnMgKDMpIChOaWwpKSlcbiAgLy8uXG4gIC8vLiA+IFMucHJlcGVuZCAoWzFdKSAoUy5Ob3RoaW5nKVxuICAvLy4gSnVzdCAoWzFdKVxuICAvLy5cbiAgLy8uID4gUy5wcmVwZW5kIChbMV0pIChTLkp1c3QgKFsyLCAzXSkpXG4gIC8vLiBKdXN0IChbMSwgMiwgM10pXG4gIC8vLiBgYGBcbiAgXy5wcmVwZW5kID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFwcGxpY2F0aXZlLCBaLlNlbWlncm91cF19LFxuICAgIHR5cGVzOiBbYSwgZiAoYSksIGYgKGEpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFoucHJlcGVuZClcbiAgfTtcblxuICAvLyMgam9pbldpdGggOjogU3RyaW5nIC0+IEFycmF5IFN0cmluZyAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBKb2lucyB0aGUgc3RyaW5ncyBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50IHNlcGFyYXRlZCBieSB0aGUgZmlyc3QgYXJndW1lbnQuXG4gIC8vLlxuICAvLy4gUHJvcGVydGllczpcbiAgLy8uXG4gIC8vLiAgIC0gYGZvcmFsbCBzIDo6IFN0cmluZywgdCA6OiBTdHJpbmcuXG4gIC8vLiAgICAgIFMuam9pbldpdGggKHMpIChTLnNwbGl0T24gKHMpICh0KSkgPSB0YFxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc3BsaXRPbmBdKCNzcGxpdE9uKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuam9pbldpdGggKCc6JykgKFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uICdmb286YmFyOmJheidcbiAgLy8uIGBgYFxuICBfLmpvaW5XaXRoID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgJC5BcnJheSAoJC5TdHJpbmcpLCAkLlN0cmluZ10sXG4gICAgaW1wbDogaW52b2tlMSAoJ2pvaW4nKVxuICB9O1xuXG4gIC8vIyBlbGVtIDo6IChTZXRvaWQgYSwgRm9sZGFibGUgZikgPT4gYSAtPiBmIGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFRha2VzIGEgdmFsdWUgYW5kIGEgc3RydWN0dXJlIGFuZCByZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSB2YWx1ZSBpcyBhblxuICAvLy4gZWxlbWVudCBvZiB0aGUgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZmluZGBdKCNmaW5kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZWxlbSAoJ2MnKSAoWydhJywgJ2InLCAnYyddKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lbGVtICgneCcpIChbJ2EnLCAnYicsICdjJ10pXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5lbGVtICgzKSAoe3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lbGVtICg4KSAoe3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IFMuZWxlbSAoMCkgKFMuSnVzdCAoMCkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmVsZW0gKDApIChTLkp1c3QgKDEpKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IFMuZWxlbSAoMCkgKFMuTm90aGluZylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgXy5lbGVtID0ge1xuICAgIGNvbnN0czoge2E6IFtaLlNldG9pZF0sIGY6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFthLCBmIChhKSwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouZWxlbSlcbiAgfTtcblxuICAvLyMgZmluZCA6OiBGb2xkYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwcmVkaWNhdGUgYW5kIGEgc3RydWN0dXJlIGFuZCByZXR1cm5zIEp1c3QgdGhlIGxlZnRtb3N0IGVsZW1lbnRcbiAgLy8uIG9mIHRoZSBzdHJ1Y3R1cmUgd2hpY2ggc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGU7IE5vdGhpbmcgaWYgdGhlcmUgaXMgbm9cbiAgLy8uIHN1Y2ggZWxlbWVudC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGVsZW1gXSgjZWxlbSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbmQgKFMubHQgKDApKSAoWzEsIC0yLCAzLCAtNCwgNV0pXG4gIC8vLiBKdXN0ICgtMilcbiAgLy8uXG4gIC8vLiA+IFMuZmluZCAoUy5sdCAoMCkpIChbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZmluZChwcmVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHhzKSB7XG4gICAgICByZXR1cm4gWi5yZWR1Y2UgKFxuICAgICAgICBmdW5jdGlvbihtLCB4KSB7XG4gICAgICAgICAgcmV0dXJuIG0uaXNKdXN0ID8gbSA6IHByZWQgKHgpID8gSnVzdCAoeCkgOiBOb3RoaW5nO1xuICAgICAgICB9LFxuICAgICAgICBOb3RoaW5nLFxuICAgICAgICB4c1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIF8uZmluZCA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5Gb2xkYWJsZV19LFxuICAgIHR5cGVzOiBbJC5QcmVkaWNhdGUgKGEpLCBmIChhKSwgJE1heWJlIChhKV0sXG4gICAgaW1wbDogZmluZFxuICB9O1xuXG4gIC8vIyBmb2xkTWFwIDo6IChNb25vaWQgbSwgRm9sZGFibGUgZikgPT4gVHlwZVJlcCBtIC0+IChhIC0+IG0pIC0+IGYgYSAtPiBtXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5mb2xkTWFwYF1bXS4gRGVjb25zdHJ1Y3RzIGEgZm9sZGFibGUgYnkgbWFwcGluZ1xuICAvLy4gZXZlcnkgZWxlbWVudCB0byBhIG1vbm9pZCBhbmQgY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZm9sZE1hcCAoU3RyaW5nKSAoZiA9PiBmLm5hbWUpIChbTWF0aC5zaW4sIE1hdGguY29zLCBNYXRoLnRhbl0pXG4gIC8vLiAnc2luY29zdGFuJ1xuICAvLy4gYGBgXG4gIF8uZm9sZE1hcCA9IHtcbiAgICBjb25zdHM6IHtiOiBbWi5Nb25vaWRdLCBmOiBbWi5Gb2xkYWJsZV19LFxuICAgIHR5cGVzOiBbVHlwZVJlcCAoYiksIEZuIChhKSAoYiksIGYgKGEpLCBiXSxcbiAgICBpbXBsOiBjdXJyeTMgKFouZm9sZE1hcClcbiAgfTtcblxuICAvLyMgdW5mb2xkciA6OiAoYiAtPiBNYXliZSAoUGFpciBhIGIpKSAtPiBiIC0+IEFycmF5IGFcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCBhIHNlZWQgdmFsdWUsIGFuZCByZXR1cm5zIGFuIGFycmF5IGdlbmVyYXRlZCBieVxuICAvLy4gYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHJlcGVhdGVkbHkuIFRoZSBhcnJheSBpcyBpbml0aWFsbHkgZW1wdHkuIFRoZVxuICAvLy4gZnVuY3Rpb24gaXMgaW5pdGlhbGx5IGFwcGxpZWQgdG8gdGhlIHNlZWQgdmFsdWUuIEVhY2ggYXBwbGljYXRpb25cbiAgLy8uIG9mIHRoZSBmdW5jdGlvbiBzaG91bGQgcmVzdWx0IGluIGVpdGhlcjpcbiAgLy8uXG4gIC8vLiAgIC0gTm90aGluZywgaW4gd2hpY2ggY2FzZSB0aGUgYXJyYXkgaXMgcmV0dXJuZWQ7IG9yXG4gIC8vLlxuICAvLy4gICAtIEp1c3QgYSBwYWlyLCBpbiB3aGljaCBjYXNlIHRoZSBmaXJzdCBlbGVtZW50IGlzIGFwcGVuZGVkIHRvXG4gIC8vLiAgICAgdGhlIGFycmF5IGFuZCB0aGUgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUgc2Vjb25kIGVsZW1lbnQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnVuZm9sZHIgKG4gPT4gbiA8IDUgPyBTLkp1c3QgKFMuUGFpciAobikgKG4gKyAxKSkgOiBTLk5vdGhpbmcpICgxKVxuICAvLy4gWzEsIDIsIDMsIDRdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdW5mb2xkcihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIG0gPSBmICh4KTsgbS5pc0p1c3Q7IG0gPSBmIChtLnZhbHVlLnNuZCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2ggKG0udmFsdWUuZnN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBfLnVuZm9sZHIgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW0ZuIChiKSAoJE1heWJlICgkUGFpciAoYSkgKGIpKSksIGIsICQuQXJyYXkgKGEpXSxcbiAgICBpbXBsOiB1bmZvbGRyXG4gIH07XG5cbiAgLy8jIHJhbmdlIDo6IEludGVnZXIgLT4gSW50ZWdlciAtPiBBcnJheSBJbnRlZ2VyXG4gIC8vLlxuICAvLy4gUmV0dXJucyBhbiBhcnJheSBvZiBjb25zZWN1dGl2ZSBpbnRlZ2VycyBzdGFydGluZyB3aXRoIHRoZSBmaXJzdCBhcmd1bWVudFxuICAvLy4gYW5kIGVuZGluZyB3aXRoIHRoZSBzZWNvbmQgYXJndW1lbnQgbWludXMgb25lLiBSZXR1cm5zIGBbXWAgaWYgdGhlIHNlY29uZFxuICAvLy4gYXJndW1lbnQgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmFuZ2UgKDApICgxMClcbiAgLy8uIFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XVxuICAvLy5cbiAgLy8uID4gUy5yYW5nZSAoLTUpICgwKVxuICAvLy4gWy01LCAtNCwgLTMsIC0yLCAtMV1cbiAgLy8uXG4gIC8vLiA+IFMucmFuZ2UgKDApICgtNSlcbiAgLy8uIFtdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmFuZ2UoZnJvbSkge1xuICAgIHJldHVybiBmdW5jdGlvbih0bykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgbiA9IGZyb207IG4gPCB0bzsgbiArPSAxKSByZXN1bHQucHVzaCAobik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbiAgXy5yYW5nZSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5JbnRlZ2VyLCAkLkludGVnZXIsICQuQXJyYXkgKCQuSW50ZWdlcildLFxuICAgIGltcGw6IHJhbmdlXG4gIH07XG5cbiAgLy8jIGdyb3VwQnkgOjogKGEgLT4gYSAtPiBCb29sZWFuKSAtPiBBcnJheSBhIC0+IEFycmF5IChBcnJheSBhKVxuICAvLy5cbiAgLy8uIFNwbGl0cyBpdHMgYXJyYXkgYXJndW1lbnQgaW50byBhbiBhcnJheSBvZiBhcnJheXMgb2YgZXF1YWwsXG4gIC8vLiBhZGphY2VudCBlbGVtZW50cy4gRXF1YWxpdHkgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZnVuY3Rpb25cbiAgLy8uIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudC4gSXRzIGJlaGF2aW91ciBjYW4gYmUgc3VycHJpc2luZ1xuICAvLy4gZm9yIGZ1bmN0aW9ucyB0aGF0IGFyZW4ndCByZWZsZXhpdmUsIHRyYW5zaXRpdmUsIGFuZCBzeW1tZXRyaWNcbiAgLy8uIChzZWUgW2VxdWl2YWxlbmNlXVtdIHJlbGF0aW9uKS5cbiAgLy8uXG4gIC8vLiBQcm9wZXJ0aWVzOlxuICAvLy5cbiAgLy8uICAgLSBgZm9yYWxsIGYgOjogYSAtPiBhIC0+IEJvb2xlYW4sIHhzIDo6IEFycmF5IGEuXG4gIC8vLiAgICAgIFMuam9pbiAoUy5ncm91cEJ5IChmKSAoeHMpKSA9IHhzYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5ncm91cEJ5IChTLmVxdWFscykgKFsxLCAxLCAyLCAxLCAxXSlcbiAgLy8uIFtbMSwgMV0sIFsyXSwgWzEsIDFdXVxuICAvLy5cbiAgLy8uID4gUy5ncm91cEJ5ICh4ID0+IHkgPT4geCArIHkgPT09IDApIChbMiwgLTMsIDMsIDMsIDMsIDQsIC00LCA0XSlcbiAgLy8uIFtbMl0sIFstMywgMywgMywgM10sIFs0LCAtNF0sIFs0XV1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBncm91cEJ5KGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIGlmICh4cy5sZW5ndGggPT09IDApIHJldHVybiBbXTtcbiAgICAgIHZhciB4MCA9IHhzWzBdOyAgICAgICAgIC8vIDo6IGFcbiAgICAgIHZhciBhY3RpdmUgPSBbeDBdOyAgICAgIC8vIDo6IEFycmF5IGFcbiAgICAgIHZhciByZXN1bHQgPSBbYWN0aXZlXTsgIC8vIDo6IEFycmF5IChBcnJheSBhKVxuICAgICAgZm9yICh2YXIgaWR4ID0gMTsgaWR4IDwgeHMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgICB2YXIgeCA9IHhzW2lkeF07XG4gICAgICAgIGlmIChmICh4MCkgKHgpKSBhY3RpdmUucHVzaCAoeCk7IGVsc2UgcmVzdWx0LnB1c2ggKGFjdGl2ZSA9IFt4MCA9IHhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBfLmdyb3VwQnkgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW0ZuIChhKSAoJC5QcmVkaWNhdGUgKGEpKSwgJC5BcnJheSAoYSksICQuQXJyYXkgKCQuQXJyYXkgKGEpKV0sXG4gICAgaW1wbDogZ3JvdXBCeVxuICB9O1xuXG4gIC8vIyByZXZlcnNlIDo6IChBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXZlcnNlcyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmV2ZXJzZSAoWzEsIDIsIDNdKVxuICAvLy4gWzMsIDIsIDFdXG4gIC8vLlxuICAvLy4gPiBTLnJldmVyc2UgKENvbnMgKDEpIChDb25zICgyKSAoQ29ucyAoMykgKE5pbCkpKSlcbiAgLy8uIENvbnMgKDMpIChDb25zICgyKSAoQ29ucyAoMSkgKE5pbCkpKVxuICAvLy5cbiAgLy8uID4gUy5waXBlIChbUy5zcGxpdE9uICgnJyksIFMucmV2ZXJzZSwgUy5qb2luV2l0aCAoJycpXSkgKCdhYmMnKVxuICAvLy4gJ2NiYSdcbiAgLy8uIGBgYFxuICBfLnJldmVyc2UgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbGljYXRpdmUsIFouRm9sZGFibGUsIFouTW9ub2lkXX0sXG4gICAgdHlwZXM6IFtmIChhKSwgZiAoYSldLFxuICAgIGltcGw6IFoucmV2ZXJzZVxuICB9O1xuXG4gIC8vIyBzb3J0IDo6IChPcmQgYSwgQXBwbGljYXRpdmUgbSwgRm9sZGFibGUgbSwgTW9ub2lkIChtIGEpKSA9PiBtIGEgLT4gbSBhXG4gIC8vLlxuICAvLy4gUGVyZm9ybXMgYSBbc3RhYmxlIHNvcnRdW10gb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUsIHVzaW5nXG4gIC8vLiBbYFoubHRlYF1bXSBmb3IgY29tcGFyaXNvbnMuXG4gIC8vLlxuICAvLy4gUHJvcGVydGllczpcbiAgLy8uXG4gIC8vLiAgIC0gYFMuc29ydCAoUy5zb3J0IChtKSkgPSBTLnNvcnQgKG0pYCAoaWRlbXBvdGVuY2UpXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bzb3J0QnlgXSgjc29ydEJ5KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc29ydCAoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gWydiYXInLCAnYmF6JywgJ2ZvbyddXG4gIC8vLlxuICAvLy4gPiBTLnNvcnQgKFtTLkxlZnQgKDQpLCBTLlJpZ2h0ICgzKSwgUy5MZWZ0ICgyKSwgUy5SaWdodCAoMSldKVxuICAvLy4gW0xlZnQgKDIpLCBMZWZ0ICg0KSwgUmlnaHQgKDEpLCBSaWdodCAoMyldXG4gIC8vLiBgYGBcbiAgXy5zb3J0ID0ge1xuICAgIGNvbnN0czoge2E6IFtaLk9yZF0sIG06IFtaLkFwcGxpY2F0aXZlLCBaLkZvbGRhYmxlLCBaLk1vbm9pZF19LFxuICAgIHR5cGVzOiBbbSAoYSksIG0gKGEpXSxcbiAgICBpbXBsOiBaLnNvcnRcbiAgfTtcblxuICAvLyMgc29ydEJ5IDo6IChPcmQgYiwgQXBwbGljYXRpdmUgbSwgRm9sZGFibGUgbSwgTW9ub2lkIChtIGEpKSA9PiAoYSAtPiBiKSAtPiBtIGEgLT4gbSBhXG4gIC8vLlxuICAvLy4gUGVyZm9ybXMgYSBbc3RhYmxlIHNvcnRdW10gb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUsIHVzaW5nXG4gIC8vLiBbYFoubHRlYF1bXSB0byBjb21wYXJlIHRoZSB2YWx1ZXMgcHJvZHVjZWQgYnkgYXBwbHlpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uXG4gIC8vLiB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBQcm9wZXJ0aWVzOlxuICAvLy5cbiAgLy8uICAgLSBgUy5zb3J0QnkgKGYpIChTLnNvcnRCeSAoZikgKG0pKSA9IFMuc29ydEJ5IChmKSAobSlgIChpZGVtcG90ZW5jZSlcbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHNvcnRgXSgjc29ydCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNvcnRCeSAoUy5wcm9wICgncmFuaycpKSAoW1xuICAvLy4gLiAgIHtyYW5rOiA3LCBzdWl0OiAnc3BhZGVzJ30sXG4gIC8vLiAuICAge3Jhbms6IDUsIHN1aXQ6ICdoZWFydHMnfSxcbiAgLy8uIC4gICB7cmFuazogMiwgc3VpdDogJ2hlYXJ0cyd9LFxuICAvLy4gLiAgIHtyYW5rOiA1LCBzdWl0OiAnc3BhZGVzJ30sXG4gIC8vLiAuIF0pXG4gIC8vLiBbIHtyYW5rOiAyLCBzdWl0OiAnaGVhcnRzJ30sXG4gIC8vLiAuIHtyYW5rOiA1LCBzdWl0OiAnaGVhcnRzJ30sXG4gIC8vLiAuIHtyYW5rOiA1LCBzdWl0OiAnc3BhZGVzJ30sXG4gIC8vLiAuIHtyYW5rOiA3LCBzdWl0OiAnc3BhZGVzJ30gXVxuICAvLy5cbiAgLy8uID4gUy5zb3J0QnkgKFMucHJvcCAoJ3N1aXQnKSkgKFtcbiAgLy8uIC4gICB7cmFuazogNywgc3VpdDogJ3NwYWRlcyd9LFxuICAvLy4gLiAgIHtyYW5rOiA1LCBzdWl0OiAnaGVhcnRzJ30sXG4gIC8vLiAuICAge3Jhbms6IDIsIHN1aXQ6ICdoZWFydHMnfSxcbiAgLy8uIC4gICB7cmFuazogNSwgc3VpdDogJ3NwYWRlcyd9LFxuICAvLy4gLiBdKVxuICAvLy4gWyB7cmFuazogNSwgc3VpdDogJ2hlYXJ0cyd9LFxuICAvLy4gLiB7cmFuazogMiwgc3VpdDogJ2hlYXJ0cyd9LFxuICAvLy4gLiB7cmFuazogNywgc3VpdDogJ3NwYWRlcyd9LFxuICAvLy4gLiB7cmFuazogNSwgc3VpdDogJ3NwYWRlcyd9IF1cbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIElmIGRlc2NlbmRpbmcgb3JkZXIgaXMgZGVzaXJlZCwgb25lIG1heSB1c2UgW2BEZXNjZW5kaW5nYF1bXTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc29ydEJ5IChEZXNjZW5kaW5nKSAoWzgzLCA5NywgMTEwLCA5OSwgMTE2LCAxMTcsIDk3LCAxMTQsIDEyMV0pXG4gIC8vLiBbMTIxLCAxMTcsIDExNiwgMTE0LCAxMTAsIDk5LCA5NywgOTcsIDgzXVxuICAvLy4gYGBgXG4gIF8uc29ydEJ5ID0ge1xuICAgIGNvbnN0czoge2I6IFtaLk9yZF0sIG06IFtaLkFwcGxpY2F0aXZlLCBaLkZvbGRhYmxlLCBaLk1vbm9pZF19LFxuICAgIHR5cGVzOiBbRm4gKGEpIChiKSwgbSAoYSksIG0gKGEpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouc29ydEJ5KVxuICB9O1xuXG4gIC8vIyB6aXAgOjogQXJyYXkgYSAtPiBBcnJheSBiIC0+IEFycmF5IChQYWlyIGEgYilcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGFuIGFycmF5IG9mIHBhaXJzIG9mIGNvcnJlc3BvbmRpbmcgZWxlbWVudHMgZnJvbSB0aGUgZ2l2ZW5cbiAgLy8uIGFycmF5cy4gVGhlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIGFycmF5IGlzIGVxdWFsIHRvIHRoZSBsZW5ndGggb2ZcbiAgLy8uIHRoZSBzaG9ydGVyIGlucHV0IGFycmF5LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgemlwV2l0aGBdKCN6aXBXaXRoKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuemlwIChbJ2EnLCAnYiddKSAoWyd4JywgJ3knLCAneiddKVxuICAvLy4gW1BhaXIgKCdhJykgKCd4JyksIFBhaXIgKCdiJykgKCd5JyldXG4gIC8vLlxuICAvLy4gPiBTLnppcCAoWzEsIDMsIDVdKSAoWzIsIDRdKVxuICAvLy4gW1BhaXIgKDEpICgyKSwgUGFpciAoMykgKDQpXVxuICAvLy4gYGBgXG4gIF8uemlwID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkFycmF5IChhKSwgJC5BcnJheSAoYiksICQuQXJyYXkgKCRQYWlyIChhKSAoYikpXSxcbiAgICBpbXBsOiB6aXBXaXRoIChQYWlyKVxuICB9O1xuXG4gIC8vIyB6aXBXaXRoIDo6IChhIC0+IGIgLT4gYykgLT4gQXJyYXkgYSAtPiBBcnJheSBiIC0+IEFycmF5IGNcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgY29tYmluaW5nLCBwYWlyd2lzZSwgdGhlIGdpdmVuIGFycmF5cyB1c2luZyB0aGVcbiAgLy8uIGdpdmVuIGJpbmFyeSBmdW5jdGlvbi4gVGhlIGxlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIGFycmF5IGlzIGVxdWFsIHRvIHRoZVxuICAvLy4gbGVuZ3RoIG9mIHRoZSBzaG9ydGVyIGlucHV0IGFycmF5LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgemlwYF0oI3ppcCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnppcFdpdGggKGEgPT4gYiA9PiBhICsgYikgKFsnYScsICdiJ10pIChbJ3gnLCAneScsICd6J10pXG4gIC8vLiBbJ2F4JywgJ2J5J11cbiAgLy8uXG4gIC8vLiA+IFMuemlwV2l0aCAoYSA9PiBiID0+IFthLCBiXSkgKFsxLCAzLCA1XSkgKFsyLCA0XSlcbiAgLy8uIFtbMSwgMl0sIFszLCA0XV1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB6aXBXaXRoKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih5cykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBsZW4gPSBNYXRoLm1pbiAoeHMubGVuZ3RoLCB5cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW47IGlkeCArPSAxKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2ggKGYgKHhzW2lkeF0pICh5c1tpZHhdKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLnppcFdpdGggPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW0ZuIChhKSAoRm4gKGIpIChjKSksICQuQXJyYXkgKGEpLCAkLkFycmF5IChiKSwgJC5BcnJheSAoYyldLFxuICAgIGltcGw6IHppcFdpdGhcbiAgfTtcblxuICAvLy4gIyMjIE9iamVjdFxuXG4gIC8vIyBwcm9wIDo6IFN0cmluZyAtPiBhIC0+IGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHByb3BlcnR5IG5hbWUgYW5kIGFuIG9iamVjdCB3aXRoIGtub3duIHByb3BlcnRpZXMgYW5kIHJldHVybnNcbiAgLy8uIHRoZSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LiBJZiBmb3Igc29tZSByZWFzb24gdGhlIG9iamVjdFxuICAvLy4gbGFja3MgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSwgYSB0eXBlIGVycm9yIGlzIHRocm93bi5cbiAgLy8uXG4gIC8vLiBGb3IgYWNjZXNzaW5nIHByb3BlcnRpZXMgb2YgdW5jZXJ0YWluIG9iamVjdHMsIHVzZSBbYGdldGBdKCNnZXQpIGluc3RlYWQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnByb3AgKCdhJykgKHthOiAxLCBiOiAyfSlcbiAgLy8uIDFcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwcm9wKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICB2YXIgb2JqID0gdG9PYmplY3QgKHgpO1xuICAgICAgaWYgKGtleSBpbiBvYmopIHJldHVybiBvYmpba2V5XTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCfigJhwcm9w4oCZIGV4cGVjdGVkIG9iamVjdCB0byBoYXZlIGEgcHJvcGVydHkgbmFtZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAn4oCYJyArIGtleSArICfigJk7ICcgKyBzaG93ICh4KSArICcgZG9lcyBub3QnKTtcbiAgICB9O1xuICB9XG4gIF8ucHJvcCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsIGEsIGJdLFxuICAgIGltcGw6IHByb3BcbiAgfTtcblxuICAvLyMgcHJvcHMgOjogQXJyYXkgU3RyaW5nIC0+IGEgLT4gYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgcHJvcGVydHkgcGF0aCAoYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMpIGFuZCBhbiBvYmplY3Qgd2l0aFxuICAvLy4ga25vd24gc3RydWN0dXJlIGFuZCByZXR1cm5zIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGF0aC4gSWYgZm9yIHNvbWVcbiAgLy8uIHJlYXNvbiB0aGUgcGF0aCBkb2VzIG5vdCBleGlzdCwgYSB0eXBlIGVycm9yIGlzIHRocm93bi5cbiAgLy8uXG4gIC8vLiBGb3IgYWNjZXNzaW5nIHByb3BlcnR5IHBhdGhzIG9mIHVuY2VydGFpbiBvYmplY3RzLCB1c2UgW2BnZXRzYF0oI2dldHMpXG4gIC8vLiBpbnN0ZWFkLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wcm9wcyAoWydhJywgJ2InLCAnYyddKSAoe2E6IHtiOiB7YzogMX19fSlcbiAgLy8uIDFcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwcm9wcyhwYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBwYXRoLnJlZHVjZSAoZnVuY3Rpb24oeCwga2V5KSB7XG4gICAgICAgIHZhciBvYmogPSB0b09iamVjdCAoeCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqKSByZXR1cm4gb2JqW2tleV07XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IgKCfigJhwcm9wc+KAmSBleHBlY3RlZCBvYmplY3QgdG8gaGF2ZSBhIHByb3BlcnR5IGF0ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93IChwYXRoKSArICc7ICcgKyBzaG93ICh4KSArICcgZG9lcyBub3QnKTtcbiAgICAgIH0sIHgpO1xuICAgIH07XG4gIH1cbiAgXy5wcm9wcyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5BcnJheSAoJC5TdHJpbmcpLCBhLCBiXSxcbiAgICBpbXBsOiBwcm9wc1xuICB9O1xuXG4gIC8vIyBnZXQgOjogKEFueSAtPiBCb29sZWFuKSAtPiBTdHJpbmcgLT4gYSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwcmVkaWNhdGUsIGEgcHJvcGVydHkgbmFtZSwgYW5kIGFuIG9iamVjdCBhbmQgcmV0dXJucyBKdXN0IHRoZVxuICAvLy4gdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaWYgaXQgZXhpc3RzIGFuZCB0aGUgdmFsdWVcbiAgLy8uIHNhdGlzZmllcyB0aGUgZ2l2ZW4gcHJlZGljYXRlOyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGdldHNgXSgjZ2V0cykgYW5kIFtgcHJvcGBdKCNwcm9wKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZ2V0IChTLmlzICgkLk51bWJlcikpICgneCcpICh7eDogMSwgeTogMn0pXG4gIC8vLiBKdXN0ICgxKVxuICAvLy5cbiAgLy8uID4gUy5nZXQgKFMuaXMgKCQuTnVtYmVyKSkgKCd4JykgKHt4OiAnMScsIHk6ICcyJ30pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmdldCAoUy5pcyAoJC5OdW1iZXIpKSAoJ3gnKSAoe30pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmdldCAoUy5pcyAoJC5BcnJheSAoJC5OdW1iZXIpKSkgKCd4JykgKHt4OiBbMSwgMiwgM119KVxuICAvLy4gSnVzdCAoWzEsIDIsIDNdKVxuICAvLy5cbiAgLy8uID4gUy5nZXQgKFMuaXMgKCQuQXJyYXkgKCQuTnVtYmVyKSkpICgneCcpICh7eDogWzEsIDIsIDMsIG51bGxdfSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBnZXQocHJlZCkge1xuICAgIHJldHVybiBCIChCIChmaWx0ZXIgKHByZWQpKSkgKGdldF8pO1xuICB9XG4gIF8uZ2V0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlByZWRpY2F0ZSAoJC5BbnkpLCAkLlN0cmluZywgYSwgJE1heWJlIChiKV0sXG4gICAgaW1wbDogZ2V0XG4gIH07XG5cbiAgLy8jIGdldHMgOjogKEFueSAtPiBCb29sZWFuKSAtPiBBcnJheSBTdHJpbmcgLT4gYSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwcmVkaWNhdGUsIGEgcHJvcGVydHkgcGF0aCAoYW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMpLCBhbmRcbiAgLy8uIGFuIG9iamVjdCBhbmQgcmV0dXJucyBKdXN0IHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGF0aCBpZiBzdWNoIGEgcGF0aFxuICAvLy4gZXhpc3RzIGFuZCB0aGUgdmFsdWUgc2F0aXNmaWVzIHRoZSBnaXZlbiBwcmVkaWNhdGU7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZ2V0YF0oI2dldCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmdldHMgKFMuaXMgKCQuTnVtYmVyKSkgKFsnYScsICdiJywgJ2MnXSkgKHthOiB7Yjoge2M6IDQyfX19KVxuICAvLy4gSnVzdCAoNDIpXG4gIC8vLlxuICAvLy4gPiBTLmdldHMgKFMuaXMgKCQuTnVtYmVyKSkgKFsnYScsICdiJywgJ2MnXSkgKHthOiB7Yjoge2M6ICc0Mid9fX0pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmdldHMgKFMuaXMgKCQuTnVtYmVyKSkgKFsnYScsICdiJywgJ2MnXSkgKHt9KVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGdldHMocHJlZCkge1xuICAgIHJldHVybiBmdW5jdGlvbihrZXlzKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gWi5maWx0ZXIgKHByZWQsIGtleXMucmVkdWNlIChmdW5jdGlvbihtYXliZSwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFouY2hhaW4gKGdldF8gKGtleSksIG1heWJlKTtcbiAgICAgICAgfSwgSnVzdCAoeCkpKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLmdldHMgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlICgkLkFueSksICQuQXJyYXkgKCQuU3RyaW5nKSwgYSwgJE1heWJlIChiKV0sXG4gICAgaW1wbDogZ2V0c1xuICB9O1xuXG4gIC8vLiAjIyMgU3RyTWFwXG4gIC8vLlxuICAvLy4gU3RyTWFwIGlzIGFuIGFiYnJldmlhdGlvbiBvZiBfc3RyaW5nIG1hcF8uIEEgc3RyaW5nIG1hcCBpcyBhbiBvYmplY3QsXG4gIC8vLiBzdWNoIGFzIGB7Zm9vOiAxLCBiYXI6IDIsIGJhejogM31gLCB3aG9zZSB2YWx1ZXMgYXJlIGFsbCBtZW1iZXJzIG9mXG4gIC8vLiB0aGUgc2FtZSB0eXBlLiBGb3JtYWxseSwgYSB2YWx1ZSBpcyBhIG1lbWJlciBvZiB0eXBlIGBTdHJNYXAgYWAgaWYgaXRzXG4gIC8vLiBbdHlwZSBpZGVudGlmaWVyXVtdIGlzIGAnT2JqZWN0J2AgYW5kIHRoZSB2YWx1ZXMgb2YgaXRzIGVudW1lcmFibGUgb3duXG4gIC8vLiBwcm9wZXJ0aWVzIGFyZSBhbGwgbWVtYmVycyBvZiB0eXBlIGBhYC5cblxuICAvLyMgc2luZ2xldG9uIDo6IFN0cmluZyAtPiBhIC0+IFN0ck1hcCBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdHJpbmcgYW5kIGEgdmFsdWUgb2YgYW55IHR5cGUsIGFuZCByZXR1cm5zIGEgc3RyaW5nIG1hcCB3aXRoXG4gIC8vLiBhIHNpbmdsZSBlbnRyeSAobWFwcGluZyB0aGUga2V5IHRvIHRoZSB2YWx1ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNpbmdsZXRvbiAoJ2ZvbycpICg0MilcbiAgLy8uIHtmb286IDQyfVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNpbmdsZXRvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgc3RyTWFwID0ge307XG4gICAgICBzdHJNYXBba2V5XSA9IHZhbDtcbiAgICAgIHJldHVybiBzdHJNYXA7XG4gICAgfTtcbiAgfVxuICBfLnNpbmdsZXRvbiA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsIGEsICQuU3RyTWFwIChhKV0sXG4gICAgaW1wbDogc2luZ2xldG9uXG4gIH07XG5cbiAgLy8jIGluc2VydCA6OiBTdHJpbmcgLT4gYSAtPiBTdHJNYXAgYSAtPiBTdHJNYXAgYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RyaW5nLCBhIHZhbHVlIG9mIGFueSB0eXBlLCBhbmQgYSBzdHJpbmcgbWFwLCBhbmQgcmV0dXJucyBhXG4gIC8vLiBzdHJpbmcgbWFwIGNvbXByaXNpbmcgYWxsIHRoZSBlbnRyaWVzIG9mIHRoZSBnaXZlbiBzdHJpbmcgbWFwIHBsdXMgdGhlXG4gIC8vLiBlbnRyeSBzcGVjaWZpZWQgYnkgdGhlIGZpcnN0IHR3byBhcmd1bWVudHMgKHdoaWNoIHRha2VzIHByZWNlZGVuY2UpLlxuICAvLy5cbiAgLy8uIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGBpbnNlcnRgIGZ1bmN0aW9uLiBTaW1pbGFyIHRvIENsb2p1cmUncyBgYXNzb2NgXG4gIC8vLiBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaW5zZXJ0ICgnYycpICgzKSAoe2E6IDEsIGI6IDJ9KVxuICAvLy4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gIC8vLlxuICAvLy4gPiBTLmluc2VydCAoJ2EnKSAoNCkgKHthOiAxLCBiOiAyfSlcbiAgLy8uIHthOiA0LCBiOiAyfVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGluc2VydChrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyTWFwKSB7XG4gICAgICAgIHJldHVybiBaLmNvbmNhdCAoc3RyTWFwLCBzaW5nbGV0b24gKGtleSkgKHZhbCkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uaW5zZXJ0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgYSwgJC5TdHJNYXAgKGEpLCAkLlN0ck1hcCAoYSldLFxuICAgIGltcGw6IGluc2VydFxuICB9O1xuXG4gIC8vIyByZW1vdmUgOjogU3RyaW5nIC0+IFN0ck1hcCBhIC0+IFN0ck1hcCBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdHJpbmcgYW5kIGEgc3RyaW5nIG1hcCwgYW5kIHJldHVybnMgYSBzdHJpbmcgbWFwIGNvbXByaXNpbmcgYWxsXG4gIC8vLiB0aGUgZW50cmllcyBvZiB0aGUgZ2l2ZW4gc3RyaW5nIG1hcCBleGNlcHQgdGhlIG9uZSB3aG9zZSBrZXkgbWF0Y2hlcyB0aGVcbiAgLy8uIGdpdmVuIHN0cmluZyAoaWYgc3VjaCBhIGtleSBleGlzdHMpLlxuICAvLy5cbiAgLy8uIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGBkZWxldGVgIGZ1bmN0aW9uLiBTaW1pbGFyIHRvIENsb2p1cmUncyBgZGlzc29jYFxuICAvLy4gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlbW92ZSAoJ2MnKSAoe2E6IDEsIGI6IDIsIGM6IDN9KVxuICAvLy4ge2E6IDEsIGI6IDJ9XG4gIC8vLlxuICAvLy4gPiBTLnJlbW92ZSAoJ2MnKSAoe30pXG4gIC8vLiB7fVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJlbW92ZShrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyTWFwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gWi5jb25jYXQgKHN0ck1hcCwge30pO1xuICAgICAgZGVsZXRlIHJlc3VsdFtrZXldO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIF8ucmVtb3ZlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgJC5TdHJNYXAgKGEpLCAkLlN0ck1hcCAoYSldLFxuICAgIGltcGw6IHJlbW92ZVxuICB9O1xuXG4gIC8vIyBrZXlzIDo6IFN0ck1hcCBhIC0+IEFycmF5IFN0cmluZ1xuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIGtleXMgb2YgdGhlIGdpdmVuIHN0cmluZyBtYXAsIGluIGFyYml0cmFyeSBvcmRlci5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc29ydCAoUy5rZXlzICh7YjogMiwgYzogMywgYTogMX0pKVxuICAvLy4gWydhJywgJ2InLCAnYyddXG4gIC8vLiBgYGBcbiAgXy5rZXlzID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0ck1hcCAoYSksICQuQXJyYXkgKCQuU3RyaW5nKV0sXG4gICAgaW1wbDogT2JqZWN0LmtleXNcbiAgfTtcblxuICAvLyMgdmFsdWVzIDo6IFN0ck1hcCBhIC0+IEFycmF5IGFcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIHN0cmluZyBtYXAsIGluIGFyYml0cmFyeSBvcmRlci5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc29ydCAoUy52YWx1ZXMgKHthOiAxLCBjOiAzLCBiOiAyfSkpXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB2YWx1ZXMoc3RyTWFwKSB7XG4gICAgcmV0dXJuIFoubWFwIChmdW5jdGlvbihrKSB7IHJldHVybiBzdHJNYXBba107IH0sIE9iamVjdC5rZXlzIChzdHJNYXApKTtcbiAgfVxuICBfLnZhbHVlcyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJNYXAgKGEpLCAkLkFycmF5IChhKV0sXG4gICAgaW1wbDogdmFsdWVzXG4gIH07XG5cbiAgLy8jIHBhaXJzIDo6IFN0ck1hcCBhIC0+IEFycmF5IChQYWlyIFN0cmluZyBhKVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIGtleeKAk3ZhbHVlIHBhaXJzIG9mIHRoZSBnaXZlbiBzdHJpbmcgbWFwLCBpbiBhcmJpdHJhcnkgb3JkZXIuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNvcnQgKFMucGFpcnMgKHtiOiAyLCBhOiAxLCBjOiAzfSkpXG4gIC8vLiBbUGFpciAoJ2EnKSAoMSksIFBhaXIgKCdiJykgKDIpLCBQYWlyICgnYycpICgzKV1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwYWlycyhzdHJNYXApIHtcbiAgICByZXR1cm4gWi5tYXAgKGZ1bmN0aW9uKGspIHsgcmV0dXJuIFBhaXIgKGspIChzdHJNYXBba10pOyB9LFxuICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMgKHN0ck1hcCkpO1xuICB9XG4gIF8ucGFpcnMgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyTWFwIChhKSwgJC5BcnJheSAoJFBhaXIgKCQuU3RyaW5nKSAoYSkpXSxcbiAgICBpbXBsOiBwYWlyc1xuICB9O1xuXG4gIC8vIyBmcm9tUGFpcnMgOjogRm9sZGFibGUgZiA9PiBmIChQYWlyIFN0cmluZyBhKSAtPiBTdHJNYXAgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgYSBzdHJpbmcgbWFwIGNvbnRhaW5pbmcgdGhlIGtleeKAk3ZhbHVlIHBhaXJzIHNwZWNpZmllZCBieSB0aGVcbiAgLy8uIGdpdmVuIFtGb2xkYWJsZV1bXS4gSWYgYSBrZXkgYXBwZWFycyBpbiBtdWx0aXBsZSBwYWlycywgdGhlIHJpZ2h0bW9zdFxuICAvLy4gcGFpciB0YWtlcyBwcmVjZWRlbmNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5mcm9tUGFpcnMgKFtTLlBhaXIgKCdhJykgKDEpLCBTLlBhaXIgKCdiJykgKDIpLCBTLlBhaXIgKCdjJykgKDMpXSlcbiAgLy8uIHthOiAxLCBiOiAyLCBjOiAzfVxuICAvLy5cbiAgLy8uID4gUy5mcm9tUGFpcnMgKFtTLlBhaXIgKCd4JykgKDEpLCBTLlBhaXIgKCd4JykgKDIpXSlcbiAgLy8uIHt4OiAyfVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgIHJldHVybiBaLnJlZHVjZSAoZnVuY3Rpb24oc3RyTWFwLCBwYWlyKSB7XG4gICAgICBzdHJNYXBbcGFpci5mc3RdID0gcGFpci5zbmQ7XG4gICAgICByZXR1cm4gc3RyTWFwO1xuICAgIH0sIHt9LCBwYWlycyk7XG4gIH1cbiAgXy5mcm9tUGFpcnMgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRm9sZGFibGVdfSxcbiAgICB0eXBlczogW2YgKCRQYWlyICgkLlN0cmluZykgKGEpKSwgJC5TdHJNYXAgKGEpXSxcbiAgICBpbXBsOiBmcm9tUGFpcnNcbiAgfTtcblxuICAvLy4gIyMjIE51bWJlclxuXG4gIC8vIyBuZWdhdGUgOjogVmFsaWROdW1iZXIgLT4gVmFsaWROdW1iZXJcbiAgLy8uXG4gIC8vLiBOZWdhdGVzIGl0cyBhcmd1bWVudC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubmVnYXRlICgxMi41KVxuICAvLy4gLTEyLjVcbiAgLy8uXG4gIC8vLiA+IFMubmVnYXRlICgtNDIpXG4gIC8vLiA0MlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG5lZ2F0ZShuKSB7XG4gICAgcmV0dXJuIC1uO1xuICB9XG4gIF8ubmVnYXRlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlZhbGlkTnVtYmVyLCAkLlZhbGlkTnVtYmVyXSxcbiAgICBpbXBsOiBuZWdhdGVcbiAgfTtcblxuICAvLyMgYWRkIDo6IEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgc3VtIG9mIHR3byAoZmluaXRlKSBudW1iZXJzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hZGQgKDEpICgxKVxuICAvLy4gMlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFkZCh4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB4ICsgeTtcbiAgICB9O1xuICB9XG4gIF8uYWRkID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyXSxcbiAgICBpbXBsOiBhZGRcbiAgfTtcblxuICAvLyMgc3VtIDo6IEZvbGRhYmxlIGYgPT4gZiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgc3VtIG9mIHRoZSBnaXZlbiBhcnJheSBvZiAoZmluaXRlKSBudW1iZXJzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zdW0gKFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIDE1XG4gIC8vLlxuICAvLy4gPiBTLnN1bSAoW10pXG4gIC8vLiAwXG4gIC8vLlxuICAvLy4gPiBTLnN1bSAoUy5KdXN0ICg0MikpXG4gIC8vLiA0MlxuICAvLy5cbiAgLy8uID4gUy5zdW0gKFMuTm90aGluZylcbiAgLy8uIDBcbiAgLy8uIGBgYFxuICBfLnN1bSA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5Gb2xkYWJsZV19LFxuICAgIHR5cGVzOiBbZiAoJC5GaW5pdGVOdW1iZXIpLCAkLkZpbml0ZU51bWJlcl0sXG4gICAgaW1wbDogcmVkdWNlIChhZGQpICgwKVxuICB9O1xuXG4gIC8vIyBzdWIgOjogRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZpbml0ZSBudW1iZXIgYG5gIGFuZCByZXR1cm5zIHRoZSBfc3VidHJhY3QgYG5gXyBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwIChTLnN1YiAoMSkpIChbMSwgMiwgM10pXG4gIC8vLiBbMCwgMSwgMl1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzdWIoeSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4geCAtIHk7XG4gICAgfTtcbiAgfVxuICBfLnN1YiA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyLCAkLkZpbml0ZU51bWJlcl0sXG4gICAgaW1wbDogc3ViXG4gIH07XG5cbiAgLy8jIG11bHQgOjogRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHR3byAoZmluaXRlKSBudW1iZXJzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tdWx0ICg0KSAoMilcbiAgLy8uIDhcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtdWx0KHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHggKiB5O1xuICAgIH07XG4gIH1cbiAgXy5tdWx0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyXSxcbiAgICBpbXBsOiBtdWx0XG4gIH07XG5cbiAgLy8jIHByb2R1Y3QgOjogRm9sZGFibGUgZiA9PiBmIEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoZSBnaXZlbiBhcnJheSBvZiAoZmluaXRlKSBudW1iZXJzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wcm9kdWN0IChbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiAxMjBcbiAgLy8uXG4gIC8vLiA+IFMucHJvZHVjdCAoW10pXG4gIC8vLiAxXG4gIC8vLlxuICAvLy4gPiBTLnByb2R1Y3QgKFMuSnVzdCAoNDIpKVxuICAvLy4gNDJcbiAgLy8uXG4gIC8vLiA+IFMucHJvZHVjdCAoUy5Ob3RoaW5nKVxuICAvLy4gMVxuICAvLy4gYGBgXG4gIF8ucHJvZHVjdCA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5Gb2xkYWJsZV19LFxuICAgIHR5cGVzOiBbZiAoJC5GaW5pdGVOdW1iZXIpLCAkLkZpbml0ZU51bWJlcl0sXG4gICAgaW1wbDogcmVkdWNlIChtdWx0KSAoMSlcbiAgfTtcblxuICAvLyMgZGl2IDo6IE5vblplcm9GaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlclxuICAvLy5cbiAgLy8uIFRha2VzIGEgbm9uLXplcm8gZmluaXRlIG51bWJlciBgbmAgYW5kIHJldHVybnMgdGhlIF9kaXZpZGUgYnkgYG5gX1xuICAvLy4gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcCAoUy5kaXYgKDIpKSAoWzAsIDEsIDIsIDNdKVxuICAvLy4gWzAsIDAuNSwgMSwgMS41XVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGRpdih5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4IC8geTtcbiAgICB9O1xuICB9XG4gIF8uZGl2ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLk5vblplcm9GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyLCAkLkZpbml0ZU51bWJlcl0sXG4gICAgaW1wbDogZGl2XG4gIH07XG5cbiAgLy8jIHBvdyA6OiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlclxuICAvLy5cbiAgLy8uIFRha2VzIGEgZmluaXRlIG51bWJlciBgbmAgYW5kIHJldHVybnMgdGhlIF9wb3dlciBvZiBgbmBfIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXAgKFMucG93ICgyKSkgKFstMywgLTIsIC0xLCAwLCAxLCAyLCAzXSlcbiAgLy8uIFs5LCA0LCAxLCAwLCAxLCA0LCA5XVxuICAvLy5cbiAgLy8uID4gUy5tYXAgKFMucG93ICgwLjUpKSAoWzEsIDQsIDksIDE2LCAyNV0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNV1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwb3coZXhwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdyAoYmFzZSwgZXhwKTtcbiAgICB9O1xuICB9XG4gIF8ucG93ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyXSxcbiAgICBpbXBsOiBwb3dcbiAgfTtcblxuICAvLyMgbWVhbiA6OiBGb2xkYWJsZSBmID0+IGYgRmluaXRlTnVtYmVyIC0+IE1heWJlIEZpbml0ZU51bWJlclxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIG1lYW4gb2YgdGhlIGdpdmVuIGFycmF5IG9mIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1lYW4gKFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIEp1c3QgKDMpXG4gIC8vLlxuICAvLy4gPiBTLm1lYW4gKFtdKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5tZWFuIChTLkp1c3QgKDQyKSlcbiAgLy8uIEp1c3QgKDQyKVxuICAvLy5cbiAgLy8uID4gUy5tZWFuIChTLk5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbWVhbihmb2xkYWJsZSkge1xuICAgIHZhciByZXN1bHQgPSBaLnJlZHVjZSAoXG4gICAgICBmdW5jdGlvbihhY2MsIG4pIHtcbiAgICAgICAgYWNjLnRvdGFsICs9IG47XG4gICAgICAgIGFjYy5jb3VudCArPSAxO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt0b3RhbDogMCwgY291bnQ6IDB9LFxuICAgICAgZm9sZGFibGVcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQuY291bnQgPiAwID8gSnVzdCAocmVzdWx0LnRvdGFsIC8gcmVzdWx0LmNvdW50KSA6IE5vdGhpbmc7XG4gIH1cbiAgXy5tZWFuID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFtmICgkLkZpbml0ZU51bWJlciksICRNYXliZSAoJC5GaW5pdGVOdW1iZXIpXSxcbiAgICBpbXBsOiBtZWFuXG4gIH07XG5cbiAgLy8uICMjIyBJbnRlZ2VyXG5cbiAgLy8jIGV2ZW4gOjogSW50ZWdlciAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVnZXIgaXMgZXZlbjsgYGZhbHNlYCBpZiBpdCBpcyBvZGQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmV2ZW4gKDQyKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5ldmVuICg5OSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZXZlbihuKSB7XG4gICAgcmV0dXJuIG4gJSAyID09PSAwO1xuICB9XG4gIF8uZXZlbiA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5JbnRlZ2VyLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGV2ZW5cbiAgfTtcblxuICAvLyMgb2RkIDo6IEludGVnZXIgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIHRoZSBnaXZlbiBpbnRlZ2VyIGlzIG9kZDsgYGZhbHNlYCBpZiBpdCBpcyBldmVuLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5vZGQgKDk5KVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5vZGQgKDQyKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBvZGQobikge1xuICAgIHJldHVybiBuICUgMiAhPT0gMDtcbiAgfVxuICBfLm9kZCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5JbnRlZ2VyLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IG9kZFxuICB9O1xuXG4gIC8vLiAjIyMgUGFyc2VcblxuICAvLyMgcGFyc2VEYXRlIDo6IFN0cmluZyAtPiBNYXliZSBWYWxpZERhdGVcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cmluZyBhbmQgcmV0dXJucyBKdXN0IHRoZSBkYXRlIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmdcbiAgLy8uIGlmIGl0IGRvZXMgaW4gZmFjdCByZXByZXNlbnQgYSBkYXRlOyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucGFyc2VEYXRlICgnMjAxMS0wMS0xOVQxNzo0MDowMFonKVxuICAvLy4gSnVzdCAobmV3IERhdGUgKCcyMDExLTAxLTE5VDE3OjQwOjAwLjAwMFonKSlcbiAgLy8uXG4gIC8vLiA+IFMucGFyc2VEYXRlICgndG9kYXknKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBhcnNlRGF0ZShzKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSAocyk7XG4gICAgcmV0dXJuIGlzTmFOIChkYXRlLnZhbHVlT2YgKCkpID8gTm90aGluZyA6IEp1c3QgKGRhdGUpO1xuICB9XG4gIF8ucGFyc2VEYXRlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgJE1heWJlICgkLlZhbGlkRGF0ZSldLFxuICAgIGltcGw6IHBhcnNlRGF0ZVxuICB9O1xuXG4gIC8vICByZXF1aXJlZE5vbkNhcHR1cmluZ0dyb3VwIDo6IEFycmF5IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gcmVxdWlyZWROb25DYXB0dXJpbmdHcm91cCh4cykge1xuICAgIHJldHVybiAnKD86JyArIHhzLmpvaW4gKCd8JykgKyAnKSc7XG4gIH1cblxuICAvLyAgb3B0aW9uYWxOb25DYXB0dXJpbmdHcm91cCA6OiBBcnJheSBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIG9wdGlvbmFsTm9uQ2FwdHVyaW5nR3JvdXAoeHMpIHtcbiAgICByZXR1cm4gcmVxdWlyZWROb25DYXB0dXJpbmdHcm91cCAoeHMpICsgJz8nO1xuICB9XG5cbiAgLy8gIHZhbGlkRmxvYXRSZXByIDo6IFJlZ0V4cFxuICB2YXIgdmFsaWRGbG9hdFJlcHIgPSBuZXcgUmVnRXhwIChcbiAgICAnXicgKyAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0LW9mLXN0cmluZyBhbmNob3JcbiAgICAnXFxcXHMqJyArICAgICAgICAgICAgICAgICAgLy8gYW55IG51bWJlciBvZiBsZWFkaW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuICAgICdbKy1dPycgKyAgICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwgc2lnblxuICAgIHJlcXVpcmVkTm9uQ2FwdHVyaW5nR3JvdXAgKFtcbiAgICAgICdJbmZpbml0eScsICAgICAgICAgICAgIC8vIFwiSW5maW5pdHlcIlxuICAgICAgJ05hTicsICAgICAgICAgICAgICAgICAgLy8gXCJOYU5cIlxuICAgICAgcmVxdWlyZWROb25DYXB0dXJpbmdHcm91cCAoW1xuICAgICAgICAnWzAtOV0rJywgICAgICAgICAgICAgLy8gbnVtYmVyXG4gICAgICAgICdbMC05XStbLl1bMC05XSsnLCAgICAvLyBudW1iZXIgd2l0aCBpbnRlcmlvciBkZWNpbWFsIHBvaW50XG4gICAgICAgICdbMC05XStbLl0nLCAgICAgICAgICAvLyBudW1iZXIgd2l0aCB0cmFpbGluZyBkZWNpbWFsIHBvaW50XG4gICAgICAgICdbLl1bMC05XSsnICAgICAgICAgICAvLyBudW1iZXIgd2l0aCBsZWFkaW5nIGRlY2ltYWwgcG9pbnRcbiAgICAgIF0pICtcbiAgICAgIG9wdGlvbmFsTm9uQ2FwdHVyaW5nR3JvdXAgKFtcbiAgICAgICAgJ1tFZV0nICsgICAgICAgICAgICAgIC8vIFwiRVwiIG9yIFwiZVwiXG4gICAgICAgICdbKy1dPycgKyAgICAgICAgICAgICAvLyBvcHRpb25hbCBzaWduXG4gICAgICAgICdbMC05XSsnICAgICAgICAgICAgICAvLyBleHBvbmVudFxuICAgICAgXSlcbiAgICBdKSArXG4gICAgJ1xcXFxzKicgKyAgICAgICAgICAgICAgICAgIC8vIGFueSBudW1iZXIgb2YgdHJhaWxpbmcgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgJyQnICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIGFuY2hvclxuICApO1xuXG4gIC8vIyBwYXJzZUZsb2F0IDo6IFN0cmluZyAtPiBNYXliZSBOdW1iZXJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cmluZyBhbmQgcmV0dXJucyBKdXN0IHRoZSBudW1iZXIgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZ1xuICAvLy4gaWYgaXQgZG9lcyBpbiBmYWN0IHJlcHJlc2VudCBhIG51bWJlcjsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnBhcnNlRmxvYXQgKCctMTIzLjQ1JylcbiAgLy8uIEp1c3QgKC0xMjMuNDUpXG4gIC8vLlxuICAvLy4gPiBTLnBhcnNlRmxvYXQgKCdmb28uYmFyJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwYXJzZUZsb2F0XyhzKSB7XG4gICAgcmV0dXJuIHZhbGlkRmxvYXRSZXByLnRlc3QgKHMpID8gSnVzdCAocGFyc2VGbG9hdCAocykpIDogTm90aGluZztcbiAgfVxuICBfLnBhcnNlRmxvYXQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkTWF5YmUgKCQuTnVtYmVyKV0sXG4gICAgaW1wbDogcGFyc2VGbG9hdF9cbiAgfTtcblxuICAvLyAgUmFkaXggOjogVHlwZVxuICB2YXIgUmFkaXggPSAkLk51bGxhcnlUeXBlXG4gICAgKCdzYW5jdHVhcnkvUmFkaXgnKVxuICAgICgnJylcbiAgICAoZnVuY3Rpb24oeCkgeyByZXR1cm4gJC5JbnRlZ2VyLl90ZXN0ICh4KSAmJiB4ID49IDIgJiYgeCA8PSAzNjsgfSk7XG5cbiAgLy8jIHBhcnNlSW50IDo6IFJhZGl4IC0+IFN0cmluZyAtPiBNYXliZSBJbnRlZ2VyXG4gIC8vLlxuICAvLy4gVGFrZXMgYSByYWRpeCAoYW4gaW50ZWdlciBiZXR3ZWVuIDIgYW5kIDM2IGluY2x1c2l2ZSkgYW5kIGEgc3RyaW5nLFxuICAvLy4gYW5kIHJldHVybnMgSnVzdCB0aGUgbnVtYmVyIHJlcHJlc2VudGVkIGJ5IHRoZSBzdHJpbmcgaWYgaXQgZG9lcyBpblxuICAvLy4gZmFjdCByZXByZXNlbnQgYSBudW1iZXIgaW4gdGhlIGJhc2Ugc3BlY2lmaWVkIGJ5IHRoZSByYWRpeDsgTm90aGluZ1xuICAvLy4gb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgc3RyaWN0ZXIgdGhhbiBbYHBhcnNlSW50YF1bcGFyc2VJbnRdOiBhIHN0cmluZ1xuICAvLy4gaXMgY29uc2lkZXJlZCB0byByZXByZXNlbnQgYW4gaW50ZWdlciBvbmx5IGlmIGFsbCBpdHMgbm9uLXByZWZpeFxuICAvLy4gY2hhcmFjdGVycyBhcmUgbWVtYmVycyBvZiB0aGUgY2hhcmFjdGVyIHNldCBzcGVjaWZpZWQgYnkgdGhlIHJhZGl4LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wYXJzZUludCAoMTApICgnLTQyJylcbiAgLy8uIEp1c3QgKC00MilcbiAgLy8uXG4gIC8vLiA+IFMucGFyc2VJbnQgKDE2KSAoJzB4RkYnKVxuICAvLy4gSnVzdCAoMjU1KVxuICAvLy5cbiAgLy8uID4gUy5wYXJzZUludCAoMTYpICgnMHhHRycpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcGFyc2VJbnRfKHJhZGl4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBjaGFyc2V0ID0gJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWicuc2xpY2UgKDAsIHJhZGl4KTtcbiAgICAgIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cCAoJ15bJyArIGNoYXJzZXQgKyAnXSskJywgJ2knKTtcblxuICAgICAgdmFyIHQgPSBzLnJlcGxhY2UgKC9eWystXS8sICcnKTtcbiAgICAgIGlmIChwYXR0ZXJuLnRlc3QgKHJhZGl4ID09PSAxNiA/IHQucmVwbGFjZSAoL14weC9pLCAnJykgOiB0KSkge1xuICAgICAgICB2YXIgbiA9IHBhcnNlSW50IChzLCByYWRpeCk7XG4gICAgICAgIGlmICgkLkludGVnZXIuX3Rlc3QgKG4pKSByZXR1cm4gSnVzdCAobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gTm90aGluZztcbiAgICB9O1xuICB9XG4gIF8ucGFyc2VJbnQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW1JhZGl4LCAkLlN0cmluZywgJE1heWJlICgkLkludGVnZXIpXSxcbiAgICBpbXBsOiBwYXJzZUludF9cbiAgfTtcblxuICAvLyMgcGFyc2VKc29uIDo6IChBbnkgLT4gQm9vbGVhbikgLT4gU3RyaW5nIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBzdHJpbmcgd2hpY2ggbWF5IG9yIG1heSBub3QgYmUgdmFsaWQgSlNPTiwgYW5kXG4gIC8vLiByZXR1cm5zIEp1c3QgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgSlNPTi5wYXJzZWAgdG8gdGhlIHN0cmluZyAqaWYqIHRoZVxuICAvLy4gcmVzdWx0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlOyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucGFyc2VKc29uIChTLmlzICgkLkFycmF5ICgkLkludGVnZXIpKSkgKCdbJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMucGFyc2VKc29uIChTLmlzICgkLkFycmF5ICgkLkludGVnZXIpKSkgKCdbXCIxXCIsXCIyXCIsXCIzXCJdJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMucGFyc2VKc29uIChTLmlzICgkLkFycmF5ICgkLkludGVnZXIpKSkgKCdbMCwxLjUsMyw0LjVdJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMucGFyc2VKc29uIChTLmlzICgkLkFycmF5ICgkLkludGVnZXIpKSkgKCdbMSwyLDNdJylcbiAgLy8uIEp1c3QgKFsxLCAyLCAzXSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwYXJzZUpzb24ocHJlZCkge1xuICAgIHJldHVybiBCIChmaWx0ZXIgKHByZWQpKSAoZW5jYXNlIChKU09OLnBhcnNlKSk7XG4gIH1cbiAgXy5wYXJzZUpzb24gPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlICgkLkFueSksICQuU3RyaW5nLCAkTWF5YmUgKGEpXSxcbiAgICBpbXBsOiBwYXJzZUpzb25cbiAgfTtcblxuICAvLy4gIyMjIFJlZ0V4cFxuXG4gIC8vICBNYXRjaCA6OiBUeXBlXG4gIHZhciBNYXRjaCA9ICQuUmVjb3JkVHlwZSAoe1xuICAgIG1hdGNoOiAkLlN0cmluZyxcbiAgICBncm91cHM6ICQuQXJyYXkgKCRNYXliZSAoJC5TdHJpbmcpKVxuICB9KTtcblxuICAvLyAgdG9NYXRjaCA6OiBBcnJheSBTdHJpbmc/IC0+IE1hdGNoXG4gIGZ1bmN0aW9uIHRvTWF0Y2goc3MpIHtcbiAgICByZXR1cm4ge21hdGNoOiBzc1swXSwgZ3JvdXBzOiBaLm1hcCAodG9NYXliZSwgc3Muc2xpY2UgKDEpKX07XG4gIH1cblxuICAvLyAgd2l0aFJlZ2V4IDo6IChSZWdFeHAsICgpIC0+IGEpIC0+IGFcbiAgZnVuY3Rpb24gd2l0aFJlZ2V4KHBhdHRlcm4sIHRodW5rKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IHBhdHRlcm4ubGFzdEluZGV4O1xuICAgIHZhciByZXN1bHQgPSB0aHVuayAoKTtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8jIHJlZ2V4IDo6IFJlZ2V4RmxhZ3MgLT4gU3RyaW5nIC0+IFJlZ0V4cFxuICAvLy5cbiAgLy8uIFRha2VzIGEgW1JlZ2V4RmxhZ3NdW10gYW5kIGEgcGF0dGVybiwgYW5kIHJldHVybnMgYSBSZWdFeHAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlZ2V4ICgnZycpICgnOlxcXFxkKzonKVxuICAvLy4gLzpcXGQrOi9nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmVnZXgoZmxhZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCAoc291cmNlLCBmbGFncyk7XG4gICAgfTtcbiAgfVxuICBfLnJlZ2V4ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlJlZ2V4RmxhZ3MsICQuU3RyaW5nLCAkLlJlZ0V4cF0sXG4gICAgaW1wbDogcmVnZXhcbiAgfTtcblxuICAvLyMgcmVnZXhFc2NhcGUgOjogU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RyaW5nIHdoaWNoIG1heSBjb250YWluIHJlZ3VsYXIgZXhwcmVzc2lvbiBtZXRhY2hhcmFjdGVycyxcbiAgLy8uIGFuZCByZXR1cm5zIGEgc3RyaW5nIHdpdGggdGhvc2UgbWV0YWNoYXJhY3RlcnMgZXNjYXBlZC5cbiAgLy8uXG4gIC8vLiBQcm9wZXJ0aWVzOlxuICAvLy5cbiAgLy8uICAgLSBgZm9yYWxsIHMgOjogU3RyaW5nLlxuICAvLy4gICAgICBTLnRlc3QgKFMucmVnZXggKCcnKSAoUy5yZWdleEVzY2FwZSAocykpKSAocykgPSB0cnVlYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yZWdleEVzY2FwZSAoJy09KntYWVp9Kj0tJylcbiAgLy8uICdcXFxcLT1cXFxcKlxcXFx7WFlaXFxcXH1cXFxcKj1cXFxcLSdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgcmV0dXJuIHMucmVwbGFjZSAoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJyk7XG4gIH1cbiAgXy5yZWdleEVzY2FwZSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsICQuU3RyaW5nXSxcbiAgICBpbXBsOiByZWdleEVzY2FwZVxuICB9O1xuXG4gIC8vIyB0ZXN0IDo6IFJlZ0V4cCAtPiBTdHJpbmcgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFRha2VzIGEgcGF0dGVybiBhbmQgYSBzdHJpbmcsIGFuZCByZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSBwYXR0ZXJuXG4gIC8vLiBtYXRjaGVzIHRoZSBzdHJpbmcuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRlc3QgKC9eYS8pICgnYWJhY3VzJylcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMudGVzdCAoL15hLykgKCdiYW5hbmEnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0ZXN0KHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHdpdGhSZWdleCAocGF0dGVybiwgZnVuY3Rpb24oKSB7IHJldHVybiBwYXR0ZXJuLnRlc3QgKHMpOyB9KTtcbiAgICB9O1xuICB9XG4gIF8udGVzdCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5SZWdFeHAsICQuU3RyaW5nLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IHRlc3RcbiAgfTtcblxuICAvLyMgbWF0Y2ggOjogTm9uR2xvYmFsUmVnRXhwIC0+IFN0cmluZyAtPiBNYXliZSB7IG1hdGNoIDo6IFN0cmluZywgZ3JvdXBzIDo6IEFycmF5IChNYXliZSBTdHJpbmcpIH1cbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHBhdHRlcm4gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBKdXN0IGEgbWF0Y2ggcmVjb3JkIGlmIHRoZVxuICAvLy4gcGF0dGVybiBtYXRjaGVzIHRoZSBzdHJpbmc7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBncm91cHMgOjogQXJyYXkgKE1heWJlIFN0cmluZylgIGFja25vd2xlZGdlcyB0aGUgZXhpc3RlbmNlIG9mIG9wdGlvbmFsXG4gIC8vLiBjYXB0dXJpbmcgZ3JvdXBzLlxuICAvLy5cbiAgLy8uIFByb3BlcnRpZXM6XG4gIC8vLlxuICAvLy4gICAtIGBmb3JhbGwgcCA6OiBQYXR0ZXJuLCBzIDo6IFN0cmluZy5cbiAgLy8uICAgICAgUy5oZWFkIChTLm1hdGNoQWxsIChTLnJlZ2V4ICgnZycpIChwKSkgKHMpKVxuICAvLy4gICAgICA9IFMubWF0Y2ggKFMucmVnZXggKCcnKSAocCkpIChzKWBcbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1hdGNoQWxsYF0oI21hdGNoQWxsKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWF0Y2ggKC8oZ29vZCk/YnllLykgKCdnb29kYnllJylcbiAgLy8uIEp1c3QgKHttYXRjaDogJ2dvb2RieWUnLCBncm91cHM6IFtKdXN0ICgnZ29vZCcpXX0pXG4gIC8vLlxuICAvLy4gPiBTLm1hdGNoICgvKGdvb2QpP2J5ZS8pICgnYnllJylcbiAgLy8uIEp1c3QgKHttYXRjaDogJ2J5ZScsIGdyb3VwczogW05vdGhpbmddfSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtYXRjaChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBaLm1hcCAodG9NYXRjaCwgdG9NYXliZSAocy5tYXRjaCAocGF0dGVybikpKTtcbiAgICB9O1xuICB9XG4gIF8ubWF0Y2ggPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuTm9uR2xvYmFsUmVnRXhwLCAkLlN0cmluZywgJE1heWJlIChNYXRjaCldLFxuICAgIGltcGw6IG1hdGNoXG4gIH07XG5cbiAgLy8jIG1hdGNoQWxsIDo6IEdsb2JhbFJlZ0V4cCAtPiBTdHJpbmcgLT4gQXJyYXkgeyBtYXRjaCA6OiBTdHJpbmcsIGdyb3VwcyA6OiBBcnJheSAoTWF5YmUgU3RyaW5nKSB9XG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwYXR0ZXJuIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2ggcmVjb3Jkcy5cbiAgLy8uXG4gIC8vLiBgZ3JvdXBzIDo6IEFycmF5IChNYXliZSBTdHJpbmcpYCBhY2tub3dsZWRnZXMgdGhlIGV4aXN0ZW5jZSBvZiBvcHRpb25hbFxuICAvLy4gY2FwdHVyaW5nIGdyb3Vwcy5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1hdGNoYF0oI21hdGNoKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWF0Y2hBbGwgKC9AKFthLXpdKykvZykgKCdIZWxsbywgd29ybGQhJylcbiAgLy8uIFtdXG4gIC8vLlxuICAvLy4gPiBTLm1hdGNoQWxsICgvQChbYS16XSspL2cpICgnSGVsbG8sIEBmb28hIEhlbGxvLCBAYmFyISBIZWxsbywgQGJheiEnKVxuICAvLy4gWyB7bWF0Y2g6ICdAZm9vJywgZ3JvdXBzOiBbSnVzdCAoJ2ZvbycpXX0sXG4gIC8vLiAuIHttYXRjaDogJ0BiYXInLCBncm91cHM6IFtKdXN0ICgnYmFyJyldfSxcbiAgLy8uIC4ge21hdGNoOiAnQGJheicsIGdyb3VwczogW0p1c3QgKCdiYXonKV19IF1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtYXRjaEFsbChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiB3aXRoUmVnZXggKHBhdHRlcm4sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdW5mb2xkciAoZnVuY3Rpb24oXykge1xuICAgICAgICAgIHJldHVybiBaLm1hcCAoZnVuY3Rpb24oc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBQYWlyICh0b01hdGNoIChzcykpIChudWxsKTtcbiAgICAgICAgICB9LCB0b01heWJlIChwYXR0ZXJuLmV4ZWMgKHMpKSk7XG4gICAgICAgIH0pIChbXSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIF8ubWF0Y2hBbGwgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuR2xvYmFsUmVnRXhwLCAkLlN0cmluZywgJC5BcnJheSAoTWF0Y2gpXSxcbiAgICBpbXBsOiBtYXRjaEFsbFxuICB9O1xuXG4gIC8vLiAjIyMgU3RyaW5nXG5cbiAgLy8jIHRvVXBwZXIgOjogU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHVwcGVyLWNhc2UgZXF1aXZhbGVudCBvZiBpdHMgYXJndW1lbnQuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B0b0xvd2VyYF0oI3RvTG93ZXIpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50b1VwcGVyICgnQUJDIGRlZiAxMjMnKVxuICAvLy4gJ0FCQyBERUYgMTIzJ1xuICAvLy4gYGBgXG4gIF8udG9VcHBlciA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsICQuU3RyaW5nXSxcbiAgICBpbXBsOiBpbnZva2UwICgndG9VcHBlckNhc2UnKVxuICB9O1xuXG4gIC8vIyB0b0xvd2VyIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBsb3dlci1jYXNlIGVxdWl2YWxlbnQgb2YgaXRzIGFyZ3VtZW50LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdG9VcHBlcmBdKCN0b1VwcGVyKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudG9Mb3dlciAoJ0FCQyBkZWYgMTIzJylcbiAgLy8uICdhYmMgZGVmIDEyMydcbiAgLy8uIGBgYFxuICBfLnRvTG93ZXIgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkLlN0cmluZ10sXG4gICAgaW1wbDogaW52b2tlMCAoJ3RvTG93ZXJDYXNlJylcbiAgfTtcblxuICAvLyMgdHJpbSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gU3RyaXBzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgY2hhcmFjdGVycy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudHJpbSAoJ1xcdFxcdCBmb28gYmFyIFxcbicpXG4gIC8vLiAnZm9vIGJhcidcbiAgLy8uIGBgYFxuICBfLnRyaW0gPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkLlN0cmluZ10sXG4gICAgaW1wbDogaW52b2tlMCAoJ3RyaW0nKVxuICB9O1xuXG4gIC8vIyBzdHJpcFByZWZpeCA6OiBTdHJpbmcgLT4gU3RyaW5nIC0+IE1heWJlIFN0cmluZ1xuICAvLy5cbiAgLy8uIFJldHVybnMgSnVzdCB0aGUgcG9ydGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nICh0aGUgc2Vjb25kIGFyZ3VtZW50KSBsZWZ0XG4gIC8vLiBhZnRlciByZW1vdmluZyB0aGUgZ2l2ZW4gcHJlZml4ICh0aGUgZmlyc3QgYXJndW1lbnQpIGlmIHRoZSBzdHJpbmcgc3RhcnRzXG4gIC8vLiB3aXRoIHRoZSBwcmVmaXg7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc3RyaXBTdWZmaXhgXSgjc3RyaXBTdWZmaXgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zdHJpcFByZWZpeCAoJ2h0dHBzOi8vJykgKCdodHRwczovL3NhbmN0dWFyeS5qcy5vcmcnKVxuICAvLy4gSnVzdCAoJ3NhbmN0dWFyeS5qcy5vcmcnKVxuICAvLy5cbiAgLy8uID4gUy5zdHJpcFByZWZpeCAoJ2h0dHBzOi8vJykgKCdodHRwOi8vc2FuY3R1YXJ5LmpzLm9yZycpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc3RyaXBQcmVmaXgocHJlZml4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHZhciBpZHggPSBwcmVmaXgubGVuZ3RoO1xuICAgICAgcmV0dXJuIHMuc2xpY2UgKDAsIGlkeCkgPT09IHByZWZpeCA/IEp1c3QgKHMuc2xpY2UgKGlkeCkpIDogTm90aGluZztcbiAgICB9O1xuICB9XG4gIF8uc3RyaXBQcmVmaXggPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkLlN0cmluZywgJE1heWJlICgkLlN0cmluZyldLFxuICAgIGltcGw6IHN0cmlwUHJlZml4XG4gIH07XG5cbiAgLy8jIHN0cmlwU3VmZml4IDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gTWF5YmUgU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IHRoZSBwb3J0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcgKHRoZSBzZWNvbmQgYXJndW1lbnQpIGxlZnRcbiAgLy8uIGFmdGVyIHJlbW92aW5nIHRoZSBnaXZlbiBzdWZmaXggKHRoZSBmaXJzdCBhcmd1bWVudCkgaWYgdGhlIHN0cmluZyBlbmRzXG4gIC8vLiB3aXRoIHRoZSBzdWZmaXg7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc3RyaXBQcmVmaXhgXSgjc3RyaXBQcmVmaXgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zdHJpcFN1ZmZpeCAoJy5tZCcpICgnUkVBRE1FLm1kJylcbiAgLy8uIEp1c3QgKCdSRUFETUUnKVxuICAvLy5cbiAgLy8uID4gUy5zdHJpcFN1ZmZpeCAoJy5tZCcpICgnUkVBRE1FJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzdHJpcFN1ZmZpeChzdWZmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIGlkeCA9IHMubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aDsgIC8vIHZhbHVlIG1heSBiZSBuZWdhdGl2ZVxuICAgICAgcmV0dXJuIHMuc2xpY2UgKGlkeCkgPT09IHN1ZmZpeCA/IEp1c3QgKHMuc2xpY2UgKDAsIGlkeCkpIDogTm90aGluZztcbiAgICB9O1xuICB9XG4gIF8uc3RyaXBTdWZmaXggPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkLlN0cmluZywgJE1heWJlICgkLlN0cmluZyldLFxuICAgIGltcGw6IHN0cmlwU3VmZml4XG4gIH07XG5cbiAgLy8jIHdvcmRzIDo6IFN0cmluZyAtPiBBcnJheSBTdHJpbmdcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2Ygd29yZHMgdGhlIHN0cmluZyBjb250YWluc1xuICAvLy4gKHdvcmRzIGFyZSBkZWxpbWl0ZWQgYnkgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHVud29yZHNgXSgjdW53b3JkcykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLndvcmRzICgnIGZvbyBiYXIgYmF6ICcpXG4gIC8vLiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB3b3JkcyhzKSB7XG4gICAgdmFyIHdvcmRzID0gcy5zcGxpdCAoL1xccysvKTtcbiAgICB2YXIgbGVuID0gd29yZHMubGVuZ3RoO1xuICAgIHJldHVybiB3b3Jkcy5zbGljZSAod29yZHNbMF0gPT09ICcnID8gMSA6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3Jkc1tsZW4gLSAxXSA9PT0gJycgPyBsZW4gLSAxIDogbGVuKTtcbiAgfVxuICBfLndvcmRzID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgJC5BcnJheSAoJC5TdHJpbmcpXSxcbiAgICBpbXBsOiB3b3Jkc1xuICB9O1xuXG4gIC8vIyB1bndvcmRzIDo6IEFycmF5IFN0cmluZyAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBUYWtlcyBhbiBhcnJheSBvZiB3b3JkcyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGpvaW5pbmcgdGhlIHdvcmRzXG4gIC8vLiB3aXRoIHNlcGFyYXRpbmcgc3BhY2VzLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgd29yZHNgXSgjd29yZHMpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy51bndvcmRzIChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAnZm9vIGJhciBiYXonXG4gIC8vLiBgYGBcbiAgXy51bndvcmRzID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkFycmF5ICgkLlN0cmluZyksICQuU3RyaW5nXSxcbiAgICBpbXBsOiBpbnZva2UxICgnam9pbicpICgnICcpXG4gIH07XG5cbiAgLy8jIGxpbmVzIDo6IFN0cmluZyAtPiBBcnJheSBTdHJpbmdcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgbGluZXMgdGhlIHN0cmluZyBjb250YWluc1xuICAvLy4gKGxpbmVzIGFyZSBkZWxpbWl0ZWQgYnkgbmV3bGluZXM6IGAnXFxuJ2Agb3IgYCdcXHJcXG4nYCBvciBgJ1xccidgKS5cbiAgLy8uIFRoZSByZXN1bHRpbmcgc3RyaW5ncyBkbyBub3QgY29udGFpbiBuZXdsaW5lcy5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHVubGluZXNgXSgjdW5saW5lcykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmxpbmVzICgnZm9vXFxuYmFyXFxuYmF6XFxuJylcbiAgLy8uIFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGxpbmVzKHMpIHtcbiAgICByZXR1cm4gcyA9PT0gJycgPyBbXVxuICAgICAgICAgICAgICAgICAgICA6IChzLnJlcGxhY2UgKC9cXHJcXG4/L2csICdcXG4nKSkubWF0Y2ggKC9eKD89W1xcc1xcU10pLiovZ20pO1xuICB9XG4gIF8ubGluZXMgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkLkFycmF5ICgkLlN0cmluZyldLFxuICAgIGltcGw6IGxpbmVzXG4gIH07XG5cbiAgLy8jIHVubGluZXMgOjogQXJyYXkgU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFRha2VzIGFuIGFycmF5IG9mIGxpbmVzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygam9pbmluZyB0aGUgbGluZXNcbiAgLy8uIGFmdGVyIGFwcGVuZGluZyBhIHRlcm1pbmF0aW5nIGxpbmUgZmVlZCAoYCdcXG4nYCkgdG8gZWFjaC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGxpbmVzYF0oI2xpbmVzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudW5saW5lcyAoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gJ2Zvb1xcbmJhclxcbmJhelxcbidcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB1bmxpbmVzKHhzKSB7XG4gICAgcmV0dXJuIHhzLnJlZHVjZSAoZnVuY3Rpb24ocywgeCkgeyByZXR1cm4gcyArIHggKyAnXFxuJzsgfSwgJycpO1xuICB9XG4gIF8udW5saW5lcyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5BcnJheSAoJC5TdHJpbmcpLCAkLlN0cmluZ10sXG4gICAgaW1wbDogdW5saW5lc1xuICB9O1xuXG4gIC8vIyBzcGxpdE9uIDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gQXJyYXkgU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgc3Vic3RyaW5ncyBvZiBpdHMgc2Vjb25kIGFyZ3VtZW50IHNlcGFyYXRlZCBieSBvY2N1cnJlbmNlc1xuICAvLy4gb2YgaXRzIGZpcnN0IGFyZ3VtZW50LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgam9pbldpdGhgXSgjam9pbldpdGgpIGFuZCBbYHNwbGl0T25SZWdleGBdKCNzcGxpdE9uUmVnZXgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zcGxpdE9uICgnOjonKSAoJ2Zvbzo6YmFyOjpiYXonKVxuICAvLy4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gIC8vLiBgYGBcbiAgXy5zcGxpdE9uID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgJC5TdHJpbmcsICQuQXJyYXkgKCQuU3RyaW5nKV0sXG4gICAgaW1wbDogaW52b2tlMSAoJ3NwbGl0JylcbiAgfTtcblxuICAvLyMgc3BsaXRPblJlZ2V4IDo6IEdsb2JhbFJlZ0V4cCAtPiBTdHJpbmcgLT4gQXJyYXkgU3RyaW5nXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwYXR0ZXJuIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBzcGxpdHRpbmcgdGhlXG4gIC8vLiBzdHJpbmcgYXQgZXZlcnkgbm9uLW92ZXJsYXBwaW5nIG9jY3VycmVuY2Ugb2YgdGhlIHBhdHRlcm4uXG4gIC8vLlxuICAvLy4gUHJvcGVydGllczpcbiAgLy8uXG4gIC8vLiAgIC0gYGZvcmFsbCBzIDo6IFN0cmluZywgdCA6OiBTdHJpbmcuXG4gIC8vLiAgICAgIFMuam9pbldpdGggKHMpXG4gIC8vLiAgICAgICAgICAgICAgICAgKFMuc3BsaXRPblJlZ2V4IChTLnJlZ2V4ICgnZycpIChTLnJlZ2V4RXNjYXBlIChzKSkpICh0KSlcbiAgLy8uICAgICAgPSB0YFxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc3BsaXRPbmBdKCNzcGxpdE9uKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc3BsaXRPblJlZ2V4ICgvWyw7XVsgXSovZykgKCdmb28sIGJhciwgYmF6JylcbiAgLy8uIFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAvLy5cbiAgLy8uID4gUy5zcGxpdE9uUmVnZXggKC9bLDtdWyBdKi9nKSAoJ2ZvbztiYXI7YmF6JylcbiAgLy8uIFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNwbGl0T25SZWdleChwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiB3aXRoUmVnZXggKHBhdHRlcm4sIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBwYXR0ZXJuLmV4ZWMgKHMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHBhdHRlcm4ubGFzdEluZGV4ID09PSBsYXN0SW5kZXggJiYgbWF0Y2hbMF0gPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IHMubGVuZ3RoKSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgcGF0dGVybi5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2ggKHMuc2xpY2UgKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCAocy5zbGljZSAobGFzdEluZGV4KSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIF8uc3BsaXRPblJlZ2V4ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkdsb2JhbFJlZ0V4cCwgJC5TdHJpbmcsICQuQXJyYXkgKCQuU3RyaW5nKV0sXG4gICAgaW1wbDogc3BsaXRPblJlZ2V4XG4gIH07XG5cbiAgcmV0dXJuIGNyZWF0ZSAoe1xuICAgIGNoZWNrVHlwZXM6IChcbiAgICAgIC8qIGdsb2JhbCBwcm9jZXNzOmZhbHNlICovXG4gICAgICB0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgIHx8IHByb2Nlc3MgPT0gbnVsbFxuICAgICAgfHwgcHJvY2Vzcy5lbnYgPT0gbnVsbFxuICAgICAgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICksXG4gICAgZW52OiBaLmNvbmNhdCAoJC5lbnYsIFtcbiAgICAgICQuRmluaXRlTnVtYmVyLFxuICAgICAgJC5Ob25aZXJvRmluaXRlTnVtYmVyLFxuICAgICAgJEVpdGhlciAoJC5Vbmtub3duKSAoJC5Vbmtub3duKSxcbiAgICAgIEZuICgkLlVua25vd24pICgkLlVua25vd24pLFxuICAgICAgJC5HbG9iYWxSZWdFeHAsXG4gICAgICAkLk5vbkdsb2JhbFJlZ0V4cCxcbiAgICAgICQuSW50ZWdlcixcbiAgICAgICQuTm9uTmVnYXRpdmVJbnRlZ2VyLFxuICAgICAgJE1heWJlICgkLlVua25vd24pLFxuICAgICAgJC5BcnJheTIgKCQuVW5rbm93bikgKCQuVW5rbm93biksXG4gICAgICAkUGFpciAoJC5Vbmtub3duKSAoJC5Vbmtub3duKSxcbiAgICAgICQuUmVnZXhGbGFncyxcbiAgICAgICQuVHlwZSxcbiAgICAgICQuVHlwZUNsYXNzLFxuICAgICAgJC5WYWxpZERhdGUsXG4gICAgICAkLlZhbGlkTnVtYmVyXG4gICAgXSlcbiAgfSk7XG5cbn0pKTtcblxuLy8uIFsjNDM4XTogICAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS9pc3N1ZXMvNDM4XG4vLy4gW0FwcGx5XTogICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGx5XG4vLy4gW0JpbmFyeVR5cGVdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYjQmluYXJ5VHlwZVxuLy8uIFtDaGFpbl06ICAgICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpblxuLy8uIFtFaXRoZXJdOiAgICAgICAgICAgICAgICAgICAjZWl0aGVyLXR5cGVcbi8vLiBbRmFudGFzeSBMYW5kXTogICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmRcbi8vLiBbRm9sZGFibGVdOiAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZm9sZGFibGVcbi8vLiBbR0lHT106ICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvR2FyYmFnZV9pbixfZ2FyYmFnZV9vdXRcbi8vLiBbSGFza2VsbF06ICAgICAgICAgICAgICAgICAgaHR0cHM6Ly93d3cuaGFza2VsbC5vcmcvXG4vLy4gW0tsZWlzbGldOiAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0tsZWlzbGlfY2F0ZWdvcnlcbi8vLiBbTWF5YmVdOiAgICAgICAgICAgICAgICAgICAgI21heWJlLXR5cGVcbi8vLiBbTnVsbGFibGVdOiAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiNOdWxsYWJsZVxuLy8uIFtQdXJlU2NyaXB0XTogICAgICAgICAgICAgICBodHRwOi8vd3d3LnB1cmVzY3JpcHQub3JnL1xuLy8uIFtSYW1kYV06ICAgICAgICAgICAgICAgICAgICBodHRwOi8vcmFtZGFqcy5jb20vXG4vLy4gW1JlZ2V4RmxhZ3NdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYjUmVnZXhGbGFnc1xuLy8uIFtTZW1pZ3JvdXBvaWRdOiAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZW1pZ3JvdXBvaWRcbi8vLiBbVW5hcnlUeXBlXTogICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiNVbmFyeVR5cGVcbi8vLiBbYCQudGVzdGBdOiAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiN0ZXN0XG4vLy4gW2BEZXNjZW5kaW5nYF06ICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZXNjZW5kaW5nI0Rlc2NlbmRpbmdcbi8vLiBbYFIuX19gXTogICAgICAgICAgICAgICAgICAgaHR0cDovL3JhbWRhanMuY29tL2RvY3MvI19fXG4vLy4gW2BSLmJpbmRgXTogICAgICAgICAgICAgICAgIGh0dHA6Ly9yYW1kYWpzLmNvbS9kb2NzLyNiaW5kXG4vLy4gW2BSLmludm9rZXJgXTogICAgICAgICAgICAgIGh0dHA6Ly9yYW1kYWpzLmNvbS9kb2NzLyNpbnZva2VyXG4vLy4gW2BaLmFsdGBdOiAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjYWx0XG4vLy4gW2BaLmFwYF06ICAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjYXBcbi8vLiBbYFouYXBGaXJzdGBdOiAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNhcEZpcnN0XG4vLy4gW2BaLmFwU2Vjb25kYF06ICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjYXBTZWNvbmRcbi8vLiBbYFouYmltYXBgXTogICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNiaW1hcFxuLy8uIFtgWi5jaGFpbmBdOiAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2NoYWluXG4vLy4gW2BaLmNoYWluUmVjYF06ICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjY2hhaW5SZWNcbi8vLiBbYFouY29tcG9zZWBdOiAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNjb21wb3NlXG4vLy4gW2BaLmNvbmNhdGBdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjY29uY2F0XG4vLy4gW2BaLmNvbnRyYW1hcGBdOiAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjY29udHJhbWFwXG4vLy4gW2BaLmRyb3BXaGlsZWBdOiAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZHJvcFdoaWxlXG4vLy4gW2BaLmR1cGxpY2F0ZWBdOiAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZHVwbGljYXRlXG4vLy4gW2BaLmVtcHR5YF06ICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZW1wdHlcbi8vLiBbYFouZXF1YWxzYF06ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNlcXVhbHNcbi8vLiBbYFouZXh0ZW5kYF06ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNleHRlbmRcbi8vLiBbYFouZXh0cmFjdGBdOiAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNleHRyYWN0XG4vLy4gW2BaLmZpbHRlcmBdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZmlsdGVyXG4vLy4gW2BaLmZsaXBgXTogICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZmxpcFxuLy8uIFtgWi5mb2xkTWFwYF06ICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2ZvbGRNYXBcbi8vLiBbYFouZ3RgXTogICAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNndFxuLy8uIFtgWi5ndGVgXTogICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2d0ZVxuLy8uIFtgWi5pZGBdOiAgICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2lkXG4vLy4gW2BaLmludmVydGBdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjaW52ZXJ0XG4vLy4gW2BaLmpvaW5gXTogICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjam9pblxuLy8uIFtgWi5sdGBdOiAgICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2x0XG4vLy4gW2BaLmx0ZWBdOiAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjbHRlXG4vLy4gW2BaLm1hcGBdOiAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjbWFwXG4vLy4gW2BaLm1hcExlZnRgXTogICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjbWFwTGVmdFxuLy8uIFtgWi5vZmBdOiAgICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI29mXG4vLy4gW2BaLnByb21hcGBdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjcHJvbWFwXG4vLy4gW2BaLnJlamVjdGBdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjcmVqZWN0XG4vLy4gW2BaLnNlcXVlbmNlYF06ICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjc2VxdWVuY2Vcbi8vLiBbYFoudGFrZVdoaWxlYF06ICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyN0YWtlV2hpbGVcbi8vLiBbYFoudHJhdmVyc2VgXTogICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyN0cmF2ZXJzZVxuLy8uIFtgWi56ZXJvYF06ICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI3plcm9cbi8vLiBbYHNob3dgXTogICAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXNob3cjc2hvd1xuLy8uIFtlcXVpdmFsZW5jZV06ICAgICAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FcXVpdmFsZW5jZV9yZWxhdGlvblxuLy8uIFtpZmZdOiAgICAgICAgICAgICAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JZl9hbmRfb25seV9pZlxuLy8uIFtwYXJzZUludF06ICAgICAgICAgICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9wYXJzZUludFxuLy8uIFtwYXJ0aWFsIGZ1bmN0aW9uc106ICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXJ0aWFsX2Z1bmN0aW9uXG4vLy4gW3JhbWRhL3JhbWRhIzY4M106ICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yYW1kYS9yYW1kYS9pc3N1ZXMvNjgzXG4vLy4gW3JhbWRhL3JhbWRhIzE0MTNdOiAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yYW1kYS9yYW1kYS9pc3N1ZXMvMTQxM1xuLy8uIFtyYW1kYS9yYW1kYSMxNDE5XTogICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcmFtZGEvcmFtZGEvcHVsbC8xNDE5XG4vLy4gW3NhbmN0dWFyeS1kZWZdOiAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWZcbi8vLiBbc2FuY3R1YXJ5LWVpdGhlcl06ICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWVpdGhlclxuLy8uIFtzYW5jdHVhcnktbWF5YmVdOiAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktbWF5YmVcbi8vLiBbc2FuY3R1YXJ5LXBhaXJdOiAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXBhaXJcbi8vLiBbc2FuY3R1YXJ5LXNob3ddOiAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXNob3dcbi8vLiBbc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlc106ICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlc1xuLy8uIFtzdGFibGUgc29ydF06ICAgICAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Tb3J0aW5nX2FsZ29yaXRobSNTdGFiaWxpdHlcbi8vLiBbdGhydXNoXTogICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3JhZ2Fud2FsZC1kZXByZWNhdGVkL2hvbW9pY29uaWMvYmxvYi9tYXN0ZXIvMjAwOC0xMC0zMC90aHJ1c2gubWFya2Rvd25cbi8vLiBbdG90YWwgZnVuY3Rpb25zXTogICAgICAgICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFydGlhbF9mdW5jdGlvbiNUb3RhbF9mdW5jdGlvblxuLy8uIFt0eXBlIGNoZWNraW5nXTogICAgICAgICAgICAjdHlwZS1jaGVja2luZ1xuLy8uIFt0eXBlIGlkZW50aWZpZXJdOiAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1pZGVudGlmaWVyc1xuLy8uIFt0eXBlIHJlcHJlc2VudGF0aXZlXTogICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0eXBlLXJlcHJlc2VudGF0aXZlc1xuLy8uIFt2YXJpYWRpYyBmdW5jdGlvbnNdOiAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYXJpYWRpY19mdW5jdGlvblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIi8qIGdsb2JhbHMgX193ZWJwYWNrX2FtZF9vcHRpb25zX18gKi9cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX2FtZF9vcHRpb25zX187XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCIvKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuaW1wb3J0IHByaW50TWUgZnJvbSAnLi9wcmludC5qcydcbmNvbnN0IHtyZWR1Y2UsIGNvbmNhdCwgbWFwfSA9IHJlcXVpcmUgKCdzYW5jdHVhcnknKVxuXG5mdW5jdGlvbiBqb2luKGxpc3QsIHNlcGFyYXRvcikge1xuICByZXR1cm4gcmVkdWNlIChjb25jYXQpICgnJykgKG1hcCAoeCA9PiBjb25jYXQgKHgpIChzZXBhcmF0b3IpKSAobGlzdCkpXG59XG5cbmZ1bmN0aW9uIGNvbXBvbmVudCgpIHtcbiAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgKCdkaXYnKVxuICBjb25zdCBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50ICgnYnV0dG9uJylcblxuICBlbGVtZW50LmlubmVySFRNTCA9IGpvaW4gKFsnSGVsbG8nLCAnV2VicGFjayddLCAnICcpXG5cbiAgYnRuLmlubmVySFRNTCA9ICdDbGljayBtZSBhbmQgY2hlY2sgdGhlIGNvbnNvbGUnXG4gIGJ0bi5vbmNsaWNrID0gcHJpbnRNZVxuICBlbGVtZW50LmFwcGVuZENoaWxkIChidG4pXG5cblxuICByZXR1cm4gZWxlbWVudFxufVxuXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkIChjb21wb25lbnQgKCkpXG4iLCIvKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJpbnRNZSgpIHtcbiAgY29uc29sZS5sb2cgKCdJIGdldCBjYWxsZWQgZnJvbSBwcmludC5qcyEnKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=