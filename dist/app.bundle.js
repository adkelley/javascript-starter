/******/ (function(modules) {
  // webpackBootstrap
  /******/ // The module cache
  /******/ var installedModules = {}; // The require function
  /******/
  /******/ /******/ function __webpack_require__(moduleId) {
    /******/
    /******/ // Check if module is in cache
    /******/ if (installedModules[moduleId]) {
      /******/ return installedModules[moduleId].exports;
      /******/
    } // Create a new module (and put it into the cache)
    /******/ /******/ var module = (installedModules[moduleId] = {
      /******/ i: moduleId,
      /******/ l: false,
      /******/ exports: {},
      /******/
    }); // Execute the module function
    /******/
    /******/ /******/ modules[moduleId].call(
      module.exports,
      module,
      module.exports,
      __webpack_require__
    ); // Flag the module as loaded
    /******/
    /******/ /******/ module.l = true; // Return the exports of the module
    /******/
    /******/ /******/ return module.exports;
    /******/
  } // expose the modules object (__webpack_modules__)
  /******/
  /******/
  /******/ /******/ __webpack_require__.m = modules; // expose the module cache
  /******/
  /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
  /******/
  /******/ /******/ __webpack_require__.d = function(exports, name, getter) {
    /******/ if (!__webpack_require__.o(exports, name)) {
      /******/ Object.defineProperty(exports, name, {
        enumerable: true,
        get: getter,
      });
      /******/
    }
    /******/
  }; // define __esModule on exports
  /******/
  /******/ /******/ __webpack_require__.r = function(exports) {
    /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, {
        value: "Module",
      });
      /******/
    }
    /******/ Object.defineProperty(exports, "__esModule", { value: true });
    /******/
  }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
  /******/
  /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function(
    value,
    mode
  ) {
    /******/ if (mode & 1) value = __webpack_require__(value);
    /******/ if (mode & 8) return value;
    /******/ if (
      mode & 4 &&
      typeof value === "object" &&
      value &&
      value.__esModule
    )
      return value;
    /******/ var ns = Object.create(null);
    /******/ __webpack_require__.r(ns);
    /******/ Object.defineProperty(ns, "default", {
      enumerable: true,
      value: value,
    });
    /******/ if (mode & 2 && typeof value != "string")
      for (var key in value)
        __webpack_require__.d(
          ns,
          key,
          function(key) {
            return value[key];
          }.bind(null, key)
        );
    /******/ return ns;
    /******/
  }; // getDefaultExport function for compatibility with non-harmony modules
  /******/
  /******/ /******/ __webpack_require__.n = function(module) {
    /******/ var getter =
      module && module.__esModule
        ? /******/ function getDefault() {
            return module["default"];
          }
        : /******/ function getModuleExports() {
            return module;
          };
    /******/ __webpack_require__.d(getter, "a", getter);
    /******/ return getter;
    /******/
  }; // Object.prototype.hasOwnProperty.call
  /******/
  /******/ /******/ __webpack_require__.o = function(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }; // __webpack_public_path__
  /******/
  /******/ /******/ __webpack_require__.p = ""; // Load entry module and return exports
  /******/
  /******/
  /******/ /******/ return __webpack_require__(
    (__webpack_require__.s = "./src/index.js")
  );
  /******/
})(
  /************************************************************************/
  /******/ {
    /***/ "./node_modules/inherits/inherits_browser.js":
      /*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        if (typeof Object.create === "function") {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true,
              },
            });
          };
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          };
        }

        /***/
      },

    /***/ "./node_modules/process/browser.js":
      /*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        // shim for using process in browser
        var process = (module.exports = {});

        // cached from whatever global is present so that test runners that stub it
        // don't break things.  But we need to wrap it in a try catch in case it is
        // wrapped in strict mode code which doesn't define any globals.  It's inside a
        // function because try/catches deoptimize in certain engines.

        var cachedSetTimeout;
        var cachedClearTimeout;

        function defaultSetTimout() {
          throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
          throw new Error("clearTimeout has not been defined");
        }
        (function() {
          try {
            if (typeof setTimeout === "function") {
              cachedSetTimeout = setTimeout;
            } else {
              cachedSetTimeout = defaultSetTimout;
            }
          } catch (e) {
            cachedSetTimeout = defaultSetTimout;
          }
          try {
            if (typeof clearTimeout === "function") {
              cachedClearTimeout = clearTimeout;
            } else {
              cachedClearTimeout = defaultClearTimeout;
            }
          } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
          }
        })();
        function runTimeout(fun) {
          if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
          }
          // if setTimeout wasn't available but was latter defined
          if (
            (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
            setTimeout
          ) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
            }
          }
        }
        function runClearTimeout(marker) {
          if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
          }
          // if clearTimeout wasn't available but was latter defined
          if (
            (cachedClearTimeout === defaultClearTimeout ||
              !cachedClearTimeout) &&
            clearTimeout
          ) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
          }
          try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
          } catch (e) {
            try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
            } catch (e) {
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
            }
          }
        }
        var queue = [];
        var draining = false;
        var currentQueue;
        var queueIndex = -1;

        function cleanUpNextTick() {
          if (!draining || !currentQueue) {
            return;
          }
          draining = false;
          if (currentQueue.length) {
            queue = currentQueue.concat(queue);
          } else {
            queueIndex = -1;
          }
          if (queue.length) {
            drainQueue();
          }
        }

        function drainQueue() {
          if (draining) {
            return;
          }
          var timeout = runTimeout(cleanUpNextTick);
          draining = true;

          var len = queue.length;
          while (len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
              if (currentQueue) {
                currentQueue[queueIndex].run();
              }
            }
            queueIndex = -1;
            len = queue.length;
          }
          currentQueue = null;
          draining = false;
          runClearTimeout(timeout);
        }

        process.nextTick = function(fun) {
          var args = new Array(arguments.length - 1);
          if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
            }
          }
          queue.push(new Item(fun, args));
          if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
          }
        };

        // v8 likes predictible objects
        function Item(fun, array) {
          this.fun = fun;
          this.array = array;
        }
        Item.prototype.run = function() {
          this.fun.apply(null, this.array);
        };
        process.title = "browser";
        process.browser = true;
        process.env = {};
        process.argv = [];
        process.version = ""; // empty string to avoid regexp issues
        process.versions = {};

        function noop() {}

        process.on = noop;
        process.addListener = noop;
        process.once = noop;
        process.off = noop;
        process.removeListener = noop;
        process.removeAllListeners = noop;
        process.emit = noop;
        process.prependListener = noop;
        process.prependOnceListener = noop;

        process.listeners = function(name) {
          return [];
        };

        process.binding = function(name) {
          throw new Error("process.binding is not supported");
        };

        process.cwd = function() {
          return "/";
        };
        process.chdir = function(dir) {
          throw new Error("process.chdir is not supported");
        };
        process.umask = function() {
          return 0;
        };

        /***/
      },

    /***/ "./node_modules/sanctuary-def/index.js":
      /*!*********************************************!*\
  !*** ./node_modules/sanctuary-def/index.js ***!
  \*********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(process) {
          var __WEBPACK_AMD_DEFINE_FACTORY__,
            __WEBPACK_AMD_DEFINE_ARRAY__,
            __WEBPACK_AMD_DEFINE_RESULT__; /*              ___                 ______
               /  /\               /  ___/\
        ______/  / / _______    __/  /___\/
       /  ___   / / /  ___  \  /_   __/\
      /  /\_/  / / /  /__/  /\ \/  /\_\/
     /  / //  / / /  ______/ / /  / /
    /  /_//  / / /  /______\/ /  / /
    \_______/ /  \_______/\  /__/ /
     \______\/    \______\/  \__*/

          //. # sanctuary-def
          //.
          //. sanctuary-def is a run-time type system for JavaScript. It facilitates
          //. the definition of curried JavaScript functions which are explicit about
          //. the number of arguments to which they may be applied and the types of
          //. those arguments.
          //.
          //. It is conventional to import the package as `$`:
          //.
          //. ```javascript
          //. const $ = require ('sanctuary-def');
          //. ```
          //.
          //. The next step is to define an environment. An environment is an array
          //. of [types][]. [`env`][] is an environment containing all the built-in
          //. JavaScript types. It may be used as the basis for environments which
          //. include custom types in addition to the built-in types:
          //.
          //. ```javascript
          //. //    Integer :: Type
          //. const Integer = '...';
          //.
          //. //    NonZeroInteger :: Type
          //. const NonZeroInteger = '...';
          //.
          //. //    env :: Array Type
          //. const env = $.env.concat ([Integer, NonZeroInteger]);
          //. ```
          //.
          //. Type constructors such as `List :: Type -> Type` cannot be included in
          //. an environment as they're not of the correct type. One could, though,
          //. use a type constructor to define a fixed number of concrete types:
          //.
          //. ```javascript
          //. //    env :: Array Type
          //. const env = $.env.concat ([
          //.   List ($.Number),                // :: Type
          //.   List ($.String),                // :: Type
          //.   List (List ($.Number)),         // :: Type
          //.   List (List ($.String)),         // :: Type
          //.   List (List (List ($.Number))),  // :: Type
          //.   List (List (List ($.String))),  // :: Type
          //. ]);
          //. ```
          //.
          //. Not only would this be tedious, but one could never enumerate all possible
          //. types as there are infinitely many. Instead, one should use [`Unknown`][]:
          //.
          //. ```javascript
          //. //    env :: Array Type
          //. const env = $.env.concat ([List ($.Unknown)]);
          //. ```
          //.
          //. The next step is to define a `def` function for the environment:
          //.
          //. ```javascript
          //. const def = $.create ({checkTypes: true, env});
          //. ```
          //.
          //. The `checkTypes` option determines whether type checking is enabled.
          //. This allows one to only pay the performance cost of run-time type checking
          //. during development. For example:
          //.
          //. ```javascript
          //. const def = $.create ({
          //.   checkTypes: process.env.NODE_ENV === 'development',
          //.   env,
          //. });
          //. ```
          //.
          //. `def` is a function for defining functions. For example:
          //.
          //. ```javascript
          //. //    add :: Number -> Number -> Number
          //. const add =
          //. def ('add')
          //.     ({})
          //.     ([$.Number, $.Number, $.Number])
          //.     (x => y => x + y);
          //. ```
          //.
          //. `[$.Number, $.Number, $.Number]` specifies that `add` takes two arguments
          //. of type `Number`, one at a time, and returns a value of type `Number`.
          //.
          //. Applying `add` to two arguments, one at a time, gives the expected result:
          //.
          //. ```javascript
          //. add (2) (2);
          //. // => 4
          //. ```
          //.
          //. Applying `add` to multiple arguments at once results in an exception being
          //. thrown:
          //.
          //. ```javascript
          //. add (2, 2, 2);
          //. // ! TypeError: ‘add’ applied to the wrong number of arguments
          //. //
          //. //   add :: Number -> Number -> Number
          //. //          ^^^^^^
          //. //            1
          //. //
          //. //   Expected one argument but received three arguments:
          //. //
          //. //     - 2
          //. //     - 2
          //. //     - 2
          //. ```
          //.
          //. Applying `add` to one argument produces a function awaiting the remaining
          //. argument. This is known as partial application. Partial application allows
          //. more specific functions to be defined in terms of more general ones:
          //.
          //. ```javascript
          //. //    inc :: Number -> Number
          //. const inc = add (1);
          //.
          //. inc (7);
          //. // => 8
          //. ```
          //.
          //. JavaScript's implicit type coercion often obfuscates the source of type
          //. errors. Consider the following function:
          //.
          //. ```javascript
          //. //    _add :: Number -> Number -> Number
          //. const _add = x => y => x + y;
          //. ```
          //.
          //. The type signature indicates that `_add` takes arguments of type `Number`,
          //. but this is not enforced. This allows type errors to be silently ignored:
          //.
          //. ```javascript
          //. _add ('2') ('2');
          //. // => '22'
          //. ```
          //.
          //. `add`, on the other hand, throws if applied to arguments of the wrong
          //. types:
          //.
          //. ```javascript
          //. add ('2') ('2');
          //. // ! TypeError: Invalid value
          //. //
          //. //   add :: Number -> Number -> Number
          //. //          ^^^^^^
          //. //            1
          //. //
          //. //   1)  "2" :: String
          //. //
          //. //   The value at position 1 is not a member of ‘Number’.
          //. ```
          //.
          //. Type checking is performed as arguments are provided (rather than once all
          //. arguments have been provided), so type errors are reported early:
          //.
          //. ```javascript
          //. add ('X');
          //. // ! TypeError: Invalid value
          //. //
          //. //   add :: Number -> Number -> Number
          //. //          ^^^^^^
          //. //            1
          //. //
          //. //   1)  "X" :: String
          //. //
          //. //   The value at position 1 is not a member of ‘Number’.
          //. ```

          (function(f) {
            "use strict";

            /* istanbul ignore else */
            if (true && typeof module.exports === "object") {
              module.exports = f(
                __webpack_require__(
                  /*! sanctuary-either */ "./node_modules/sanctuary-either/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-identifiers/index.js"
                )
              );
            } else if (
              true &&
              __webpack_require__(
                /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
              ) != null
            ) {
              !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
                __webpack_require__(
                  /*! sanctuary-either */ "./node_modules/sanctuary-either/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-identifiers/index.js"
                ),
              ]),
              (__WEBPACK_AMD_DEFINE_FACTORY__ = f),
              (__WEBPACK_AMD_DEFINE_RESULT__ =
                typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                  ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                      exports,
                      __WEBPACK_AMD_DEFINE_ARRAY__
                    )
                  : __WEBPACK_AMD_DEFINE_FACTORY__),
              __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
              self.sanctuaryDef = f(
                self.sanctuaryEither,
                self.sanctuaryShow,
                self.sanctuaryTypeClasses,
                self.sanctuaryTypeIdentifiers
              );
            }
          })(function(Either, show, Z, type) {
            "use strict";

            var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;
            var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER;

            var slice = Array.prototype.slice;
            var hasOwnProperty = Object.prototype.hasOwnProperty;
            var toString = Object.prototype.toString;

            var inspect = (function() {
              /* istanbul ignore else */
              if (true && typeof module.exports === "object") {
                var util = __webpack_require__(
                  /*! util */ "./node_modules/util/util.js"
                );
                /* istanbul ignore else */
                if (typeof util.inspect.custom === "symbol")
                  return util.inspect.custom;
              }
              return "inspect";
            })();

            //  Left :: a -> Either a b
            var Left = Either.Left;

            //  Right :: b -> Either a b
            var Right = Either.Right;

            //  K :: a -> b -> a
            function K(x) {
              return function(y) {
                return x;
              };
            }

            //  W :: (a -> a -> b) -> a -> b
            function W(f) {
              return function(x) {
                return f(x)(x);
              };
            }

            //  always0 :: a -> () -> a
            function always0(x) {
              return function() {
                return x;
              };
            }

            //  always2 :: a -> (b, c) -> a
            function always2(x) {
              return function(y, z) {
                return x;
              };
            }

            //  compose :: (b -> c, a -> b) -> (a -> c)
            function compose(f, g) {
              return function(x) {
                return f(g(x));
              };
            }

            //  id :: a -> a
            function id(x) {
              return x;
            }

            //  init :: Array a -> Array a
            function init(xs) {
              return xs.slice(0, -1);
            }

            //  isEmpty :: Array a -> Boolean
            function isEmpty(xs) {
              return xs.length === 0;
            }

            //  isPrefix :: Array a -> Array a -> Boolean
            function isPrefix(candidate) {
              return function(xs) {
                if (candidate.length > xs.length) return false;
                for (var idx = 0; idx < candidate.length; idx += 1) {
                  if (candidate[idx] !== xs[idx]) return false;
                }
                return true;
              };
            }

            //  joinWith :: (String, Array String) -> String
            function joinWith(separator, ss) {
              return ss.join(separator);
            }

            //  last :: Array a -> a
            function last(xs) {
              return xs[xs.length - 1];
            }

            //  memberOf :: Array a -> a -> Boolean
            function memberOf(xs) {
              return function(y) {
                return xs.some(function(x) {
                  return Z.equals(x, y);
                });
              };
            }

            //  or :: (Array a, Array a) -> Array a
            function or(xs, ys) {
              return isEmpty(xs) ? ys : xs;
            }

            //  strRepeat :: (String, Integer) -> String
            function strRepeat(s, times) {
              return joinWith(s, Array(times + 1));
            }

            //  r :: Char -> String -> String
            function r(c) {
              return function(s) {
                return strRepeat(c, s.length);
              };
            }

            //  _ :: String -> String
            var _ = r(" ");

            //  sortedKeys :: Object -> Array String
            function sortedKeys(o) {
              return Object.keys(o).sort();
            }

            //  stripOutermostParens :: String -> String
            function stripOutermostParens(s) {
              return s.slice("(".length, -")".length);
            }

            //  toMarkdownList :: (String, String, a -> String, Array a) -> String
            function toMarkdownList(empty, s, f, xs) {
              return isEmpty(xs)
                ? empty
                : Z.reduce(
                    function(s, x) {
                      return s + "  - " + f(x) + "\n";
                    },
                    s,
                    xs
                  );
            }

            //  trimTrailingSpaces :: String -> String
            function trimTrailingSpaces(s) {
              return s.replace(/[ ]+$/gm, "");
            }

            //  unless :: (Boolean, (a -> a), a) -> a
            function unless(bool, f, x) {
              return bool ? x : f(x);
            }

            //  when :: (Boolean, (a -> a), a) -> a
            function when(bool, f, x) {
              return bool ? f(x) : x;
            }

            //  wrap :: String -> String -> String -> String
            function wrap(prefix) {
              return function(suffix) {
                return function(s) {
                  return prefix + s + suffix;
                };
              };
            }

            //  parenthesize :: String -> String
            var parenthesize = wrap("(")(")");

            //  q :: String -> String
            var q = wrap("\u2018")("\u2019");

            //  stripNamespace :: String -> String
            function stripNamespace(s) {
              return s.slice(s.indexOf("/") + 1);
            }

            //  _Type :: ... -> Type
            function _Type(
              type, // :: String
              name, // :: String
              url, // :: String
              format, // :: (String -> String, String -> String -> String) -> String
              test, // :: Any -> Boolean
              keys, // :: Array String
              types // :: StrMap { extractor :: a -> Array b, type :: Type }
            ) {
              this._test = test;
              this.format = format;
              this.keys = keys;
              this.name = name;
              this.type = type;
              this.types = types;
              this.url = url;
            }

            _Type["@@type"] = "sanctuary-def/Type";

            //  Type#fantasy-land/equals :: Type ~> Type -> Boolean
            _Type.prototype["fantasy-land/equals"] = function(other) {
              return (
                Z.equals(this.type, other.type) &&
                Z.equals(this.name, other.name) &&
                Z.equals(this.url, other.url) &&
                Z.equals(this.keys, other.keys) &&
                this.keys.every(function(k) {
                  return Z.equals(this.types[k].type, other.types[k].type);
                }, this)
              );
            };

            _Type.prototype.validate = function(x) {
              if (!this._test(x)) return Left({ value: x, propPath: [] });
              for (var idx = 0; idx < this.keys.length; idx += 1) {
                var k = this.keys[idx];
                var t = this.types[k];
                for (
                  var idx2 = 0, ys = t.extractor(x);
                  idx2 < ys.length;
                  idx2 += 1
                ) {
                  var result = t.type.validate(ys[idx2]);
                  if (result.isLeft) {
                    var value = result.value.value;
                    var propPath = Z.concat([k], result.value.propPath);
                    return Left({ value: value, propPath: propPath });
                  }
                }
              }
              return Right(x);
            };

            _Type.prototype["@@show"] = function() {
              return this.format(id, K(id));
            };

            var BINARY = "BINARY";
            var FUNCTION = "FUNCTION";
            var INCONSISTENT = "INCONSISTENT";
            var NO_ARGUMENTS = "NO_ARGUMENTS";
            var NULLARY = "NULLARY";
            var RECORD = "RECORD";
            var UNARY = "UNARY";
            var UNKNOWN = "UNKNOWN";
            var VARIABLE = "VARIABLE";

            //  Inconsistent :: Type
            var Inconsistent = new _Type(
              INCONSISTENT,
              "",
              "",
              always2("???"),
              K(false),
              [],
              {}
            );

            //  NoArguments :: Type
            var NoArguments = new _Type(
              NO_ARGUMENTS,
              "",
              "",
              always2("()"),
              K(true),
              [],
              {}
            );

            //  typeEq :: String -> a -> Boolean
            function typeEq(name) {
              return function(x) {
                return type(x) === name;
              };
            }

            //  typeofEq :: String -> a -> Boolean
            function typeofEq(typeof_) {
              return function(x) {
                // eslint-disable-next-line valid-typeof
                return typeof x === typeof_;
              };
            }

            //  functionUrl :: String -> String
            function functionUrl(name) {
              var version = "0.18.1"; // updated programmatically
              return (
                "https://github.com/sanctuary-js/sanctuary-def/tree/v" +
                version +
                "#" +
                stripNamespace(name)
              );
            }

            //  NullaryTypeWithUrl :: (String, Any -> Boolean) -> Type
            function NullaryTypeWithUrl(name, test) {
              return NullaryType(name)(functionUrl(name))(test);
            }

            //  EnumTypeWithUrl :: (String, Array Any) -> Type
            function EnumTypeWithUrl(name, members) {
              return EnumType(name)(functionUrl(name))(members);
            }

            //  UnaryTypeWithUrl ::
            //    (String, Any -> Boolean, t a -> Array a) -> (Type -> Type)
            function UnaryTypeWithUrl(name, test, _1) {
              return UnaryType(name)(functionUrl(name))(test)(_1);
            }

            //  BinaryTypeWithUrl ::
            //    (String, Any -> Boolean, t a b -> Array a, t a b -> Array b) ->
            //      ((Type, Type) -> Type)
            function BinaryTypeWithUrl(name, test, _1, _2) {
              return BinaryType(name)(functionUrl(name))(test)(_1)(_2);
            }

            //. ### Types
            //.
            //. Conceptually, a type is a set of values. One can think of a value of
            //. type `Type` as a function of type `Any -> Boolean` which tests values
            //. for membership in the set (though this is an oversimplification).

            //# Any :: Type
            //.
            //. Type comprising every JavaScript value.
            var Any = NullaryTypeWithUrl("sanctuary-def/Any", K(true));

            //# AnyFunction :: Type
            //.
            //. Type comprising every Function value.
            var AnyFunction = NullaryTypeWithUrl(
              "Function",
              typeofEq("function")
            );

            //# Arguments :: Type
            //.
            //. Type comprising every [`arguments`][arguments] object.
            var Arguments = NullaryTypeWithUrl(
              "Arguments",
              typeEq("Arguments")
            );

            //# Array :: Type -> Type
            //.
            //. Constructor for homogeneous Array types.
            var Array_ = UnaryTypeWithUrl("Array", typeEq("Array"), id);

            //# Array0 :: Type
            //.
            //. Type whose sole member is `[]`.
            var Array0 = NullaryTypeWithUrl("sanctuary-def/Array0", function(
              x
            ) {
              return typeEq("Array")(x) && x.length === 0;
            });

            //# Array1 :: Type -> Type
            //.
            //. Constructor for singleton Array types.
            var Array1 = UnaryTypeWithUrl(
              "sanctuary-def/Array1",
              function(x) {
                return typeEq("Array")(x) && x.length === 1;
              },
              id
            );

            //# Array2 :: Type -> Type -> Type
            //.
            //. Constructor for heterogeneous Array types of length 2. `['foo', true]` is
            //. a member of `Array2 String Boolean`.
            var Array2 = BinaryTypeWithUrl(
              "sanctuary-def/Array2",
              function(x) {
                return typeEq("Array")(x) && x.length === 2;
              },
              function(array2) {
                return [array2[0]];
              },
              function(array2) {
                return [array2[1]];
              }
            );

            //# Boolean :: Type
            //.
            //. Type comprising `true` and `false`.
            var Boolean_ = NullaryTypeWithUrl("Boolean", typeofEq("boolean"));

            //# Date :: Type
            //.
            //. Type comprising every Date value.
            var Date_ = NullaryTypeWithUrl("Date", typeEq("Date"));

            //# Error :: Type
            //.
            //. Type comprising every Error value, including values of more specific
            //. constructors such as [`SyntaxError`][] and [`TypeError`][].
            var Error_ = NullaryTypeWithUrl("Error", typeEq("Error"));

            //# FiniteNumber :: Type
            //.
            //. Type comprising every [`ValidNumber`][] value except `Infinity` and
            //. `-Infinity`.
            var FiniteNumber = NullaryTypeWithUrl(
              "sanctuary-def/FiniteNumber",
              function(x) {
                return ValidNumber._test(x) && isFinite(x);
              }
            );

            //  augmentThunk :: NonEmpty (Array Type) -> NonEmpty (Array Type)
            function augmentThunk(types) {
              return types.length === 1
                ? Z.concat([NoArguments], types)
                : types;
            }

            //# Function :: NonEmpty (Array Type) -> Type
            //.
            //. Constructor for Function types.
            //.
            //. Examples:
            //.
            //.   - `$.Function ([$.Date, $.String])` represents the `Date -> String`
            //.     type; and
            //.   - `$.Function ([a, b, a])` represents the `(a, b) -> a` type.
            function Function_(_types) {
              var types = augmentThunk(_types);

              function format(outer, inner) {
                var xs = types.map(function(t, idx) {
                  return unless(
                    t.type === RECORD || isEmpty(t.keys),
                    stripOutermostParens,
                    inner("$" + show(idx + 1))(show(t))
                  );
                });
                var parenthesize = wrap(outer("("))(outer(")"));
                return parenthesize(
                  unless(
                    types.length === 2,
                    parenthesize,
                    joinWith(outer(", "), init(xs))
                  ) +
                    outer(" -> ") +
                    last(xs)
                );
              }

              var test = AnyFunction._test;

              var $keys = [];
              var $types = {};
              types.forEach(function(t, idx) {
                var k = "$" + show(idx + 1);
                $keys.push(k);
                $types[k] = { extractor: K([]), type: t };
              });

              return new _Type(FUNCTION, "", "", format, test, $keys, $types);
            }

            //# GlobalRegExp :: Type
            //.
            //. Type comprising every [`RegExp`][] value whose `global` flag is `true`.
            //.
            //. See also [`NonGlobalRegExp`][].
            var GlobalRegExp = NullaryTypeWithUrl(
              "sanctuary-def/GlobalRegExp",
              function(x) {
                return RegExp_._test(x) && x.global;
              }
            );

            //# HtmlElement :: Type
            //.
            //. Type comprising every [HTML element][].
            var HtmlElement = NullaryTypeWithUrl(
              "sanctuary-def/HtmlElement",
              function(x) {
                return /^\[object HTML.+Element\]$/.test(toString.call(x));
              }
            );

            //# Integer :: Type
            //.
            //. Type comprising every integer in the range
            //. [[`Number.MIN_SAFE_INTEGER`][min] .. [`Number.MAX_SAFE_INTEGER`][max]].
            var Integer = NullaryTypeWithUrl("sanctuary-def/Integer", function(
              x
            ) {
              return (
                ValidNumber._test(x) &&
                Math.floor(x) === x &&
                x >= MIN_SAFE_INTEGER &&
                x <= MAX_SAFE_INTEGER
              );
            });

            //# NegativeFiniteNumber :: Type
            //.
            //. Type comprising every [`FiniteNumber`][] value less than zero.
            var NegativeFiniteNumber = NullaryTypeWithUrl(
              "sanctuary-def/NegativeFiniteNumber",
              function(x) {
                return FiniteNumber._test(x) && x < 0;
              }
            );

            //# NegativeInteger :: Type
            //.
            //. Type comprising every [`Integer`][] value less than zero.
            var NegativeInteger = NullaryTypeWithUrl(
              "sanctuary-def/NegativeInteger",
              function(x) {
                return Integer._test(x) && x < 0;
              }
            );

            //# NegativeNumber :: Type
            //.
            //. Type comprising every [`Number`][] value less than zero.
            var NegativeNumber = NullaryTypeWithUrl(
              "sanctuary-def/NegativeNumber",
              function(x) {
                return Number_._test(x) && x < 0;
              }
            );

            //# NonEmpty :: Type -> Type
            //.
            //. Constructor for non-empty types. `$.NonEmpty ($.String)`, for example, is
            //. the type comprising every [`String`][] value except `''`.
            //.
            //. The given type must satisfy the [Monoid][] and [Setoid][] specifications.
            var NonEmpty = UnaryTypeWithUrl(
              "sanctuary-def/NonEmpty",
              function(x) {
                return (
                  Z.Monoid.test(x) &&
                  Z.Setoid.test(x) &&
                  !Z.equals(x, Z.empty(x.constructor))
                );
              },
              function(monoid) {
                return [monoid];
              }
            );

            //# NonGlobalRegExp :: Type
            //.
            //. Type comprising every [`RegExp`][] value whose `global` flag is `false`.
            //.
            //. See also [`GlobalRegExp`][].
            var NonGlobalRegExp = NullaryTypeWithUrl(
              "sanctuary-def/NonGlobalRegExp",
              function(x) {
                return RegExp_._test(x) && !x.global;
              }
            );

            //# NonNegativeInteger :: Type
            //.
            //. Type comprising every non-negative [`Integer`][] value (including `-0`).
            //. Also known as the set of natural numbers under ISO 80000-2:2009.
            var NonNegativeInteger = NullaryTypeWithUrl(
              "sanctuary-def/NonNegativeInteger",
              function(x) {
                return Integer._test(x) && x >= 0;
              }
            );

            //# NonZeroFiniteNumber :: Type
            //.
            //. Type comprising every [`FiniteNumber`][] value except `0` and `-0`.
            var NonZeroFiniteNumber = NullaryTypeWithUrl(
              "sanctuary-def/NonZeroFiniteNumber",
              function(x) {
                return FiniteNumber._test(x) && x !== 0;
              }
            );

            //# NonZeroInteger :: Type
            //.
            //. Type comprising every [`Integer`][] value except `0` and `-0`.
            var NonZeroInteger = NullaryTypeWithUrl(
              "sanctuary-def/NonZeroInteger",
              function(x) {
                return Integer._test(x) && x !== 0;
              }
            );

            //# NonZeroValidNumber :: Type
            //.
            //. Type comprising every [`ValidNumber`][] value except `0` and `-0`.
            var NonZeroValidNumber = NullaryTypeWithUrl(
              "sanctuary-def/NonZeroValidNumber",
              function(x) {
                return ValidNumber._test(x) && x !== 0;
              }
            );

            //# Null :: Type
            //.
            //. Type whose sole member is `null`.
            var Null = NullaryTypeWithUrl("Null", typeEq("Null"));

            //# Nullable :: Type -> Type
            //.
            //. Constructor for types which include `null` as a member.
            var Nullable = UnaryTypeWithUrl(
              "sanctuary-def/Nullable",
              K(true),
              function(nullable) {
                // eslint-disable-next-line eqeqeq
                return nullable === null ? [] : [nullable];
              }
            );

            //# Number :: Type
            //.
            //. Type comprising every primitive Number value (including `NaN`).
            var Number_ = NullaryTypeWithUrl("Number", typeofEq("number"));

            //# Object :: Type
            //.
            //. Type comprising every "plain" Object value. Specifically, values
            //. created via:
            //.
            //.   - object literal syntax;
            //.   - [`Object.create`][]; or
            //.   - the `new` operator in conjunction with `Object` or a custom
            //.     constructor function.
            var Object_ = NullaryTypeWithUrl("Object", typeEq("Object"));

            //# PositiveFiniteNumber :: Type
            //.
            //. Type comprising every [`FiniteNumber`][] value greater than zero.
            var PositiveFiniteNumber = NullaryTypeWithUrl(
              "sanctuary-def/PositiveFiniteNumber",
              function(x) {
                return FiniteNumber._test(x) && x > 0;
              }
            );

            //# PositiveInteger :: Type
            //.
            //. Type comprising every [`Integer`][] value greater than zero.
            var PositiveInteger = NullaryTypeWithUrl(
              "sanctuary-def/PositiveInteger",
              function(x) {
                return Integer._test(x) && x > 0;
              }
            );

            //# PositiveNumber :: Type
            //.
            //. Type comprising every [`Number`][] value greater than zero.
            var PositiveNumber = NullaryTypeWithUrl(
              "sanctuary-def/PositiveNumber",
              function(x) {
                return Number_._test(x) && x > 0;
              }
            );

            //# RegExp :: Type
            //.
            //. Type comprising every RegExp value.
            var RegExp_ = NullaryTypeWithUrl("RegExp", typeEq("RegExp"));

            //# RegexFlags :: Type
            //.
            //. Type comprising the canonical RegExp flags:
            //.
            //.   - `''`
            //.   - `'g'`
            //.   - `'i'`
            //.   - `'m'`
            //.   - `'gi'`
            //.   - `'gm'`
            //.   - `'im'`
            //.   - `'gim'`
            var RegexFlags = EnumTypeWithUrl("sanctuary-def/RegexFlags", [
              "",
              "g",
              "i",
              "m",
              "gi",
              "gm",
              "im",
              "gim",
            ]);

            //# StrMap :: Type -> Type
            //.
            //. Constructor for homogeneous Object types.
            //.
            //. `{foo: 1, bar: 2, baz: 3}`, for example, is a member of `StrMap Number`;
            //. `{foo: 1, bar: 2, baz: 'XXX'}` is not.
            var StrMap = UnaryTypeWithUrl(
              "sanctuary-def/StrMap",
              Object_._test,
              function(strMap) {
                return Z.reduce(
                  function(xs, x) {
                    xs.push(x);
                    return xs;
                  },
                  [],
                  strMap
                );
              }
            );

            //# String :: Type
            //.
            //. Type comprising every primitive String value.
            var String_ = NullaryTypeWithUrl("String", typeofEq("string"));

            //# Symbol :: Type
            //.
            //. Type comprising every Symbol value.
            var Symbol_ = NullaryTypeWithUrl("Symbol", typeofEq("symbol"));

            //# Type :: Type
            //.
            //. Type comprising every `Type` value.
            var Type = NullaryTypeWithUrl("Type", typeEq("sanctuary-def/Type"));

            //# TypeClass :: Type
            //.
            //. Type comprising every [`TypeClass`][] value.
            var TypeClass = NullaryTypeWithUrl(
              "TypeClass",
              typeEq("sanctuary-type-classes/TypeClass")
            );

            //# Undefined :: Type
            //.
            //. Type whose sole member is `undefined`.
            var Undefined = NullaryTypeWithUrl(
              "Undefined",
              typeEq("Undefined")
            );

            //# Unknown :: Type
            //.
            //. Type used to represent missing type information. The type of `[]`,
            //. for example, is `Array ???`.
            //.
            //. May be used with type constructors when defining environments. Given a
            //. type constructor `List :: Type -> Type`, one could use `List ($.Unknown)`
            //. to include an infinite number of types in an environment:
            //.
            //.   - `List Number`
            //.   - `List String`
            //.   - `List (List Number)`
            //.   - `List (List String)`
            //.   - `List (List (List Number))`
            //.   - `List (List (List String))`
            //.   - `...`
            var Unknown = new _Type(
              UNKNOWN,
              "",
              "",
              always2("Unknown"),
              K(true),
              [],
              {}
            );

            //# ValidDate :: Type
            //.
            //. Type comprising every [`Date`][] value except `new Date (NaN)`.
            var ValidDate = NullaryTypeWithUrl(
              "sanctuary-def/ValidDate",
              function(x) {
                return Date_._test(x) && !isNaN(x.valueOf());
              }
            );

            //# ValidNumber :: Type
            //.
            //. Type comprising every [`Number`][] value except `NaN`.
            var ValidNumber = NullaryTypeWithUrl(
              "sanctuary-def/ValidNumber",
              function(x) {
                return Number_._test(x) && !isNaN(x);
              }
            );

            //# env :: Array Type
            //.
            //. An array of [types][]:
            //.
            //.   - <code>[AnyFunction](#AnyFunction)</code>
            //.   - <code>[Arguments](#Arguments)</code>
            //.   - <code>[Array](#Array) ([Unknown](#Unknown))</code>
            //.   - <code>[Boolean](#Boolean)</code>
            //.   - <code>[Date](#Date)</code>
            //.   - <code>[Error](#Error)</code>
            //.   - <code>[HtmlElement](#HtmlElement)</code>
            //.   - <code>[Null](#Null)</code>
            //.   - <code>[Number](#Number)</code>
            //.   - <code>[Object](#Object)</code>
            //.   - <code>[RegExp](#RegExp)</code>
            //.   - <code>[StrMap](#StrMap) ([Unknown](#Unknown))</code>
            //.   - <code>[String](#String)</code>
            //.   - <code>[Symbol](#Symbol)</code>
            //.   - <code>[Undefined](#Undefined)</code>
            var env = [
              AnyFunction,
              Arguments,
              Array_(Unknown),
              Boolean_,
              Date_,
              Error_,
              HtmlElement,
              Null,
              Number_,
              Object_,
              RegExp_,
              StrMap(Unknown),
              String_,
              Symbol_,
              Undefined,
            ];

            //  Unchecked :: String -> Type
            function Unchecked(s) {
              return NullaryType(s)("")(K(true));
            }

            //  production :: Boolean
            var production =
              typeof process !== "undefined" &&
              /* global process:false */
              process != null &&
              process.env != null &&
              "development" === "production";

            var def = _create({ checkTypes: !production, env: env });

            //  numbers :: Array String
            var numbers = [
              "zero",
              "one",
              "two",
              "three",
              "four",
              "five",
              "six",
              "seven",
              "eight",
              "nine",
            ];

            //  numArgs :: Integer -> String
            function numArgs(n) {
              return (
                (n < numbers.length ? numbers[n] : show(n)) +
                " " +
                (n === 1 ? "argument" : "arguments")
              );
            }

            //  expandUnknown :: ... -> Array Type
            function expandUnknown(
              env, // :: Array Type
              seen, // :: Array Object
              value, // :: Any
              r // :: { extractor :: a -> Array b, type :: Type }
            ) {
              return r.type.type === UNKNOWN
                ? _determineActualTypes(env, seen, r.extractor(value))
                : [r.type];
            }

            //  _determineActualTypes :: ... -> Array Type
            function _determineActualTypes(
              env, // :: Array Type
              seen, // :: Array Object
              values // :: Array Any
            ) {
              function refine(types, value) {
                var seen$;
                if (
                  (typeof value === "object" && value != null) ||
                  typeof value === "function"
                ) {
                  //  Abort if a circular reference is encountered; add the current
                  //  object to the array of seen objects otherwise.
                  if (seen.indexOf(value) >= 0) return [];
                  seen$ = Z.concat(seen, [value]);
                } else {
                  seen$ = seen;
                }
                return Z.chain(function(t) {
                  return t.name === "sanctuary-def/Nullable" ||
                    t.validate(value).isLeft
                    ? []
                    : t.type === UNARY
                    ? Z.map(
                        fromUnaryType(t),
                        expandUnknown(env, seen$, value, t.types.$1)
                      )
                    : t.type === BINARY
                    ? xprod(
                        t,
                        expandUnknown(env, seen$, value, t.types.$1),
                        expandUnknown(env, seen$, value, t.types.$2)
                      )
                    : // else
                      [t];
                }, types);
              }

              return isEmpty(values)
                ? [Unknown]
                : or(Z.reduce(refine, env, values), [Inconsistent]);
            }

            //  isConsistent :: Type -> Boolean
            function isConsistent(t) {
              return t.type === UNARY
                ? isConsistent(t.types.$1.type)
                : t.type === BINARY
                ? isConsistent(t.types.$1.type) && isConsistent(t.types.$2.type)
                : /* else */ t.type !== INCONSISTENT;
            }

            //  determineActualTypesStrict :: (Array Type, Array Any) -> Array Type
            function determineActualTypesStrict(env, values) {
              return Z.filter(
                isConsistent,
                _determineActualTypes(env, [], values)
              );
            }

            //  determineActualTypesLoose :: (Array Type, Array Any) -> Array Type
            function determineActualTypesLoose(env, values) {
              return Z.reject(function(t) {
                return t.type === INCONSISTENT;
              }, _determineActualTypes(env, [], values));
            }

            //  TypeInfo = { name :: String
            //             , constraints :: StrMap (Array TypeClass)
            //             , types :: NonEmpty (Array Type) }
            //
            //  TypeVarMap = StrMap { types :: Array Type
            //                      , valuesByPath :: StrMap (Array Any) }
            //
            //  PropPath = Array (Number | String)

            //  updateTypeVarMap :: ... -> TypeVarMap
            function updateTypeVarMap(
              env, // :: Array Type
              typeVarMap, // :: TypeVarMap
              typeVar, // :: Type
              index, // :: Integer
              propPath, // :: PropPath
              values // :: Array Any
            ) {
              var $typeVarMap = {};
              for (var typeVarName in typeVarMap) {
                var entry = typeVarMap[typeVarName];
                var $entry = { types: entry.types.slice(), valuesByPath: {} };
                for (var k in entry.valuesByPath) {
                  $entry.valuesByPath[k] = entry.valuesByPath[k].slice();
                }
                $typeVarMap[typeVarName] = $entry;
              }
              if (!hasOwnProperty.call($typeVarMap, typeVar.name)) {
                $typeVarMap[typeVar.name] = {
                  types: env.slice(),
                  valuesByPath: {},
                };
              }

              var key = JSON.stringify(Z.concat([index], propPath));
              if (
                !hasOwnProperty.call(
                  $typeVarMap[typeVar.name].valuesByPath,
                  key
                )
              ) {
                $typeVarMap[typeVar.name].valuesByPath[key] = [];
              }

              var isNullaryTypeVar = isEmpty(typeVar.keys);
              var isValid = test(env);

              function expandUnknownStrict(value, r) {
                return Z.filter(isConsistent, expandUnknown(env, [], value, r));
              }

              values.forEach(function(value) {
                $typeVarMap[typeVar.name].valuesByPath[key].push(value);
                $typeVarMap[typeVar.name].types = Z.chain(function(t) {
                  return t.keys.length < typeVar.keys.length ||
                    !isValid(t)(value)
                    ? []
                    : isNullaryTypeVar && t.type === UNARY
                    ? Z.map(
                        fromUnaryType(t),
                        expandUnknownStrict(value, t.types.$1)
                      )
                    : isNullaryTypeVar && t.type === BINARY
                    ? xprod(
                        t,
                        expandUnknownStrict(value, t.types.$1),
                        expandUnknownStrict(value, t.types.$2)
                      )
                    : // else
                      [t];
                }, $typeVarMap[typeVar.name].types);
              });

              return $typeVarMap;
            }

            //  underlineTypeVars :: (TypeInfo, StrMap (Array Any)) -> String
            function underlineTypeVars(typeInfo, valuesByPath) {
              //  Note: Sorting these keys lexicographically is not "correct", but it
              //  does the right thing for indexes less than 10.
              var paths = Z.map(JSON.parse, sortedKeys(valuesByPath));
              return underline(typeInfo, K(K(_)), function(index) {
                return function(f) {
                  return function(t) {
                    return function(propPath) {
                      var indexedPropPath = Z.concat([index], propPath);
                      return function(s) {
                        if (paths.some(isPrefix(indexedPropPath))) {
                          var key = JSON.stringify(indexedPropPath);
                          if (!hasOwnProperty.call(valuesByPath, key)) return s;
                          if (!isEmpty(valuesByPath[key])) return f(s);
                        }
                        return _(s);
                      };
                    };
                  };
                };
              });
            }

            //  satisfactoryTypes :: ... -> Either (() -> Error)
            //                                     { typeVarMap :: TypeVarMap
            //                                     , types :: Array Type }
            function satisfactoryTypes(
              env, // :: Array Type
              typeInfo, // :: TypeInfo
              typeVarMap, // :: TypeVarMap
              expType, // :: Type
              index, // :: Integer
              propPath, // :: PropPath
              values // :: Array Any
            ) {
              var recur = satisfactoryTypes;

              for (var idx = 0; idx < values.length; idx += 1) {
                var result = expType.validate(values[idx]);
                if (result.isLeft) {
                  return Left(function() {
                    return invalidValue(
                      env,
                      typeInfo,
                      index,
                      Z.concat(propPath, result.value.propPath),
                      result.value.value
                    );
                  });
                }
              }

              switch (expType.type) {
                case VARIABLE:
                  var typeVarName = expType.name;
                  var constraints = typeInfo.constraints;
                  if (hasOwnProperty.call(constraints, typeVarName)) {
                    var typeClasses = constraints[typeVarName];
                    for (idx = 0; idx < values.length; idx += 1) {
                      for (var idx2 = 0; idx2 < typeClasses.length; idx2 += 1) {
                        if (!typeClasses[idx2].test(values[idx])) {
                          return Left(function() {
                            return typeClassConstraintViolation(
                              env,
                              typeInfo,
                              typeClasses[idx2],
                              index,
                              propPath,
                              values[idx],
                              typeVarMap
                            );
                          });
                        }
                      }
                    }
                  }

                  var typeVarMap$ = updateTypeVarMap(
                    env,
                    typeVarMap,
                    expType,
                    index,
                    propPath,
                    values
                  );

                  var okTypes = typeVarMap$[typeVarName].types;
                  return isEmpty(okTypes)
                    ? Left(function() {
                        return typeVarConstraintViolation(
                          env,
                          typeInfo,
                          index,
                          propPath,
                          typeVarMap$[typeVarName].valuesByPath
                        );
                      })
                    : Z.reduce(
                        function(e, t) {
                          return Z.chain(function(r) {
                            //  The `a` in `Functor f => f a` corresponds to the `a`
                            //  in `Maybe a` but to the `b` in `Either a b`. A type
                            //  variable's $1 will correspond to either $1 or $2 of
                            //  the actual type depending on the actual type's arity.
                            var offset = t.keys.length - expType.keys.length;
                            return expType.keys.reduce(function(e, k, idx) {
                              var extractor =
                                t.types[t.keys[offset + idx]].extractor;
                              return Z.reduce(
                                function(e, x) {
                                  return Z.chain(function(r) {
                                    return recur(
                                      env,
                                      typeInfo,
                                      r.typeVarMap,
                                      expType.types[k].type,
                                      index,
                                      Z.concat(propPath, [k]),
                                      [x]
                                    );
                                  }, e);
                                },
                                e,
                                Z.chain(extractor, values)
                              );
                            }, Right(r));
                          }, e);
                        },
                        Right({ typeVarMap: typeVarMap$, types: okTypes }),
                        okTypes
                      );

                case UNARY:
                  return Z.map(function(result) {
                    return {
                      typeVarMap: result.typeVarMap,
                      types: Z.map(
                        fromUnaryType(expType),
                        or(result.types, [expType.types.$1.type])
                      ),
                    };
                  }, recur(
                    env,
                    typeInfo,
                    typeVarMap,
                    expType.types.$1.type,
                    index,
                    Z.concat(propPath, ["$1"]),
                    Z.chain(expType.types.$1.extractor, values)
                  ));

                case BINARY:
                  return Z.chain(function(result) {
                    var $1s = result.types;
                    return Z.map(function(result) {
                      var $2s = result.types;
                      return {
                        typeVarMap: result.typeVarMap,
                        types: xprod(
                          expType,
                          or($1s, [expType.types.$1.type]),
                          or($2s, [expType.types.$2.type])
                        ),
                      };
                    }, recur(
                      env,
                      typeInfo,
                      result.typeVarMap,
                      expType.types.$2.type,
                      index,
                      Z.concat(propPath, ["$2"]),
                      Z.chain(expType.types.$2.extractor, values)
                    ));
                  }, recur(
                    env,
                    typeInfo,
                    typeVarMap,
                    expType.types.$1.type,
                    index,
                    Z.concat(propPath, ["$1"]),
                    Z.chain(expType.types.$1.extractor, values)
                  ));

                case RECORD:
                  return Z.reduce(
                    function(e, k) {
                      return Z.chain(function(r) {
                        return recur(
                          env,
                          typeInfo,
                          r.typeVarMap,
                          expType.types[k].type,
                          index,
                          Z.concat(propPath, [k]),
                          Z.chain(expType.types[k].extractor, values)
                        );
                      }, e);
                    },
                    Right({ typeVarMap: typeVarMap, types: [expType] }),
                    expType.keys
                  );

                default:
                  return Right({ typeVarMap: typeVarMap, types: [expType] });
              }
            }

            //# test :: Array Type -> Type -> a -> Boolean
            //.
            //. Takes an environment, a type, and any value. Returns `true` if the value
            //. is a member of the type; `false` otherwise.
            //.
            //. The environment is only significant if the type contains
            //. [type variables][].
            //.
            //. One may define a more restrictive type in terms of a more general one:
            //.
            //. ```javascript
            //. //    NonNegativeInteger :: Type
            //. const NonNegativeInteger = $.NullaryType
            //.   ('my-package/NonNegativeInteger')
            //.   ('http://example.com/my-package#NonNegativeInteger')
            //.   (x => $.test ([]) ($.Integer) (x) && x >= 0);
            //. ```
            //.
            //. Using types as predicates is useful in other contexts too. One could,
            //. for example, define a [record type][] for each endpoint of a REST API
            //. and validate the bodies of incoming POST requests against these types.
            function test(env) {
              return function(t) {
                return function(x) {
                  var typeInfo = { name: "name", constraints: {}, types: [t] };
                  return satisfactoryTypes(
                    env,
                    typeInfo,
                    {},
                    t,
                    0,
                    [],
                    [x]
                  ).isRight;
                };
              };
            }

            //. ### Type constructors
            //.
            //. sanctuary-def provides several functions for defining types.

            //# NullaryType :: String -> String -> (Any -> Boolean) -> Type
            //.
            //. Type constructor for types with no type variables (such as [`Number`][]).
            //.
            //. To define a nullary type `t` one must provide:
            //.
            //.   - the name of `t` (exposed as `t.name`);
            //.
            //.   - the documentation URL of `t` (exposed as `t.url`); and
            //.
            //.   - a predicate which accepts any JavaScript value and returns `true` if
            //.     (and only if) the value is a member of `t`.
            //.
            //. For example:
            //.
            //. ```javascript
            //. //    Integer :: Type
            //. const Integer = $.NullaryType
            //.   ('my-package/Integer')
            //.   ('http://example.com/my-package#Integer')
            //.   (x => typeof x === 'number' &&
            //.         Math.floor (x) === x &&
            //.         x >= Number.MIN_SAFE_INTEGER &&
            //.         x <= Number.MAX_SAFE_INTEGER);
            //.
            //. //    NonZeroInteger :: Type
            //. const NonZeroInteger = $.NullaryType
            //.   ('my-package/NonZeroInteger')
            //.   ('http://example.com/my-package#NonZeroInteger')
            //.   (x => $.test ([]) (Integer) (x) && x !== 0);
            //.
            //. //    rem :: Integer -> NonZeroInteger -> Integer
            //. const rem =
            //. def ('rem')
            //.     ({})
            //.     ([Integer, NonZeroInteger, Integer])
            //.     (x => y => x % y);
            //.
            //. rem (42) (5);
            //. // => 2
            //.
            //. rem (0.5);
            //. // ! TypeError: Invalid value
            //. //
            //. //   rem :: Integer -> NonZeroInteger -> Integer
            //. //          ^^^^^^^
            //. //             1
            //. //
            //. //   1)  0.5 :: Number
            //. //
            //. //   The value at position 1 is not a member of ‘Integer’.
            //.
            //. rem (42) (0);
            //. // ! TypeError: Invalid value
            //. //
            //. //   rem :: Integer -> NonZeroInteger -> Integer
            //. //                     ^^^^^^^^^^^^^^
            //. //                           1
            //. //
            //. //   1)  0 :: Number
            //. //
            //. //   The value at position 1 is not a member of ‘NonZeroInteger’.
            //. ```
            function NullaryType(name) {
              function format(outer, inner) {
                return outer(stripNamespace(name));
              }
              return function(url) {
                return function(test) {
                  return new _Type(NULLARY, name, url, format, test, [], {});
                };
              };
            }

            var CheckedNullaryType = def("NullaryType")({})([
              String_,
              String_,
              Function_([Any, Boolean_]),
              Type,
            ])(NullaryType);

            //# UnaryType :: String -> String -> (Any -> Boolean) -> (t a -> Array a) -> Type -> Type
            //.
            //. Type constructor for types with one type variable (such as [`Array`][]).
            //.
            //. To define a unary type `t a` one must provide:
            //.
            //.   - the name of `t` (exposed as `t.name`);
            //.
            //.   - the documentation URL of `t` (exposed as `t.url`);
            //.
            //.   - a predicate which accepts any JavaScript value and returns `true`
            //.     if (and only if) the value is a member of `t x` for some type `x`;
            //.
            //.   - a function which takes any value of type `t a` and returns an array
            //.     of the values of type `a` contained in the `t` (exposed as
            //.     `t.types.$1.extractor`); and
            //.
            //.   - the type of `a` (exposed as `t.types.$1.type`).
            //.
            //. For example:
            //.
            //. ```javascript
            //. const show = require ('sanctuary-show');
            //. const type = require ('sanctuary-type-identifiers');
            //.
            //. //    maybeTypeIdent :: String
            //. const maybeTypeIdent = 'my-package/Maybe';
            //.
            //. //    Maybe :: Type -> Type
            //. const Maybe = $.UnaryType
            //.   (maybeTypeIdent)
            //.   ('http://example.com/my-package#Maybe')
            //.   (x => type (x) === maybeTypeIdent)
            //.   (maybe => maybe.isJust ? [maybe.value] : []);
            //.
            //. //    MaybeTypeRep :: TypeRep Maybe
            //. const MaybeTypeRep = {'@@type': maybeTypeIdent};
            //.
            //. //    Nothing :: Maybe a
            //. const Nothing = {
            //.   'constructor': MaybeTypeRep,
            //.   'isJust': false,
            //.   'isNothing': true,
            //.   '@@show': () => 'Nothing',
            //. };
            //.
            //. //    Just :: a -> Maybe a
            //. const Just = x => ({
            //.   'constructor': MaybeTypeRep,
            //.   'isJust': true,
            //.   'isNothing': false,
            //.   '@@show': () => `Just (${show (x)})`,
            //.   'value': x,
            //. });
            //.
            //. //    fromMaybe :: a -> Maybe a -> a
            //. const fromMaybe =
            //. def ('fromMaybe')
            //.     ({})
            //.     ([a, Maybe (a), a])
            //.     (x => m => m.isJust ? m.value : x);
            //.
            //. fromMaybe (0) (Just (42));
            //. // => 42
            //.
            //. fromMaybe (0) (Nothing);
            //. // => 0
            //.
            //. fromMaybe (0) (Just ('XXX'));
            //. // ! TypeError: Type-variable constraint violation
            //. //
            //. //   fromMaybe :: a -> Maybe a -> a
            //. //                ^          ^
            //. //                1          2
            //. //
            //. //   1)  0 :: Number
            //. //
            //. //   2)  "XXX" :: String
            //. //
            //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.
            //. ```
            function UnaryType(name) {
              return function(url) {
                return function(test) {
                  return function(_1) {
                    return function($1) {
                      function format(outer, inner) {
                        return (
                          outer("(" + stripNamespace(name) + " ") +
                          inner("$1")(show($1)) +
                          outer(")")
                        );
                      }
                      var types = { $1: { extractor: _1, type: $1 } };
                      return new _Type(
                        UNARY,
                        name,
                        url,
                        format,
                        test,
                        ["$1"],
                        types
                      );
                    };
                  };
                };
              };
            }

            var CheckedUnaryType = def("UnaryType")({})([
              String_,
              String_,
              Function_([Any, Boolean_]),
              Function_([Unchecked("t a"), Array_(Unchecked("a"))]),
              AnyFunction,
            ])(function(name) {
              return function(url) {
                return function(test) {
                  return compose(
                    def(stripNamespace(name))({})([Type, Type]),
                    UnaryType(name)(url)(test)
                  );
                };
              };
            });

            //  fromUnaryType :: Type -> (Type -> Type)
            function fromUnaryType(t) {
              return UnaryType(t.name)(t.url)(t._test)(t.types.$1.extractor);
            }

            //# BinaryType :: String -> String -> (Any -> Boolean) -> (t a b -> Array a) -> (t a b -> Array b) -> Type -> Type -> Type
            //.
            //. Type constructor for types with two type variables (such as
            //. [`Array2`][]).
            //.
            //. To define a binary type `t a b` one must provide:
            //.
            //.   - the name of `t` (exposed as `t.name`);
            //.
            //.   - the documentation URL of `t` (exposed as `t.url`);
            //.
            //.   - a predicate which accepts any JavaScript value and returns `true`
            //.     if (and only if) the value is a member of `t x y` for some types
            //.     `x` and `y`;
            //.
            //.   - a function which takes any value of type `t a b` and returns an array
            //.     of the values of type `a` contained in the `t` (exposed as
            //.     `t.types.$1.extractor`);
            //.
            //.   - a function which takes any value of type `t a b` and returns an array
            //.     of the values of type `b` contained in the `t` (exposed as
            //.     `t.types.$2.extractor`);
            //.
            //.   - the type of `a` (exposed as `t.types.$1.type`); and
            //.
            //.   - the type of `b` (exposed as `t.types.$2.type`).
            //.
            //. For example:
            //.
            //. ```javascript
            //. const type = require ('sanctuary-type-identifiers');
            //.
            //. //    pairTypeIdent :: String
            //. const pairTypeIdent = 'my-package/Pair';
            //.
            //. //    $Pair :: Type -> Type -> Type
            //. const $Pair = $.BinaryType
            //.   (pairTypeIdent)
            //.   ('http://example.com/my-package#Pair')
            //.   (x => type (x) === pairTypeIdent)
            //.   (({fst}) => [fst])
            //.   (({snd}) => [snd]);
            //.
            //. //    PairTypeRep :: TypeRep Pair
            //. const PairTypeRep = {'@@type': pairTypeIdent};
            //.
            //. //    Pair :: a -> b -> Pair a b
            //. const Pair =
            //. def ('Pair')
            //.     ({})
            //.     ([a, b, $Pair (a) (b)])
            //.     (fst => snd => ({
            //.        'constructor': PairTypeRep,
            //.        'fst': fst,
            //.        'snd': snd,
            //.        '@@show': () => `Pair (${show (fst)}) (${show (snd)})`,
            //.      }));
            //.
            //. //    Rank :: Type
            //. const Rank = $.NullaryType
            //.   ('my-package/Rank')
            //.   ('http://example.com/my-package#Rank')
            //.   (x => typeof x === 'string' &&
            //.         /^(A|2|3|4|5|6|7|8|9|10|J|Q|K)$/.test (x));
            //.
            //. //    Suit :: Type
            //. const Suit = $.NullaryType
            //.   ('my-package/Suit')
            //.   ('http://example.com/my-package#Suit')
            //.   (x => typeof x === 'string' &&
            //.         /^[\u2660\u2663\u2665\u2666]$/.test (x));
            //.
            //. //    Card :: Type
            //. const Card = $Pair (Rank) (Suit);
            //.
            //. //    showCard :: Card -> String
            //. const showCard =
            //. def ('showCard')
            //.     ({})
            //.     ([Card, $.String])
            //.     (card => card.fst + card.snd);
            //.
            //. showCard (Pair ('A') ('♠'));
            //. // => 'A♠'
            //.
            //. showCard (Pair ('X') ('♠'));
            //. // ! TypeError: Invalid value
            //. //
            //. //   showCard :: Pair Rank Suit -> String
            //. //                    ^^^^
            //. //                     1
            //. //
            //. //   1)  "X" :: String
            //. //
            //. //   The value at position 1 is not a member of ‘Rank’.
            //. ```
            function BinaryType(name) {
              return function(url) {
                return function(test) {
                  return function(_1) {
                    return function(_2) {
                      return function($1) {
                        return function($2) {
                          function format(outer, inner) {
                            return (
                              outer("(" + stripNamespace(name) + " ") +
                              inner("$1")(show($1)) +
                              outer(" ") +
                              inner("$2")(show($2)) +
                              outer(")")
                            );
                          }
                          return new _Type(
                            BINARY,
                            name,
                            url,
                            format,
                            test,
                            ["$1", "$2"],
                            {
                              $1: { extractor: _1, type: $1 },
                              $2: { extractor: _2, type: $2 },
                            }
                          );
                        };
                      };
                    };
                  };
                };
              };
            }

            var CheckedBinaryType = def("BinaryType")({})([
              String_,
              String_,
              Function_([Any, Boolean_]),
              Function_([Unchecked("t a b"), Array_(Unchecked("a"))]),
              Function_([Unchecked("t a b"), Array_(Unchecked("b"))]),
              AnyFunction,
            ])(function(name) {
              return function(url) {
                return function(test) {
                  return function(_1) {
                    return function(_2) {
                      return def(
                        stripNamespace(name)
                      )({})([Type, Type, Type])(BinaryType(name)(url)(test)(_1)(_2));
                    };
                  };
                };
              };
            });

            //  xprod :: (Type, Array Type, Array Type) -> Array Type
            function xprod(t, $1s, $2s) {
              return Z.chain(function(specialize) {
                return Z.map(specialize, $2s);
              }, Z.map(
                BinaryType(t.name)(t.url)(t._test)(t.types.$1.extractor)(
                  t.types.$2.extractor
                ),
                $1s
              ));
            }

            //# EnumType :: String -> String -> Array Any -> Type
            //.
            //. Type constructor for [enumerated types][] (such as [`RegexFlags`][]).
            //.
            //. To define an enumerated type `t` one must provide:
            //.
            //.   - the name of `t` (exposed as `t.name`);
            //.
            //.   - the documentation URL of `t` (exposed as `t.url`); and
            //.
            //.   - an array of distinct values.
            //.
            //. For example:
            //.
            //. ```javascript
            //. //    Denomination :: Type
            //. const Denomination = $.EnumType
            //.   ('my-package/Denomination')
            //.   ('http://example.com/my-package#Denomination')
            //.   ([10, 20, 50, 100, 200]);
            //. ```
            function EnumType(name) {
              return function(url) {
                return compose(
                  NullaryType(name)(url),
                  memberOf
                );
              };
            }

            var CheckedEnumType = def("EnumType")({})([
              String_,
              String_,
              Array_(Any),
              Type,
            ])(EnumType);

            //# RecordType :: StrMap Type -> Type
            //.
            //. `RecordType` is used to construct record types. The type definition
            //. specifies the name and type of each required field. A field is an
            //. enumerable property (either an own property or an inherited property).
            //.
            //. To define a record type one must provide:
            //.
            //.   - an object mapping field name to type.
            //.
            //. For example:
            //.
            //. ```javascript
            //. //    Point :: Type
            //. const Point = $.RecordType ({x: $.FiniteNumber, y: $.FiniteNumber});
            //.
            //. //    dist :: Point -> Point -> FiniteNumber
            //. const dist =
            //. def ('dist')
            //.     ({})
            //.     ([Point, Point, $.FiniteNumber])
            //.     (p => q => Math.sqrt (Math.pow (p.x - q.x, 2) +
            //.                           Math.pow (p.y - q.y, 2)));
            //.
            //. dist ({x: 0, y: 0}) ({x: 3, y: 4});
            //. // => 5
            //.
            //. dist ({x: 0, y: 0}) ({x: 3, y: 4, color: 'red'});
            //. // => 5
            //.
            //. dist ({x: 0, y: 0}) ({x: NaN, y: NaN});
            //. // ! TypeError: Invalid value
            //. //
            //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber
            //. //                                                              ^^^^^^^^^^^^
            //. //                                                                   1
            //. //
            //. //   1)  NaN :: Number
            //. //
            //. //   The value at position 1 is not a member of ‘FiniteNumber’.
            //.
            //. dist (0);
            //. // ! TypeError: Invalid value
            //. //
            //. //   dist :: { x :: FiniteNumber, y :: FiniteNumber } -> { x :: FiniteNumber, y :: FiniteNumber } -> FiniteNumber
            //. //           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            //. //                              1
            //. //
            //. //   1)  0 :: Number
            //. //
            //. //   The value at position 1 is not a member of ‘{ x :: FiniteNumber, y :: FiniteNumber }’.
            //. ```
            function RecordType(fields) {
              var keys = sortedKeys(fields);

              function format(outer, inner) {
                if (isEmpty(keys)) return outer("{}");
                var reprs = Z.map(function(k) {
                  var t = fields[k];
                  return (
                    outer(" ") +
                    outer(/^(?!\d)[$\w]+$/.test(k) ? k : show(k)) +
                    outer(" :: ") +
                    unless(
                      t.type === RECORD || isEmpty(t.keys),
                      stripOutermostParens,
                      inner(k)(show(t))
                    )
                  );
                }, keys);
                return wrap(
                  outer("{")
                )(outer(" }"))(joinWith(outer(","), reprs));
              }

              function test(x) {
                var missing = {};
                keys.forEach(function(k) {
                  missing[k] = k;
                });
                for (var k in x) delete missing[k];
                return isEmpty(Object.keys(missing));
              }

              var $types = {};
              keys.forEach(function(k) {
                $types[k] = {
                  extractor: function(x) {
                    return [x[k]];
                  },
                  type: fields[k],
                };
              });

              return new _Type(RECORD, "", "", format, test, keys, $types);
            }

            var CheckedRecordType = def("RecordType")({})([StrMap(Type), Type])(
              RecordType
            );

            //# TypeVariable :: String -> Type
            //.
            //. Polymorphism is powerful. Not being able to define a function for
            //. all types would be very limiting indeed: one couldn't even define the
            //. identity function!
            //.
            //. Before defining a polymorphic function one must define one or more type
            //. variables:
            //.
            //. ```javascript
            //. const a = $.TypeVariable ('a');
            //. const b = $.TypeVariable ('b');
            //.
            //. //    id :: a -> a
            //. const id = def ('id') ({}) ([a, a]) (x => x);
            //.
            //. id (42);
            //. // => 42
            //.
            //. id (null);
            //. // => null
            //. ```
            //.
            //. The same type variable may be used in multiple positions, creating a
            //. constraint:
            //.
            //. ```javascript
            //. //    cmp :: a -> a -> Number
            //. const cmp =
            //. def ('cmp')
            //.     ({})
            //.     ([a, a, $.Number])
            //.     (x => y => x < y ? -1 : x > y ? 1 : 0);
            //.
            //. cmp (42) (42);
            //. // => 0
            //.
            //. cmp ('a') ('z');
            //. // => -1
            //.
            //. cmp ('z') ('a');
            //. // => 1
            //.
            //. cmp (0) ('1');
            //. // ! TypeError: Type-variable constraint violation
            //. //
            //. //   cmp :: a -> a -> Number
            //. //          ^    ^
            //. //          1    2
            //. //
            //. //   1)  0 :: Number
            //. //
            //. //   2)  "1" :: String
            //. //
            //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.
            //. ```
            function TypeVariable(name) {
              return new _Type(
                VARIABLE,
                name,
                "",
                always2(name),
                K(true),
                [],
                {}
              );
            }

            var CheckedTypeVariable = def("TypeVariable")({})([String_, Type])(
              TypeVariable
            );

            //# UnaryTypeVariable :: String -> Type -> Type
            //.
            //. Combines [`UnaryType`][] and [`TypeVariable`][].
            //.
            //. To define a unary type variable `t a` one must provide:
            //.
            //.   - a name (conventionally matching `^[a-z]$`); and
            //.
            //.   - the type of `a` (exposed as `t.types.$1.type`).
            //.
            //. Consider the type of a generalized `map`:
            //.
            //. ```haskell
            //. map :: Functor f => (a -> b) -> f a -> f b
            //. ```
            //.
            //. `f` is a unary type variable. With two (nullary) type variables, one
            //. unary type variable, and one [type class][] it's possible to define a
            //. fully polymorphic `map` function:
            //.
            //. ```javascript
            //. const $ = require ('sanctuary-def');
            //. const Z = require ('sanctuary-type-classes');
            //.
            //. const a = $.TypeVariable ('a');
            //. const b = $.TypeVariable ('b');
            //. const f = $.UnaryTypeVariable ('f');
            //.
            //. //    map :: Functor f => (a -> b) -> f a -> f b
            //. const map =
            //. def ('map')
            //.     ({f: [Z.Functor]})
            //.     ([$.Function ([a, b]), f (a), f (b)])
            //.     (f => functor => Z.map (f, functor));
            //. ```
            //.
            //. Whereas a regular type variable is fully resolved (`a` might become
            //. `Array (Array String)`, for example), a unary type variable defers to
            //. its type argument, which may itself be a type variable. The type argument
            //. corresponds to the type argument of a unary type or the *second* type
            //. argument of a binary type. The second type argument of `Map k v`, for
            //. example, is `v`. One could replace `Functor => f` with `Map k` or with
            //. `Map Integer`, but not with `Map`.
            //.
            //. This shallow inspection makes it possible to constrain a value's "outer"
            //. and "inner" types independently.
            function UnaryTypeVariable(name) {
              return function($1) {
                function format(outer, inner) {
                  return (
                    outer("(" + name + " ") + inner("$1")(show($1)) + outer(")")
                  );
                }
                var types = { $1: { extractor: K([]), type: $1 } };
                return new _Type(
                  VARIABLE,
                  name,
                  "",
                  format,
                  K(true),
                  ["$1"],
                  types
                );
              };
            }

            var CheckedUnaryTypeVariable = def("UnaryTypeVariable")({})([
              String_,
              AnyFunction,
            ])(function(name) {
              return def(name)({})([Type, Type])(UnaryTypeVariable(name));
            });

            //# BinaryTypeVariable :: String -> Type -> Type -> Type
            //.
            //. Combines [`BinaryType`][] and [`TypeVariable`][].
            //.
            //. To define a binary type variable `t a b` one must provide:
            //.
            //.   - a name (conventionally matching `^[a-z]$`);
            //.
            //.   - the type of `a` (exposed as `t.types.$1.type`); and
            //.
            //.   - the type of `b` (exposed as `t.types.$2.type`).
            //.
            //. The more detailed explanation of [`UnaryTypeVariable`][] also applies to
            //. `BinaryTypeVariable`.
            function BinaryTypeVariable(name) {
              return function($1) {
                return function($2) {
                  function format(outer, inner) {
                    return (
                      outer("(" + name + " ") +
                      inner("$1")(show($1)) +
                      outer(" ") +
                      inner("$2")(show($2)) +
                      outer(")")
                    );
                  }
                  var keys = ["$1", "$2"];
                  var types = {
                    $1: { extractor: K([]), type: $1 },
                    $2: { extractor: K([]), type: $2 },
                  };
                  return new _Type(
                    VARIABLE,
                    name,
                    "",
                    format,
                    K(true),
                    keys,
                    types
                  );
                };
              };
            }

            var CheckedBinaryTypeVariable = def("BinaryTypeVariable")({})([
              String_,
              AnyFunction,
            ])(function(name) {
              return def(
                name
              )({})([Type, Type, Type])(BinaryTypeVariable(name));
            });

            //# Thunk :: Type -> Type
            //.
            //. `$.Thunk (T)` is shorthand for `$.Function ([T])`, the type comprising
            //. every nullary function (thunk) which returns a value of type `T`.
            var Thunk = def("Thunk")({})([Type, Type])(function(t) {
              return Function_([t]);
            });

            //# Predicate :: Type -> Type
            //.
            //. `$.Predicate (T)` is shorthand for `$.Function ([T, $.Boolean])`, the
            //. type comprising every predicate function which takes a value of type `T`.
            var Predicate = def("Predicate")({})([Type, Type])(function(t) {
              return Function_([t, Boolean_]);
            });

            //. ### Type classes
            //.
            //. `concatS`, defined earlier, is a function which concatenates two strings.
            //. This is overly restrictive, since other types support concatenation
            //. (Array, for example).
            //.
            //. One could use a type variable to define a polymorphic "concat" function:
            //.
            //. ```javascript
            //. //    _concat :: a -> a -> a
            //. const _concat =
            //. def ('_concat')
            //.     ({})
            //.     ([a, a, a])
            //.     (x => y => x.concat (y));
            //.
            //. _concat ('fizz') ('buzz');
            //. // => 'fizzbuzz'
            //.
            //. _concat ([1, 2]) ([3, 4]);
            //. // => [1, 2, 3, 4]
            //.
            //. _concat ([1, 2]) ('buzz');
            //. // ! TypeError: Type-variable constraint violation
            //. //
            //. //   _concat :: a -> a -> a
            //. //              ^    ^
            //. //              1    2
            //. //
            //. //   1)  [1, 2] :: Array Number
            //. //
            //. //   2)  "buzz" :: String
            //. //
            //. //   Since there is no type of which all the above values are members, the type-variable constraint has been violated.
            //. ```
            //.
            //. The type of `_concat` is misleading: it suggests that it can operate on
            //. any two values of *any* one type. In fact there's an implicit constraint,
            //. since the type must support concatenation (in [mathematical][semigroup]
            //. terms, the type must have a [semigroup][FL:Semigroup]). Violating this
            //. implicit constraint results in a run-time error in the implementation:
            //.
            //. ```javascript
            //. _concat (null) (null);
            //. // ! TypeError: Cannot read property 'concat' of null
            //. ```
            //.
            //. The solution is to constrain `a` by first defining a [`TypeClass`][]
            //. value, then specifying the constraint in the definition of the "concat"
            //. function:
            //.
            //. ```javascript
            //. const Z = require ('sanctuary-type-classes');
            //.
            //. //    Semigroup :: TypeClass
            //. const Semigroup = Z.TypeClass (
            //.   'my-package/Semigroup',
            //.   'http://example.com/my-package#Semigroup',
            //.   [],
            //.   x => x != null && typeof x.concat === 'function'
            //. );
            //.
            //. //    concat :: Semigroup a => a -> a -> a
            //. const concat =
            //. def ('concat')
            //.     ({a: [Semigroup]})
            //.     ([a, a, a])
            //.     (x => y => x.concat (y));
            //.
            //. concat ([1, 2]) ([3, 4]);
            //. // => [1, 2, 3, 4]
            //.
            //. concat (null) (null);
            //. // ! TypeError: Type-class constraint violation
            //. //
            //. //   concat :: Semigroup a => a -> a -> a
            //. //             ^^^^^^^^^^^    ^
            //. //                            1
            //. //
            //. //   1)  null :: Null
            //. //
            //. //   ‘concat’ requires ‘a’ to satisfy the Semigroup type-class constraint; the value at position 1 does not.
            //. //
            //. //   See http://example.com/my-package#Semigroup for information about the my-package/Semigroup type class.
            //. ```
            //.
            //. Multiple constraints may be placed on a type variable by including
            //. multiple `TypeClass` values in the array (e.g. `{a: [Foo, Bar, Baz]}`).

            //  invalidArgumentsCount :: (TypeInfo, Integer, Integer, Array Any) -> Error
            //
            //  This function is used in `curry` when a function defined via `def`
            //  is applied to too many arguments.
            function invalidArgumentsCount(
              typeInfo,
              index,
              numArgsExpected,
              args
            ) {
              return new TypeError(
                trimTrailingSpaces(
                  q(typeInfo.name) +
                    " applied to the wrong number of arguments\n\n" +
                    underline(typeInfo, K(K(_)), function(index_) {
                      return function(f) {
                        return K(K(index_ === index ? f : _));
                      };
                    }) +
                    "\n" +
                    "Expected " +
                    numArgs(numArgsExpected) +
                    " but received " +
                    numArgs(args.length) +
                    toMarkdownList(".\n", ":\n\n", show, args)
                )
              );
            }

            //  constraintsRepr :: ... -> String
            function constraintsRepr(
              constraints, // :: StrMap (Array TypeClass)
              outer, // :: String -> String
              inner // :: String -> TypeClass -> String -> String
            ) {
              var $reprs = [];
              sortedKeys(constraints).forEach(function(k) {
                var f = inner(k);
                constraints[k].forEach(function(typeClass) {
                  $reprs.push(
                    f(typeClass)(stripNamespace(typeClass.name) + " " + k)
                  );
                });
              });
              return when(
                $reprs.length > 0,
                function(s) {
                  return s + outer(" => ");
                },
                when(
                  $reprs.length > 1,
                  wrap(outer("("))(outer(")")),
                  joinWith(outer(", "), $reprs)
                )
              );
            }

            //  label :: String -> String -> String
            function label(label) {
              return function(s) {
                var delta = s.length - label.length;
                return (
                  strRepeat(" ", Math.floor(delta / 2)) +
                  label +
                  strRepeat(" ", Math.ceil(delta / 2))
                );
              };
            }

            //  typeVarNames :: Type -> Array String
            function typeVarNames(t) {
              return Z.concat(
                t.type === VARIABLE ? [t.name] : [],
                Z.chain(function(k) {
                  return typeVarNames(t.types[k].type);
                }, t.keys)
              );
            }

            //  showTypeWith :: TypeInfo -> Type -> String
            function showTypeWith(typeInfo) {
              var names = Z.chain(typeVarNames, typeInfo.types);
              return function(t) {
                var code = "a".charCodeAt(0);
                return unless(
                  t.type === FUNCTION || t.type === RECORD || isEmpty(t.keys),
                  stripOutermostParens,
                  show(t).replace(/\bUnknown\b/g, function() {
                    // eslint-disable-next-line no-plusplus
                    do var name = String.fromCharCode(code++);
                    while (names.indexOf(name) >= 0);
                    return name;
                  })
                );
              };
            }

            //  showTypeQuoted :: Type -> String
            function showTypeQuoted(t) {
              return q(
                unless(
                  t.type === RECORD || isEmpty(t.keys),
                  stripOutermostParens,
                  show(t)
                )
              );
            }

            //  showValuesAndTypes :: ... -> String
            function showValuesAndTypes(
              env, // :: Array Type
              typeInfo, // :: TypeInfo
              values, // :: Array Any
              pos // :: Integer
            ) {
              var showType = showTypeWith(typeInfo);
              return (
                show(pos) +
                ")  " +
                joinWith(
                  "\n    ",
                  Z.map(function(x) {
                    var types = determineActualTypesLoose(env, [x]);
                    return (
                      show(x) + " :: " + joinWith(", ", Z.map(showType, types))
                    );
                  }, values)
                )
              );
            }

            //  typeSignature :: TypeInfo -> String
            function typeSignature(typeInfo) {
              var reprs = Z.map(showTypeWith(typeInfo), typeInfo.types);
              var arity = reprs.length - 1;
              return (
                typeInfo.name +
                " :: " +
                constraintsRepr(typeInfo.constraints, id, K(K(id))) +
                when(arity === 0, parenthesize, joinWith(" -> ", init(reprs))) +
                " -> " +
                last(reprs)
              );
            }

            //  _underline :: ... -> String
            function _underline(
              t, // :: Type
              propPath, // :: PropPath
              formatType3 // :: Type -> Array String -> String -> String
            ) {
              return unless(
                t.type === RECORD ||
                  isEmpty(t.keys) ||
                  (t.type === FUNCTION && isEmpty(propPath)) ||
                  !isEmpty(propPath),
                stripOutermostParens,
                formatType3(t)(propPath)(
                  t.format(_, function(k) {
                    return K(
                      _underline(
                        t.types[k].type,
                        Z.concat(propPath, [k]),
                        formatType3
                      )
                    );
                  })
                )
              );
            }

            //  underline :: ... -> String
            function underline(
              typeInfo, // :: TypeInfo
              underlineConstraint, // :: String -> TypeClass -> String -> String
              formatType5
              // :: Integer -> (String -> String) -> Type -> PropPath -> String -> String
            ) {
              var st = typeInfo.types.reduce(
                function(st, t, index) {
                  var formatType4 = formatType5(index);
                  st.numbers.push(
                    _underline(
                      t,
                      [],
                      formatType4(function(s) {
                        return label(show((st.counter += 1)))(s);
                      })
                    )
                  );
                  st.carets.push(
                    _underline(
                      t,
                      [],
                      W(function(type) {
                        var repr = show(type);
                        var parenthesized =
                          repr.slice(0, 1) + repr.slice(-1) === "()";
                        return formatType4(function(s) {
                          return parenthesized &&
                            repr !== "()" &&
                            s.length === repr.length
                            ? _("(") + r("^")(s.slice(1, -1)) + _(")")
                            : r("^")(s);
                        });
                      })
                    )
                  );
                  return st;
                },
                { carets: [], numbers: [], counter: 0 }
              );

              return (
                typeSignature(typeInfo) +
                "\n" +
                _(typeInfo.name + " :: ") +
                constraintsRepr(typeInfo.constraints, _, underlineConstraint) +
                joinWith(_(" -> "), st.carets) +
                "\n" +
                _(typeInfo.name + " :: ") +
                constraintsRepr(typeInfo.constraints, _, K(K(_))) +
                joinWith(_(" -> "), st.numbers) +
                "\n"
              );
            }

            //  resolvePropPath :: (Type, Array String) -> Type
            function resolvePropPath(t, propPath) {
              return Z.reduce(
                function(t, prop) {
                  return t.types[prop].type;
                },
                t,
                propPath
              );
            }

            //  formatType6 ::
            //    PropPath -> Integer -> (String -> String) ->
            //      Type -> PropPath -> String -> String
            function formatType6(indexedPropPath) {
              return function(index_) {
                return function(f) {
                  return function(t) {
                    return function(propPath_) {
                      var indexedPropPath_ = Z.concat([index_], propPath_);
                      var p = isPrefix(indexedPropPath_)(indexedPropPath);
                      var q = isPrefix(indexedPropPath)(indexedPropPath_);
                      return p && q ? f : p ? id : _;
                    };
                  };
                };
              };
            }

            //  see :: (String, { name :: String, url :: String? }) -> String
            function see(label, record) {
              return record.url == null || record.url === ""
                ? ""
                : "\nSee " +
                    record.url +
                    " for information about the " +
                    record.name +
                    " " +
                    label +
                    ".\n";
            }

            //  typeClassConstraintViolation :: ... -> Error
            function typeClassConstraintViolation(
              env, // :: Array Type
              typeInfo, // :: TypeInfo
              typeClass, // :: TypeClass
              index, // :: Integer
              propPath, // :: PropPath
              value, // :: Any
              typeVarMap // :: TypeVarMap
            ) {
              var expType = resolvePropPath(typeInfo.types[index], propPath);
              return new TypeError(
                trimTrailingSpaces(
                  "Type-class constraint violation\n\n" +
                    underline(
                      typeInfo,
                      function(tvn) {
                        return function(tc) {
                          return tvn === expType.name &&
                            tc.name === typeClass.name
                            ? r("^")
                            : _;
                        };
                      },
                      formatType6(Z.concat([index], propPath))
                    ) +
                    "\n" +
                    showValuesAndTypes(env, typeInfo, [value], 1) +
                    "\n\n" +
                    q(typeInfo.name) +
                    " requires " +
                    q(expType.name) +
                    " to satisfy the " +
                    stripNamespace(typeClass.name) +
                    " type-class constraint; " +
                    "the value at position 1 does not.\n" +
                    see("type class", typeClass)
                )
              );
            }

            //  typeVarConstraintViolation :: ... -> Error
            function typeVarConstraintViolation(
              env, // :: Array Type
              typeInfo, // :: TypeInfo
              index, // :: Integer
              propPath, // :: PropPath
              valuesByPath // :: StrMap (Array Any)
            ) {
              //  If we apply an ‘a -> a -> a -> a’ function to Left ('x'), Right (1),
              //  and Right (null) we'd like to avoid underlining the first argument
              //  position, since Left ('x') is compatible with the other ‘a’ values.
              var key = JSON.stringify(Z.concat([index], propPath));
              var values = valuesByPath[key];

              //  Note: Sorting these keys lexicographically is not "correct", but it
              //  does the right thing for indexes less than 10.
              var keys = Z.filter(function(k) {
                var values_ = valuesByPath[k];
                return (
                  //  Keep X, the position at which the violation was observed.
                  k === key ||
                  //  Keep positions whose values are incompatible with the values at X.
                  isEmpty(
                    determineActualTypesStrict(env, Z.concat(values, values_))
                  )
                );
              }, sortedKeys(valuesByPath));

              var underlinedTypeVars = underlineTypeVars(
                typeInfo,
                Z.reduce(
                  function($valuesByPath, k) {
                    $valuesByPath[k] = valuesByPath[k];
                    return $valuesByPath;
                  },
                  {},
                  keys
                )
              );

              return new TypeError(
                trimTrailingSpaces(
                  values.length === 1 &&
                    isEmpty(determineActualTypesLoose(env, values))
                    ? "Unrecognized value\n\n" +
                        underlinedTypeVars +
                        "\n" +
                        "1)  " +
                        show(values[0]) +
                        " :: (no types)\n\n" +
                        toMarkdownList(
                          "The environment is empty! " +
                            "Polymorphic functions require a non-empty environment.\n",
                          "The value at position 1 is not a member of any type in " +
                            "the environment.\n\n" +
                            "The environment contains the following types:\n\n",
                          showTypeWith(typeInfo),
                          env
                        )
                    : // else
                      "Type-variable constraint violation\n\n" +
                        underlinedTypeVars +
                        "\n" +
                        Z.reduce(
                          function(st, k) {
                            var values = valuesByPath[k];
                            return isEmpty(values)
                              ? st
                              : {
                                  idx: st.idx + 1,
                                  s:
                                    st.s +
                                    showValuesAndTypes(
                                      env,
                                      typeInfo,
                                      values,
                                      st.idx + 1
                                    ) +
                                    "\n\n",
                                };
                          },
                          { idx: 0, s: "" },
                          keys
                        ).s +
                        "Since there is no type of which all the above values are " +
                        "members, the type-variable constraint has been violated.\n"
                )
              );
            }

            //  invalidValue :: ... -> Error
            function invalidValue(
              env, // :: Array Type
              typeInfo, // :: TypeInfo
              index, // :: Integer
              propPath, // :: PropPath
              value // :: Any
            ) {
              var t = resolvePropPath(typeInfo.types[index], propPath);
              return new TypeError(
                trimTrailingSpaces(
                  "Invalid value\n\n" +
                    underline(
                      typeInfo,
                      K(K(_)),
                      formatType6(Z.concat([index], propPath))
                    ) +
                    "\n" +
                    showValuesAndTypes(env, typeInfo, [value], 1) +
                    "\n\n" +
                    "The value at position 1 is not a member of " +
                    showTypeQuoted(t) +
                    ".\n" +
                    see("type", t)
                )
              );
            }

            //  invalidArgumentsLength :: ... -> Error
            //
            //  This function is used in `wrapFunctionCond` to ensure that higher-order
            //  functions defined via `def` only ever apply a function argument to the
            //  correct number of arguments.
            function invalidArgumentsLength(
              typeInfo, // :: TypeInfo
              index, // :: Integer
              numArgsExpected, // :: Integer
              args // :: Array Any
            ) {
              return new TypeError(
                trimTrailingSpaces(
                  q(typeInfo.name) +
                    " applied " +
                    showTypeQuoted(typeInfo.types[index]) +
                    " to the wrong number of arguments\n\n" +
                    underline(typeInfo, K(K(_)), function(index_) {
                      return function(f) {
                        return function(t) {
                          return function(propPath) {
                            return function(s) {
                              return index_ === index
                                ? t.format(_, function(k) {
                                    return k === "$1" ? f : _;
                                  })
                                : _(s);
                            };
                          };
                        };
                      };
                    }) +
                    "\n" +
                    "Expected " +
                    numArgs(numArgsExpected) +
                    " but received " +
                    numArgs(args.length) +
                    toMarkdownList(".\n", ":\n\n", show, args)
                )
              );
            }

            //  assertRight :: Either (() -> Error) a -> a !
            function assertRight(either) {
              if (either.isLeft) throw either.value();
              return either.value;
            }

            //  withTypeChecking :: ... -> Function
            function withTypeChecking(
              env, // :: Array Type
              typeInfo, // :: TypeInfo
              impl // :: Function
            ) {
              var n = typeInfo.types.length - 1;

              //  wrapFunctionCond :: (TypeVarMap, Integer, a) -> a
              function wrapFunctionCond(_typeVarMap, index, value) {
                if (typeInfo.types[index].type !== FUNCTION) return value;

                var expType = typeInfo.types[index];

                //  checkValue :: (TypeVarMap, Integer, String, a) -> Either (() -> Error) TypeVarMap
                function checkValue(typeVarMap, index, k, x) {
                  var propPath = [k];
                  var t = expType.types[k].type;
                  return t.type === VARIABLE
                    ? Z.chain(function(typeVarMap) {
                        return isEmpty(typeVarMap[t.name].types)
                          ? Left(function() {
                              return typeVarConstraintViolation(
                                env,
                                typeInfo,
                                index,
                                propPath,
                                typeVarMap[t.name].valuesByPath
                              );
                            })
                          : Right(typeVarMap);
                      }, Right(
                        updateTypeVarMap(env, typeVarMap, t, index, propPath, [
                          x,
                        ])
                      ))
                    : // else
                      Z.map(function(r) {
                        return r.typeVarMap;
                      }, satisfactoryTypes(
                        env,
                        typeInfo,
                        typeVarMap,
                        t,
                        index,
                        propPath,
                        [x]
                      ));
                }

                var isThunk = expType.types.$1.type.type === NO_ARGUMENTS;
                var numArgsExpected = isThunk ? 0 : expType.keys.length - 1;
                var typeVarMap = _typeVarMap;
                return function(x) {
                  if (arguments.length !== numArgsExpected) {
                    throw invalidArgumentsLength(
                      typeInfo,
                      index,
                      numArgsExpected,
                      slice.call(arguments)
                    );
                  }

                  var args = arguments;
                  typeVarMap = assertRight(
                    init(expType.keys).reduce(function(either, k, idx) {
                      var arg = args[idx];
                      return Z.chain(function(typeVarMap) {
                        return checkValue(typeVarMap, index, k, arg);
                      }, either);
                    }, Right(typeVarMap))
                  );

                  var output = value.apply(this, arguments);
                  var k = last(expType.keys);
                  typeVarMap = assertRight(
                    checkValue(typeVarMap, index, k, output)
                  );
                  return output;
                };
              }

              //  wrapNext :: (TypeVarMap, Array Any, Integer) -> (a -> b)
              function wrapNext(_typeVarMap, _values, index) {
                return function(x) {
                  var args = slice.call(arguments);
                  if (args.length !== 1) {
                    throw invalidArgumentsCount(typeInfo, index, 1, args);
                  }
                  var typeVarMap = assertRight(
                    satisfactoryTypes(
                      env,
                      typeInfo,
                      _typeVarMap,
                      typeInfo.types[index],
                      index,
                      [],
                      args
                    )
                  ).typeVarMap;

                  var values = Z.concat(_values, args);
                  if (index + 1 === n) {
                    var value = values.reduce(function(f, x, idx) {
                      return f(wrapFunctionCond(typeVarMap, idx, x));
                    }, impl);
                    typeVarMap = assertRight(
                      satisfactoryTypes(
                        env,
                        typeInfo,
                        typeVarMap,
                        typeInfo.types[n],
                        n,
                        [],
                        [value]
                      )
                    ).typeVarMap;
                    return wrapFunctionCond(typeVarMap, n, value);
                  } else {
                    return wrapNext(typeVarMap, values, index + 1);
                  }
                };
              }

              var wrapped =
                typeInfo.types[0].type === NO_ARGUMENTS
                  ? function() {
                      if (arguments.length !== 0) {
                        throw invalidArgumentsCount(
                          typeInfo,
                          0,
                          0,
                          slice.call(arguments)
                        );
                      }
                      var value = impl();
                      var typeVarMap = assertRight(
                        satisfactoryTypes(
                          env,
                          typeInfo,
                          {},
                          typeInfo.types[n],
                          n,
                          [],
                          [value]
                        )
                      ).typeVarMap;
                      return wrapFunctionCond(typeVarMap, n, value);
                    }
                  : wrapNext({}, [], 0);

              wrapped[inspect] = wrapped.toString = always0(
                typeSignature(typeInfo)
              );

              return wrapped;
            }

            function _create(opts) {
              function def(name) {
                return function(constraints) {
                  return function(expTypes) {
                    return function(impl) {
                      return opts.checkTypes
                        ? withTypeChecking(
                            opts.env,
                            {
                              name: name,
                              constraints: constraints,
                              types: augmentThunk(expTypes),
                            },
                            impl
                          )
                        : impl;
                    };
                  };
                };
              }
              return def(
                def.name
              )({})([String_, StrMap(Array_(TypeClass)), NonEmpty(Array_(Type)), AnyFunction, AnyFunction])(def);
            }

            var create = def("create")({})([
              RecordType({ checkTypes: Boolean_, env: Array_(Any) }),
              AnyFunction,
            ])(_create);

            //  fromUncheckedUnaryType :: (Type -> Type) -> Type -> Type
            function fromUncheckedUnaryType(typeConstructor) {
              var t = typeConstructor(Unknown);
              var _1 = t.types.$1.extractor;
              return CheckedUnaryType(t.name)(t.url)(t._test)(_1);
            }

            //  fromUncheckedBinaryType :: (Type -> Type -> Type) -> Type -> Type -> Type
            function fromUncheckedBinaryType(typeConstructor) {
              var t = typeConstructor(Unknown)(Unknown);
              var _1 = t.types.$1.extractor;
              var _2 = t.types.$2.extractor;
              return CheckedBinaryType(t.name)(t.url)(t._test)(_1)(_2);
            }

            return {
              Any: Any,
              AnyFunction: AnyFunction,
              Arguments: Arguments,
              Array: fromUncheckedUnaryType(Array_),
              Array0: Array0,
              Array1: fromUncheckedUnaryType(Array1),
              Array2: fromUncheckedBinaryType(Array2),
              Boolean: Boolean_,
              Date: Date_,
              Error: Error_,
              FiniteNumber: FiniteNumber,
              Function: def("Function")({})([Array_(Type), Type])(Function_),
              GlobalRegExp: GlobalRegExp,
              HtmlElement: HtmlElement,
              Integer: Integer,
              NegativeFiniteNumber: NegativeFiniteNumber,
              NegativeInteger: NegativeInteger,
              NegativeNumber: NegativeNumber,
              NonEmpty: NonEmpty,
              NonGlobalRegExp: NonGlobalRegExp,
              NonNegativeInteger: NonNegativeInteger,
              NonZeroFiniteNumber: NonZeroFiniteNumber,
              NonZeroInteger: NonZeroInteger,
              NonZeroValidNumber: NonZeroValidNumber,
              Null: Null,
              Nullable: fromUncheckedUnaryType(Nullable),
              Number: Number_,
              Object: Object_,
              PositiveFiniteNumber: PositiveFiniteNumber,
              PositiveInteger: PositiveInteger,
              PositiveNumber: PositiveNumber,
              RegExp: RegExp_,
              RegexFlags: RegexFlags,
              StrMap: fromUncheckedUnaryType(StrMap),
              String: String_,
              Symbol: Symbol_,
              Type: Type,
              TypeClass: TypeClass,
              Undefined: Undefined,
              Unknown: Unknown,
              ValidDate: ValidDate,
              ValidNumber: ValidNumber,
              env: env,
              create: create,
              test: def("test")({})([Array_(Type), Type, Any, Boolean_])(test),
              NullaryType: CheckedNullaryType,
              UnaryType: CheckedUnaryType,
              BinaryType: CheckedBinaryType,
              EnumType: CheckedEnumType,
              RecordType: CheckedRecordType,
              TypeVariable: CheckedTypeVariable,
              UnaryTypeVariable: CheckedUnaryTypeVariable,
              BinaryTypeVariable: CheckedBinaryTypeVariable,
              Thunk: Thunk,
              Predicate: Predicate,
            };
          });

          //. [FL:Semigroup]:         https://github.com/fantasyland/fantasy-land#semigroup
          //. [HTML element]:         https://developer.mozilla.org/en-US/docs/Web/HTML/Element
          //. [Monoid]:               https://github.com/fantasyland/fantasy-land#monoid
          //. [Setoid]:               https://github.com/fantasyland/fantasy-land#setoid
          //. [`Array`]:              #Array
          //. [`Array2`]:             #Array2
          //. [`BinaryType`]:         #BinaryType
          //. [`Date`]:               #Date
          //. [`FiniteNumber`]:       #FiniteNumber
          //. [`GlobalRegExp`]:       #GlobalRegExp
          //. [`Integer`]:            #Integer
          //. [`NonGlobalRegExp`]:    #NonGlobalRegExp
          //. [`Number`]:             #Number
          //. [`Object.create`]:      https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create
          //. [`RegExp`]:             #RegExp
          //. [`RegexFlags`]:         #RegexFlags
          //. [`String`]:             #String
          //. [`SyntaxError`]:        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError
          //. [`TypeClass`]:          https://github.com/sanctuary-js/sanctuary-type-classes#TypeClass
          //. [`TypeError`]:          https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError
          //. [`TypeVariable`]:       #TypeVariable
          //. [`UnaryType`]:          #UnaryType
          //. [`UnaryTypeVariable`]:  #UnaryTypeVariable
          //. [`Unknown`]:            #Unknown
          //. [`ValidNumber`]:        #ValidNumber
          //. [`env`]:                #env
          //. [arguments]:            https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments
          //. [enumerated types]:     https://en.wikipedia.org/wiki/Enumerated_type
          //. [max]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER
          //. [min]:                  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MIN_SAFE_INTEGER
          //. [record type]:          #RecordType
          //. [semigroup]:            https://en.wikipedia.org/wiki/Semigroup
          //. [type class]:           #type-classes
          //. [type variables]:       #TypeVariable
          //. [types]:                #types

          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../process/browser.js */ "./node_modules/process/browser.js"
          )
        ));

        /***/
      },

    /***/ "./node_modules/sanctuary-either/index.js":
      /*!************************************************!*\
  !*** ./node_modules/sanctuary-either/index.js ***!
  \************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__; /*
         _______    ___    _________    ___   ___    _______    ______
        /  ____/\  /  /\  /__   ___/\  /  /\ /  /\  /  ____/\  /  __  \
       /  /\___\/ /  / /  \_/  /\__\/ /  /_//  / / /  /\___\/ /  /\/  /\
      /  ____/\  /  / /    /  / /    /  ___   / / /  ____/\  /      _/ /
     /  /\___\/ /  / /    /  / /    /  /\_/  / / /  /\___\/ /  /|  |\\/
    /______/\  /__/ /    /__/ /    /__/ //__/ / /______/\  /__/ |__| |
    \______\/  \__\/     \__\/     \__\/ \__\/  \______\/  \__\/ \__\|
                                                                            */

        //. <a href="https://github.com/fantasyland/fantasy-land"><img alt="Fantasy Land" src="https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png" width="75" height="75" align="left"></a>
        //.
        //. # sanctuary-either
        //.
        //. The Either type represents values with two possibilities: a value of type
        //. `Either a b` is either a Left whose value is of type `a` or a Right whose
        //. value is of type `b`.

        (function(f) {
          "use strict";

          /* istanbul ignore else */
          if (true && typeof module.exports === "object") {
            module.exports = f(
              __webpack_require__(
                /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
              ),
              __webpack_require__(
                /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
              )
            );
          } else if (
            true &&
            __webpack_require__(
              /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
            ) != null
          ) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
              __webpack_require__(
                /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
              ),
              __webpack_require__(
                /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
              ),
            ]),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = f),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
            self.sanctuaryEither = f(
              self.sanctuaryShow,
              self.sanctuaryTypeClasses
            );
          }
        })(function(show, Z) {
          "use strict";

          /* istanbul ignore if */
          if (typeof __doctest !== "undefined") {
            var $ = __doctest.require("sanctuary-def");
            var type = __doctest.require("sanctuary-type-identifiers");
            var S = (function() {
              var S = __doctest.require("sanctuary");
              var EitherType = $.BinaryType("sanctuary-either/Either")("")(
                function(x) {
                  return type(x) === Either["@@type"];
                }
              )(function(e) {
                return e.isLeft ? [e.value] : [];
              })(function(e) {
                return e.isLeft ? [] : [e.value];
              });
              var env = Z.concat(S.env, [
                $.TypeClass,
                EitherType($.Unknown)($.Unknown),
              ]);
              return S.create({ checkTypes: true, env: env });
            })();
          }

          var Either = {};

          var Left$prototype = {
            /* eslint-disable key-spacing */
            constructor: Either,
            isLeft: true,
            isRight: false,
            "@@show": Left$prototype$show,
            "fantasy-land/map": Left$prototype$map,
            "fantasy-land/bimap": Left$prototype$bimap,
            "fantasy-land/ap": Left$prototype$ap,
            "fantasy-land/chain": Left$prototype$chain,
            "fantasy-land/alt": Left$prototype$alt,
            "fantasy-land/reduce": Left$prototype$reduce,
            "fantasy-land/traverse": Left$prototype$traverse,
            "fantasy-land/extend": Left$prototype$extend,
            /* eslint-enable key-spacing */
          };

          var Right$prototype = {
            /* eslint-disable key-spacing */
            constructor: Either,
            isLeft: false,
            isRight: true,
            "@@show": Right$prototype$show,
            "fantasy-land/map": Right$prototype$map,
            "fantasy-land/bimap": Right$prototype$bimap,
            "fantasy-land/ap": Right$prototype$ap,
            "fantasy-land/chain": Right$prototype$chain,
            "fantasy-land/alt": Right$prototype$alt,
            "fantasy-land/reduce": Right$prototype$reduce,
            "fantasy-land/traverse": Right$prototype$traverse,
            "fantasy-land/extend": Right$prototype$extend,
            /* eslint-enable key-spacing */
          };

          var util =
            true && typeof module.exports === "object"
              ? __webpack_require__(/*! util */ "./node_modules/util/util.js")
              : /* istanbul ignore next */ {};
          var inspect =
            util.inspect != null && typeof util.inspect.custom === "symbol"
              ? /* istanbul ignore next */ util.inspect.custom
              : /* istanbul ignore next */ "inspect";
          Left$prototype[inspect] = Left$prototype$show;
          Right$prototype[inspect] = Right$prototype$show;

          //. `Either a b` satisfies the following [Fantasy Land][] specifications:
          //.
          //. ```javascript
          //. > const Useless = require ('sanctuary-useless')
          //.
          //. > S.map (k => k + ' '.repeat (16 - k.length) +
          //. .             (Z[k].test (Right (Useless)) ? '\u2705   ' :
          //. .              Z[k].test (Right (['foo'])) ? '\u2705 * ' :
          //. .              /* otherwise */               '\u274C   '))
          //. .       (S.keys (Z.filter ($.test ([]) ($.TypeClass), Z)))
          //. [ 'Setoid          ✅ * ',  // if ‘a’ and ‘b’ satisfy Setoid
          //. . 'Ord             ✅ * ',  // if ‘a’ and ‘b’ satisfy Ord
          //. . 'Semigroupoid    ❌   ',
          //. . 'Category        ❌   ',
          //. . 'Semigroup       ✅ * ',  // if ‘a’ and ‘b’ satisfy Semigroup
          //. . 'Monoid          ❌   ',
          //. . 'Group           ❌   ',
          //. . 'Filterable      ❌   ',
          //. . 'Functor         ✅   ',
          //. . 'Bifunctor       ✅   ',
          //. . 'Profunctor      ❌   ',
          //. . 'Apply           ✅   ',
          //. . 'Applicative     ✅   ',
          //. . 'Chain           ✅   ',
          //. . 'ChainRec        ✅   ',
          //. . 'Monad           ✅   ',
          //. . 'Alt             ✅   ',
          //. . 'Plus            ❌   ',
          //. . 'Alternative     ❌   ',
          //. . 'Foldable        ✅   ',
          //. . 'Traversable     ✅   ',
          //. . 'Extend          ✅   ',
          //. . 'Comonad         ❌   ',
          //. . 'Contravariant   ❌   ' ]
          //. ```

          //# Either :: TypeRep Either
          //.
          //. Either [type representative][].

          //# Either.Left :: a -> Either a b
          //.
          //. Constructs a value of type `Either a b` from a value of type `a`.
          //.
          //. ```javascript
          //. > Left ('sqrt undefined for -1')
          //. Left ('sqrt undefined for -1')
          //. ```
          var Left = (Either.Left = function(value) {
            var left = Object.create(Left$prototype);
            if (Z.Setoid.test(value)) {
              left["fantasy-land/equals"] = Left$prototype$equals;
              if (Z.Ord.test(value)) {
                left["fantasy-land/lte"] = Left$prototype$lte;
              }
            }
            if (Z.Semigroup.test(value)) {
              left["fantasy-land/concat"] = Left$prototype$concat;
            }
            left.value = value;
            return left;
          });

          //# Either.Right :: b -> Either a b
          //.
          //. Constructs a value of type `Either a b` from a value of type `b`.
          //.
          //. ```javascript
          //. > Right (42)
          //. Right (42)
          //. ```
          var Right = (Either.Right = function Right(value) {
            var right = Object.create(Right$prototype);
            if (Z.Setoid.test(value)) {
              right["fantasy-land/equals"] = Right$prototype$equals;
              if (Z.Ord.test(value)) {
                right["fantasy-land/lte"] = Right$prototype$lte;
              }
            }
            if (Z.Semigroup.test(value)) {
              right["fantasy-land/concat"] = Right$prototype$concat;
            }
            right.value = value;
            return right;
          });

          //# Either.@@type :: String
          //.
          //. Either [type identifier][].
          //.
          //. ```javascript
          //. > type (Right (42))
          //. 'sanctuary-either/Either@1'
          //.
          //. > type.parse (type (Right (42)))
          //. {namespace: 'sanctuary-either', name: 'Either', version: 1}
          //. ```
          Either["@@type"] = "sanctuary-either/Either@1";

          //# Either.fantasy-land/of :: b -> Either a b
          //.
          //.   - `of (Either) (x)` is equivalent to `Right (x)`
          //.
          //. ```javascript
          //. > S.of (Either) (42)
          //. Right (42)
          //. ```
          Either["fantasy-land/of"] = Right;

          function next(x) {
            return { tag: next, value: x };
          }
          function done(x) {
            return { tag: done, value: x };
          }

          //# Either.fantasy-land/chainRec :: ((a -> c, b -> c, a) -> Either d c, a) -> Either d b
          //.
          //. ```javascript
          //. > Z.chainRec (
          //. .   Either,
          //. .   (next, done, x) =>
          //. .     x <= 1 ? Left ('!!') : Right (x >= 1000 ? done (x) : next (x * x)),
          //. .   1
          //. . )
          //. Left ('!!')
          //.
          //. > Z.chainRec (
          //. .   Either,
          //. .   (next, done, x) =>
          //. .     x <= 1 ? Left ('!!') : Right (x >= 1000 ? done (x) : next (x * x)),
          //. .   2
          //. . )
          //. Right (65536)
          //. ```
          Either["fantasy-land/chainRec"] = function(f, x) {
            var r = next(x);
            while (r.tag === next) {
              var either = f(next, done, r.value);
              if (either.isLeft) return either;
              r = either.value;
            }
            return Right(r.value);
          };

          //# Either#@@show :: (Showable a, Showable b) => Either a b ~> () -> String
          //.
          //.   - `show (Left (x))` is equivalent to `'Left (' + show (x) + ')'`
          //.   - `show (Right (x))` is equivalent to `'Right (' + show (x) + ')'`
          //.
          //. ```javascript
          //. > show (Left ('sqrt undefined for -1'))
          //. 'Left ("sqrt undefined for -1")'
          //.
          //. > show (Right ([1, 2, 3]))
          //. 'Right ([1, 2, 3])'
          //. ```
          function Left$prototype$show() {
            return "Left (" + show(this.value) + ")";
          }
          function Right$prototype$show() {
            return "Right (" + show(this.value) + ")";
          }

          //# Either#fantasy-land/equals :: (Setoid a, Setoid b) => Either a b ~> Either a b -> Boolean
          //.
          //.   - `Left (x)` is equal to `Left (y)` [iff][] `x` is equal to `y`
          //.     according to [`Z.equals`][]
          //.   - `Right (x)` is equal to `Right (y)` [iff][] `x` is equal to `y`
          //.     according to [`Z.equals`][]
          //.   - `Left (x)` is never equal to `Right (y)`
          //.
          //. ```javascript
          //. > S.equals (Left ([1, 2, 3])) (Left ([1, 2, 3]))
          //. true
          //.
          //. > S.equals (Right ([1, 2, 3])) (Right ([1, 2, 3]))
          //. true
          //.
          //. > S.equals (Left ([1, 2, 3])) (Right ([1, 2, 3]))
          //. false
          //. ```
          function Left$prototype$equals(other) {
            return other.isLeft && Z.equals(this.value, other.value);
          }
          function Right$prototype$equals(other) {
            return other.isRight && Z.equals(this.value, other.value);
          }

          //# Either#fantasy-land/lte :: (Ord a, Ord b) => Either a b ~> Either a b -> Boolean
          //.
          //.   - `Left (x)` is less than or equal to `Left (y)` [iff][] `x` is less
          //.     than or equal to `y` according to [`Z.lte`][]
          //.   - `Right (x)` is less than or equal to `Right (y)` [iff][] `x` is less
          //.     than or equal to `y` according to [`Z.lte`][]
          //.   - `Left (x)` is always less than `Right (y)`
          //.
          //. ```javascript
          //. > S.filter (S.lte (Left (1))) ([Left (0), Left (1), Left (2)])
          //. [Left (0), Left (1)]
          //.
          //. > S.filter (S.lte (Right (1))) ([Right (0), Right (1), Right (2)])
          //. [Right (0), Right (1)]
          //.
          //. > S.filter (S.lte (Left (1))) ([Right (0), Right (1), Right (2)])
          //. []
          //.
          //. > S.filter (S.lte (Right (1))) ([Left (0), Left (1), Left (2)])
          //. [Left (0), Left (1), Left (2)]
          //. ```
          function Left$prototype$lte(other) {
            return other.isRight || Z.lte(this.value, other.value);
          }
          function Right$prototype$lte(other) {
            return other.isRight && Z.lte(this.value, other.value);
          }

          //# Either#fantasy-land/concat :: (Semigroup a, Semigroup b) => Either a b ~> Either a b -> Either a b
          //.
          //.   - `concat (Left (x)) (Left (y))` is equivalent to
          //.     `Left (concat (x) (y))`
          //.   - `concat (Right (x)) (Right (y))` is equivalent to
          //.     `Right (concat (x) (y))`
          //.   - `concat (Left (x)) (Right (y))` is equivalent to `Right (y)`
          //.   - `concat (Right (x)) (Left (y))` is equivalent to `Right (x)`
          //.
          //. ```javascript
          //. > S.concat (Left ('abc')) (Left ('def'))
          //. Left ('abcdef')
          //.
          //. > S.concat (Right ([1, 2, 3])) (Right ([4, 5, 6]))
          //. Right ([1, 2, 3, 4, 5, 6])
          //.
          //. > S.concat (Left ('abc')) (Right ([1, 2, 3]))
          //. Right ([1, 2, 3])
          //.
          //. > S.concat (Right ([1, 2, 3])) (Left ('abc'))
          //. Right ([1, 2, 3])
          //. ```
          function Left$prototype$concat(other) {
            return other.isLeft
              ? Left(Z.concat(this.value, other.value))
              : other;
          }
          function Right$prototype$concat(other) {
            return other.isRight
              ? Right(Z.concat(this.value, other.value))
              : this;
          }

          //# Either#fantasy-land/map :: Either a b ~> (b -> c) -> Either a c
          //.
          //.   - `map (f) (Left (x))` is equivalent to `Left (x)`
          //.   - `map (f) (Right (x))` is equivalent to `Right (f (x))`
          //.
          //. ```javascript
          //. > S.map (S.add (1)) (Left ('sqrt undefined for -1'))
          //. Left ('sqrt undefined for -1')
          //.
          //. > S.map (S.add (1)) (Right (99))
          //. Right (100)
          //. ```
          function Left$prototype$map(f) {
            return this;
          }
          function Right$prototype$map(f) {
            return Right(f(this.value));
          }

          //# Either#fantasy-land/bimap :: Either a c ~> (a -> b, c -> d) -> Either b d
          //.
          //.   - `bimap (f) (g) (Left (x))` is equivalent to `Left (f (x))`
          //.   - `bimap (f) (g) (Right (x))` is equivalent to `Right (g (x))`
          //.
          //. ```javascript
          //. > S.bimap (S.toUpper) (S.add (1)) (Left ('abc'))
          //. Left ('ABC')
          //.
          //. > S.bimap (S.toUpper) (S.add (1)) (Right (99))
          //. Right (100)
          //. ```
          function Left$prototype$bimap(f, g) {
            return Left(f(this.value));
          }
          function Right$prototype$bimap(f, g) {
            return Right(g(this.value));
          }

          //# Either#fantasy-land/ap :: Either a b ~> Either a (b -> c) -> Either a c
          //.
          //.   - `ap (Left (x)) (Left (y))` is equivalent to `Left (x)`
          //.   - `ap (Left (x)) (Right (y))` is equivalent to `Left (x)`
          //.   - `ap (Right (f)) (Left (x))` is equivalent to `Left (x)`
          //.   - `ap (Right (f)) (Right (x))` is equivalent to `Right (f (x))`
          //.
          //. ```javascript
          //. > S.ap (Left ('div undefined for 0')) (Left ('sqrt undefined for -1'))
          //. Left ('div undefined for 0')
          //.
          //. > S.ap (Left ('div undefined for 0')) (Right (99))
          //. Left ('div undefined for 0')
          //.
          //. > S.ap (Right (S.add (1))) (Left ('sqrt undefined for -1'))
          //. Left ('sqrt undefined for -1')
          //.
          //. > S.ap (Right (S.add (1))) (Right (99))
          //. Right (100)
          //. ```
          function Left$prototype$ap(other) {
            return other.isLeft ? other : this;
          }
          function Right$prototype$ap(other) {
            return other.isLeft ? other : Right(other.value(this.value));
          }

          //# Either#fantasy-land/chain :: Either a b ~> (b -> Either a c) -> Either a c
          //.
          //.   - `chain (f) (Left (x))` is equivalent to `Left (x)`
          //.   - `chain (f) (Right (x))` is equivalent to `f (x)`
          //.
          //. ```javascript
          //. > const sqrt = n => n < 0 ? Left ('sqrt undefined for ' + show (n))
          //. .                         : Right (Math.sqrt (n))
          //.
          //. > S.chain (sqrt) (Left ('div undefined for 0'))
          //. Left ('div undefined for 0')
          //.
          //. > S.chain (sqrt) (Right (-1))
          //. Left ('sqrt undefined for -1')
          //.
          //. > S.chain (sqrt) (Right (25))
          //. Right (5)
          //. ```
          function Left$prototype$chain(f) {
            return this;
          }
          function Right$prototype$chain(f) {
            return f(this.value);
          }

          //# Either#fantasy-land/alt :: Either a b ~> Either a b -> Either a b
          //.
          //.   - `alt (Left (x)) (Left (y))` is equivalent to `Left (y)`
          //.   - `alt (Left (x)) (Right (y))` is equivalent to `Right (y)`
          //.   - `alt (Right (x)) (Left (y))` is equivalent to `Right (x)`
          //.   - `alt (Right (x)) (Right (y))` is equivalent to `Right (x)`
          //.
          //. ```javascript
          //. > S.alt (Left ('A')) (Left ('B'))
          //. Left ('B')
          //.
          //. > S.alt (Left ('C')) (Right (1))
          //. Right (1)
          //.
          //. > S.alt (Right (2)) (Left ('D'))
          //. Right (2)
          //.
          //. > S.alt (Right (3)) (Right (4))
          //. Right (3)
          //. ```
          function Left$prototype$alt(other) {
            return other;
          }
          function Right$prototype$alt(other) {
            return this;
          }

          //# Either#fantasy-land/reduce :: Either a b ~> ((c, b) -> c, c) -> c
          //.
          //.   - `reduce (f) (x) (Left (y))` is equivalent to `x`
          //.   - `reduce (f) (x) (Right (y))` is equivalent to `f (x) (y)`
          //.
          //. ```javascript
          //. > S.reduce (S.concat) ([1]) (Left ('sqrt undefined for -1'))
          //. [1]
          //.
          //. > S.reduce (S.concat) ([1]) (Right ([2]))
          //. [1, 2]
          //. ```
          function Left$prototype$reduce(f, x) {
            return x;
          }
          function Right$prototype$reduce(f, x) {
            return f(x, this.value);
          }

          //# Either#fantasy-land/traverse :: Applicative f => Either a b ~> (TypeRep f, b -> f c) -> f (Either a c)
          //.
          //.   - `traverse (A) (f) (Left (x))` is equivalent to `of (A) (Left (x))`
          //.   - `traverse (A) (f) (Right (x))` is equivalent to `map (Right) (f (x))`
          //.
          //. ```javascript
          //. > S.traverse (Array) (S.words) (Left ('sqrt undefined for -1'))
          //. [Left ('sqrt undefined for -1')]
          //.
          //. > S.traverse (Array) (S.words) (Right ('foo bar baz'))
          //. [Right ('foo'), Right ('bar'), Right ('baz')]
          //. ```
          function Left$prototype$traverse(typeRep, f) {
            return Z.of(typeRep, this);
          }
          function Right$prototype$traverse(typeRep, f) {
            return Z.map(Right, f(this.value));
          }

          //# Either#fantasy-land/extend :: Either a b ~> (Either a b -> c) -> Either a c
          //.
          //.   - `extend (f) (Left (x))` is equivalent to `Left (x)`
          //.   - `extend (f) (Right (x))` is equivalent to `Right (f (Right (x)))`
          //.
          //. ```javascript
          //. > S.extend (S.reduce (S.add) (1)) (Left ('sqrt undefined for -1'))
          //. Left ('sqrt undefined for -1')
          //.
          //. > S.extend (S.reduce (S.add) (1)) (Right (99))
          //. Right (100)
          //. ```
          function Left$prototype$extend(f) {
            return this;
          }
          function Right$prototype$extend(f) {
            return Right(f(this));
          }

          return Either;
        });

        //. [Fantasy Land]:             v:fantasyland/fantasy-land
        //. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals
        //. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte
        //. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if
        //. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers
        //. [type representative]:      v:fantasyland/fantasy-land#type-representatives

        /***/
      },

    /***/ "./node_modules/sanctuary-maybe/index.js":
      /*!***********************************************!*\
  !*** ./node_modules/sanctuary-maybe/index.js ***!
  \***********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__; /*
    ,______  ______,  ,________,,_____,,_____,,__________  ,__________,
    |      \/      |  |        ||     ||     ||          \ |          |
    |_,          ,_|  |_      _||_    ||    _||_,   __    ||_,   _____|
      |   \  /   |     /      \   \   \/   /    |        /   |      |
    ,_|    ||    |_,,_/   /\   \_, \      /   ,_|   __   \ ,_|   ___|_,
    |      ||      ||     ||     |  |    |    |           ||          |
    |______||______||_____||_____|  |____|    |__________/ |__________|
                                                                         */

        //. <a href="https://github.com/fantasyland/fantasy-land"><img alt="Fantasy Land" src="https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png" width="75" height="75" align="left"></a>
        //.
        //. # sanctuary-maybe
        //.
        //. The Maybe type represents optional values: a value of type `Maybe a` is
        //. either Nothing (the empty value) or a Just whose value is of type `a`.

        (function(f) {
          "use strict";

          /* istanbul ignore else */
          if (true && typeof module.exports === "object") {
            module.exports = f(
              __webpack_require__(
                /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
              ),
              __webpack_require__(
                /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
              )
            );
          } else if (
            true &&
            __webpack_require__(
              /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
            ) != null
          ) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
              __webpack_require__(
                /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
              ),
              __webpack_require__(
                /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
              ),
            ]),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = f),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
            self.sanctuaryMaybe = f(
              self.sanctuaryShow,
              self.sanctuaryTypeClasses
            );
          }
        })(function(show, Z) {
          "use strict";

          /* istanbul ignore if */
          if (typeof __doctest !== "undefined") {
            var $ = __doctest.require("sanctuary-def");
            var type = __doctest.require("sanctuary-type-identifiers");
            var S = (function() {
              var S = __doctest.require("sanctuary");
              var MaybeType = $.UnaryType("sanctuary-maybe/Maybe")("")(function(
                x
              ) {
                return type(x) === Maybe["@@type"];
              })(function(m) {
                return m.isJust ? [m.value] : [];
              });
              var env = Z.concat(S.env, [$.TypeClass, MaybeType($.Unknown)]);
              return S.create({ checkTypes: true, env: env });
            })();
          }

          var Maybe = {};

          var Nothing$prototype = {
            /* eslint-disable key-spacing */
            constructor: Maybe,
            isNothing: true,
            isJust: false,
            "@@show": Nothing$prototype$show,
            "fantasy-land/equals": Nothing$prototype$equals,
            "fantasy-land/lte": Nothing$prototype$lte,
            "fantasy-land/concat": Nothing$prototype$concat,
            "fantasy-land/filter": Nothing$prototype$filter,
            "fantasy-land/map": Nothing$prototype$map,
            "fantasy-land/ap": Nothing$prototype$ap,
            "fantasy-land/chain": Nothing$prototype$chain,
            "fantasy-land/alt": Nothing$prototype$alt,
            "fantasy-land/reduce": Nothing$prototype$reduce,
            "fantasy-land/traverse": Nothing$prototype$traverse,
            "fantasy-land/extend": Nothing$prototype$extend,
            /* eslint-enable key-spacing */
          };

          var Just$prototype = {
            /* eslint-disable key-spacing */
            constructor: Maybe,
            isNothing: false,
            isJust: true,
            "@@show": Just$prototype$show,
            "fantasy-land/filter": Just$prototype$filter,
            "fantasy-land/map": Just$prototype$map,
            "fantasy-land/ap": Just$prototype$ap,
            "fantasy-land/chain": Just$prototype$chain,
            "fantasy-land/alt": Just$prototype$alt,
            "fantasy-land/reduce": Just$prototype$reduce,
            "fantasy-land/traverse": Just$prototype$traverse,
            "fantasy-land/extend": Just$prototype$extend,
            /* eslint-enable key-spacing */
          };

          var util =
            true && typeof module.exports === "object"
              ? __webpack_require__(/*! util */ "./node_modules/util/util.js")
              : /* istanbul ignore next */ {};
          var inspect =
            util.inspect != null && typeof util.inspect.custom === "symbol"
              ? /* istanbul ignore next */ util.inspect.custom
              : /* istanbul ignore next */ "inspect";
          Nothing$prototype[inspect] = Nothing$prototype$show;
          Just$prototype[inspect] = Just$prototype$show;

          //. `Maybe a` satisfies the following [Fantasy Land][] specifications:
          //.
          //. ```javascript
          //. > const Useless = require ('sanctuary-useless')
          //.
          //. > S.map (k => k + ' '.repeat (16 - k.length) +
          //. .             (Z[k].test (Just (Useless)) ? '\u2705   ' :
          //. .              Z[k].test (Nothing)        ? '\u2705 * ' :
          //. .              /* otherwise */              '\u274C   '))
          //. .       (S.keys (Z.filter ($.test ([]) ($.TypeClass), Z)))
          //. [ 'Setoid          ✅ * ',  // if ‘a’ satisfies Setoid
          //. . 'Ord             ✅ * ',  // if ‘a’ satisfies Ord
          //. . 'Semigroupoid    ❌   ',
          //. . 'Category        ❌   ',
          //. . 'Semigroup       ✅ * ',  // if ‘a’ satisfies Semigroup
          //. . 'Monoid          ✅ * ',  // if ‘a’ satisfies Semigroup
          //. . 'Group           ❌   ',
          //. . 'Filterable      ✅   ',
          //. . 'Functor         ✅   ',
          //. . 'Bifunctor       ❌   ',
          //. . 'Profunctor      ❌   ',
          //. . 'Apply           ✅   ',
          //. . 'Applicative     ✅   ',
          //. . 'Chain           ✅   ',
          //. . 'ChainRec        ✅   ',
          //. . 'Monad           ✅   ',
          //. . 'Alt             ✅   ',
          //. . 'Plus            ✅   ',
          //. . 'Alternative     ✅   ',
          //. . 'Foldable        ✅   ',
          //. . 'Traversable     ✅   ',
          //. . 'Extend          ✅   ',
          //. . 'Comonad         ❌   ',
          //. . 'Contravariant   ❌   ' ]
          //. ```

          //# Maybe :: TypeRep Maybe
          //.
          //. Maybe [type representative][].

          //# Maybe.Nothing :: Maybe a
          //.
          //. The empty value of type `Maybe a`.
          //.
          //. ```javascript
          //. > Nothing
          //. Nothing
          //. ```
          var Nothing = (Maybe.Nothing = Object.create(Nothing$prototype));

          //# Maybe.Just :: a -> Maybe a
          //.
          //. Constructs a value of type `Maybe a` from a value of type `a`.
          //.
          //. ```javascript
          //. > Just (42)
          //. Just (42)
          //. ```
          var Just = (Maybe.Just = function(value) {
            var just = Object.create(Just$prototype);
            if (Z.Setoid.test(value)) {
              just["fantasy-land/equals"] = Just$prototype$equals;
              if (Z.Ord.test(value)) {
                just["fantasy-land/lte"] = Just$prototype$lte;
              }
            }
            if (Z.Semigroup.test(value)) {
              just["fantasy-land/concat"] = Just$prototype$concat;
            }
            just.value = value;
            return just;
          });

          //# Maybe.@@type :: String
          //.
          //. Maybe [type identifier][].
          //.
          //. ```javascript
          //. > type (Just (42))
          //. 'sanctuary-maybe/Maybe@1'
          //.
          //. > type.parse (type (Just (42)))
          //. {namespace: 'sanctuary-maybe', name: 'Maybe', version: 1}
          //. ```
          Maybe["@@type"] = "sanctuary-maybe/Maybe@1";

          //# Maybe.fantasy-land/empty :: () -> Maybe a
          //.
          //.   - `empty (Maybe)` is equivalent to `Nothing`
          //.
          //. ```javascript
          //. > S.empty (Maybe)
          //. Nothing
          //. ```
          Maybe["fantasy-land/empty"] = function() {
            return Nothing;
          };

          //# Maybe.fantasy-land/of :: a -> Maybe a
          //.
          //.   - `of (Maybe) (x)` is equivalent to `Just (x)`
          //.
          //. ```javascript
          //. > S.of (Maybe) (42)
          //. Just (42)
          //. ```
          Maybe["fantasy-land/of"] = Just;

          function next(x) {
            return { tag: next, value: x };
          }
          function done(x) {
            return { tag: done, value: x };
          }

          //# Maybe.fantasy-land/chainRec :: ((a -> c, b -> c, a) -> Maybe c, a) -> Maybe b
          //.
          //. ```javascript
          //. > Z.chainRec (
          //. .   Maybe,
          //. .   (next, done, x) =>
          //. .     x <= 1 ? Nothing : Just (x >= 1000 ? done (x) : next (x * x)),
          //. .   1
          //. . )
          //. Nothing
          //.
          //. > Z.chainRec (
          //. .   Maybe,
          //. .   (next, done, x) =>
          //. .     x <= 1 ? Nothing : Just (x >= 1000 ? done (x) : next (x * x)),
          //. .   2
          //. . )
          //. Just (65536)
          //. ```
          Maybe["fantasy-land/chainRec"] = function(f, x) {
            var r = next(x);
            while (r.tag === next) {
              var maybe = f(next, done, r.value);
              if (maybe.isNothing) return maybe;
              r = maybe.value;
            }
            return Just(r.value);
          };

          //# Maybe.fantasy-land/zero :: () -> Maybe a
          //.
          //.   - `zero (Maybe)` is equivalent to `Nothing`
          //.
          //. ```javascript
          //. > S.zero (Maybe)
          //. Nothing
          //. ```
          Maybe["fantasy-land/zero"] = function() {
            return Nothing;
          };

          //# Maybe#@@show :: Showable a => Maybe a ~> () -> String
          //.
          //.   - `show (Nothing)` is equivalent to `'Nothing'`
          //.   - `show (Just (x))` is equivalent to `'Just (' + show (x) + ')'`
          //.
          //. ```javascript
          //. > show (Nothing)
          //. 'Nothing'
          //.
          //. > show (Just (['foo', 'bar', 'baz']))
          //. 'Just (["foo", "bar", "baz"])'
          //. ```
          function Nothing$prototype$show() {
            return "Nothing";
          }
          function Just$prototype$show() {
            return "Just (" + show(this.value) + ")";
          }

          //# Maybe#fantasy-land/equals :: Setoid a => Maybe a ~> Maybe a -> Boolean
          //.
          //.   - `Nothing` is equal to `Nothing`
          //.   - `Just (x)` is equal to `Just (y)` [iff][] `x` is equal to `y`
          //.     according to [`Z.equals`][]
          //.   - `Nothing` is never equal to `Just (x)`
          //.
          //. ```javascript
          //. > S.equals (Nothing) (Nothing)
          //. true
          //.
          //. > S.equals (Just ([1, 2, 3])) (Just ([1, 2, 3]))
          //. true
          //.
          //. > S.equals (Just ([1, 2, 3])) (Just ([3, 2, 1]))
          //. false
          //.
          //. > S.equals (Just ([1, 2, 3])) (Nothing)
          //. false
          //. ```
          function Nothing$prototype$equals(other) {
            return other.isNothing;
          }
          function Just$prototype$equals(other) {
            return other.isJust && Z.equals(this.value, other.value);
          }

          //# Maybe#fantasy-land/lte :: Ord a => Maybe a ~> Maybe a -> Boolean
          //.
          //.   - `Nothing` is (less than or) equal to `Nothing`
          //.   - `Just (x)` is less than or equal to `Just (y)` [iff][] `x` is less
          //.     than or equal to `y` according to [`Z.lte`][]
          //.   - `Nothing` is always less than `Just (x)`
          //.
          //. ```javascript
          //. > S.filter (S.lte (Nothing)) ([Nothing, Just (0), Just (1), Just (2)])
          //. [Nothing]
          //.
          //. > S.filter (S.lte (Just (1))) ([Nothing, Just (0), Just (1), Just (2)])
          //. [Nothing, Just (0), Just (1)]
          //. ```
          function Nothing$prototype$lte(other) {
            return true;
          }
          function Just$prototype$lte(other) {
            return other.isJust && Z.lte(this.value, other.value);
          }

          //# Maybe#fantasy-land/concat :: Semigroup a => Maybe a ~> Maybe a -> Maybe a
          //.
          //.   - `concat (Nothing) (Nothing)` is equivalent to `Nothing`
          //.   - `concat (Just (x)) (Just (y))` is equivalent to
          //.     `Just (concat (x) (y))`
          //.   - `concat (Nothing) (Just (x))` is equivalent to `Just (x)`
          //.   - `concat (Just (x)) (Nothing)` is equivalent to `Just (x)`
          //.
          //. ```javascript
          //. > S.concat (Nothing) (Nothing)
          //. Nothing
          //.
          //. > S.concat (Just ([1, 2, 3])) (Just ([4, 5, 6]))
          //. Just ([1, 2, 3, 4, 5, 6])
          //.
          //. > S.concat (Nothing) (Just ([1, 2, 3]))
          //. Just ([1, 2, 3])
          //.
          //. > S.concat (Just ([1, 2, 3])) (Nothing)
          //. Just ([1, 2, 3])
          //. ```
          function Nothing$prototype$concat(other) {
            return other;
          }
          function Just$prototype$concat(other) {
            return other.isJust
              ? Just(Z.concat(this.value, other.value))
              : this;
          }

          //# Maybe#fantasy-land/filter :: Maybe a ~> (a -> Boolean) -> Maybe a
          //.
          //.   - `filterM (p) (Nothing)` is equivalent to `Nothing`
          //.   - `filterM (p) (Just (x))` is equivalent to
          //.     `p (x) ? Just (x) : Nothing`
          //.
          //. ```javascript
          //. > S.filterM (isFinite) (Nothing)
          //. Nothing
          //.
          //. > S.filterM (isFinite) (Just (Infinity))
          //. Nothing
          //.
          //. > S.filterM (isFinite) (Just (Number.MAX_SAFE_INTEGER))
          //. Just (9007199254740991)
          //. ```
          function Nothing$prototype$filter(pred) {
            return this;
          }
          function Just$prototype$filter(pred) {
            return pred(this.value) ? this : Nothing;
          }

          //# Maybe#fantasy-land/map :: Maybe a ~> (a -> b) -> Maybe b
          //.
          //.   - `map (f) (Nothing)` is equivalent to `Nothing`
          //.   - `map (f) (Just (x))` is equivalent to `Just (f (x))`
          //.
          //. ```javascript
          //. > S.map (Math.sqrt) (Nothing)
          //. Nothing
          //.
          //. > S.map (Math.sqrt) (Just (9))
          //. Just (3)
          //. ```
          function Nothing$prototype$map(f) {
            return this;
          }
          function Just$prototype$map(f) {
            return Just(f(this.value));
          }

          //# Maybe#fantasy-land/ap :: Maybe a ~> Maybe (a -> b) -> Maybe b
          //.
          //.   - `ap (Nothing) (Nothing)` is equivalent to `Nothing`
          //.   - `ap (Nothing) (Just (x))` is equivalent to `Nothing`
          //.   - `ap (Just (f)) (Nothing)` is equivalent to `Nothing`
          //.   - `ap (Just (f)) (Just (x))` is equivalent to `Just (f (x))`
          //.
          //. ```javascript
          //. > S.ap (Nothing) (Nothing)
          //. Nothing
          //.
          //. > S.ap (Nothing) (Just (9))
          //. Nothing
          //.
          //. > S.ap (Just (Math.sqrt)) (Nothing)
          //. Nothing
          //.
          //. > S.ap (Just (Math.sqrt)) (Just (9))
          //. Just (3)
          //. ```
          function Nothing$prototype$ap(other) {
            return this;
          }
          function Just$prototype$ap(other) {
            return other.isJust ? Just(other.value(this.value)) : other;
          }

          //# Maybe#fantasy-land/chain :: Maybe a ~> (a -> Maybe b) -> Maybe b
          //.
          //.   - `chain (f) (Nothing)` is equivalent to `Nothing`
          //.   - `chain (f) (Just (x))` is equivalent to `f (x)`
          //.
          //. ```javascript
          //. > const head = xs => xs.length === 0 ? Nothing : Just (xs[0])
          //.
          //. > S.chain (head) (Nothing)
          //. Nothing
          //.
          //. > S.chain (head) (Just ([]))
          //. Nothing
          //.
          //. > S.chain (head) (Just (['foo', 'bar', 'baz']))
          //. Just ('foo')
          //. ```
          function Nothing$prototype$chain(f) {
            return this;
          }
          function Just$prototype$chain(f) {
            return f(this.value);
          }

          //# Maybe#fantasy-land/alt :: Maybe a ~> Maybe a -> Maybe a
          //.
          //.   - `alt (Nothing) (Nothing)` is equivalent to `Nothing`
          //.   - `alt (Nothing) (Just (x))` is equivalent to `Just (x)`
          //.   - `alt (Just (x)) (Nothing)` is equivalent to `Just (x)`
          //.   - `alt (Just (x)) (Just (y))` is equivalent to `Just (x)`
          //.
          //. ```javascript
          //. > S.alt (Nothing) (Nothing)
          //. Nothing
          //.
          //. > S.alt (Nothing) (Just (1))
          //. Just (1)
          //.
          //. > S.alt (Just (2)) (Nothing)
          //. Just (2)
          //.
          //. > S.alt (Just (3)) (Just (4))
          //. Just (3)
          //. ```
          function Nothing$prototype$alt(other) {
            return other;
          }
          function Just$prototype$alt(other) {
            return this;
          }

          //# Maybe#fantasy-land/reduce :: Maybe a ~> ((b, a) -> b, b) -> b
          //.
          //.   - `reduce (f) (x) (Nothing)` is equivalent to `x`
          //.   - `reduce (f) (x) (Just (y))` is equivalent to `f (x) (y)`
          //.
          //. ```javascript
          //. > S.reduce (S.concat) ('abc') (Nothing)
          //. 'abc'
          //.
          //. > S.reduce (S.concat) ('abc') (Just ('xyz'))
          //. 'abcxyz'
          //. ```
          function Nothing$prototype$reduce(f, x) {
            return x;
          }
          function Just$prototype$reduce(f, x) {
            return f(x, this.value);
          }

          //# Maybe#fantasy-land/traverse :: Applicative f => Maybe a ~> (TypeRep f, a -> f b) -> f (Maybe b)
          //.
          //.   - `traverse (A) (f) (Nothing)` is equivalent to `of (A) (Nothing)`
          //.   - `traverse (A) (f) (Just (x))` is equivalent to `map (Just) (f (x))`
          //.
          //. ```javascript
          //. > S.traverse (Array) (S.words) (Nothing)
          //. [Nothing]
          //.
          //. > S.traverse (Array) (S.words) (Just ('foo bar baz'))
          //. [Just ('foo'), Just ('bar'), Just ('baz')]
          //. ```
          function Nothing$prototype$traverse(typeRep, f) {
            return Z.of(typeRep, this);
          }
          function Just$prototype$traverse(typeRep, f) {
            return Z.map(Just, f(this.value));
          }

          //# Maybe#fantasy-land/extend :: Maybe a ~> (Maybe a -> b) -> Maybe b
          //.
          //.   - `extend (f) (Nothing)` is equivalent to `Nothing`
          //.   - `extend (f) (Just (x))` is equivalent to `Just (f (Just (x)))`
          //.
          //. ```javascript
          //. > S.extend (S.reduce (S.add) (1)) (Nothing)
          //. Nothing
          //.
          //. > S.extend (S.reduce (S.add) (1)) (Just (99))
          //. Just (100)
          //. ```
          function Nothing$prototype$extend(f) {
            return this;
          }
          function Just$prototype$extend(f) {
            return Just(f(this));
          }

          return Maybe;
        });

        //. [Fantasy Land]:             v:fantasyland/fantasy-land
        //. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals
        //. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte
        //. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if
        //. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers
        //. [type representative]:      v:fantasyland/fantasy-land#type-representatives

        /***/
      },

    /***/ "./node_modules/sanctuary-pair/index.js":
      /*!**********************************************!*\
  !*** ./node_modules/sanctuary-pair/index.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__; /*                   *\
      //                     \\
     //   @@  @@     @@  @@   \\
    //      @@       @@  @@    \\
    \\      @@       @@  @@    //
     \\   @@  @@  @    @@ @   //
      \\          /       @  //
       \*             @@@@  */

        //. <a href="https://github.com/fantasyland/fantasy-land"><img alt="Fantasy Land" src="https://raw.githubusercontent.com/fantasyland/fantasy-land/master/logo.png" width="75" height="75" align="left"></a>
        //.
        //. # sanctuary-pair
        //.
        //. Pair is the canonical product type: a value of type `Pair a b` always
        //. contains exactly two values: one of type `a`; one of type `b`.

        (function(f) {
          "use strict";

          /* istanbul ignore else */
          if (true && typeof module.exports === "object") {
            module.exports = f(
              __webpack_require__(
                /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
              ),
              __webpack_require__(
                /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
              )
            );
          } else if (
            true &&
            __webpack_require__(
              /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
            ) != null
          ) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
              __webpack_require__(
                /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
              ),
              __webpack_require__(
                /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
              ),
            ]),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = f),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
            self.sanctuaryPair = f(
              self.sanctuaryShow,
              self.sanctuaryTypeClasses
            );
          }
        })(function(show, Z) {
          "use strict";

          /* istanbul ignore if */
          if (typeof __doctest !== "undefined") {
            var $ = __doctest.require("sanctuary-def");
            var type = __doctest.require("sanctuary-type-identifiers");
            var S = (function() {
              var S = __doctest.require("sanctuary");
              var PairType = $.BinaryType("sanctuary-pair/Pair")("")(function(
                x
              ) {
                return type(x) === Pair["@@type"];
              })(function(p) {
                return [p.fst];
              })(function(p) {
                return [p.snd];
              });
              var env = Z.concat(S.env, [
                $.TypeClass,
                PairType($.Unknown)($.Unknown),
              ]);
              return S.create({ checkTypes: true, env: env });
            })();
          }

          var prototype = {
            /* eslint-disable key-spacing */
            constructor: Pair,
            "@@show": Pair$prototype$show,
            "fantasy-land/compose": Pair$prototype$compose,
            "fantasy-land/map": Pair$prototype$map,
            "fantasy-land/bimap": Pair$prototype$bimap,
            "fantasy-land/reduce": Pair$prototype$reduce,
            "fantasy-land/traverse": Pair$prototype$traverse,
            "fantasy-land/extend": Pair$prototype$extend,
            "fantasy-land/extract": Pair$prototype$extract,
            /* eslint-enable key-spacing */
          };

          var util =
            true && typeof module.exports === "object"
              ? __webpack_require__(/*! util */ "./node_modules/util/util.js")
              : /* istanbul ignore next */ {};
          prototype[
            util.inspect != null && typeof util.inspect.custom === "symbol"
              ? /* istanbul ignore next */ util.inspect.custom
              : /* istanbul ignore next */ "inspect"
          ] = Pair$prototype$show;

          /* istanbul ignore else */
          if (
            typeof Symbol === "function" &&
            typeof Symbol.iterator === "symbol"
          ) {
            prototype[Symbol.iterator] = function() {
              return [this.fst, this.snd][Symbol.iterator]();
            };
          }

          //. `Pair a b` satisfies the following [Fantasy Land][] specifications:
          //.
          //. ```javascript
          //. > const Useless = require ('sanctuary-useless')
          //.
          //. > S.map (k => k + ' '.repeat (16 - k.length) +
          //. .             (Z[k].test (Pair (Useless) (Useless)) ? '\u2705   ' :
          //. .              Z[k].test (Pair (['foo']) (['bar'])) ? '\u2705 * ' :
          //. .              /* otherwise */                        '\u274C   '))
          //. .       (S.keys (Z.filter ($.test ([]) ($.TypeClass), Z)))
          //. [ 'Setoid          ✅ * ',  // if ‘a’ and ‘b’ satisfy Setoid
          //. . 'Ord             ✅ * ',  // if ‘a’ and ‘b’ satisfy Ord
          //. . 'Semigroupoid    ✅   ',
          //. . 'Category        ❌   ',
          //. . 'Semigroup       ✅ * ',  // if ‘a’ and ‘b’ satisfy Semigroup
          //. . 'Monoid          ❌   ',
          //. . 'Group           ❌   ',
          //. . 'Filterable      ❌   ',
          //. . 'Functor         ✅   ',
          //. . 'Bifunctor       ✅   ',
          //. . 'Profunctor      ❌   ',
          //. . 'Apply           ✅ * ',  // if ‘a’ satisfies Semigroup
          //. . 'Applicative     ❌   ',
          //. . 'Chain           ✅ * ',  // if ‘a’ satisfies Semigroup
          //. . 'ChainRec        ❌   ',
          //. . 'Monad           ❌   ',
          //. . 'Alt             ❌   ',
          //. . 'Plus            ❌   ',
          //. . 'Alternative     ❌   ',
          //. . 'Foldable        ✅   ',
          //. . 'Traversable     ✅   ',
          //. . 'Extend          ✅   ',
          //. . 'Comonad         ✅   ',
          //. . 'Contravariant   ❌   ' ]
          //. ```

          //# Pair :: a -> b -> Pair a b
          //.
          //. Pair's sole data constructor. Additionally, it serves as the
          //. Pair [type representative][].
          //.
          //. ```javascript
          //. > Pair (1) (2)
          //. Pair (1) (2)
          //. ```
          function Pair(fst) {
            return function(snd) {
              var pair = Object.create(prototype);
              if (Z.Setoid.test(fst) && Z.Setoid.test(snd)) {
                pair["fantasy-land/equals"] = Pair$prototype$equals;
                if (Z.Ord.test(fst) && Z.Ord.test(snd)) {
                  pair["fantasy-land/lte"] = Pair$prototype$lte;
                }
              }
              if (Z.Semigroup.test(fst)) {
                if (Z.Semigroup.test(snd)) {
                  pair["fantasy-land/concat"] = Pair$prototype$concat;
                }
                pair["fantasy-land/ap"] = Pair$prototype$ap;
                pair["fantasy-land/chain"] = Pair$prototype$chain;
              }
              pair.fst = fst;
              pair.snd = snd;
              return pair;
            };
          }

          //# Pair.fst :: Pair a b -> a
          //.
          //. `fst (Pair (x) (y))` is equivalent to `x`.
          //.
          //. ```javascript
          //. > Pair.fst (Pair ('abc') ([1, 2, 3]))
          //. 'abc'
          //. ```
          Pair.fst = function(p) {
            return p.fst;
          };

          //# Pair.snd :: Pair a b -> b
          //.
          //. `snd (Pair (x) (y))` is equivalent to `y`.
          //.
          //. ```javascript
          //. > Pair.snd (Pair ('abc') ([1, 2, 3]))
          //. [1, 2, 3]
          //. ```
          Pair.snd = function(p) {
            return p.snd;
          };

          //# Pair.swap :: Pair a b -> Pair b a
          //.
          //. `swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.
          //.
          //. ```javascript
          //. > Pair.swap (Pair ('abc') ([1, 2, 3]))
          //. Pair ([1, 2, 3]) ('abc')
          //. ```
          Pair.swap = function(p) {
            return Pair(p.snd)(p.fst);
          };

          //# Pair.@@type :: String
          //.
          //. Pair [type identifier][].
          //.
          //. ```javascript
          //. > type (Pair ('abc') ([1, 2, 3]))
          //. 'sanctuary-pair/Pair@1'
          //.
          //. > type.parse (type (Pair ('abc') ([1, 2, 3])))
          //. {namespace: 'sanctuary-pair', name: 'Pair', version: 1}
          //. ```
          Pair["@@type"] = "sanctuary-pair/Pair@1";

          //# Pair#@@show :: (Showable a, Showable b) => Pair a b ~> () -> String
          //.
          //. `show (Pair (x) (y))` is equivalent to
          //. `'Pair (' + show (x) + ') (' + show (y) + ')'`.
          //.
          //. ```javascript
          //. > show (Pair ('abc') ([1, 2, 3]))
          //. 'Pair ("abc") ([1, 2, 3])'
          //. ```
          function Pair$prototype$show() {
            return "Pair (" + show(this.fst) + ") (" + show(this.snd) + ")";
          }

          //# Pair#fantasy-land/equals :: (Setoid a, Setoid b) => Pair a b ~> Pair a b -> Boolean
          //.
          //. `Pair (x) (y)` is equal to `Pair (v) (w)` [iff][] `x` is equal to `v`
          //. and `y` is equal to `w` according to [`Z.equals`][].
          //.
          //. ```javascript
          //. > S.equals (Pair ('abc') ([1, 2, 3])) (Pair ('abc') ([1, 2, 3]))
          //. true
          //.
          //. > S.equals (Pair ('abc') ([1, 2, 3])) (Pair ('abc') ([3, 2, 1]))
          //. false
          //. ```
          function Pair$prototype$equals(other) {
            return (
              Z.equals(this.fst, other.fst) && Z.equals(this.snd, other.snd)
            );
          }

          //# Pair#fantasy-land/lte :: (Ord a, Ord b) => Pair a b ~> Pair a b -> Boolean
          //.
          //. `Pair (x) (y)` is less than or equal to `Pair (v) (w)` [iff][] `x` is
          //. less than `v` or `x` is equal to `v` and `y` is less than or equal to
          //. `w` according to [`Z.lte`][].
          //.
          //. ```javascript
          //. > S.filter (S.lte (Pair ('b') (2)))
          //. .          ([Pair ('a') (1), Pair ('a') (2), Pair ('a') (3),
          //. .            Pair ('b') (1), Pair ('b') (2), Pair ('b') (3),
          //. .            Pair ('c') (1), Pair ('c') (2), Pair ('c') (3)])
          //. [ Pair ('a') (1),
          //. . Pair ('a') (2),
          //. . Pair ('a') (3),
          //. . Pair ('b') (1),
          //. . Pair ('b') (2) ]
          //. ```
          function Pair$prototype$lte(other) {
            return Z.equals(this.fst, other.fst)
              ? Z.lte(this.snd, other.snd)
              : Z.lte(this.fst, other.fst);
          }

          //# Pair#fantasy-land/compose :: Pair a b ~> Pair b c -> Pair a c
          //.
          //. `compose (Pair (x) (y)) (Pair (v) (w))` is equivalent to `Pair (v) (y)`.
          //.
          //. ```javascript
          //. > S.compose (Pair ('a') (0)) (Pair ([1, 2, 3]) ('b'))
          //. Pair ([1, 2, 3]) (0)
          //. ```
          function Pair$prototype$compose(other) {
            return Pair(this.fst)(other.snd);
          }

          //# Pair#fantasy-land/concat :: (Semigroup a, Semigroup b) => Pair a b ~> Pair a b -> Pair a b
          //.
          //. `concat (Pair (x) (y)) (Pair (v) (w))` is equivalent to
          //. `Pair (concat (x) (v)) (concat (y) (w))`.
          //.
          //. ```javascript
          //. > S.concat (Pair ('abc') ([1, 2, 3])) (Pair ('xyz') ([4, 5, 6]))
          //. Pair ('abcxyz') ([1, 2, 3, 4, 5, 6])
          //. ```
          function Pair$prototype$concat(other) {
            return Pair(
              Z.concat(this.fst, other.fst)
            )(Z.concat(this.snd, other.snd));
          }

          //# Pair#fantasy-land/map :: Pair a b ~> (b -> c) -> Pair a c
          //.
          //. `map (f) (Pair (x) (y))` is equivalent to `Pair (x) (f (y))`.
          //.
          //. ```javascript
          //. > S.map (Math.sqrt) (Pair ('abc') (256))
          //. Pair ('abc') (16)
          //. ```
          function Pair$prototype$map(f) {
            return Pair(this.fst)(f(this.snd));
          }

          //# Pair#fantasy-land/bimap :: Pair a c ~> (a -> b, c -> d) -> Pair b d
          //.
          //. `bimap (f) (g) (Pair (x) (y))` is equivalent to `Pair (f (x)) (g (y))`.
          //.
          //. ```javascript
          //. > S.bimap (S.toUpper) (Math.sqrt) (Pair ('abc') (256))
          //. Pair ('ABC') (16)
          //. ```
          function Pair$prototype$bimap(f, g) {
            return Pair(f(this.fst))(g(this.snd));
          }

          //# Pair#fantasy-land/ap :: Semigroup a => Pair a b ~> Pair a (b -> c) -> Pair a c
          //.
          //. `ap (Pair (v) (f)) (Pair (x) (y))` is equivalent to
          //. `Pair (concat (v) (x)) (f (y))`.
          //.
          //. ```javascript
          //. > S.ap (Pair ('abc') (Math.sqrt)) (Pair ('xyz') (256))
          //. Pair ('abcxyz') (16)
          //. ```
          function Pair$prototype$ap(other) {
            return Pair(Z.concat(other.fst, this.fst))(other.snd(this.snd));
          }

          //# Pair#fantasy-land/chain :: Semigroup a => Pair a b ~> (b -> Pair a c) -> Pair a c
          //.
          //. `chain (f) (Pair (x) (y))` is equivalent to
          //. `Pair (concat (x) (fst (f (y)))) (snd (f (y)))`.
          //.
          //. ```javascript
          //. > S.chain (n => Pair (show (n)) (Math.sqrt (n))) (Pair ('abc') (256))
          //. Pair ('abc256') (16)
          //. ```
          function Pair$prototype$chain(f) {
            var other = f(this.snd);
            return Pair(Z.concat(this.fst, other.fst))(other.snd);
          }

          //# Pair#fantasy-land/reduce :: Pair a b ~> ((c, b) -> c, c) -> c
          //.
          //. `reduce (f) (x) (Pair (v) (w))` is equivalent to `f (x) (w)`.
          //.
          //. ```javascript
          //. > S.reduce (S.concat) ([1, 2, 3]) (Pair ('abc') ([4, 5, 6]))
          //. [1, 2, 3, 4, 5, 6]
          //. ```
          function Pair$prototype$reduce(f, x) {
            return f(x, this.snd);
          }

          //# Pair#fantasy-land/traverse :: Applicative f => Pair a b ~> (TypeRep f, b -> f c) -> f (Pair a c)
          //.
          //. `traverse (_) (f) (Pair (x) (y))` is equivalent to
          //. `map (Pair (x)) (f (y))`.
          //.
          //. ```javascript
          //. > S.traverse (Array) (S.words) (Pair (123) ('foo bar baz'))
          //. [Pair (123) ('foo'), Pair (123) ('bar'), Pair (123) ('baz')]
          //. ```
          function Pair$prototype$traverse(typeRep, f) {
            return Z.map(Pair(this.fst), f(this.snd));
          }

          //# Pair#fantasy-land/extend :: Pair a b ~> (Pair a b -> c) -> Pair a c
          //.
          //. `extend (f) (Pair (x) (y))` is equivalent to
          //. `Pair (x) (f (Pair (x) (y)))`.
          //.
          //. ```javascript
          //. > S.extend (S.reduce (S.add) (1)) (Pair ('abc') (99))
          //. Pair ('abc') (100)
          //. ```
          function Pair$prototype$extend(f) {
            return Pair(this.fst)(f(this));
          }

          //# Pair#fantasy-land/extract :: Pair a b ~> () -> b
          //.
          //. `extract (Pair (x) (y))` is equivalent to `y`.
          //.
          //. ```javascript
          //. > S.extract (Pair ('abc') ([1, 2, 3]))
          //. [1, 2, 3]
          //. ```
          function Pair$prototype$extract() {
            return this.snd;
          }

          return Pair;
        });

        //. [Fantasy Land]:             v:fantasyland/fantasy-land
        //. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals
        //. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte
        //. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if
        //. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers
        //. [type representative]:      v:fantasyland/fantasy-land#type-representatives

        /***/
      },

    /***/ "./node_modules/sanctuary-show/index.js":
      /*!**********************************************!*\
  !*** ./node_modules/sanctuary-show/index.js ***!
  \**********************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__; //. # sanctuary-show
        //.
        //. Haskell has a `show` function which can be applied to a compatible value to
        //. produce a descriptive string representation of that value. The idea is that
        //. the string representation should, if possible, be an expression which would
        //. produce the original value if evaluated.
        //.
        //. This library provides a similar [`show`](#show) function.
        //.
        //. In general, this property should hold: `eval (show (x)) = x`. In some cases
        //. parens are necessary to ensure correct interpretation (`{}`, for example,
        //. is an empty block rather than an empty object in some contexts). Thus the
        //. property is more accurately stated `eval ('(' + show (x) + ')') = x`.
        //.
        //. One can make values of a custom type compatible with [`show`](#show) by
        //. defining a `@@show` method. For example:
        //.
        //. ```javascript
        //. //# Maybe#@@show :: Maybe a ~> () -> String
        //. //.
        //. //. ```javascript
        //. //. > show (Nothing)
        //. //. 'Nothing'
        //. //.
        //. //. > show (Just (['foo', 'bar', 'baz']))
        //. //. 'Just (["foo", "bar", "baz"])'
        //. //. ```
        //. Maybe.prototype['@@show'] = function() {
        //.   return this.isNothing ? 'Nothing' : 'Just (' + show (this.value) + ')';
        //. };
        //. ```

        (function(f) {
          "use strict";

          /* istanbul ignore else */
          if (true && typeof module.exports === "object") {
            module.exports = f();
          } else if (
            true &&
            __webpack_require__(
              /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
            ) != null
          ) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = f),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
            self.sanctuaryShow = f();
          }
        })(function() {
          "use strict";

          //  $$show :: String
          var $$show = "@@show";

          //  seen :: Array Any
          var seen = [];

          //  entry :: Object -> String -> String
          function entry(o) {
            return function(k) {
              return show(k) + ": " + show(o[k]);
            };
          }

          //# show :: Showable a => a -> String
          //.
          //. Returns a useful string representation of the given value.
          //.
          //. Dispatches to the value's `@@show` method if present.
          //.
          //. Where practical, `show (eval ('(' + show (x) + ')')) = show (x)`.
          //.
          //. ```javascript
          //. > show (null)
          //. 'null'
          //.
          //. > show (undefined)
          //. 'undefined'
          //.
          //. > show (true)
          //. 'true'
          //.
          //. > show (new Boolean (false))
          //. 'new Boolean (false)'
          //.
          //. > show (-0)
          //. '-0'
          //.
          //. > show (NaN)
          //. 'NaN'
          //.
          //. > show (new Number (Infinity))
          //. 'new Number (Infinity)'
          //.
          //. > show ('foo\n"bar"\nbaz\n')
          //. '"foo\\n\\"bar\\"\\nbaz\\n"'
          //.
          //. > show (new String (''))
          //. 'new String ("")'
          //.
          //. > show (['foo', 'bar', 'baz'])
          //. '["foo", "bar", "baz"]'
          //.
          //. > show ([[[[[0]]]]])
          //. '[[[[[0]]]]]'
          //.
          //. > show ({x: [1, 2], y: [3, 4], z: [5, 6]})
          //. '{"x": [1, 2], "y": [3, 4], "z": [5, 6]}'
          //. ```
          function show(x) {
            if (seen.indexOf(x) >= 0) return "<Circular>";

            switch (Object.prototype.toString.call(x)) {
              case "[object Boolean]":
                return typeof x === "object"
                  ? "new Boolean (" + show(x.valueOf()) + ")"
                  : x.toString();

              case "[object Number]":
                return typeof x === "object"
                  ? "new Number (" + show(x.valueOf()) + ")"
                  : 1 / x === -Infinity
                  ? "-0"
                  : x.toString(10);

              case "[object String]":
                return typeof x === "object"
                  ? "new String (" + show(x.valueOf()) + ")"
                  : JSON.stringify(x);

              case "[object Date]":
                return (
                  "new Date (" +
                  show(isNaN(x.valueOf()) ? NaN : x.toISOString()) +
                  ")"
                );

              case "[object Error]":
                return "new " + x.name + " (" + show(x.message) + ")";

              case "[object Arguments]":
                return (
                  "function () { return arguments; } (" +
                  Array.prototype.map.call(x, show).join(", ") +
                  ")"
                );

              case "[object Array]":
                seen.push(x);
                try {
                  return (
                    "[" +
                    x
                      .map(show)
                      .concat(
                        Object.keys(x)
                          .sort()
                          .filter(function(k) {
                            return !/^\d+$/.test(k);
                          })
                          .map(entry(x))
                      )
                      .join(", ") +
                    "]"
                  );
                } finally {
                  seen.pop();
                }

              case "[object Object]":
                seen.push(x);
                try {
                  return $$show in x &&
                    (x.constructor == null || x.constructor.prototype !== x)
                    ? x[$$show]()
                    : "{" +
                        Object.keys(x)
                          .sort()
                          .map(entry(x))
                          .join(", ") +
                        "}";
                } finally {
                  seen.pop();
                }

              default:
                return String(x);
            }
          }

          return show;
        });

        /***/
      },

    /***/ "./node_modules/sanctuary-type-classes/index.js":
      /*!******************************************************!*\
  !*** ./node_modules/sanctuary-type-classes/index.js ***!
  \******************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__; /*
             ############                  #
            ############                  ###
                  #####                  #####
                #####      ####################
              #####       ######################
            #####                     ###########
          #####         ######################
        #####          ####################
      #####                        #####
     ############                 ###
    ############                 */

        //. # sanctuary-type-classes
        //.
        //. The [Fantasy Land Specification][FL] "specifies interoperability of common
        //. algebraic structures" by defining a number of type classes. For each type
        //. class, it states laws which every member of a type must obey in order for
        //. the type to be a member of the type class. In order for the Maybe type to
        //. be considered a [Functor][], for example, every `Maybe a` value must have
        //. a `fantasy-land/map` method which obeys the identity and composition laws.
        //.
        //. This project provides:
        //.
        //.   - [`TypeClass`](#TypeClass), a function for defining type classes;
        //.   - one `TypeClass` value for each Fantasy Land type class;
        //.   - lawful Fantasy Land methods for JavaScript's built-in types;
        //.   - one function for each Fantasy Land method; and
        //.   - several functions derived from these functions.
        //.
        //. ## Type-class hierarchy
        //.
        /* eslint-disable max-len */
        //. <pre>
        //.  Setoid   Semigroupoid  Semigroup   Foldable        Functor      Contravariant  Filterable
        //. (equals)    (compose)    (concat)   (reduce)         (map)        (contramap)    (filter)
        //.     |           |           |           \         / | | | | \
        //.     |           |           |            \       /  | | | |  \
        //.     |           |           |             \     /   | | | |   \
        //.     |           |           |              \   /    | | | |    \
        //.     |           |           |               \ /     | | | |     \
        //.    Ord      Category     Monoid         Traversable | | | |      \
        //.   (lte)       (id)       (empty)        (traverse)  / | | \       \
        //.                             |                      /  | |  \       \
        //.                             |                     /   / \   \       \
        //.                             |             Profunctor /   \ Bifunctor \
        //.                             |              (promap) /     \ (bimap)   \
        //.                             |                      /       \           \
        //.                           Group                   /         \           \
        //.                          (invert)               Alt        Apply      Extend
        //.                                                (alt)        (ap)     (extend)
        //.                                                 /           / \           \
        //.                                                /           /   \           \
        //.                                               /           /     \           \
        //.                                              /           /       \           \
        //.                                             /           /         \           \
        //.                                           Plus    Applicative    Chain      Comonad
        //.                                          (zero)       (of)      (chain)    (extract)
        //.                                             \         / \         / \
        //.                                              \       /   \       /   \
        //.                                               \     /     \     /     \
        //.                                                \   /       \   /       \
        //.                                                 \ /         \ /         \
        //.                                             Alternative    Monad     ChainRec
        //.                                                                     (chainRec)
        //. </pre>
        /* eslint-enable max-len */
        //.
        //. ## API

        (function(f) {
          "use strict";

          /* istanbul ignore else */
          if (true && typeof module.exports === "object") {
            module.exports = f(
              __webpack_require__(
                /*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-classes/node_modules/sanctuary-type-identifiers/index.js"
              )
            );
          } else if (
            true &&
            __webpack_require__(
              /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
            ) != null
          ) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
              __webpack_require__(
                /*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-classes/node_modules/sanctuary-type-identifiers/index.js"
              ),
            ]),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = f),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
            self.sanctuaryTypeClasses = f(self.sanctuaryTypeIdentifiers);
          }
        })(function(type) {
          "use strict";

          /* istanbul ignore if */
          if (typeof __doctest !== "undefined") {
            /* global __doctest:false */
            /* eslint-disable no-unused-vars */
            var Identity = __doctest.require("./test/Identity");
            var List = __doctest.require("./test/List");
            var Maybe = __doctest.require("./test/Maybe");
            var Sum = __doctest.require("./test/Sum");
            var Tuple = __doctest.require("./test/Tuple");

            var Nil = List.Nil,
              Cons = List.Cons;
            var Nothing = Maybe.Nothing,
              Just = Maybe.Just;
            /* eslint-enable no-unused-vars */
          }

          //  concat_ :: Array a -> Array a -> Array a
          function concat_(xs) {
            return function(ys) {
              return xs.concat(ys);
            };
          }

          //  constant :: a -> b -> a
          function constant(x) {
            return function(y) {
              return x;
            };
          }

          //  forEachKey :: (StrMap a, StrMap a ~> String -> Undefined) -> Undefined
          function forEachKey(strMap, f) {
            Object.keys(strMap).forEach(f, strMap);
          }

          //  has :: (String, Object) -> Boolean
          function has(k, o) {
            return Object.prototype.hasOwnProperty.call(o, k);
          }

          //  identity :: a -> a
          function identity(x) {
            return x;
          }

          //  pair :: a -> b -> Array2 a b
          function pair(x) {
            return function(y) {
              return [x, y];
            };
          }

          //  sameType :: (a, b) -> Boolean
          function sameType(x, y) {
            return typeof x === typeof y && type(x) === type(y);
          }

          //  thrush :: a -> (a -> b) -> b
          function thrush(x) {
            return function(f) {
              return f(x);
            };
          }

          //  type Iteration a = { value :: a, done :: Boolean }

          //  iterationNext :: a -> Iteration a
          function iterationNext(x) {
            return { value: x, done: false };
          }

          //  iterationDone :: a -> Iteration a
          function iterationDone(x) {
            return { value: x, done: true };
          }

          //# TypeClass :: (String, String, Array TypeClass, a -> Boolean) -> TypeClass
          //.
          //. The arguments are:
          //.
          //.   - the name of the type class, prefixed by its npm package name;
          //.   - the documentation URL of the type class;
          //.   - an array of dependencies; and
          //.   - a predicate which accepts any JavaScript value and returns `true`
          //.     if the value satisfies the requirements of the type class; `false`
          //.     otherwise.
          //.
          //. Example:
          //.
          //. ```javascript
          //. //    hasMethod :: String -> a -> Boolean
          //. const hasMethod = name => x => x != null && typeof x[name] == 'function';
          //.
          //. //    Foo :: TypeClass
          //. const Foo = Z.TypeClass(
          //.   'my-package/Foo',
          //.   'http://example.com/my-package#Foo',
          //.   [],
          //.   hasMethod('foo')
          //. );
          //.
          //. //    Bar :: TypeClass
          //. const Bar = Z.TypeClass(
          //.   'my-package/Bar',
          //.   'http://example.com/my-package#Bar',
          //.   [Foo],
          //.   hasMethod('bar')
          //. );
          //. ```
          //.
          //. Types whose values have a `foo` method are members of the Foo type class.
          //. Members of the Foo type class whose values have a `bar` method are also
          //. members of the Bar type class.
          //.
          //. Each `TypeClass` value has a `test` field: a function which accepts
          //. any JavaScript value and returns `true` if the value satisfies the
          //. type class's predicate and the predicates of all the type class's
          //. dependencies; `false` otherwise.
          //.
          //. `TypeClass` values may be used with [sanctuary-def][type-classes]
          //. to define parametrically polymorphic functions which verify their
          //. type-class constraints at run time.
          function TypeClass(name, url, dependencies, test) {
            if (!(this instanceof TypeClass)) {
              return new TypeClass(name, url, dependencies, test);
            }
            this.name = name;
            this.url = url;
            this.test = function(x) {
              return (
                dependencies.every(function(d) {
                  return d.test(x);
                }) && test(x)
              );
            };
          }

          TypeClass["@@type"] = "sanctuary-type-classes/TypeClass";

          //  data Location = Constructor | Value

          //  Constructor :: Location
          var Constructor = "Constructor";

          //  Value :: Location
          var Value = "Value";

          //  _funcPath :: (Boolean, Array String, a) -> Nullable Function
          function _funcPath(allowInheritedProps, path, _x) {
            var x = _x;
            for (var idx = 0; idx < path.length; idx += 1) {
              var k = path[idx];
              if (x == null || !(allowInheritedProps || has(k, x))) return null;
              x = x[k];
            }
            return typeof x === "function" ? x : null;
          }

          //  funcPath :: (Array String, a) -> Nullable Function
          function funcPath(path, x) {
            return _funcPath(true, path, x);
          }

          //  implPath :: Array String -> Nullable Function
          function implPath(path) {
            return _funcPath(false, path, implementations);
          }

          //  functionName :: Function -> String
          var functionName = has("name", function f() {})
            ? function functionName(f) {
                return f.name;
              }
            : /* istanbul ignore next */
              function functionName(f) {
                var match = /function (\w*)/.exec(f);
                return match == null ? "" : match[1];
              };

          //  $ :: (String, Array TypeClass, StrMap (Array Location)) -> TypeClass
          function $(_name, dependencies, requirements) {
            function getBoundMethod(_name) {
              var name = "fantasy-land/" + _name;
              return requirements[_name] === Constructor
                ? function(typeRep) {
                    var f = funcPath([name], typeRep);
                    return f == null && typeof typeRep === "function"
                      ? implPath([functionName(typeRep), name])
                      : f;
                  }
                : function(x) {
                    var isPrototype =
                      x != null &&
                      x.constructor != null &&
                      x.constructor.prototype === x;
                    var m = null;
                    if (!isPrototype) m = funcPath([name], x);
                    if (m == null) m = implPath([type(x), "prototype", name]);
                    return m && m.bind(x);
                  };
            }

            var version = "9.0.0"; // updated programmatically
            var keys = Object.keys(requirements);

            var typeClass = TypeClass(
              "sanctuary-type-classes/" + _name,
              "https://github.com/sanctuary-js/sanctuary-type-classes/tree/v" +
                version +
                "#" +
                _name,
              dependencies,
              function(x) {
                return keys.every(function(_name) {
                  var arg =
                    requirements[_name] === Constructor ? x.constructor : x;
                  return getBoundMethod(_name)(arg) != null;
                });
              }
            );

            typeClass.methods = keys.reduce(function(methods, _name) {
              methods[_name] = getBoundMethod(_name);
              return methods;
            }, {});

            return typeClass;
          }

          //# Setoid :: TypeClass
          //.
          //. `TypeClass` value for [Setoid][].
          //.
          //. ```javascript
          //. > Setoid.test(null)
          //. true
          //. ```
          var Setoid = $("Setoid", [], { equals: Value });

          //# Ord :: TypeClass
          //.
          //. `TypeClass` value for [Ord][].
          //.
          //. ```javascript
          //. > Ord.test(0)
          //. true
          //.
          //. > Ord.test(Math.sqrt)
          //. false
          //. ```
          var Ord = $("Ord", [Setoid], { lte: Value });

          //# Semigroupoid :: TypeClass
          //.
          //. `TypeClass` value for [Semigroupoid][].
          //.
          //. ```javascript
          //. > Semigroupoid.test(Math.sqrt)
          //. true
          //.
          //. > Semigroupoid.test(0)
          //. false
          //. ```
          var Semigroupoid = $("Semigroupoid", [], { compose: Value });

          //# Category :: TypeClass
          //.
          //. `TypeClass` value for [Category][].
          //.
          //. ```javascript
          //. > Category.test(Math.sqrt)
          //. true
          //.
          //. > Category.test(0)
          //. false
          //. ```
          var Category = $("Category", [Semigroupoid], { id: Constructor });

          //# Semigroup :: TypeClass
          //.
          //. `TypeClass` value for [Semigroup][].
          //.
          //. ```javascript
          //. > Semigroup.test('')
          //. true
          //.
          //. > Semigroup.test(0)
          //. false
          //. ```
          var Semigroup = $("Semigroup", [], { concat: Value });

          //# Monoid :: TypeClass
          //.
          //. `TypeClass` value for [Monoid][].
          //.
          //. ```javascript
          //. > Monoid.test('')
          //. true
          //.
          //. > Monoid.test(0)
          //. false
          //. ```
          var Monoid = $("Monoid", [Semigroup], { empty: Constructor });

          //# Group :: TypeClass
          //.
          //. `TypeClass` value for [Group][].
          //.
          //. ```javascript
          //. > Group.test(Sum(0))
          //. true
          //.
          //. > Group.test('')
          //. false
          //. ```
          var Group = $("Group", [Monoid], { invert: Value });

          //# Filterable :: TypeClass
          //.
          //. `TypeClass` value for [Filterable][].
          //.
          //. ```javascript
          //. > Filterable.test({})
          //. true
          //.
          //. > Filterable.test('')
          //. false
          //. ```
          var Filterable = $("Filterable", [], { filter: Value });

          //# Functor :: TypeClass
          //.
          //. `TypeClass` value for [Functor][].
          //.
          //. ```javascript
          //. > Functor.test([])
          //. true
          //.
          //. > Functor.test('')
          //. false
          //. ```
          var Functor = $("Functor", [], { map: Value });

          //# Bifunctor :: TypeClass
          //.
          //. `TypeClass` value for [Bifunctor][].
          //.
          //. ```javascript
          //. > Bifunctor.test(Tuple('foo', 64))
          //. true
          //.
          //. > Bifunctor.test([])
          //. false
          //. ```
          var Bifunctor = $("Bifunctor", [Functor], { bimap: Value });

          //# Profunctor :: TypeClass
          //.
          //. `TypeClass` value for [Profunctor][].
          //.
          //. ```javascript
          //. > Profunctor.test(Math.sqrt)
          //. true
          //.
          //. > Profunctor.test([])
          //. false
          //. ```
          var Profunctor = $("Profunctor", [Functor], { promap: Value });

          //# Apply :: TypeClass
          //.
          //. `TypeClass` value for [Apply][].
          //.
          //. ```javascript
          //. > Apply.test([])
          //. true
          //.
          //. > Apply.test('')
          //. false
          //. ```
          var Apply = $("Apply", [Functor], { ap: Value });

          //# Applicative :: TypeClass
          //.
          //. `TypeClass` value for [Applicative][].
          //.
          //. ```javascript
          //. > Applicative.test([])
          //. true
          //.
          //. > Applicative.test({})
          //. false
          //. ```
          var Applicative = $("Applicative", [Apply], { of: Constructor });

          //# Chain :: TypeClass
          //.
          //. `TypeClass` value for [Chain][].
          //.
          //. ```javascript
          //. > Chain.test([])
          //. true
          //.
          //. > Chain.test({})
          //. false
          //. ```
          var Chain = $("Chain", [Apply], { chain: Value });

          //# ChainRec :: TypeClass
          //.
          //. `TypeClass` value for [ChainRec][].
          //.
          //. ```javascript
          //. > ChainRec.test([])
          //. true
          //.
          //. > ChainRec.test({})
          //. false
          //. ```
          var ChainRec = $("ChainRec", [Chain], { chainRec: Constructor });

          //# Monad :: TypeClass
          //.
          //. `TypeClass` value for [Monad][].
          //.
          //. ```javascript
          //. > Monad.test([])
          //. true
          //.
          //. > Monad.test({})
          //. false
          //. ```
          var Monad = $("Monad", [Applicative, Chain], {});

          //# Alt :: TypeClass
          //.
          //. `TypeClass` value for [Alt][].
          //.
          //. ```javascript
          //. > Alt.test({})
          //. true
          //.
          //. > Alt.test('')
          //. false
          //. ```
          var Alt = $("Alt", [Functor], { alt: Value });

          //# Plus :: TypeClass
          //.
          //. `TypeClass` value for [Plus][].
          //.
          //. ```javascript
          //. > Plus.test({})
          //. true
          //.
          //. > Plus.test('')
          //. false
          //. ```
          var Plus = $("Plus", [Alt], { zero: Constructor });

          //# Alternative :: TypeClass
          //.
          //. `TypeClass` value for [Alternative][].
          //.
          //. ```javascript
          //. > Alternative.test([])
          //. true
          //.
          //. > Alternative.test({})
          //. false
          //. ```
          var Alternative = $("Alternative", [Applicative, Plus], {});

          //# Foldable :: TypeClass
          //.
          //. `TypeClass` value for [Foldable][].
          //.
          //. ```javascript
          //. > Foldable.test({})
          //. true
          //.
          //. > Foldable.test('')
          //. false
          //. ```
          var Foldable = $("Foldable", [], { reduce: Value });

          //# Traversable :: TypeClass
          //.
          //. `TypeClass` value for [Traversable][].
          //.
          //. ```javascript
          //. > Traversable.test([])
          //. true
          //.
          //. > Traversable.test('')
          //. false
          //. ```
          var Traversable = $("Traversable", [Functor, Foldable], {
            traverse: Value,
          });

          //# Extend :: TypeClass
          //.
          //. `TypeClass` value for [Extend][].
          //.
          //. ```javascript
          //. > Extend.test([])
          //. true
          //.
          //. > Extend.test({})
          //. false
          //. ```
          var Extend = $("Extend", [Functor], { extend: Value });

          //# Comonad :: TypeClass
          //.
          //. `TypeClass` value for [Comonad][].
          //.
          //. ```javascript
          //. > Comonad.test(Identity(0))
          //. true
          //.
          //. > Comonad.test([])
          //. false
          //. ```
          var Comonad = $("Comonad", [Extend], { extract: Value });

          //# Contravariant :: TypeClass
          //.
          //. `TypeClass` value for [Contravariant][].
          //.
          //. ```javascript
          //. > Contravariant.test(Math.sqrt)
          //. true
          //.
          //. > Contravariant.test([])
          //. false
          //. ```
          var Contravariant = $("Contravariant", [], { contramap: Value });

          //  Null$prototype$equals :: Null ~> Null -> Boolean
          function Null$prototype$equals(other) {
            return true;
          }

          //  Null$prototype$lte :: Null ~> Null -> Boolean
          function Null$prototype$lte(other) {
            return true;
          }

          //  Undefined$prototype$equals :: Undefined ~> Undefined -> Boolean
          function Undefined$prototype$equals(other) {
            return true;
          }

          //  Undefined$prototype$lte :: Undefined ~> Undefined -> Boolean
          function Undefined$prototype$lte(other) {
            return true;
          }

          //  Boolean$prototype$equals :: Boolean ~> Boolean -> Boolean
          function Boolean$prototype$equals(other) {
            return typeof this === "object"
              ? equals(this.valueOf(), other.valueOf())
              : this === other;
          }

          //  Boolean$prototype$lte :: Boolean ~> Boolean -> Boolean
          function Boolean$prototype$lte(other) {
            return typeof this === "object"
              ? lte(this.valueOf(), other.valueOf())
              : this === false || other === true;
          }

          //  Number$prototype$equals :: Number ~> Number -> Boolean
          function Number$prototype$equals(other) {
            return typeof this === "object"
              ? equals(this.valueOf(), other.valueOf())
              : (isNaN(this) && isNaN(other)) || this === other;
          }

          //  Number$prototype$lte :: Number ~> Number -> Boolean
          function Number$prototype$lte(other) {
            return typeof this === "object"
              ? lte(this.valueOf(), other.valueOf())
              : isNaN(this) || this <= other;
          }

          //  Date$prototype$equals :: Date ~> Date -> Boolean
          function Date$prototype$equals(other) {
            return equals(this.valueOf(), other.valueOf());
          }

          //  Date$prototype$lte :: Date ~> Date -> Boolean
          function Date$prototype$lte(other) {
            return lte(this.valueOf(), other.valueOf());
          }

          //  RegExp$prototype$equals :: RegExp ~> RegExp -> Boolean
          function RegExp$prototype$equals(other) {
            return (
              other.source === this.source &&
              other.global === this.global &&
              other.ignoreCase === this.ignoreCase &&
              other.multiline === this.multiline &&
              other.sticky === this.sticky &&
              other.unicode === this.unicode
            );
          }

          //  String$empty :: () -> String
          function String$empty() {
            return "";
          }

          //  String$prototype$equals :: String ~> String -> Boolean
          function String$prototype$equals(other) {
            return typeof this === "object"
              ? equals(this.valueOf(), other.valueOf())
              : this === other;
          }

          //  String$prototype$lte :: String ~> String -> Boolean
          function String$prototype$lte(other) {
            return typeof this === "object"
              ? lte(this.valueOf(), other.valueOf())
              : this <= other;
          }

          //  String$prototype$concat :: String ~> String -> String
          function String$prototype$concat(other) {
            return this + other;
          }

          //  Array$empty :: () -> Array a
          function Array$empty() {
            return [];
          }

          //  Array$of :: a -> Array a
          function Array$of(x) {
            return [x];
          }

          //  Array$chainRec :: ((a -> c, b -> c, a) -> Array c, a) -> Array b
          function Array$chainRec(f, x) {
            var result = [];
            var nil = {};
            var todo = { head: x, tail: nil };
            while (todo !== nil) {
              var more = nil;
              var steps = f(iterationNext, iterationDone, todo.head);
              for (var idx = 0; idx < steps.length; idx += 1) {
                var step = steps[idx];
                if (step.done) {
                  result.push(step.value);
                } else {
                  more = { head: step.value, tail: more };
                }
              }
              todo = todo.tail;
              while (more !== nil) {
                todo = { head: more.head, tail: todo };
                more = more.tail;
              }
            }
            return result;
          }

          //  Array$zero :: () -> Array a
          function Array$zero() {
            return [];
          }

          //  Array$prototype$equals :: Array a ~> Array a -> Boolean
          function Array$prototype$equals(other) {
            if (other.length !== this.length) return false;
            for (var idx = 0; idx < this.length; idx += 1) {
              if (!equals(this[idx], other[idx])) return false;
            }
            return true;
          }

          //  Array$prototype$lte :: Array a ~> Array a -> Boolean
          function Array$prototype$lte(other) {
            for (var idx = 0; true; idx += 1) {
              if (idx === this.length) return true;
              if (idx === other.length) return false;
              if (!equals(this[idx], other[idx]))
                return lte(this[idx], other[idx]);
            }
          }

          //  Array$prototype$concat :: Array a ~> Array a -> Array a
          function Array$prototype$concat(other) {
            return this.concat(other);
          }

          //  Array$prototype$filter :: Array a ~> (a -> Boolean) -> Array a
          function Array$prototype$filter(pred) {
            return this.filter(function(x) {
              return pred(x);
            });
          }

          //  Array$prototype$map :: Array a ~> (a -> b) -> Array b
          function Array$prototype$map(f) {
            return this.map(function(x) {
              return f(x);
            });
          }

          //  Array$prototype$ap :: Array a ~> Array (a -> b) -> Array b
          function Array$prototype$ap(fs) {
            var result = [];
            for (var idx = 0; idx < fs.length; idx += 1) {
              for (var idx2 = 0; idx2 < this.length; idx2 += 1) {
                result.push(fs[idx](this[idx2]));
              }
            }
            return result;
          }

          //  Array$prototype$chain :: Array a ~> (a -> Array b) -> Array b
          function Array$prototype$chain(f) {
            var result = [];
            for (var idx = 0; idx < this.length; idx += 1) {
              for (
                var idx2 = 0, xs = f(this[idx]);
                idx2 < xs.length;
                idx2 += 1
              ) {
                result.push(xs[idx2]);
              }
            }
            return result;
          }

          //  Array$prototype$alt :: Array a ~> Array a -> Array a
          var Array$prototype$alt = Array$prototype$concat;

          //  Array$prototype$reduce :: Array a ~> ((b, a) -> b, b) -> b
          function Array$prototype$reduce(f, initial) {
            var acc = initial;
            for (var idx = 0; idx < this.length; idx += 1)
              acc = f(acc, this[idx]);
            return acc;
          }

          //  Array$prototype$traverse :: Applicative f => Array a ~> (TypeRep f, a -> f b) -> f (Array b)
          function Array$prototype$traverse(typeRep, f) {
            var xs = this;
            function go(idx, n) {
              switch (n) {
                case 0:
                  return of(typeRep, []);
                case 2:
                  return lift2(pair, f(xs[idx]), f(xs[idx + 1]));
                default:
                  var m = Math.floor(n / 4) * 2;
                  return lift2(concat_, go(idx, m), go(idx + m, n - m));
              }
            }
            return this.length % 2 === 1
              ? lift2(
                  concat_,
                  map(Array$of, f(this[0])),
                  go(1, this.length - 1)
                )
              : go(0, this.length);
          }

          //  Array$prototype$extend :: Array a ~> (Array a -> b) -> Array b
          function Array$prototype$extend(f) {
            return this.map(function(_, idx, xs) {
              return f(xs.slice(idx));
            });
          }

          //  Arguments$prototype$equals :: Arguments ~> Arguments -> Boolean
          function Arguments$prototype$equals(other) {
            return Array$prototype$equals.call(this, other);
          }

          //  Arguments$prototype$lte :: Arguments ~> Arguments -> Boolean
          function Arguments$prototype$lte(other) {
            return Array$prototype$lte.call(this, other);
          }

          //  Error$prototype$equals :: Error ~> Error -> Boolean
          function Error$prototype$equals(other) {
            return (
              equals(this.name, other.name) &&
              equals(this.message, other.message)
            );
          }

          //  Object$empty :: () -> StrMap a
          function Object$empty() {
            return {};
          }

          //  Object$zero :: () -> StrMap a
          function Object$zero() {
            return {};
          }

          //  Object$prototype$equals :: StrMap a ~> StrMap a -> Boolean
          function Object$prototype$equals(other) {
            var self = this;
            var keys = Object.keys(this).sort();
            return (
              equals(keys, Object.keys(other).sort()) &&
              keys.every(function(k) {
                return equals(self[k], other[k]);
              })
            );
          }

          //  Object$prototype$lte :: StrMap a ~> StrMap a -> Boolean
          function Object$prototype$lte(other) {
            var theseKeys = Object.keys(this).sort();
            var otherKeys = Object.keys(other).sort();
            while (true) {
              if (theseKeys.length === 0) return true;
              if (otherKeys.length === 0) return false;
              var k = theseKeys.shift();
              var z = otherKeys.shift();
              if (k < z) return true;
              if (k > z) return false;
              if (!equals(this[k], other[k])) return lte(this[k], other[k]);
            }
          }

          //  Object$prototype$concat :: StrMap a ~> StrMap a -> StrMap a
          function Object$prototype$concat(other) {
            var result = {};
            function assign(k) {
              result[k] = this[k];
            }
            forEachKey(this, assign);
            forEachKey(other, assign);
            return result;
          }

          //  Object$prototype$filter :: StrMap a ~> (a -> Boolean) -> StrMap a
          function Object$prototype$filter(pred) {
            var result = {};
            forEachKey(this, function(k) {
              if (pred(this[k])) result[k] = this[k];
            });
            return result;
          }

          //  Object$prototype$map :: StrMap a ~> (a -> b) -> StrMap b
          function Object$prototype$map(f) {
            var result = {};
            forEachKey(this, function(k) {
              result[k] = f(this[k]);
            });
            return result;
          }

          //  Object$prototype$ap :: StrMap a ~> StrMap (a -> b) -> StrMap b
          function Object$prototype$ap(other) {
            var result = {};
            forEachKey(this, function(k) {
              if (has(k, other)) result[k] = other[k](this[k]);
            });
            return result;
          }

          //  Object$prototype$alt :: StrMap a ~> StrMap a -> StrMap a
          var Object$prototype$alt = Object$prototype$concat;

          //  Object$prototype$reduce :: StrMap a ~> ((b, a) -> b, b) -> b
          function Object$prototype$reduce(f, initial) {
            var self = this;
            function reducer(acc, k) {
              return f(acc, self[k]);
            }
            return Object.keys(this)
              .sort()
              .reduce(reducer, initial);
          }

          //  Object$prototype$traverse :: Applicative f => StrMap a ~> (TypeRep f, a -> f b) -> f (StrMap b)
          function Object$prototype$traverse(typeRep, f) {
            var self = this;
            return Object.keys(this).reduce(function(applicative, k) {
              function set(o) {
                return function(v) {
                  var singleton = {};
                  singleton[k] = v;
                  return Object$prototype$concat.call(o, singleton);
                };
              }
              return lift2(set, applicative, f(self[k]));
            }, of(typeRep, {}));
          }

          //  Function$id :: () -> a -> a
          function Function$id() {
            return identity;
          }

          //  Function$of :: b -> (a -> b)
          function Function$of(x) {
            return function(_) {
              return x;
            };
          }

          //  Function$chainRec :: ((a -> c, b -> c, a) -> (z -> c), a) -> (z -> b)
          function Function$chainRec(f, x) {
            return function(a) {
              var step = iterationNext(x);
              while (!step.done) {
                step = f(iterationNext, iterationDone, step.value)(a);
              }
              return step.value;
            };
          }

          //  Function$prototype$equals :: Function ~> Function -> Boolean
          function Function$prototype$equals(other) {
            return other === this;
          }

          //  Function$prototype$compose :: (a -> b) ~> (b -> c) -> (a -> c)
          function Function$prototype$compose(other) {
            var semigroupoid = this;
            return function(x) {
              return other(semigroupoid(x));
            };
          }

          //  Function$prototype$map :: (a -> b) ~> (b -> c) -> (a -> c)
          function Function$prototype$map(f) {
            var functor = this;
            return function(x) {
              return f(functor(x));
            };
          }

          //  Function$prototype$promap :: (b -> c) ~> (a -> b, c -> d) -> (a -> d)
          function Function$prototype$promap(f, g) {
            var profunctor = this;
            return function(x) {
              return g(profunctor(f(x)));
            };
          }

          //  Function$prototype$ap :: (a -> b) ~> (a -> b -> c) -> (a -> c)
          function Function$prototype$ap(f) {
            var apply = this;
            return function(x) {
              return f(x)(apply(x));
            };
          }

          //  Function$prototype$chain :: (a -> b) ~> (b -> a -> c) -> (a -> c)
          function Function$prototype$chain(f) {
            var chain = this;
            return function(x) {
              return f(chain(x))(x);
            };
          }

          //  Function$prototype$extend :: Semigroup a => (a -> b) ~> ((a -> b) -> c) -> (a -> c)
          function Function$prototype$extend(f) {
            var extend = this;
            return function(x) {
              return f(function(y) {
                return extend(concat(x, y));
              });
            };
          }

          //  Function$prototype$contramap :: (b -> c) ~> (a -> b) -> (a -> c)
          function Function$prototype$contramap(f) {
            var contravariant = this;
            return function(x) {
              return contravariant(f(x));
            };
          }

          /* eslint-disable key-spacing */
          var implementations = {
            Null: {
              prototype: {
                "fantasy-land/equals": Null$prototype$equals,
                "fantasy-land/lte": Null$prototype$lte,
              },
            },
            Undefined: {
              prototype: {
                "fantasy-land/equals": Undefined$prototype$equals,
                "fantasy-land/lte": Undefined$prototype$lte,
              },
            },
            Boolean: {
              prototype: {
                "fantasy-land/equals": Boolean$prototype$equals,
                "fantasy-land/lte": Boolean$prototype$lte,
              },
            },
            Number: {
              prototype: {
                "fantasy-land/equals": Number$prototype$equals,
                "fantasy-land/lte": Number$prototype$lte,
              },
            },
            Date: {
              prototype: {
                "fantasy-land/equals": Date$prototype$equals,
                "fantasy-land/lte": Date$prototype$lte,
              },
            },
            RegExp: {
              prototype: {
                "fantasy-land/equals": RegExp$prototype$equals,
              },
            },
            String: {
              "fantasy-land/empty": String$empty,
              prototype: {
                "fantasy-land/equals": String$prototype$equals,
                "fantasy-land/lte": String$prototype$lte,
                "fantasy-land/concat": String$prototype$concat,
              },
            },
            Array: {
              "fantasy-land/empty": Array$empty,
              "fantasy-land/of": Array$of,
              "fantasy-land/chainRec": Array$chainRec,
              "fantasy-land/zero": Array$zero,
              prototype: {
                "fantasy-land/equals": Array$prototype$equals,
                "fantasy-land/lte": Array$prototype$lte,
                "fantasy-land/concat": Array$prototype$concat,
                "fantasy-land/filter": Array$prototype$filter,
                "fantasy-land/map": Array$prototype$map,
                "fantasy-land/ap": Array$prototype$ap,
                "fantasy-land/chain": Array$prototype$chain,
                "fantasy-land/alt": Array$prototype$alt,
                "fantasy-land/reduce": Array$prototype$reduce,
                "fantasy-land/traverse": Array$prototype$traverse,
                "fantasy-land/extend": Array$prototype$extend,
              },
            },
            Arguments: {
              prototype: {
                "fantasy-land/equals": Arguments$prototype$equals,
                "fantasy-land/lte": Arguments$prototype$lte,
              },
            },
            Error: {
              prototype: {
                "fantasy-land/equals": Error$prototype$equals,
              },
            },
            Object: {
              "fantasy-land/empty": Object$empty,
              "fantasy-land/zero": Object$zero,
              prototype: {
                "fantasy-land/equals": Object$prototype$equals,
                "fantasy-land/lte": Object$prototype$lte,
                "fantasy-land/concat": Object$prototype$concat,
                "fantasy-land/filter": Object$prototype$filter,
                "fantasy-land/map": Object$prototype$map,
                "fantasy-land/ap": Object$prototype$ap,
                "fantasy-land/alt": Object$prototype$alt,
                "fantasy-land/reduce": Object$prototype$reduce,
                "fantasy-land/traverse": Object$prototype$traverse,
              },
            },
            Function: {
              "fantasy-land/id": Function$id,
              "fantasy-land/of": Function$of,
              "fantasy-land/chainRec": Function$chainRec,
              prototype: {
                "fantasy-land/equals": Function$prototype$equals,
                "fantasy-land/compose": Function$prototype$compose,
                "fantasy-land/map": Function$prototype$map,
                "fantasy-land/promap": Function$prototype$promap,
                "fantasy-land/ap": Function$prototype$ap,
                "fantasy-land/chain": Function$prototype$chain,
                "fantasy-land/extend": Function$prototype$extend,
                "fantasy-land/contramap": Function$prototype$contramap,
              },
            },
          };
          /* eslint-enable key-spacing */

          //# equals :: (a, b) -> Boolean
          //.
          //. Returns `true` if its arguments are of the same type and equal according
          //. to the type's [`fantasy-land/equals`][] method; `false` otherwise.
          //.
          //. `fantasy-land/equals` implementations are provided for the following
          //. built-in types: Null, Undefined, Boolean, Number, Date, RegExp, String,
          //. Array, Arguments, Error, Object, and Function.
          //.
          //. The algorithm supports circular data structures. Two arrays are equal
          //. if they have the same index paths and for each path have equal values.
          //. Two arrays which represent `[1, [1, [1, [1, [1, ...]]]]]`, for example,
          //. are equal even if their internal structures differ. Two objects are equal
          //. if they have the same property paths and for each path have equal values.
          //.
          //. ```javascript
          //. > equals(0, -0)
          //. true
          //.
          //. > equals(NaN, NaN)
          //. true
          //.
          //. > equals(Cons('foo', Cons('bar', Nil)), Cons('foo', Cons('bar', Nil)))
          //. true
          //.
          //. > equals(Cons('foo', Cons('bar', Nil)), Cons('bar', Cons('foo', Nil)))
          //. false
          //. ```
          var equals = (function() {
            //  $pairs :: Array (Array2 Any Any)
            var $pairs = [];

            return function equals(x, y) {
              if (!sameType(x, y)) return false;

              //  This algorithm for comparing circular data structures was
              //  suggested in <http://stackoverflow.com/a/40622794/312785>.
              if (
                $pairs.some(function(p) {
                  return p[0] === x && p[1] === y;
                })
              ) {
                return true;
              }

              $pairs.push([x, y]);
              try {
                return (
                  Setoid.test(x) &&
                  Setoid.test(y) &&
                  Setoid.methods.equals(x)(y)
                );
              } finally {
                $pairs.pop();
              }
            };
          })();

          //# lt :: (a, b) -> Boolean
          //.
          //. Returns `true` if its arguments are of the same type and the first is
          //. less than the second according to the type's [`fantasy-land/lte`][]
          //. method; `false` otherwise.
          //.
          //. This function is derived from [`lte`](#lte).
          //.
          //. See also [`gt`](#gt) and [`gte`](#gte).
          //.
          //. ```javascript
          //. > lt(0, 0)
          //. false
          //.
          //. > lt(0, 1)
          //. true
          //.
          //. > lt(1, 0)
          //. false
          //. ```
          function lt(x, y) {
            return sameType(x, y) && !lte(y, x);
          }

          //# lte :: (a, b) -> Boolean
          //.
          //. Returns `true` if its arguments are of the same type and the first
          //. is less than or equal to the second according to the type's
          //. [`fantasy-land/lte`][] method; `false` otherwise.
          //.
          //. `fantasy-land/lte` implementations are provided for the following
          //. built-in types: Null, Undefined, Boolean, Number, Date, String, Array,
          //. Arguments, and Object.
          //.
          //. The algorithm supports circular data structures in the same manner as
          //. [`equals`](#equals).
          //.
          //. See also [`lt`](#lt), [`gt`](#gt), and [`gte`](#gte).
          //.
          //. ```javascript
          //. > lte(0, 0)
          //. true
          //.
          //. > lte(0, 1)
          //. true
          //.
          //. > lte(1, 0)
          //. false
          //. ```
          var lte = (function() {
            //  $pairs :: Array (Array2 Any Any)
            var $pairs = [];

            return function lte(x, y) {
              if (!sameType(x, y)) return false;

              //  This algorithm for comparing circular data structures was
              //  suggested in <http://stackoverflow.com/a/40622794/312785>.
              if (
                $pairs.some(function(p) {
                  return p[0] === x && p[1] === y;
                })
              ) {
                return equals(x, y);
              }

              $pairs.push([x, y]);
              try {
                return Ord.test(x) && Ord.test(y) && Ord.methods.lte(x)(y);
              } finally {
                $pairs.pop();
              }
            };
          })();

          //# gt :: (a, b) -> Boolean
          //.
          //. Returns `true` if its arguments are of the same type and the first is
          //. greater than the second according to the type's [`fantasy-land/lte`][]
          //. method; `false` otherwise.
          //.
          //. This function is derived from [`lte`](#lte).
          //.
          //. See also [`lt`](#lt) and [`gte`](#gte).
          //.
          //. ```javascript
          //. > gt(0, 0)
          //. false
          //.
          //. > gt(0, 1)
          //. false
          //.
          //. > gt(1, 0)
          //. true
          //. ```
          function gt(x, y) {
            return lt(y, x);
          }

          //# gte :: (a, b) -> Boolean
          //.
          //. Returns `true` if its arguments are of the same type and the first
          //. is greater than or equal to the second according to the type's
          //. [`fantasy-land/lte`][] method; `false` otherwise.
          //.
          //. This function is derived from [`lte`](#lte).
          //.
          //. See also [`lt`](#lt) and [`gt`](#gt).
          //.
          //. ```javascript
          //. > gte(0, 0)
          //. true
          //.
          //. > gte(0, 1)
          //. false
          //.
          //. > gte(1, 0)
          //. true
          //. ```
          function gte(x, y) {
            return lte(y, x);
          }

          //# min :: Ord a => (a, a) -> a
          //.
          //. Returns the smaller of its two arguments.
          //.
          //. This function is derived from [`lte`](#lte).
          //.
          //. See also [`max`](#max).
          //.
          //. ```javascript
          //. > min(10, 2)
          //. 2
          //.
          //. > min(new Date('1999-12-31'), new Date('2000-01-01'))
          //. new Date('1999-12-31')
          //.
          //. > min('10', '2')
          //. '10'
          //. ```
          function min(x, y) {
            return lte(x, y) ? x : y;
          }

          //# max :: Ord a => (a, a) -> a
          //.
          //. Returns the larger of its two arguments.
          //.
          //. This function is derived from [`lte`](#lte).
          //.
          //. See also [`min`](#min).
          //.
          //. ```javascript
          //. > max(10, 2)
          //. 10
          //.
          //. > max(new Date('1999-12-31'), new Date('2000-01-01'))
          //. new Date('2000-01-01')
          //.
          //. > max('10', '2')
          //. '2'
          //. ```
          function max(x, y) {
            return lte(x, y) ? y : x;
          }

          //# compose :: Semigroupoid c => (c j k, c i j) -> c i k
          //.
          //. Function wrapper for [`fantasy-land/compose`][].
          //.
          //. `fantasy-land/compose` implementations are provided for the following
          //. built-in types: Function.
          //.
          //. ```javascript
          //. > compose(Math.sqrt, x => x + 1)(99)
          //. 10
          //. ```
          function compose(x, y) {
            return Semigroupoid.methods.compose(y)(x);
          }

          //# id :: Category c => TypeRep c -> c
          //.
          //. Function wrapper for [`fantasy-land/id`][].
          //.
          //. `fantasy-land/id` implementations are provided for the following
          //. built-in types: Function.
          //.
          //. ```javascript
          //. > id(Function)('foo')
          //. 'foo'
          //. ```
          function id(typeRep) {
            return Category.methods.id(typeRep)();
          }

          //# concat :: Semigroup a => (a, a) -> a
          //.
          //. Function wrapper for [`fantasy-land/concat`][].
          //.
          //. `fantasy-land/concat` implementations are provided for the following
          //. built-in types: String, Array, and Object.
          //.
          //. ```javascript
          //. > concat('abc', 'def')
          //. 'abcdef'
          //.
          //. > concat([1, 2, 3], [4, 5, 6])
          //. [1, 2, 3, 4, 5, 6]
          //.
          //. > concat({x: 1, y: 2}, {y: 3, z: 4})
          //. {x: 1, y: 3, z: 4}
          //.
          //. > concat(Cons('foo', Cons('bar', Cons('baz', Nil))), Cons('quux', Nil))
          //. Cons('foo', Cons('bar', Cons('baz', Cons('quux', Nil))))
          //. ```
          function concat(x, y) {
            return Semigroup.methods.concat(x)(y);
          }

          //# empty :: Monoid m => TypeRep m -> m
          //.
          //. Function wrapper for [`fantasy-land/empty`][].
          //.
          //. `fantasy-land/empty` implementations are provided for the following
          //. built-in types: String, Array, and Object.
          //.
          //. ```javascript
          //. > empty(String)
          //. ''
          //.
          //. > empty(Array)
          //. []
          //.
          //. > empty(Object)
          //. {}
          //.
          //. > empty(List)
          //. Nil
          //. ```
          function empty(typeRep) {
            return Monoid.methods.empty(typeRep)();
          }

          //# invert :: Group g => g -> g
          //.
          //. Function wrapper for [`fantasy-land/invert`][].
          //.
          //. ```javascript
          //. > invert(Sum(5))
          //. Sum(-5)
          //. ```
          function invert(group) {
            return Group.methods.invert(group)();
          }

          //# filter :: Filterable f => (a -> Boolean, f a) -> f a
          //.
          //. Function wrapper for [`fantasy-land/filter`][]. Discards every element
          //. which does not satisfy the predicate.
          //.
          //. `fantasy-land/filter` implementations are provided for the following
          //. built-in types: Array and Object.
          //.
          //. See also [`reject`](#reject).
          //.
          //. ```javascript
          //. > filter(x => x % 2 == 1, [1, 2, 3])
          //. [1, 3]
          //.
          //. > filter(x => x % 2 == 1, {x: 1, y: 2, z: 3})
          //. {x: 1, z: 3}
          //.
          //. > filter(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))
          //. Cons(1, Cons(3, Nil))
          //.
          //. > filter(x => x % 2 == 1, Nothing)
          //. Nothing
          //.
          //. > filter(x => x % 2 == 1, Just(0))
          //. Nothing
          //.
          //. > filter(x => x % 2 == 1, Just(1))
          //. Just(1)
          //. ```
          function filter(pred, filterable) {
            return Filterable.methods.filter(filterable)(pred);
          }

          //# reject :: Filterable f => (a -> Boolean, f a) -> f a
          //.
          //. Discards every element which satisfies the predicate.
          //.
          //. This function is derived from [`filter`](#filter).
          //.
          //. ```javascript
          //. > reject(x => x % 2 == 1, [1, 2, 3])
          //. [2]
          //.
          //. > reject(x => x % 2 == 1, {x: 1, y: 2, z: 3})
          //. {y: 2}
          //.
          //. > reject(x => x % 2 == 1, Cons(1, Cons(2, Cons(3, Nil))))
          //. Cons(2, Nil)
          //.
          //. > reject(x => x % 2 == 1, Nothing)
          //. Nothing
          //.
          //. > reject(x => x % 2 == 1, Just(0))
          //. Just(0)
          //.
          //. > reject(x => x % 2 == 1, Just(1))
          //. Nothing
          //. ```
          function reject(pred, filterable) {
            return filter(function(x) {
              return !pred(x);
            }, filterable);
          }

          //# takeWhile :: Filterable f => (a -> Boolean, f a) -> f a
          //.
          //. Discards the first element which does not satisfy the predicate, and all
          //. subsequent elements.
          //.
          //. This function is derived from [`filter`](#filter).
          //.
          //. See also [`dropWhile`](#dropWhile).
          //.
          //. ```javascript
          //. > takeWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
          //. ['xy', 'xz', 'yx']
          //.
          //. > takeWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
          //. ['xy']
          //.
          //. > takeWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
          //. []
          //. ```
          function takeWhile(pred, filterable) {
            var take = true;
            return filter(function(x) {
              return (take = take && pred(x));
            }, filterable);
          }

          //# dropWhile :: Filterable f => (a -> Boolean, f a) -> f a
          //.
          //. Retains the first element which does not satisfy the predicate, and all
          //. subsequent elements.
          //.
          //. This function is derived from [`filter`](#filter).
          //.
          //. See also [`takeWhile`](#takeWhile).
          //.
          //. ```javascript
          //. > dropWhile(s => /x/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
          //. ['yz', 'zx', 'zy']
          //.
          //. > dropWhile(s => /y/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
          //. ['xz', 'yx', 'yz', 'zx', 'zy']
          //.
          //. > dropWhile(s => /z/.test(s), ['xy', 'xz', 'yx', 'yz', 'zx', 'zy'])
          //. ['xy', 'xz', 'yx', 'yz', 'zx', 'zy']
          //. ```
          function dropWhile(pred, filterable) {
            var take = false;
            return filter(function(x) {
              return (take = take || !pred(x));
            }, filterable);
          }

          //# map :: Functor f => (a -> b, f a) -> f b
          //.
          //. Function wrapper for [`fantasy-land/map`][].
          //.
          //. `fantasy-land/map` implementations are provided for the following
          //. built-in types: Array, Object, and Function.
          //.
          //. ```javascript
          //. > map(Math.sqrt, [1, 4, 9])
          //. [1, 2, 3]
          //.
          //. > map(Math.sqrt, {x: 1, y: 4, z: 9})
          //. {x: 1, y: 2, z: 3}
          //.
          //. > map(Math.sqrt, s => s.length)('Sanctuary')
          //. 3
          //.
          //. > map(Math.sqrt, Tuple('foo', 64))
          //. Tuple('foo', 8)
          //.
          //. > map(Math.sqrt, Nil)
          //. Nil
          //.
          //. > map(Math.sqrt, Cons(1, Cons(4, Cons(9, Nil))))
          //. Cons(1, Cons(2, Cons(3, Nil)))
          //. ```
          function map(f, functor) {
            return Functor.methods.map(functor)(f);
          }

          //# flip :: Functor f => (f (a -> b), a) -> f b
          //.
          //. Maps over the given functions, applying each to the given value.
          //.
          //. This function is derived from [`map`](#map).
          //.
          //. ```javascript
          //. > flip(x => y => x + y, '!')('foo')
          //. 'foo!'
          //.
          //. > flip([Math.floor, Math.ceil], 1.5)
          //. [1, 2]
          //.
          //. > flip({floor: Math.floor, ceil: Math.ceil}, 1.5)
          //. {floor: 1, ceil: 2}
          //.
          //. > flip(Cons(Math.floor, Cons(Math.ceil, Nil)), 1.5)
          //. Cons(1, Cons(2, Nil))
          //. ```
          function flip(functor, x) {
            return Functor.methods.map(functor)(thrush(x));
          }

          //# bimap :: Bifunctor f => (a -> b, c -> d, f a c) -> f b d
          //.
          //. Function wrapper for [`fantasy-land/bimap`][].
          //.
          //. ```javascript
          //. > bimap(s => s.toUpperCase(), Math.sqrt, Tuple('foo', 64))
          //. Tuple('FOO', 8)
          //. ```
          function bimap(f, g, bifunctor) {
            return Bifunctor.methods.bimap(bifunctor)(f, g);
          }

          //# mapLeft :: Bifunctor f => (a -> b, f a c) -> f b c
          //.
          //. Maps the given function over the left side of a Bifunctor.
          //.
          //. ```javascript
          //. > mapLeft(Math.sqrt, Tuple(64, 9))
          //. Tuple(8, 9)
          //. ```
          function mapLeft(f, bifunctor) {
            return bimap(f, identity, bifunctor);
          }

          //# promap :: Profunctor p => (a -> b, c -> d, p b c) -> p a d
          //.
          //. Function wrapper for [`fantasy-land/promap`][].
          //.
          //. `fantasy-land/promap` implementations are provided for the following
          //. built-in types: Function.
          //.
          //. ```javascript
          //. > promap(Math.abs, x => x + 1, Math.sqrt)(-100)
          //. 11
          //. ```
          function promap(f, g, profunctor) {
            return Profunctor.methods.promap(profunctor)(f, g);
          }

          //# ap :: Apply f => (f (a -> b), f a) -> f b
          //.
          //. Function wrapper for [`fantasy-land/ap`][].
          //.
          //. `fantasy-land/ap` implementations are provided for the following
          //. built-in types: Array, Object, and Function.
          //.
          //. ```javascript
          //. > ap([Math.sqrt, x => x * x], [1, 4, 9, 16, 25])
          //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]
          //.
          //. > ap({a: Math.sqrt, b: x => x * x}, {a: 16, b: 10, c: 1})
          //. {a: 4, b: 100}
          //.
          //. > ap(s => n => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')
          //. 'Hask'
          //.
          //. > ap(Identity(Math.sqrt), Identity(64))
          //. Identity(8)
          //.
          //. > ap(Cons(Math.sqrt, Cons(x => x * x, Nil)), Cons(16, Cons(100, Nil)))
          //. Cons(4, Cons(10, Cons(256, Cons(10000, Nil))))
          //. ```
          function ap(applyF, applyX) {
            return Apply.methods.ap(applyX)(applyF);
          }

          //# lift2 :: Apply f => (a -> b -> c, f a, f b) -> f c
          //.
          //. Lifts `a -> b -> c` to `Apply f => f a -> f b -> f c` and returns the
          //. result of applying this to the given arguments.
          //.
          //. This function is derived from [`map`](#map) and [`ap`](#ap).
          //.
          //. See also [`lift3`](#lift3).
          //.
          //. ```javascript
          //. > lift2(x => y => Math.pow(x, y), [10], [1, 2, 3])
          //. [10, 100, 1000]
          //.
          //. > lift2(x => y => Math.pow(x, y), Identity(10), Identity(3))
          //. Identity(1000)
          //. ```
          function lift2(f, x, y) {
            return ap(map(f, x), y);
          }

          //# lift3 :: Apply f => (a -> b -> c -> d, f a, f b, f c) -> f d
          //.
          //. Lifts `a -> b -> c -> d` to `Apply f => f a -> f b -> f c -> f d` and
          //. returns the result of applying this to the given arguments.
          //.
          //. This function is derived from [`map`](#map) and [`ap`](#ap).
          //.
          //. See also [`lift2`](#lift2).
          //.
          //. ```javascript
          //. > lift3(x => y => z => x + z + y, ['<'], ['>'], ['foo', 'bar', 'baz'])
          //. ['<foo>', '<bar>', '<baz>']
          //.
          //. > lift3(x => y => z => x + z + y, Identity('<'), Identity('>'), Identity('baz'))
          //. Identity('<baz>')
          //. ```
          function lift3(f, x, y, z) {
            return ap(ap(map(f, x), y), z);
          }

          //# apFirst :: Apply f => (f a, f b) -> f a
          //.
          //. Combines two effectful actions, keeping only the result of the first.
          //. Equivalent to Haskell's `(<*)` function.
          //.
          //. This function is derived from [`lift2`](#lift2).
          //.
          //. See also [`apSecond`](#apSecond).
          //.
          //. ```javascript
          //. > apFirst([1, 2], [3, 4])
          //. [1, 1, 2, 2]
          //.
          //. > apFirst(Identity(1), Identity(2))
          //. Identity(1)
          //. ```
          function apFirst(x, y) {
            return lift2(constant, x, y);
          }

          //# apSecond :: Apply f => (f a, f b) -> f b
          //.
          //. Combines two effectful actions, keeping only the result of the second.
          //. Equivalent to Haskell's `(*>)` function.
          //.
          //. This function is derived from [`lift2`](#lift2).
          //.
          //. See also [`apFirst`](#apFirst).
          //.
          //. ```javascript
          //. > apSecond([1, 2], [3, 4])
          //. [3, 4, 3, 4]
          //.
          //. > apSecond(Identity(1), Identity(2))
          //. Identity(2)
          //. ```
          function apSecond(x, y) {
            return lift2(constant(identity), x, y);
          }

          //# of :: Applicative f => (TypeRep f, a) -> f a
          //.
          //. Function wrapper for [`fantasy-land/of`][].
          //.
          //. `fantasy-land/of` implementations are provided for the following
          //. built-in types: Array and Function.
          //.
          //. ```javascript
          //. > of(Array, 42)
          //. [42]
          //.
          //. > of(Function, 42)(null)
          //. 42
          //.
          //. > of(List, 42)
          //. Cons(42, Nil)
          //. ```
          function of(typeRep, x) {
            return Applicative.methods.of(typeRep)(x);
          }

          //# append :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a
          //.
          //. Returns the result of appending the first argument to the second.
          //.
          //. This function is derived from [`concat`](#concat) and [`of`](#of).
          //.
          //. See also [`prepend`](#prepend).
          //.
          //. ```javascript
          //. > append(3, [1, 2])
          //. [1, 2, 3]
          //.
          //. > append(3, Cons(1, Cons(2, Nil)))
          //. Cons(1, Cons(2, Cons(3, Nil)))
          //. ```
          function append(x, xs) {
            return concat(xs, of(xs.constructor, x));
          }

          //# prepend :: (Applicative f, Semigroup (f a)) => (a, f a) -> f a
          //.
          //. Returns the result of prepending the first argument to the second.
          //.
          //. This function is derived from [`concat`](#concat) and [`of`](#of).
          //.
          //. See also [`append`](#append).
          //.
          //. ```javascript
          //. > prepend(1, [2, 3])
          //. [1, 2, 3]
          //.
          //. > prepend(1, Cons(2, Cons(3, Nil)))
          //. Cons(1, Cons(2, Cons(3, Nil)))
          //. ```
          function prepend(x, xs) {
            return concat(of(xs.constructor, x), xs);
          }

          //# chain :: Chain m => (a -> m b, m a) -> m b
          //.
          //. Function wrapper for [`fantasy-land/chain`][].
          //.
          //. `fantasy-land/chain` implementations are provided for the following
          //. built-in types: Array and Function.
          //.
          //. ```javascript
          //. > chain(x => [x, x], [1, 2, 3])
          //. [1, 1, 2, 2, 3, 3]
          //.
          //. > chain(x => x % 2 == 1 ? of(List, x) : Nil, Cons(1, Cons(2, Cons(3, Nil))))
          //. Cons(1, Cons(3, Nil))
          //.
          //. > chain(n => s => s.slice(0, n), s => Math.ceil(s.length / 2))('Haskell')
          //. 'Hask'
          //. ```
          function chain(f, chain_) {
            return Chain.methods.chain(chain_)(f);
          }

          //# join :: Chain m => m (m a) -> m a
          //.
          //. Removes one level of nesting from a nested monadic structure.
          //.
          //. This function is derived from [`chain`](#chain).
          //.
          //. ```javascript
          //. > join([[1], [2], [3]])
          //. [1, 2, 3]
          //.
          //. > join([[[1, 2, 3]]])
          //. [[1, 2, 3]]
          //.
          //. > join(Identity(Identity(1)))
          //. Identity(1)
          //. ```
          function join(chain_) {
            return chain(identity, chain_);
          }

          //# chainRec :: ChainRec m => (TypeRep m, (a -> c, b -> c, a) -> m c, a) -> m b
          //.
          //. Function wrapper for [`fantasy-land/chainRec`][].
          //.
          //. `fantasy-land/chainRec` implementations are provided for the following
          //. built-in types: Array.
          //.
          //. ```javascript
          //. > chainRec(
          //. .   Array,
          //. .   (next, done, s) => s.length == 2 ? [s + '!', s + '?'].map(done)
          //. .                                    : [s + 'o', s + 'n'].map(next),
          //. .   ''
          //. . )
          //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']
          //. ```
          function chainRec(typeRep, f, x) {
            return ChainRec.methods.chainRec(typeRep)(f, x);
          }

          //# alt :: Alt f => (f a, f a) -> f a
          //.
          //. Function wrapper for [`fantasy-land/alt`][].
          //.
          //. `fantasy-land/alt` implementations are provided for the following
          //. built-in types: Array and Object.
          //.
          //. ```javascript
          //. > alt([1, 2, 3], [4, 5, 6])
          //. [1, 2, 3, 4, 5, 6]
          //.
          //. > alt(Nothing, Nothing)
          //. Nothing
          //.
          //. > alt(Nothing, Just(1))
          //. Just(1)
          //.
          //. > alt(Just(2), Just(3))
          //. Just(2)
          //. ```
          function alt(x, y) {
            return Alt.methods.alt(x)(y);
          }

          //# zero :: Plus f => TypeRep f -> f a
          //.
          //. Function wrapper for [`fantasy-land/zero`][].
          //.
          //. `fantasy-land/zero` implementations are provided for the following
          //. built-in types: Array and Object.
          //.
          //. ```javascript
          //. > zero(Array)
          //. []
          //.
          //. > zero(Object)
          //. {}
          //.
          //. > zero(Maybe)
          //. Nothing
          //. ```
          function zero(typeRep) {
            return Plus.methods.zero(typeRep)();
          }

          //# reduce :: Foldable f => ((b, a) -> b, b, f a) -> b
          //.
          //. Function wrapper for [`fantasy-land/reduce`][].
          //.
          //. `fantasy-land/reduce` implementations are provided for the following
          //. built-in types: Array and Object.
          //.
          //. ```javascript
          //. > reduce((xs, x) => [x].concat(xs), [], [1, 2, 3])
          //. [3, 2, 1]
          //.
          //. > reduce(concat, '', Cons('foo', Cons('bar', Cons('baz', Nil))))
          //. 'foobarbaz'
          //. ```
          function reduce(f, x, foldable) {
            return Foldable.methods.reduce(foldable)(f, x);
          }

          //# size :: Foldable f => f a -> Integer
          //.
          //. Returns the number of elements of the given structure.
          //.
          //. This function is derived from [`reduce`](#reduce).
          //.
          //. ```javascript
          //. > size([])
          //. 0
          //.
          //. > size(['foo', 'bar', 'baz'])
          //. 3
          //.
          //. > size(Nil)
          //. 0
          //.
          //. > size(Cons('foo', Cons('bar', Cons('baz', Nil))))
          //. 3
          //. ```
          function size(foldable) {
            //  Fast path for arrays.
            if (Array.isArray(foldable)) return foldable.length;
            return reduce(
              function(n, _) {
                return n + 1;
              },
              0,
              foldable
            );
          }

          //# elem :: (Setoid a, Foldable f) => (a, f a) -> Boolean
          //.
          //. Takes a value and a structure and returns `true` if the
          //. value is an element of the structure; `false` otherwise.
          //.
          //. This function is derived from [`equals`](#equals) and
          //. [`reduce`](#reduce).
          //.
          //. ```javascript
          //. > elem('c', ['a', 'b', 'c'])
          //. true
          //.
          //. > elem('x', ['a', 'b', 'c'])
          //. false
          //.
          //. > elem(3, {x: 1, y: 2, z: 3})
          //. true
          //.
          //. > elem(8, {x: 1, y: 2, z: 3})
          //. false
          //.
          //. > elem(0, Just(0))
          //. true
          //.
          //. > elem(0, Just(1))
          //. false
          //.
          //. > elem(0, Nothing)
          //. false
          //. ```
          function elem(x, foldable) {
            return reduce(
              function(b, y) {
                return b || equals(x, y);
              },
              false,
              foldable
            );
          }

          //# foldMap :: (Monoid m, Foldable f) => (TypeRep m, a -> m, f a) -> m
          //.
          //. Deconstructs a foldable by mapping every element to a monoid and
          //. concatenating the results.
          //.
          //. This function is derived from [`concat`](#concat), [`empty`](#empty),
          //. and [`reduce`](#reduce).
          //.
          //. ```javascript
          //. > foldMap(String, f => f.name, [Math.sin, Math.cos, Math.tan])
          //. 'sincostan'
          //. ```
          function foldMap(typeRep, f, foldable) {
            return reduce(
              function(monoid, x) {
                return concat(monoid, f(x));
              },
              empty(typeRep),
              foldable
            );
          }

          //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a
          //.
          //. Reverses the elements of the given structure.
          //.
          //. This function is derived from [`concat`](#concat), [`empty`](#empty),
          //. [`of`](#of), and [`reduce`](#reduce).
          //.
          //. ```javascript
          //. > reverse([1, 2, 3])
          //. [3, 2, 1]
          //.
          //. > reverse(Cons(1, Cons(2, Cons(3, Nil))))
          //. Cons(3, Cons(2, Cons(1, Nil)))
          //. ```
          function reverse(foldable) {
            //  Fast path for arrays.
            if (Array.isArray(foldable)) return foldable.slice().reverse();
            var F = foldable.constructor;
            return reduce(
              function(xs, x) {
                return concat(of(F, x), xs);
              },
              empty(F),
              foldable
            );
          }

          //# sort :: (Ord a, Applicative f, Foldable f, Monoid (f a)) => f a -> f a
          //.
          //. Performs a [stable sort][] of the elements of the given structure,
          //. using [`lte`](#lte) for comparisons.
          //.
          //. This function is derived from [`lte`](#lte), [`concat`](#concat),
          //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).
          //.
          //. See also [`sortBy`](#sortBy).
          //.
          //. ```javascript
          //. > sort(['foo', 'bar', 'baz'])
          //. ['bar', 'baz', 'foo']
          //.
          //. > sort([Just(2), Nothing, Just(1)])
          //. [Nothing, Just(1), Just(2)]
          //.
          //. > sort(Cons('foo', Cons('bar', Cons('baz', Nil))))
          //. Cons('bar', Cons('baz', Cons('foo', Nil)))
          //. ```
          function sort(foldable) {
            return sortBy(identity, foldable);
          }

          //# sortBy :: (Ord b, Applicative f, Foldable f, Monoid (f a)) => (a -> b, f a) -> f a
          //.
          //. Performs a [stable sort][] of the elements of the given structure,
          //. using [`lte`](#lte) to compare the values produced by applying the
          //. given function to each element of the structure.
          //.
          //. This function is derived from [`lte`](#lte), [`concat`](#concat),
          //. [`empty`](#empty), [`of`](#of), and [`reduce`](#reduce).
          //.
          //. See also [`sort`](#sort).
          //.
          //. ```javascript
          //. > sortBy(s => s.length, ['red', 'green', 'blue'])
          //. ['red', 'blue', 'green']
          //.
          //. > sortBy(s => s.length, ['black', 'white'])
          //. ['black', 'white']
          //.
          //. > sortBy(s => s.length, ['white', 'black'])
          //. ['white', 'black']
          //.
          //. > sortBy(s => s.length, Cons('red', Cons('green', Cons('blue', Nil))))
          //. Cons('red', Cons('blue', Cons('green', Nil)))
          //. ```
          function sortBy(f, foldable) {
            var rs = reduce(
              function(rs, x) {
                rs.push({ idx: rs.length, x: x, fx: f(x) });
                return rs;
              },
              [],
              foldable
            );

            var lte_ = (function(r) {
              switch (typeof (r && r.fx)) {
                case "number":
                  return function(x, y) {
                    return x <= y || x !== x;
                  };
                case "string":
                  return function(x, y) {
                    return x <= y;
                  };
                default:
                  return lte;
              }
            })(rs[0]);

            rs.sort(function(a, b) {
              return lte_(a.fx, b.fx)
                ? lte_(b.fx, a.fx)
                  ? a.idx - b.idx
                  : -1
                : 1;
            });

            if (Array.isArray(foldable)) {
              for (var idx = 0; idx < rs.length; idx += 1) rs[idx] = rs[idx].x;
              return rs;
            }

            var F = foldable.constructor;
            var result = empty(F);
            for (idx = 0; idx < rs.length; idx += 1) {
              result = concat(result, of(F, rs[idx].x));
            }
            return result;
          }

          //# traverse :: (Applicative f, Traversable t) => (TypeRep f, a -> f b, t a) -> f (t b)
          //.
          //. Function wrapper for [`fantasy-land/traverse`][].
          //.
          //. `fantasy-land/traverse` implementations are provided for the following
          //. built-in types: Array and Object.
          //.
          //. See also [`sequence`](#sequence).
          //.
          //. ```javascript
          //. > traverse(Array, x => x, [[1, 2, 3], [4, 5]])
          //. [[1, 4], [1, 5], [2, 4], [2, 5], [3, 4], [3, 5]]
          //.
          //. > traverse(Identity, x => Identity(x + 1), [1, 2, 3])
          //. Identity([2, 3, 4])
          //. ```
          function traverse(typeRep, f, traversable) {
            return Traversable.methods.traverse(traversable)(typeRep, f);
          }

          //# sequence :: (Applicative f, Traversable t) => (TypeRep f, t (f a)) -> f (t a)
          //.
          //. Inverts the given `t (f a)` to produce an `f (t a)`.
          //.
          //. This function is derived from [`traverse`](#traverse).
          //.
          //. ```javascript
          //. > sequence(Array, Identity([1, 2, 3]))
          //. [Identity(1), Identity(2), Identity(3)]
          //.
          //. > sequence(Identity, [Identity(1), Identity(2), Identity(3)])
          //. Identity([1, 2, 3])
          //. ```
          function sequence(typeRep, traversable) {
            return traverse(typeRep, identity, traversable);
          }

          //# extend :: Extend w => (w a -> b, w a) -> w b
          //.
          //. Function wrapper for [`fantasy-land/extend`][].
          //.
          //. `fantasy-land/extend` implementations are provided for the following
          //. built-in types: Array and Function.
          //.
          //. ```javascript
          //. > extend(ss => ss.join(''), ['x', 'y', 'z'])
          //. ['xyz', 'yz', 'z']
          //.
          //. > extend(f => f([3, 4]), reverse)([1, 2])
          //. [4, 3, 2, 1]
          //. ```
          function extend(f, extend_) {
            return Extend.methods.extend(extend_)(f);
          }

          //# duplicate :: Extend w => w a -> w (w a)
          //.
          //. Adds one level of nesting to a comonadic structure.
          //.
          //. This function is derived from [`extend`](#extend).
          //.
          //. ```javascript
          //. > duplicate(Identity(1))
          //. Identity(Identity(1))
          //.
          //. > duplicate([1])
          //. [[1]]
          //.
          //. > duplicate([1, 2, 3])
          //. [[1, 2, 3], [2, 3], [3]]
          //.
          //. > duplicate(reverse)([1, 2])([3, 4])
          //. [4, 3, 2, 1]
          //. ```
          function duplicate(extend_) {
            return extend(identity, extend_);
          }

          //# extract :: Comonad w => w a -> a
          //.
          //. Function wrapper for [`fantasy-land/extract`][].
          //.
          //. ```javascript
          //. > extract(Identity(42))
          //. 42
          //. ```
          function extract(comonad) {
            return Comonad.methods.extract(comonad)();
          }

          //# contramap :: Contravariant f => (b -> a, f a) -> f b
          //.
          //. Function wrapper for [`fantasy-land/contramap`][].
          //.
          //. `fantasy-land/contramap` implementations are provided for the following
          //. built-in types: Function.
          //.
          //. ```javascript
          //. > contramap(s => s.length, Math.sqrt)('Sanctuary')
          //. 3
          //. ```
          function contramap(f, contravariant) {
            return Contravariant.methods.contramap(contravariant)(f);
          }

          return {
            TypeClass: TypeClass,
            Setoid: Setoid,
            Ord: Ord,
            Semigroupoid: Semigroupoid,
            Category: Category,
            Semigroup: Semigroup,
            Monoid: Monoid,
            Group: Group,
            Filterable: Filterable,
            Functor: Functor,
            Bifunctor: Bifunctor,
            Profunctor: Profunctor,
            Apply: Apply,
            Applicative: Applicative,
            Chain: Chain,
            ChainRec: ChainRec,
            Monad: Monad,
            Alt: Alt,
            Plus: Plus,
            Alternative: Alternative,
            Foldable: Foldable,
            Traversable: Traversable,
            Extend: Extend,
            Comonad: Comonad,
            Contravariant: Contravariant,
            equals: equals,
            lt: lt,
            lte: lte,
            gt: gt,
            gte: gte,
            min: min,
            max: max,
            compose: compose,
            id: id,
            concat: concat,
            empty: empty,
            invert: invert,
            filter: filter,
            reject: reject,
            map: map,
            flip: flip,
            bimap: bimap,
            mapLeft: mapLeft,
            promap: promap,
            ap: ap,
            lift2: lift2,
            lift3: lift3,
            apFirst: apFirst,
            apSecond: apSecond,
            of: of,
            append: append,
            prepend: prepend,
            chain: chain,
            join: join,
            chainRec: chainRec,
            alt: alt,
            zero: zero,
            reduce: reduce,
            size: size,
            elem: elem,
            foldMap: foldMap,
            reverse: reverse,
            sort: sort,
            sortBy: sortBy,
            takeWhile: takeWhile,
            dropWhile: dropWhile,
            traverse: traverse,
            sequence: sequence,
            extend: extend,
            duplicate: duplicate,
            extract: extract,
            contramap: contramap,
          };
        });

        //. [Alt]:                      v:fantasyland/fantasy-land#alt
        //. [Alternative]:              v:fantasyland/fantasy-land#alternative
        //. [Applicative]:              v:fantasyland/fantasy-land#applicative
        //. [Apply]:                    v:fantasyland/fantasy-land#apply
        //. [Bifunctor]:                v:fantasyland/fantasy-land#bifunctor
        //. [Category]:                 v:fantasyland/fantasy-land#category
        //. [Chain]:                    v:fantasyland/fantasy-land#chain
        //. [ChainRec]:                 v:fantasyland/fantasy-land#chainrec
        //. [Comonad]:                  v:fantasyland/fantasy-land#comonad
        //. [Contravariant]:            v:fantasyland/fantasy-land#contravariant
        //. [Extend]:                   v:fantasyland/fantasy-land#extend
        //. [FL]:                       v:fantasyland/fantasy-land
        //. [Filterable]:               v:fantasyland/fantasy-land#filterable
        //. [Foldable]:                 v:fantasyland/fantasy-land#foldable
        //. [Functor]:                  v:fantasyland/fantasy-land#functor
        //. [Group]:                    v:fantasyland/fantasy-land#group
        //. [Monad]:                    v:fantasyland/fantasy-land#monad
        //. [Monoid]:                   v:fantasyland/fantasy-land#monoid
        //. [Ord]:                      v:fantasyland/fantasy-land#ord
        //. [Plus]:                     v:fantasyland/fantasy-land#plus
        //. [Profunctor]:               v:fantasyland/fantasy-land#profunctor
        //. [Semigroup]:                v:fantasyland/fantasy-land#semigroup
        //. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid
        //. [Setoid]:                   v:fantasyland/fantasy-land#setoid
        //. [Traversable]:              v:fantasyland/fantasy-land#traversable
        //. [`fantasy-land/alt`]:       v:fantasyland/fantasy-land#alt-method
        //. [`fantasy-land/ap`]:        v:fantasyland/fantasy-land#ap-method
        //. [`fantasy-land/bimap`]:     v:fantasyland/fantasy-land#bimap-method
        //. [`fantasy-land/chain`]:     v:fantasyland/fantasy-land#chain-method
        //. [`fantasy-land/chainRec`]:  v:fantasyland/fantasy-land#chainrec-method
        //. [`fantasy-land/compose`]:   v:fantasyland/fantasy-land#compose-method
        //. [`fantasy-land/concat`]:    v:fantasyland/fantasy-land#concat-method
        //. [`fantasy-land/contramap`]: v:fantasyland/fantasy-land#contramap-method
        //. [`fantasy-land/empty`]:     v:fantasyland/fantasy-land#empty-method
        //. [`fantasy-land/equals`]:    v:fantasyland/fantasy-land#equals-method
        //. [`fantasy-land/extend`]:    v:fantasyland/fantasy-land#extend-method
        //. [`fantasy-land/extract`]:   v:fantasyland/fantasy-land#extract-method
        //. [`fantasy-land/filter`]:    v:fantasyland/fantasy-land#filter-method
        //. [`fantasy-land/id`]:        v:fantasyland/fantasy-land#id-method
        //. [`fantasy-land/invert`]:    v:fantasyland/fantasy-land#invert-method
        //. [`fantasy-land/lte`]:       v:fantasyland/fantasy-land#lte-method
        //. [`fantasy-land/map`]:       v:fantasyland/fantasy-land#map-method
        //. [`fantasy-land/of`]:        v:fantasyland/fantasy-land#of-method
        //. [`fantasy-land/promap`]:    v:fantasyland/fantasy-land#promap-method
        //. [`fantasy-land/reduce`]:    v:fantasyland/fantasy-land#reduce-method
        //. [`fantasy-land/traverse`]:  v:fantasyland/fantasy-land#traverse-method
        //. [`fantasy-land/zero`]:      v:fantasyland/fantasy-land#zero-method
        //. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
        //. [type-classes]:             https://github.com/sanctuary-js/sanctuary-def#type-classes

        /***/
      },

    /***/ "./node_modules/sanctuary-type-classes/node_modules/sanctuary-type-identifiers/index.js":
      /*!**********************************************************************************************!*\
  !*** ./node_modules/sanctuary-type-classes/node_modules/sanctuary-type-identifiers/index.js ***!
  \**********************************************************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__; /*
        @@@@@@@            @@@@@@@         @@
      @@       @@        @@       @@      @@@
    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@
   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@
   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@
   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@
    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@
      @@                 @@                           @@  @@
        @@@@@@@            @@@@@@@               @@@@@    @@
                                                          */
        //. # sanctuary-type-identifiers
        //.
        //. A type is a set of values. Boolean, for example, is the type comprising
        //. `true` and `false`. A value may be a member of multiple types (`42` is a
        //. member of Number, PositiveNumber, Integer, and many other types).
        //.
        //. In certain situations it is useful to divide JavaScript values into
        //. non-overlapping types. The language provides two constructs for this
        //. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].
        //. Each has pros and cons, but neither supports user-defined types.
        //.
        //. This package specifies an [algorithm][3] for deriving a _type identifier_
        //. from any JavaScript value, and exports an implementation of the algorithm.
        //. Authors of algebraic data types may follow this specification in order to
        //. make their data types compatible with the algorithm.
        //.
        //. ### Algorithm
        //.
        //. 1.  Take any JavaScript value `x`.
        //.
        //. 2.  If `x` is `null` or `undefined`, go to step 6.
        //.
        //. 3.  If `x.constructor` evaluates to `null` or `undefined`, go to step 6.
        //.
        //. 4.  If `x.constructor.prototype === x`, go to step 6. This check prevents a
        //.     prototype object from being considered a member of its associated type.
        //.
        //. 5.  If `typeof x.constructor['@@type']` evaluates to `'string'`, return
        //.     the value of `x.constructor['@@type']`.
        //.
        //. 6.  Return the [`Object.prototype.toString`][2] representation of `x`
        //.     without the leading `'[object '` and trailing `']'`.
        //.
        //. ### Compatibility
        //.
        //. For an algebraic data type to be compatible with the [algorithm][3]:
        //.
        //.   - every member of the type must have a `constructor` property pointing
        //.     to an object known as the _type representative_;
        //.
        //.   - the type representative must have a `@@type` property; and
        //.
        //.   - the type representative's `@@type` property (the _type identifier_)
        //.     must be a string primitive, ideally `'<npm-package-name>/<type-name>'`.
        //.
        //. For example:
        //.
        //. ```javascript
        //. //  Identity :: a -> Identity a
        //. function Identity(x) {
        //.   if (!(this instanceof Identity)) return new Identity(x);
        //.   this.value = x;
        //. }
        //.
        //. Identity['@@type'] = 'my-package/Identity';
        //. ```
        //.
        //. Note that by using a constructor function the `constructor` property is set
        //. implicitly for each value created. Constructor functions are convenient for
        //. this reason, but are not required. This definition is also valid:
        //.
        //. ```javascript
        //. //  IdentityTypeRep :: TypeRep Identity
        //. var IdentityTypeRep = {
        //.   '@@type': 'my-package/Identity'
        //. };
        //.
        //. //  Identity :: a -> Identity a
        //. function Identity(x) {
        //.   return {constructor: IdentityTypeRep, value: x};
        //. }
        //. ```
        //.
        //. ### Usage
        //.
        //. ```javascript
        //. var Identity = require('my-package').Identity;
        //. var type = require('sanctuary-type-identifiers');
        //.
        //. type(null);         // => 'Null'
        //. type(true);         // => 'Boolean'
        //. type([1, 2, 3]);    // => 'Array'
        //. type(Identity);     // => 'Function'
        //. type(Identity(0));  // => 'my-package/Identity'
        //. ```
        //.
        //.
        //. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
        //. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
        //. [3]: #algorithm

        (function(f) {
          "use strict";

          if (true && typeof module.exports === "object") {
            module.exports = f();
          } else if (
            true &&
            __webpack_require__(
              /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
            ) != null
          ) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = f),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
            self.sanctuaryTypeIdentifiers = f();
          }
        })(function() {
          "use strict";

          //  $$type :: String
          var $$type = "@@type";

          //  type :: Any -> String
          function type(x) {
            return x != null &&
              x.constructor != null &&
              x.constructor.prototype !== x &&
              typeof x.constructor[$$type] === "string"
              ? x.constructor[$$type]
              : Object.prototype.toString
                  .call(x)
                  .slice("[object ".length, -"]".length);
          }

          return type;
        });

        /***/
      },

    /***/ "./node_modules/sanctuary-type-identifiers/index.js":
      /*!**********************************************************!*\
  !*** ./node_modules/sanctuary-type-identifiers/index.js ***!
  \**********************************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        var __WEBPACK_AMD_DEFINE_FACTORY__,
          __WEBPACK_AMD_DEFINE_ARRAY__,
          __WEBPACK_AMD_DEFINE_RESULT__; /*
        @@@@@@@            @@@@@@@         @@
      @@       @@        @@       @@      @@@
    @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@
   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@
   @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@
   @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@
    @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@
      @@                 @@                           @@  @@
        @@@@@@@            @@@@@@@               @@@@@    @@
                                                          */
        //. # sanctuary-type-identifiers
        //.
        //. A type is a set of values. Boolean, for example, is the type comprising
        //. `true` and `false`. A value may be a member of multiple types (`42` is a
        //. member of Number, PositiveNumber, Integer, and many other types).
        //.
        //. In certain situations it is useful to divide JavaScript values into
        //. non-overlapping types. The language provides two constructs for this
        //. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].
        //. Each has pros and cons, but neither supports user-defined types.
        //.
        //. sanctuary-type-identifiers comprises:
        //.
        //.   - an npm and browser -compatible package for deriving the
        //.     _type identifier_ of a JavaScript value; and
        //.   - a specification which authors may follow to specify type
        //.     identifiers for their types.
        //.
        //. ### Specification
        //.
        //. For a type to be compatible with the algorithm:
        //.
        //.   - every member of the type MUST have a `constructor` property
        //.     pointing to an object known as the _type representative_;
        //.
        //.   - the type representative MUST have a `@@type` property
        //.     (the _type identifier_); and
        //.
        //.   - the type identifier MUST be a string primitive and SHOULD have
        //.     format `'<namespace>/<name>[@<version>]'`, where:
        //.
        //.       - `<namespace>` MUST consist of one or more characters, and
        //.         SHOULD equal the name of the npm package which defines the
        //.         type (including [scope][3] where appropriate);
        //.
        //.       - `<name>` MUST consist of one or more characters, and SHOULD
        //.         be the unique name of the type; and
        //.
        //.       - `<version>` MUST consist of one or more digits, and SHOULD
        //.         represent the version of the type.
        //.
        //. If the type identifier does not conform to the format specified above,
        //. it is assumed that the entire string represents the _name_ of the type;
        //. _namespace_ will be `null` and _version_ will be `0`.
        //.
        //. If the _version_ is not given, it is assumed to be `0`.
        //.
        //. For example:
        //.
        //. ```javascript
        //. //  Identity :: a -> Identity a
        //. function Identity(x) {
        //.   if (!(this instanceof Identity)) return new Identity(x);
        //.   this.value = x;
        //. }
        //.
        //. Identity['@@type'] = 'my-package/Identity';
        //. ```
        //.
        //. Note that by using a constructor function the `constructor` property is set
        //. implicitly for each value created. Constructor functions are convenient for
        //. this reason, but are not required. This definition is also valid:
        //.
        //. ```javascript
        //. //  IdentityTypeRep :: TypeRep Identity
        //. var IdentityTypeRep = {
        //.   '@@type': 'my-package/Identity'
        //. };
        //.
        //. //  Identity :: a -> Identity a
        //. function Identity(x) {
        //.   return {constructor: IdentityTypeRep, value: x};
        //. }
        //. ```

        (function(f) {
          "use strict";

          if (true && typeof module.exports === "object") {
            module.exports = f();
          } else if (
            true &&
            __webpack_require__(
              /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
            ) != null
          ) {
            !((__WEBPACK_AMD_DEFINE_ARRAY__ = []),
            (__WEBPACK_AMD_DEFINE_FACTORY__ = f),
            (__WEBPACK_AMD_DEFINE_RESULT__ =
              typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                    exports,
                    __WEBPACK_AMD_DEFINE_ARRAY__
                  )
                : __WEBPACK_AMD_DEFINE_FACTORY__),
            __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
              (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
          } else {
            self.sanctuaryTypeIdentifiers = f();
          }
        })(function() {
          "use strict";

          //  $$type :: String
          var $$type = "@@type";

          //  pattern :: RegExp
          var pattern = new RegExp(
            "^" +
            "([\\s\\S]+)" + //  <namespace>
            "/" + //  SOLIDUS (U+002F)
            "([\\s\\S]+?)" + //  <name>
            "(?:" + //  optional non-capturing group {
            "@" + //    COMMERCIAL AT (U+0040)
            "([0-9]+)" + //    <version>
            ")?" + //  }
              "$"
          );

          //. ### Usage
          //.
          //. ```javascript
          //. const type = require('sanctuary-type-identifiers');
          //. ```
          //.
          //. ```javascript
          //. > function Identity(x) {
          //. .   if (!(this instanceof Identity)) return new Identity(x);
          //. .   this.value = x;
          //. . }
          //. . Identity['@@type'] = 'my-package/Identity@1';
          //.
          //. > type.parse(type(Identity(0)))
          //. {namespace: 'my-package', name: 'Identity', version: 1}
          //. ```
          //.
          //. ### API
          //.
          //# type :: Any -> String
          //.
          //. Takes any value and returns a string which identifies its type. If the
          //. value conforms to the [specification][4], the custom type identifier is
          //. returned.
          //.
          //. ```javascript
          //. > type(null)
          //. 'Null'
          //.
          //. > type(true)
          //. 'Boolean'
          //.
          //. > type(Identity(0))
          //. 'my-package/Identity@1'
          //. ```
          function type(x) {
            return x != null &&
              x.constructor != null &&
              x.constructor.prototype !== x &&
              typeof x.constructor[$$type] === "string"
              ? x.constructor[$$type]
              : Object.prototype.toString
                  .call(x)
                  .slice("[object ".length, -"]".length);
          }

          //# type.parse :: String -> { namespace :: Nullable String, name :: String, version :: Number }
          //.
          //. Takes any string and parses it according to the [specification][4],
          //. returning an object with `namespace`, `name`, and `version` fields.
          //.
          //. ```javascript
          //. > type.parse('my-package/List@2')
          //. {namespace: 'my-package', name: 'List', version: 2}
          //.
          //. > type.parse('nonsense!')
          //. {namespace: null, name: 'nonsense!', version: 0}
          //.
          //. > type.parse(Identity['@@type'])
          //. {namespace: 'my-package', name: 'Identity', version: 1}
          //. ```
          type.parse = function parse(s) {
            var groups = pattern.exec(s);
            return {
              namespace: groups == null || groups[1] == null ? null : groups[1],
              name: groups == null ? s : groups[2],
              version:
                groups == null || groups[3] == null ? 0 : Number(groups[3]),
            };
          };

          return type;
        });

        //. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
        //. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
        //. [3]: https://docs.npmjs.com/misc/scope
        //. [4]: #specification

        /***/
      },

    /***/ "./node_modules/sanctuary/index.js":
      /*!*****************************************!*\
  !*** ./node_modules/sanctuary/index.js ***!
  \*****************************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(process) {
          var __WEBPACK_AMD_DEFINE_FACTORY__,
            __WEBPACK_AMD_DEFINE_ARRAY__,
            __WEBPACK_AMD_DEFINE_RESULT__; /*    #######
   ####     ####
 ####   ###   ####
#####   ###########   sanctuary
########   ########   noun
###########   #####   1 [ mass noun ] refuge from unsafe JavaScript
 ####   ###   ####
   ####     ####
      #######    */

          //. # Sanctuary
          //.
          //. [![npm](https://img.shields.io/npm/v/sanctuary.svg)](https://www.npmjs.com/package/sanctuary)
          //. [![CircleCI](https://img.shields.io/circleci/project/github/sanctuary-js/sanctuary/master.svg)](https://circleci.com/gh/sanctuary-js/sanctuary/tree/master)
          //. [![Gitter](https://img.shields.io/gitter/room/badges/shields.svg)](https://gitter.im/sanctuary-js/sanctuary)
          //.
          //. Sanctuary is a JavaScript functional programming library inspired by
          //. [Haskell][] and [PureScript][]. It's stricter than [Ramda][], and
          //. provides a similar suite of functions.
          //.
          //. Sanctuary promotes programs composed of simple, pure functions. Such
          //. programs are easier to comprehend, test, and maintain &ndash; they are
          //. also a pleasure to write.
          //.
          //. Sanctuary provides two data types, [Maybe][] and [Either][], both of
          //. which are compatible with [Fantasy Land][]. Thanks to these data types
          //. even Sanctuary functions which may fail, such as [`head`](#head), are
          //. composable.
          //.
          //. Sanctuary makes it possible to write safe code without null checks.
          //. In JavaScript it's trivial to introduce a possible run-time type error:
          //.
          //.     words[0].toUpperCase()
          //.
          //. If `words` is `[]` we'll get a familiar error at run-time:
          //.
          //.     TypeError: Cannot read property 'toUpperCase' of undefined
          //.
          //. Sanctuary gives us a fighting chance of avoiding such errors. We might
          //. write:
          //.
          //.     S.map (S.toUpper) (S.head (words))
          //.
          //. Sanctuary is designed to work in Node.js and in ES5-compatible browsers.
          //.
          //. ## Ramda
          //.
          //. [Ramda][] provides several functions which return problematic values
          //. such as `undefined`, `Infinity`, or `NaN` when applied to unsuitable
          //. inputs. These are known as [partial functions][]. Partial functions
          //. necessitate the use of guards or null checks. In order to safely use
          //. `R.head`, for example, one must ensure that the array is non-empty:
          //.
          //.     if (R.isEmpty (xs)) {
          //.       // ...
          //.     } else {
          //.       return f (R.head (xs));
          //.     }
          //.
          //. Using the Maybe type renders such guards (and null checks) unnecessary.
          //. Changing functions such as `R.head` to return Maybe values was proposed
          //. in [ramda/ramda#683][], but was considered too much of a stretch for
          //. JavaScript programmers. Sanctuary was released the following month,
          //. in January 2015, as a companion library to Ramda.
          //.
          //. In addition to broadening in scope in the years since its release,
          //. Sanctuary's philosophy has diverged from Ramda's in several respects.
          //.
          //. ### Totality
          //.
          //. Every Sanctuary function is defined for every value which is a member of
          //. the function's input type. Such functions are known as [total functions][].
          //. Ramda, on the other hand, contains a number of [partial functions][].
          //.
          //. ### Information preservation
          //.
          //. Certain Sanctuary functions preserve more information than their Ramda
          //. counterparts. Examples:
          //.
          //.     |> R.tail ([])                      |> S.tail ([])
          //.     []                                  Nothing
          //.
          //.     |> R.tail (['foo'])                 |> S.tail (['foo'])
          //.     []                                  Just ([])
          //.
          //.     |> R.replace (/^x/) ('') ('abc')    |> S.stripPrefix ('x') ('abc')
          //.     'abc'                               Nothing
          //.
          //.     |> R.replace (/^x/) ('') ('xabc')   |> S.stripPrefix ('x') ('xabc')
          //.     'abc'                               Just ('abc')
          //.
          //. ### Invariants
          //.
          //. Sanctuary performs rigorous [type checking][] of inputs and outputs, and
          //. throws a descriptive error if a type error is encountered. This allows bugs
          //. to be caught and fixed early in the development cycle.
          //.
          //. Ramda operates on the [garbage in, garbage out][GIGO] principal. Functions
          //. are documented to take arguments of particular types, but these invariants
          //. are not enforced. The problem with this approach in a language as
          //. permissive as JavaScript is that there's no guarantee that garbage input
          //. will produce garbage output ([ramda/ramda#1413][]). Ramda performs ad hoc
          //. type checking in some such cases ([ramda/ramda#1419][]).
          //.
          //. Sanctuary can be configured to operate in garbage in, garbage out mode.
          //. Ramda cannot be configured to enforce its invariants.
          //.
          //. ### Currying
          //.
          //. Sanctuary functions are curried. There is, for example, exactly one way to
          //. apply `S.reduce` to `S.add`, `0`, and `xs`:
          //.
          //.   - `S.reduce (S.add) (0) (xs)`
          //.
          //. Ramda functions are also curried, but in a complex manner. There are four
          //. ways to apply `R.reduce` to `R.add`, `0`, and `xs`:
          //.
          //.   - `R.reduce (R.add) (0) (xs)`
          //.   - `R.reduce (R.add) (0, xs)`
          //.   - `R.reduce (R.add, 0) (xs)`
          //.   - `R.reduce (R.add, 0, xs)`
          //.
          //. Ramda supports all these forms because curried functions enable partial
          //. application, one of the library's tenets, but `f(x)(y)(z)` is considered
          //. too unfamiliar and too unattractive to appeal to JavaScript programmers.
          //.
          //. Sanctuary's developers prefer a simple, unfamiliar construct to a complex,
          //. familiar one. Familiarity can be acquired; complexity is intrinsic.
          //.
          //. The lack of breathing room in `f(x)(y)(z)` impairs readability. The simple
          //. solution to this problem, proposed in [#438][], is to include a space when
          //. applying a function: `f (x) (y) (z)`.
          //.
          //. Ramda also provides a special placeholder value, [`R.__`][], which removes
          //. the restriction that a function must be applied to its arguments in order.
          //. The following expressions are equivalent:
          //.
          //.   - `R.reduce (R.__, 0, xs) (R.add)`
          //.   - `R.reduce (R.add, R.__, xs) (0)`
          //.   - `R.reduce (R.__, 0) (R.add) (xs)`
          //.   - `R.reduce (R.__, 0) (R.add, xs)`
          //.   - `R.reduce (R.__, R.__, xs) (R.add) (0)`
          //.   - `R.reduce (R.__, R.__, xs) (R.add, 0)`
          //.
          //. ### Variadic functions
          //.
          //. Ramda provides several functions which take any number of arguments. These
          //. are known as [variadic functions][]. Additionally, Ramda provides several
          //. functions which take variadic functions as arguments. Although natural in
          //. a dynamically typed language, variadic functions are at odds with the type
          //. notation Ramda and Sanctuary both use, leading to some indecipherable type
          //. signatures such as this one:
          //.
          //.     R.lift :: (*... -> *...) -> ([*]... -> [*])
          //.
          //. Sanctuary has no variadic functions, nor any functions which take variadic
          //. functions as arguments. Sanctuary provides two "lift" functions, each with
          //. a helpful type signature:
          //.
          //.     S.lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
          //.     S.lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
          //.
          //. ### Implicit context
          //.
          //. Ramda provides [`R.bind`][] and [`R.invoker`][] for working with methods.
          //. Additionally, many Ramda functions use `Function#call` or `Function#apply`
          //. to preserve context. Sanctuary makes no allowances for `this`.
          //.
          //. ### Transducers
          //.
          //. Several Ramda functions act as transducers. Sanctuary provides no support
          //. for transducers.
          //.
          //. ### Modularity
          //.
          //. Whereas Ramda has no dependencies, Sanctuary has a modular design:
          //. [sanctuary-def][] provides type checking, [sanctuary-type-classes][]
          //. provides Fantasy Land functions and type classes, [sanctuary-show][]
          //. provides string representations, and algebraic data types are provided
          //. by [sanctuary-either][], [sanctuary-maybe][], and [sanctuary-pair][].
          //. Not only does this approach reduce the complexity of Sanctuary itself,
          //. but it allows these components to be reused in other contexts.
          //.
          //. ## Types
          //.
          //. Sanctuary uses Haskell-like type signatures to describe the types of
          //. values, including functions. `'foo'`, for example, is a member of `String`;
          //. `[1, 2, 3]` is a member of `Array Number`. The double colon (`::`) is used
          //. to mean "is a member of", so one could write:
          //.
          //.     'foo' :: String
          //.     [1, 2, 3] :: Array Number
          //.
          //. An identifier may appear to the left of the double colon:
          //.
          //.     Math.PI :: Number
          //.
          //. The arrow (`->`) is used to express a function's type:
          //.
          //.     Math.abs :: Number -> Number
          //.
          //. That states that `Math.abs` is a unary function which takes an argument
          //. of type `Number` and returns a value of type `Number`.
          //.
          //. Some functions are parametrically polymorphic: their types are not fixed.
          //. Type variables are used in the representations of such functions:
          //.
          //.     S.I :: a -> a
          //.
          //. `a` is a type variable. Type variables are not capitalized, so they
          //. are differentiable from type identifiers (which are always capitalized).
          //. By convention type variables have single-character names. The signature
          //. above states that `S.I` takes a value of any type and returns a value of
          //. the same type. Some signatures feature multiple type variables:
          //.
          //.     S.K :: a -> b -> a
          //.
          //. It must be possible to replace all occurrences of `a` with a concrete type.
          //. The same applies for each other type variable. For the function above, the
          //. types with which `a` and `b` are replaced may be different, but needn't be.
          //.
          //. Since all Sanctuary functions are curried (they accept their arguments
          //. one at a time), a binary function is represented as a unary function which
          //. returns a unary function: `* -> * -> *`. This aligns neatly with Haskell,
          //. which uses curried functions exclusively. In JavaScript, though, we may
          //. wish to represent the types of functions with arities less than or greater
          //. than one. The general form is `(<input-types>) -> <output-type>`, where
          //. `<input-types>` comprises zero or more comma–space (<code>, </code>)
          //. -separated type representations:
          //.
          //.   - `() -> String`
          //.   - `(a, b) -> a`
          //.   - `(a, b, c) -> d`
          //.
          //. `Number -> Number` can thus be seen as shorthand for `(Number) -> Number`.
          //.
          //. The question mark (`?`) is used to represent types which include `null`
          //. and `undefined` as members. `String?`, for example, represents the type
          //. comprising `null`, `undefined`, and all strings.
          //.
          //. Sanctuary embraces types. JavaScript doesn't support algebraic data types,
          //. but these can be simulated by providing a group of data constructors which
          //. return values with the same set of methods. A value of the Either type, for
          //. example, is created via the Left constructor or the Right constructor.
          //.
          //. It's necessary to extend Haskell's notation to describe implicit arguments
          //. to the *methods* provided by Sanctuary's types. In `x.map(y)`, for example,
          //. the `map` method takes an implicit argument `x` in addition to the explicit
          //. argument `y`. The type of the value upon which a method is invoked appears
          //. at the beginning of the signature, separated from the arguments and return
          //. value by a squiggly arrow (`~>`). The type of the `fantasy-land/map` method
          //. of the Maybe type is written `Maybe a ~> (a -> b) -> Maybe b`. One could
          //. read this as:
          //.
          //. _When the `fantasy-land/map` method is invoked on a value of type `Maybe a`
          //. (for any type `a`) with an argument of type `a -> b` (for any type `b`),
          //. it returns a value of type `Maybe b`._
          //.
          //. The squiggly arrow is also used when representing non-function properties.
          //. `Maybe a ~> Boolean`, for example, represents a Boolean property of a value
          //. of type `Maybe a`.
          //.
          //. Sanctuary supports type classes: constraints on type variables. Whereas
          //. `a -> a` implicitly supports every type, `Functor f => (a -> b) -> f a ->
          //. f b` requires that `f` be a type which satisfies the requirements of the
          //. Functor type class. Type-class constraints appear at the beginning of a
          //. type signature, separated from the rest of the signature by a fat arrow
          //. (`=>`).
          //.
          //. ## Type checking
          //.
          //. Sanctuary functions are defined via [sanctuary-def][] to provide run-time
          //. type checking. This is tremendously useful during development: type errors
          //. are reported immediately, avoiding circuitous stack traces (at best) and
          //. silent failures due to type coercion (at worst). For example:
          //.
          //. ```javascript
          //. S.add (2) (true);
          //. // ! TypeError: Invalid value
          //. //
          //. //   add :: FiniteNumber -> FiniteNumber -> FiniteNumber
          //. //                          ^^^^^^^^^^^^
          //. //                               1
          //. //
          //. //   1)  true :: Boolean
          //. //
          //. //   The value at position 1 is not a member of ‘FiniteNumber’.
          //. //
          //. //   See v:sanctuary-js/sanctuary-def#FiniteNumber for information about the sanctuary-def/FiniteNumber type.
          //. ```
          //.
          //. Compare this to the behaviour of Ramda's unchecked equivalent:
          //.
          //. ```javascript
          //. R.add (2) (true);
          //. // => 3
          //. ```
          //.
          //. There is a performance cost to run-time type checking. Type checking is
          //. disabled by default if `process.env.NODE_ENV` is `'production'`. If this
          //. rule is unsuitable for a given program, one may use [`create`](#create)
          //. to create a Sanctuary module based on a different rule. For example:
          //.
          //. ```javascript
          //. const S = sanctuary.create ({
          //.   checkTypes: localStorage.getItem ('SANCTUARY_CHECK_TYPES') === 'true',
          //.   env: sanctuary.env,
          //. });
          //. ```
          //.
          //. Occasionally one may wish to perform an operation which is not type safe,
          //. such as mapping over an object with heterogeneous values. This is possible
          //. via selective use of [`unchecked`](#unchecked) functions.
          //.
          //. ## Installation
          //.
          //. `npm install sanctuary` will install Sanctuary for use in Node.js.
          //.
          //. Running Sanctuary in the browser is more involved. One must include a
          //. `<script>` for each dependency in addition to one for Sanctuary itself:
          //.
          //. ```html
          //. <script src="vendor/sanctuary-show.js"></script>
          //. <script src="vendor/sanctuary-type-identifiers.js"></script>
          //. <script src="vendor/sanctuary-type-classes.js"></script>
          //. <script src="vendor/sanctuary-either.js"></script>
          //. <script src="vendor/sanctuary-maybe.js"></script>
          //. <script src="vendor/sanctuary-pair.js"></script>
          //. <script src="vendor/sanctuary-def.js"></script>
          //. <script src="vendor/sanctuary.js"></script>
          //. ```
          //.
          //. To ensure compatibility one should use the dependency versions specified
          //. in __package.json__.
          //.
          //. For convenience one could define aliases for various modules:
          //.
          //. ```javascript
          //. const S = window.sanctuary;
          //. const $ = window.sanctuaryDef;
          //. // ...
          //. ```
          //.
          //. ## API

          (function(f) {
            "use strict";

            /* istanbul ignore else */
            if (true && typeof module.exports === "object") {
              module.exports = f(
                __webpack_require__(
                  /*! sanctuary-def */ "./node_modules/sanctuary-def/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-either */ "./node_modules/sanctuary-either/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-maybe */ "./node_modules/sanctuary-maybe/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-pair */ "./node_modules/sanctuary-pair/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-identifiers/index.js"
                )
              );
            } else if (
              true &&
              __webpack_require__(
                /*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js"
              ) != null
            ) {
              !((__WEBPACK_AMD_DEFINE_ARRAY__ = [
                __webpack_require__(
                  /*! sanctuary-def */ "./node_modules/sanctuary-def/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-either */ "./node_modules/sanctuary-either/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-maybe */ "./node_modules/sanctuary-maybe/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-pair */ "./node_modules/sanctuary-pair/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-show */ "./node_modules/sanctuary-show/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-type-classes */ "./node_modules/sanctuary-type-classes/index.js"
                ),
                __webpack_require__(
                  /*! sanctuary-type-identifiers */ "./node_modules/sanctuary-type-identifiers/index.js"
                ),
              ]),
              (__WEBPACK_AMD_DEFINE_FACTORY__ = f),
              (__WEBPACK_AMD_DEFINE_RESULT__ =
                typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function"
                  ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(
                      exports,
                      __WEBPACK_AMD_DEFINE_ARRAY__
                    )
                  : __WEBPACK_AMD_DEFINE_FACTORY__),
              __WEBPACK_AMD_DEFINE_RESULT__ !== undefined &&
                (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else {
              self.sanctuary = f(
                self.sanctuaryDef,
                self.sanctuaryEither,
                self.sanctuaryMaybe,
                self.sanctuaryPair,
                self.sanctuaryShow,
                self.sanctuaryTypeClasses,
                self.sanctuaryTypeIdentifiers
              );
            }
          })(function($, Either, Maybe, Pair, show, Z, type) {
            "use strict";

            /* istanbul ignore if */
            if (typeof __doctest !== "undefined") {
              /* eslint-disable no-unused-vars */
              var Descending = __doctest.require("sanctuary-descending");
              var Nil = __doctest.require("./test/internal/List").Nil;
              var Cons = __doctest.require("./test/internal/List").Cons;
              var Sum = __doctest.require("./test/internal/Sum");
              var S = (function(S) {
                //  DescendingType :: Type -> Type
                var DescendingType = $.UnaryType("sanctuary/Descending")("")(
                  typeEq(Descending["@@type"])
                )(B(of(Array))(Z.extract));

                var S_ = S.create({
                  checkTypes: true,
                  env: S.env.concat([
                    DescendingType($.Unknown),
                    __doctest.require("./test/internal/List").Type($.Unknown),
                    Sum.Type,
                  ]),
                });
                S_.env = S.env; // see S.env doctest
                return S_;
              })(
                __webpack_require__(
                  /*! . */ "./node_modules/sanctuary/index.js"
                )
              );
              /* eslint-enable no-unused-vars */
            }

            //  Left :: a -> Either a b
            var Left = Either.Left;

            //  Right :: b -> Either a b
            var Right = Either.Right;

            //  Nothing :: Maybe a
            var Nothing = Maybe.Nothing;

            //  Just :: a -> Maybe a
            var Just = Maybe.Just;

            //  B :: (b -> c) -> (a -> b) -> a -> c
            function B(f) {
              return function(g) {
                return function(x) {
                  return f(g(x));
                };
              };
            }

            //  C :: (a -> b -> c) -> b -> a -> c
            function C(f) {
              return function(y) {
                return function(x) {
                  return f(x)(y);
                };
              };
            }

            //  Fn :: Type -> Type -> Type
            function Fn(x) {
              return function(y) {
                return $.Function([x, y]);
              };
            }

            //  get_ :: String -> a -> Maybe b
            function get_(key) {
              return B(function(obj) {
                return key in obj ? Just(obj[key]) : Nothing;
              })(toObject);
            }

            //  invoke0 :: String -> a -> b
            function invoke0(name) {
              return function(target) {
                return target[name]();
              };
            }

            //  invoke1 :: String -> a -> b -> c
            function invoke1(name) {
              return function(x) {
                return function(target) {
                  return target[name](x);
                };
              };
            }

            //  toObject :: a -> Object
            function toObject(x) {
              return x == null ? Object.create(null) : Object(x);
            }

            //  typeEq :: String -> a -> Boolean
            function typeEq(typeIdent) {
              return function(x) {
                return type(x) === typeIdent;
              };
            }

            //  value :: { value :: a } -> a
            function value(r) {
              return r.value;
            }

            //  :: Type
            var a = $.TypeVariable("a");
            var b = $.TypeVariable("b");
            var c = $.TypeVariable("c");
            var d = $.TypeVariable("d");
            var e = $.TypeVariable("e");
            var g = $.TypeVariable("g");
            var l = $.TypeVariable("l");
            var r = $.TypeVariable("r");

            //  :: Type -> Type
            var f = $.UnaryTypeVariable("f");
            var m = $.UnaryTypeVariable("m");
            var t = $.UnaryTypeVariable("t");
            var w = $.UnaryTypeVariable("w");

            //  :: Type -> Type -> Type
            var p = $.BinaryTypeVariable("p");
            var s = $.BinaryTypeVariable("s");

            //  $Either :: Type -> Type -> Type
            var $Either = $.BinaryType("sanctuary/Either")(
              "https://github.com/sanctuary-js/sanctuary-either"
            )(typeEq("sanctuary-either/Either@1"))(either(of(Array))(K([])))(
              either(K([]))(of(Array))
            );

            //  $Maybe :: Type -> Type
            var $Maybe = $.UnaryType("sanctuary/Maybe")(
              "https://github.com/sanctuary-js/sanctuary-maybe"
            )(typeEq("sanctuary-maybe/Maybe@1"))(maybe([])(of(Array)));

            //  $Pair :: Type -> Type -> Type
            var $Pair = $.BinaryType("sanctuary/Pair")(
              "https://github.com/sanctuary-js/sanctuary-pair"
            )(typeEq("sanctuary-pair/Pair@1"))(function(pair) {
              return [pair.fst];
            })(function(pair) {
              return [pair.snd];
            });

            //  TypeRep :: Type -> Type
            var TypeRep = $.UnaryType("sanctuary/TypeRep")(
              "https://github.com/fantasyland/fantasy-land#type-representatives"
            )(function(x) {
              return (
                $.AnyFunction._test(x) ||
                (x != null && $.String._test(x["@@type"]))
              );
            })(K([]));

            //  Options :: Type
            var Options = $.RecordType({
              checkTypes: $.Boolean,
              env: $.Array($.Any),
            });

            var _ = {};

            //. ### Configure

            //# create :: { checkTypes :: Boolean, env :: Array Type } -> Module
            //.
            //. Takes an options record and returns a Sanctuary module. `checkTypes`
            //. specifies whether to enable type checking. The module's polymorphic
            //. functions (such as [`I`](#I)) require each value associated with a
            //. type variable to be a member of at least one type in the environment.
            //.
            //. A well-typed application of a Sanctuary function will produce the same
            //. result regardless of whether type checking is enabled. If type checking
            //. is enabled, a badly typed application will produce an exception with a
            //. descriptive error message.
            //.
            //. The following snippet demonstrates defining a custom type and using
            //. `create` to produce a Sanctuary module which is aware of that type:
            //.
            //. ```javascript
            //. const {create, env} = require ('sanctuary');
            //. const $ = require ('sanctuary-def');
            //. const type = require ('sanctuary-type-identifiers');
            //.
            //. //    Identity :: a -> Identity a
            //. const Identity = x => {
            //.   const identity = Object.create (Identity$prototype);
            //.   identity.value = x;
            //.   return identity;
            //. };
            //.
            //. Identity['@@type'] = 'my-package/Identity@1';
            //.
            //. const Identity$prototype = {
            //.   'constructor': Identity,
            //.   '@@show': function() { return `Identity (${S.show (this.value)})`; },
            //.   'fantasy-land/map': function(f) { return Identity (f (this.value)); },
            //. };
            //.
            //. //    IdentityType :: Type -> Type
            //. const IdentityType = $.UnaryType
            //.   (Identity['@@type'])
            //.   ('http://example.com/my-package#Identity')
            //.   (x => type (x) === Identity['@@type'])
            //.   (identity => [identity.value]);
            //.
            //. const S = create ({
            //.   checkTypes: process.env.NODE_ENV !== 'production',
            //.   env: env.concat ([IdentityType ($.Unknown)]),
            //. });
            //.
            //. S.map (S.sub (1)) (Identity (43));
            //. // => Identity (42)
            //. ```
            //.
            //. See also [`env`](#env).
            function create(opts) {
              var def = $.create(opts);
              var S = {
                env: opts.env,
                is: def("is")({})([$.Type, $.Any, $.Boolean])($.test(opts.env)),
                MaybeType: $Maybe,
                Maybe: Maybe,
                Nothing: Nothing,
                EitherType: $Either,
                Either: Either,
                PairType: $Pair,
              };
              Object.keys(_).forEach(function(name) {
                S[name] = def(name)(_[name].consts)(_[name].types)(
                  _[name].impl
                );
              });
              S.unchecked = opts.checkTypes
                ? create({ checkTypes: false, env: opts.env })
                : S;
              return S;
            }
            _.create = {
              consts: {},
              types: [Options, $.Object],
              impl: create,
            };

            //# env :: Array Type
            //.
            //. The Sanctuary module's environment (`(S.create ({checkTypes, env})).env`
            //. is a reference to `env`). Useful in conjunction with [`create`](#create).
            //.
            //. ```javascript
            //. > S.env
            //. [ $.AnyFunction,
            //. . $.Arguments,
            //. . $.Array ($.Unknown),
            //. . $.Boolean,
            //. . $.Date,
            //. . $.Error,
            //. . $.HtmlElement,
            //. . $.Null,
            //. . $.Number,
            //. . $.Object,
            //. . $.RegExp,
            //. . $.StrMap ($.Unknown),
            //. . $.String,
            //. . $.Symbol,
            //. . $.Undefined,
            //. . $.FiniteNumber,
            //. . $.NonZeroFiniteNumber,
            //. . S.EitherType ($.Unknown) ($.Unknown),
            //. . $.Function ([$.Unknown, $.Unknown]),
            //. . $.GlobalRegExp,
            //. . $.NonGlobalRegExp,
            //. . $.Integer,
            //. . $.NonNegativeInteger,
            //. . S.MaybeType ($.Unknown),
            //. . $.Array2 ($.Unknown) ($.Unknown),
            //. . S.PairType ($.Unknown) ($.Unknown),
            //. . $.RegexFlags,
            //. . $.Type,
            //. . $.TypeClass,
            //. . $.ValidDate,
            //. . $.ValidNumber ]
            //. ```

            //# unchecked :: Module
            //.
            //. A complete Sanctuary module which performs no type checking. This is
            //. useful as it permits operations which Sanctuary's type checking would
            //. disallow, such as mapping over an object with heterogeneous values.
            //.
            //. See also [`create`](#create).
            //.
            //. ```javascript
            //. > S.unchecked.map (S.show) ({x: 'foo', y: true, z: 42})
            //. {x: '"foo"', y: 'true', z: '42'}
            //. ```
            //.
            //. Opting out of type checking may cause type errors to go unnoticed.
            //.
            //. ```javascript
            //. > S.unchecked.add (2) ('2')
            //. '22'
            //. ```

            //. ### Classify

            //# type :: Any -> { namespace :: Maybe String, name :: String, version :: NonNegativeInteger }
            //.
            //. Returns the result of parsing the [type identifier][] of the given value.
            //.
            //. ```javascript
            //. > S.type (S.Just (42))
            //. {namespace: Just ('sanctuary-maybe'), name: 'Maybe', version: 1}
            //.
            //. > S.type ([1, 2, 3])
            //. {namespace: Nothing, name: 'Array', version: 0}
            //. ```
            function type_(x) {
              var r = type.parse(type(x));
              r.namespace = toMaybe(r.namespace);
              return r;
            }
            _.type = {
              consts: {},
              types: [
                $.Any,
                $.RecordType({
                  namespace: $Maybe($.String),
                  name: $.String,
                  version: $.NonNegativeInteger,
                }),
              ],
              impl: type_,
            };

            //# is :: Type -> Any -> Boolean
            //.
            //. Returns `true` [iff][] the given value is a member of the specified type.
            //. See [`$.test`][] for details.
            //.
            //. ```javascript
            //. > S.is ($.Array ($.Integer)) ([1, 2, 3])
            //. true
            //.
            //. > S.is ($.Array ($.Integer)) ([1, 2, 3.14])
            //. false
            //. ```

            //. ### Showable

            //# show :: Any -> String
            //.
            //. Alias of [`show`][].
            //.
            //. ```javascript
            //. > S.show (-0)
            //. '-0'
            //.
            //. > S.show (['foo', 'bar', 'baz'])
            //. '["foo", "bar", "baz"]'
            //.
            //. > S.show ({x: 1, y: 2, z: 3})
            //. '{"x": 1, "y": 2, "z": 3}'
            //.
            //. > S.show (S.Left (S.Right (S.Just (S.Nothing))))
            //. 'Left (Right (Just (Nothing)))'
            //. ```
            _.show = {
              consts: {},
              types: [$.Any, $.String],
              impl: show,
            };

            //. ### Fantasy Land
            //.
            //. Sanctuary is compatible with the [Fantasy Land][] specification.

            //# equals :: Setoid a => a -> a -> Boolean
            //.
            //. Curried version of [`Z.equals`][] which requires two arguments of the
            //. same type.
            //.
            //. To compare values of different types first use [`create`](#create) to
            //. create a Sanctuary module with type checking disabled, then use that
            //. module's `equals` function.
            //.
            //. ```javascript
            //. > S.equals (0) (-0)
            //. true
            //.
            //. > S.equals (NaN) (NaN)
            //. true
            //.
            //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 3]))
            //. true
            //.
            //. > S.equals (S.Just ([1, 2, 3])) (S.Just ([1, 2, 4]))
            //. false
            //. ```
            _.equals = {
              consts: { a: [Z.Setoid] },
              types: [a, a, $.Boolean],
              impl: curry2(Z.equals),
            };

            //# lt :: Ord a => a -> a -> Boolean
            //.
            //. Returns `true` [iff][] the *second* argument is less than the first
            //. according to [`Z.lt`][].
            //.
            //. ```javascript
            //. > S.filter (S.lt (3)) ([1, 2, 3, 4, 5])
            //. [1, 2]
            //. ```
            function lt(y) {
              return function(x) {
                return Z.lt(x, y);
              };
            }
            _.lt = {
              consts: { a: [Z.Ord] },
              types: [a, a, $.Boolean],
              impl: lt,
            };

            //# lte :: Ord a => a -> a -> Boolean
            //.
            //. Returns `true` [iff][] the *second* argument is less than or equal to
            //. the first according to [`Z.lte`][].
            //.
            //. ```javascript
            //. > S.filter (S.lte (3)) ([1, 2, 3, 4, 5])
            //. [1, 2, 3]
            //. ```
            function lte(y) {
              return function(x) {
                return Z.lte(x, y);
              };
            }
            _.lte = {
              consts: { a: [Z.Ord] },
              types: [a, a, $.Boolean],
              impl: lte,
            };

            //# gt :: Ord a => a -> a -> Boolean
            //.
            //. Returns `true` [iff][] the *second* argument is greater than the first
            //. according to [`Z.gt`][].
            //.
            //. ```javascript
            //. > S.filter (S.gt (3)) ([1, 2, 3, 4, 5])
            //. [4, 5]
            //. ```
            function gt(y) {
              return function(x) {
                return Z.gt(x, y);
              };
            }
            _.gt = {
              consts: { a: [Z.Ord] },
              types: [a, a, $.Boolean],
              impl: gt,
            };

            //# gte :: Ord a => a -> a -> Boolean
            //.
            //. Returns `true` [iff][] the *second* argument is greater than or equal
            //. to the first according to [`Z.gte`][].
            //.
            //. ```javascript
            //. > S.filter (S.gte (3)) ([1, 2, 3, 4, 5])
            //. [3, 4, 5]
            //. ```
            function gte(y) {
              return function(x) {
                return Z.gte(x, y);
              };
            }
            _.gte = {
              consts: { a: [Z.Ord] },
              types: [a, a, $.Boolean],
              impl: gte,
            };

            //# min :: Ord a => a -> a -> a
            //.
            //. Returns the smaller of its two arguments (according to [`Z.lte`][]).
            //.
            //. See also [`max`](#max).
            //.
            //. ```javascript
            //. > S.min (10) (2)
            //. 2
            //.
            //. > S.min (new Date ('1999-12-31')) (new Date ('2000-01-01'))
            //. new Date ('1999-12-31')
            //.
            //. > S.min ('10') ('2')
            //. '10'
            //. ```
            _.min = {
              consts: { a: [Z.Ord] },
              types: [a, a, a],
              impl: curry2(Z.min),
            };

            //# max :: Ord a => a -> a -> a
            //.
            //. Returns the larger of its two arguments (according to [`Z.lte`][]).
            //.
            //. See also [`min`](#min).
            //.
            //. ```javascript
            //. > S.max (10) (2)
            //. 10
            //.
            //. > S.max (new Date ('1999-12-31')) (new Date ('2000-01-01'))
            //. new Date ('2000-01-01')
            //.
            //. > S.max ('10') ('2')
            //. '2'
            //. ```
            _.max = {
              consts: { a: [Z.Ord] },
              types: [a, a, a],
              impl: curry2(Z.max),
            };

            //# id :: Category c => TypeRep c -> c
            //.
            //. [Type-safe][sanctuary-def] version of [`Z.id`][].
            //.
            //. ```javascript
            //. > S.id (Function) (42)
            //. 42
            //. ```
            _.id = {
              consts: { c: [Z.Category] },
              types: [TypeRep(c), c],
              impl: Z.id,
            };

            //# concat :: Semigroup a => a -> a -> a
            //.
            //. Curried version of [`Z.concat`][].
            //.
            //. ```javascript
            //. > S.concat ('abc') ('def')
            //. 'abcdef'
            //.
            //. > S.concat ([1, 2, 3]) ([4, 5, 6])
            //. [1, 2, 3, 4, 5, 6]
            //.
            //. > S.concat ({x: 1, y: 2}) ({y: 3, z: 4})
            //. {x: 1, y: 3, z: 4}
            //.
            //. > S.concat (S.Just ([1, 2, 3])) (S.Just ([4, 5, 6]))
            //. Just ([1, 2, 3, 4, 5, 6])
            //.
            //. > S.concat (Sum (18)) (Sum (24))
            //. Sum (42)
            //. ```
            _.concat = {
              consts: { a: [Z.Semigroup] },
              types: [a, a, a],
              impl: curry2(Z.concat),
            };

            //# empty :: Monoid a => TypeRep a -> a
            //.
            //. [Type-safe][sanctuary-def] version of [`Z.empty`][].
            //.
            //. ```javascript
            //. > S.empty (String)
            //. ''
            //.
            //. > S.empty (Array)
            //. []
            //.
            //. > S.empty (Object)
            //. {}
            //.
            //. > S.empty (Sum)
            //. Sum (0)
            //. ```
            _.empty = {
              consts: { a: [Z.Monoid] },
              types: [TypeRep(a), a],
              impl: Z.empty,
            };

            //# invert :: Group g => g -> g
            //.
            //. [Type-safe][sanctuary-def] version of [`Z.invert`][].
            //.
            //. ```javascript
            //. > S.invert (Sum (5))
            //. Sum (-5)
            //. ```
            _.invert = {
              consts: { g: [Z.Group] },
              types: [g, g],
              impl: Z.invert,
            };

            //# filter :: Filterable f => (a -> Boolean) -> f a -> f a
            //.
            //. Curried version of [`Z.filter`][]. Discards every element which does not
            //. satisfy the predicate.
            //.
            //. See also [`reject`](#reject).
            //.
            //. ```javascript
            //. > S.filter (S.odd) ([1, 2, 3])
            //. [1, 3]
            //.
            //. > S.filter (S.odd) ({x: 1, y: 2, z: 3})
            //. {x: 1, z: 3}
            //.
            //. > S.filter (S.odd) (S.Nothing)
            //. Nothing
            //.
            //. > S.filter (S.odd) (S.Just (0))
            //. Nothing
            //.
            //. > S.filter (S.odd) (S.Just (1))
            //. Just (1)
            //. ```
            function filter(pred) {
              return function(filterable) {
                return Z.filter(pred, filterable);
              };
            }
            _.filter = {
              consts: { f: [Z.Filterable] },
              types: [$.Predicate(a), f(a), f(a)],
              impl: filter,
            };

            //# reject :: Filterable f => (a -> Boolean) -> f a -> f a
            //.
            //. Curried version of [`Z.reject`][]. Discards every element which satisfies
            //. the predicate.
            //.
            //. See also [`filter`](#filter).
            //.
            //. ```javascript
            //. > S.reject (S.odd) ([1, 2, 3])
            //. [2]
            //.
            //. > S.reject (S.odd) ({x: 1, y: 2, z: 3})
            //. {y: 2}
            //.
            //. > S.reject (S.odd) (S.Nothing)
            //. Nothing
            //.
            //. > S.reject (S.odd) (S.Just (0))
            //. Just (0)
            //.
            //. > S.reject (S.odd) (S.Just (1))
            //. Nothing
            //. ```
            _.reject = {
              consts: { f: [Z.Filterable] },
              types: [$.Predicate(a), f(a), f(a)],
              impl: curry2(Z.reject),
            };

            //# takeWhile :: Filterable f => (a -> Boolean) -> f a -> f a
            //.
            //. Curried version of [`Z.takeWhile`][]. Discards the first element which
            //. does not satisfy the predicate, and all subsequent elements.
            //.
            //. See also [`dropWhile`](#dropWhile).
            //.
            //. ```javascript
            //. > S.takeWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])
            //. [3, 3, 3, 7]
            //.
            //. > S.takeWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])
            //. []
            //. ```
            _.takeWhile = {
              consts: { f: [Z.Filterable] },
              types: [$.Predicate(a), f(a), f(a)],
              impl: curry2(Z.takeWhile),
            };

            //# dropWhile :: Filterable f => (a -> Boolean) -> f a -> f a
            //.
            //. Curried version of [`Z.dropWhile`][]. Retains the first element which
            //. does not satisfy the predicate, and all subsequent elements.
            //.
            //. See also [`takeWhile`](#takeWhile).
            //.
            //. ```javascript
            //. > S.dropWhile (S.odd) ([3, 3, 3, 7, 6, 3, 5, 4])
            //. [6, 3, 5, 4]
            //.
            //. > S.dropWhile (S.even) ([3, 3, 3, 7, 6, 3, 5, 4])
            //. [3, 3, 3, 7, 6, 3, 5, 4]
            //. ```
            _.dropWhile = {
              consts: { f: [Z.Filterable] },
              types: [$.Predicate(a), f(a), f(a)],
              impl: curry2(Z.dropWhile),
            };

            //# map :: Functor f => (a -> b) -> f a -> f b
            //.
            //. Curried version of [`Z.map`][].
            //.
            //. ```javascript
            //. > S.map (Math.sqrt) ([1, 4, 9])
            //. [1, 2, 3]
            //.
            //. > S.map (Math.sqrt) ({x: 1, y: 4, z: 9})
            //. {x: 1, y: 2, z: 3}
            //.
            //. > S.map (Math.sqrt) (S.Just (9))
            //. Just (3)
            //.
            //. > S.map (Math.sqrt) (S.Right (9))
            //. Right (3)
            //.
            //. > S.map (Math.sqrt) (S.Pair (99980001) (99980001))
            //. Pair (99980001) (9999)
            //. ```
            //.
            //. Replacing `Functor f => f` with `Function x` produces the B combinator
            //. from combinatory logic (i.e. [`compose`](#compose)):
            //.
            //.     Functor f => (a -> b) -> f a -> f b
            //.     (a -> b) -> Function x a -> Function x b
            //.     (a -> c) -> Function x a -> Function x c
            //.     (b -> c) -> Function x b -> Function x c
            //.     (b -> c) -> Function a b -> Function a c
            //.     (b -> c) -> (a -> b) -> (a -> c)
            //.
            //. ```javascript
            //. > S.map (Math.sqrt) (S.add (1)) (99)
            //. 10
            //. ```
            function map(f) {
              return function(functor) {
                return Z.map(f, functor);
              };
            }
            _.map = {
              consts: { f: [Z.Functor] },
              types: [Fn(a)(b), f(a), f(b)],
              impl: map,
            };

            //# flip :: Functor f => f (a -> b) -> a -> f b
            //.
            //. Curried version of [`Z.flip`][]. Maps over the given functions, applying
            //. each to the given value.
            //.
            //. Replacing `Functor f => f` with `Function x` produces the C combinator
            //. from combinatory logic:
            //.
            //.     Functor f => f (a -> b) -> a -> f b
            //.     Function x (a -> b) -> a -> Function x b
            //.     Function x (a -> c) -> a -> Function x c
            //.     Function x (b -> c) -> b -> Function x c
            //.     Function a (b -> c) -> b -> Function a c
            //.     (a -> b -> c) -> b -> a -> c
            //.
            //. ```javascript
            //. > S.flip (S.concat) ('!') ('foo')
            //. 'foo!'
            //.
            //. > S.flip ([Math.floor, Math.ceil]) (1.5)
            //. [1, 2]
            //.
            //. > S.flip ({floor: Math.floor, ceil: Math.ceil}) (1.5)
            //. {floor: 1, ceil: 2}
            //.
            //. > S.flip (Cons (Math.floor) (Cons (Math.ceil) (Nil))) (1.5)
            //. Cons (1) (Cons (2) (Nil))
            //. ```
            _.flip = {
              consts: { f: [Z.Functor] },
              types: [f(Fn(a)(b)), a, f(b)],
              impl: curry2(Z.flip),
            };

            //# bimap :: Bifunctor f => (a -> b) -> (c -> d) -> f a c -> f b d
            //.
            //. Curried version of [`Z.bimap`][].
            //.
            //. ```javascript
            //. > S.bimap (S.toUpper) (Math.sqrt) (S.Pair ('foo') (64))
            //. Pair ('FOO') (8)
            //.
            //. > S.bimap (S.toUpper) (Math.sqrt) (S.Left ('foo'))
            //. Left ('FOO')
            //.
            //. > S.bimap (S.toUpper) (Math.sqrt) (S.Right (64))
            //. Right (8)
            //. ```
            _.bimap = {
              consts: { p: [Z.Bifunctor] },
              types: [Fn(a)(b), Fn(c)(d), p(a)(c), p(b)(d)],
              impl: curry3(Z.bimap),
            };

            //# mapLeft :: Bifunctor f => (a -> b) -> f a c -> f b c
            //.
            //. Curried version of [`Z.mapLeft`][]. Maps the given function over the left
            //. side of a Bifunctor.
            //.
            //. ```javascript
            //. > S.mapLeft (S.toUpper) (S.Pair ('foo') (64))
            //. Pair ('FOO') (64)
            //.
            //. > S.mapLeft (S.toUpper) (S.Left ('foo'))
            //. Left ('FOO')
            //.
            //. > S.mapLeft (S.toUpper) (S.Right (64))
            //. Right (64)
            //. ```
            _.mapLeft = {
              consts: { p: [Z.Bifunctor] },
              types: [Fn(a)(b), p(a)(c), p(b)(c)],
              impl: curry2(Z.mapLeft),
            };

            //# promap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
            //.
            //. Curried version of [`Z.promap`][].
            //.
            //. ```javascript
            //. > S.promap (Math.abs) (S.add (1)) (Math.sqrt) (-100)
            //. 11
            //. ```
            _.promap = {
              consts: { p: [Z.Profunctor] },
              types: [Fn(a)(b), Fn(c)(d), p(b)(c), p(a)(d)],
              impl: curry3(Z.promap),
            };

            //# alt :: Alt f => f a -> f a -> f a
            //.
            //. Curried version of [`Z.alt`][].
            //.
            //. ```javascript
            //. > S.alt (S.Nothing) (S.Just (1))
            //. Just (1)
            //.
            //. > S.alt (S.Just (2)) (S.Just (3))
            //. Just (2)
            //.
            //. > S.alt (S.Left ('X')) (S.Right (1))
            //. Right (1)
            //.
            //. > S.alt (S.Right (2)) (S.Right (3))
            //. Right (2)
            //. ```
            _.alt = {
              consts: { f: [Z.Alt] },
              types: [f(a), f(a), f(a)],
              impl: curry2(Z.alt),
            };

            //# zero :: Plus f => TypeRep f -> f a
            //.
            //. [Type-safe][sanctuary-def] version of [`Z.zero`][].
            //.
            //. ```javascript
            //. > S.zero (Array)
            //. []
            //.
            //. > S.zero (Object)
            //. {}
            //.
            //. > S.zero (S.Maybe)
            //. Nothing
            //. ```
            _.zero = {
              consts: { f: [Z.Plus] },
              types: [TypeRep($.TypeVariable("f")), f(a)],
              impl: Z.zero,
            };

            //# reduce :: Foldable f => (b -> a -> b) -> b -> f a -> b
            //.
            //. Takes a curried binary function, an initial value, and a [Foldable][],
            //. and applies the function to the initial value and the Foldable's first
            //. value, then applies the function to the result of the previous
            //. application and the Foldable's second value. Repeats this process
            //. until each of the Foldable's values has been used. Returns the initial
            //. value if the Foldable is empty; the result of the final application
            //. otherwise.
            //.
            //. ```javascript
            //. > S.reduce (S.add) (0) ([1, 2, 3, 4, 5])
            //. 15
            //.
            //. > S.reduce (xs => x => S.prepend (x) (xs)) ([]) ([1, 2, 3, 4, 5])
            //. [5, 4, 3, 2, 1]
            //. ```
            function reduce(f) {
              return function(initial) {
                return function(foldable) {
                  return Z.reduce(
                    function(y, x) {
                      return f(y)(x);
                    },
                    initial,
                    foldable
                  );
                };
              };
            }
            _.reduce = {
              consts: { f: [Z.Foldable] },
              types: [Fn(a)(Fn(b)(a)), a, f(b), a],
              impl: reduce,
            };

            //# traverse :: (Applicative f, Traversable t) => TypeRep f -> (a -> f b) -> t a -> f (t b)
            //.
            //. Curried version of [`Z.traverse`][].
            //.
            //. ```javascript
            //. > S.traverse (Array) (S.words) (S.Just ('foo bar baz'))
            //. [Just ('foo'), Just ('bar'), Just ('baz')]
            //.
            //. > S.traverse (Array) (S.words) (S.Nothing)
            //. [Nothing]
            //.
            //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C'])
            //. Just ([10, 11, 12])
            //.
            //. > S.traverse (S.Maybe) (S.parseInt (16)) (['A', 'B', 'C', 'X'])
            //. Nothing
            //.
            //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C'})
            //. Just ({a: 10, b: 11, c: 12})
            //.
            //. > S.traverse (S.Maybe) (S.parseInt (16)) ({a: 'A', b: 'B', c: 'C', x: 'X'})
            //. Nothing
            //. ```
            _.traverse = {
              consts: { f: [Z.Applicative], t: [Z.Traversable] },
              types: [TypeRep($.TypeVariable("f")), Fn(a)(f(b)), t(a), f(t(b))],
              impl: curry3(Z.traverse),
            };

            //# sequence :: (Applicative f, Traversable t) => TypeRep f -> t (f a) -> f (t a)
            //.
            //. Curried version of [`Z.sequence`][]. Inverts the given `t (f a)`
            //. to produce an `f (t a)`.
            //.
            //. ```javascript
            //. > S.sequence (Array) (S.Just ([1, 2, 3]))
            //. [Just (1), Just (2), Just (3)]
            //.
            //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Just (3)])
            //. Just ([1, 2, 3])
            //.
            //. > S.sequence (S.Maybe) ([S.Just (1), S.Just (2), S.Nothing])
            //. Nothing
            //.
            //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Just (3)})
            //. Just ({a: 1, b: 2, c: 3})
            //.
            //. > S.sequence (S.Maybe) ({a: S.Just (1), b: S.Just (2), c: S.Nothing})
            //. Nothing
            //. ```
            _.sequence = {
              consts: { f: [Z.Applicative], t: [Z.Traversable] },
              types: [TypeRep($.TypeVariable("f")), t(f(a)), f(t(a))],
              impl: curry2(Z.sequence),
            };

            //# ap :: Apply f => f (a -> b) -> f a -> f b
            //.
            //. Curried version of [`Z.ap`][].
            //.
            //. ```javascript
            //. > S.ap ([Math.sqrt, x => x * x]) ([1, 4, 9, 16, 25])
            //. [1, 2, 3, 4, 5, 1, 16, 81, 256, 625]
            //.
            //. > S.ap ({x: Math.sqrt, y: S.add (1), z: S.sub (1)}) ({w: 4, x: 4, y: 4})
            //. {x: 2, y: 5}
            //.
            //. > S.ap (S.Just (Math.sqrt)) (S.Just (64))
            //. Just (8)
            //. ```
            //.
            //. Replacing `Apply f => f` with `Function x` produces the S combinator
            //. from combinatory logic:
            //.
            //.     Apply f => f (a -> b) -> f a -> f b
            //.     Function x (a -> b) -> Function x a -> Function x b
            //.     Function x (a -> c) -> Function x a -> Function x c
            //.     Function x (b -> c) -> Function x b -> Function x c
            //.     Function a (b -> c) -> Function a b -> Function a c
            //.     (a -> b -> c) -> (a -> b) -> (a -> c)
            //.
            //. ```javascript
            //. > S.ap (s => n => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('Haskell')
            //. 'Hask'
            //. ```
            _.ap = {
              consts: { f: [Z.Apply] },
              types: [f(Fn(a)(b)), f(a), f(b)],
              impl: curry2(Z.ap),
            };

            //# lift2 :: Apply f => (a -> b -> c) -> f a -> f b -> f c
            //.
            //. Promotes a curried binary function to a function which operates on two
            //. [Apply][]s.
            //.
            //. ```javascript
            //. > S.lift2 (S.add) (S.Just (2)) (S.Just (3))
            //. Just (5)
            //.
            //. > S.lift2 (S.add) (S.Just (2)) (S.Nothing)
            //. Nothing
            //.
            //. > S.lift2 (S.and) (S.Just (true)) (S.Just (true))
            //. Just (true)
            //.
            //. > S.lift2 (S.and) (S.Just (true)) (S.Just (false))
            //. Just (false)
            //. ```
            _.lift2 = {
              consts: { f: [Z.Apply] },
              types: [Fn(a)(Fn(b)(c)), f(a), f(b), f(c)],
              impl: curry3(Z.lift2),
            };

            //# lift3 :: Apply f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
            //.
            //. Promotes a curried ternary function to a function which operates on three
            //. [Apply][]s.
            //.
            //. ```javascript
            //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Just ([1, 2, 3]))
            //. Just (6)
            //.
            //. > S.lift3 (S.reduce) (S.Just (S.add)) (S.Just (0)) (S.Nothing)
            //. Nothing
            //. ```
            _.lift3 = {
              consts: { f: [Z.Apply] },
              types: [Fn(a)(Fn(b)(Fn(c)(d))), f(a), f(b), f(c), f(d)],
              impl: curry4(Z.lift3),
            };

            //# apFirst :: Apply f => f a -> f b -> f a
            //.
            //. Curried version of [`Z.apFirst`][]. Combines two effectful actions,
            //. keeping only the result of the first. Equivalent to Haskell's `(<*)`
            //. function.
            //.
            //. See also [`apSecond`](#apSecond).
            //.
            //. ```javascript
            //. > S.apFirst ([1, 2]) ([3, 4])
            //. [1, 1, 2, 2]
            //.
            //. > S.apFirst (S.Just (1)) (S.Just (2))
            //. Just (1)
            //. ```
            _.apFirst = {
              consts: { f: [Z.Apply] },
              types: [f(a), f(b), f(a)],
              impl: curry2(Z.apFirst),
            };

            //# apSecond :: Apply f => f a -> f b -> f b
            //.
            //. Curried version of [`Z.apSecond`][]. Combines two effectful actions,
            //. keeping only the result of the second. Equivalent to Haskell's `(*>)`
            //. function.
            //.
            //. See also [`apFirst`](#apFirst).
            //.
            //. ```javascript
            //. > S.apSecond ([1, 2]) ([3, 4])
            //. [3, 4, 3, 4]
            //.
            //. > S.apSecond (S.Just (1)) (S.Just (2))
            //. Just (2)
            //. ```
            _.apSecond = {
              consts: { f: [Z.Apply] },
              types: [f(a), f(b), f(b)],
              impl: curry2(Z.apSecond),
            };

            //# of :: Applicative f => TypeRep f -> a -> f a
            //.
            //. Curried version of [`Z.of`][].
            //.
            //. ```javascript
            //. > S.of (Array) (42)
            //. [42]
            //.
            //. > S.of (Function) (42) (null)
            //. 42
            //.
            //. > S.of (S.Maybe) (42)
            //. Just (42)
            //.
            //. > S.of (S.Either) (42)
            //. Right (42)
            //. ```
            function of(typeRep) {
              return function(x) {
                return Z.of(typeRep, x);
              };
            }
            _.of = {
              consts: { f: [Z.Applicative] },
              types: [TypeRep($.TypeVariable("f")), a, f(a)],
              impl: of,
            };

            //# chain :: Chain m => (a -> m b) -> m a -> m b
            //.
            //. Curried version of [`Z.chain`][].
            //.
            //. ```javascript
            //. > S.chain (x => [x, x]) ([1, 2, 3])
            //. [1, 1, 2, 2, 3, 3]
            //.
            //. > S.chain (n => s => s.slice (0, n)) (s => Math.ceil (s.length / 2)) ('slice')
            //. 'sli'
            //.
            //. > S.chain (S.parseInt (10)) (S.Just ('123'))
            //. Just (123)
            //.
            //. > S.chain (S.parseInt (10)) (S.Just ('XXX'))
            //. Nothing
            //. ```
            _.chain = {
              consts: { m: [Z.Chain] },
              types: [Fn(a)(m(b)), m(a), m(b)],
              impl: curry2(Z.chain),
            };

            //# join :: Chain m => m (m a) -> m a
            //.
            //. [Type-safe][sanctuary-def] version of [`Z.join`][].
            //. Removes one level of nesting from a nested monadic structure.
            //.
            //. ```javascript
            //. > S.join ([[1], [2], [3]])
            //. [1, 2, 3]
            //.
            //. > S.join ([[[1, 2, 3]]])
            //. [[1, 2, 3]]
            //.
            //. > S.join (S.Just (S.Just (1)))
            //. Just (1)
            //.
            //. > S.join (S.Pair ('foo') (S.Pair ('bar') ('baz')))
            //. Pair ('foobar') ('baz')
            //. ```
            //.
            //. Replacing `Chain m => m` with `Function x` produces the W combinator
            //. from combinatory logic:
            //.
            //.     Chain m => m (m a) -> m a
            //.     Function x (Function x a) -> Function x a
            //.     (x -> x -> a) -> (x -> a)
            //.
            //. ```javascript
            //. > S.join (S.concat) ('abc')
            //. 'abcabc'
            //. ```
            _.join = {
              consts: { m: [Z.Chain] },
              types: [m(m(a)), m(a)],
              impl: Z.join,
            };

            //# chainRec :: ChainRec m => TypeRep m -> (a -> m (Either a b)) -> a -> m b
            //.
            //. Performs a [`chain`](#chain)-like computation with constant stack usage.
            //. Similar to [`Z.chainRec`][], but curried and more convenient due to the
            //. use of the Either type to indicate completion (via a Right).
            //.
            //. ```javascript
            //. > S.chainRec (Array)
            //. .            (s => s.length === 2 ? S.map (S.Right) ([s + '!', s + '?'])
            //. .                                 : S.map (S.Left) ([s + 'o', s + 'n']))
            //. .            ('')
            //. ['oo!', 'oo?', 'on!', 'on?', 'no!', 'no?', 'nn!', 'nn?']
            //. ```
            function chainRec(typeRep) {
              return function(f) {
                return function(x) {
                  return Z.chainRec(typeRep, step, x);
                };
                function step(next, done, x) {
                  return Z.map(either(next)(done), f(x));
                }
              };
            }
            _.chainRec = {
              consts: { m: [Z.ChainRec] },
              types: [
                TypeRep($.TypeVariable("m")),
                Fn(a)(m($Either(a)(b))),
                a,
                m(b),
              ],
              impl: chainRec,
            };

            //# extend :: Extend w => (w a -> b) -> w a -> w b
            //.
            //. Curried version of [`Z.extend`][].
            //.
            //. ```javascript
            //. > S.extend (S.joinWith ('')) (['x', 'y', 'z'])
            //. ['xyz', 'yz', 'z']
            //.
            //. > S.extend (f => f ([3, 4])) (S.reverse) ([1, 2])
            //. [4, 3, 2, 1]
            //. ```
            _.extend = {
              consts: { w: [Z.Extend] },
              types: [Fn(w(a))(b), w(a), w(b)],
              impl: curry2(Z.extend),
            };

            //# duplicate :: Extend w => w a -> w (w a)
            //.
            //. [Type-safe][sanctuary-def] version of [`Z.duplicate`][].
            //. Adds one level of nesting to a comonadic structure.
            //.
            //. ```javascript
            //. > S.duplicate (S.Just (1))
            //. Just (Just (1))
            //.
            //. > S.duplicate ([1])
            //. [[1]]
            //.
            //. > S.duplicate ([1, 2, 3])
            //. [[1, 2, 3], [2, 3], [3]]
            //.
            //. > S.duplicate (S.reverse) ([1, 2]) ([3, 4])
            //. [4, 3, 2, 1]
            //. ```
            _.duplicate = {
              consts: { w: [Z.Extend] },
              types: [w(a), w(w(a))],
              impl: Z.duplicate,
            };

            //# extract :: Comonad w => w a -> a
            //.
            //. [Type-safe][sanctuary-def] version of [`Z.extract`][].
            //.
            //. ```javascript
            //. > S.extract (S.Pair ('foo') ('bar'))
            //. 'bar'
            //. ```
            _.extract = {
              consts: { w: [Z.Comonad] },
              types: [w(a), a],
              impl: Z.extract,
            };

            //# contramap :: Contravariant f => (b -> a) -> f a -> f b
            //.
            //. [Type-safe][sanctuary-def] version of [`Z.contramap`][].
            //.
            //. ```javascript
            //. > S.contramap (s => s.length) (Math.sqrt) ('Sanctuary')
            //. 3
            //. ```
            _.contramap = {
              consts: { f: [Z.Contravariant] },
              types: [Fn(b)(a), f(a), f(b)],
              impl: curry2(Z.contramap),
            };

            //. ### Combinator

            //# I :: a -> a
            //.
            //. The I combinator. Returns its argument. Equivalent to Haskell's `id`
            //. function.
            //.
            //. ```javascript
            //. > S.I ('foo')
            //. 'foo'
            //. ```
            function I(x) {
              return x;
            }
            _.I = {
              consts: {},
              types: [a, a],
              impl: I,
            };

            //# K :: a -> b -> a
            //.
            //. The K combinator. Takes two values and returns the first. Equivalent to
            //. Haskell's `const` function.
            //.
            //. ```javascript
            //. > S.K ('foo') ('bar')
            //. 'foo'
            //.
            //. > S.map (S.K (42)) (S.range (0) (5))
            //. [42, 42, 42, 42, 42]
            //. ```
            function K(x) {
              return function(y) {
                return x;
              };
            }
            _.K = {
              consts: {},
              types: [a, b, a],
              impl: K,
            };

            //# T :: a -> (a -> b) -> b
            //.
            //. The T ([thrush][]) combinator. Takes a value and a function, and returns
            //. the result of applying the function to the value. Equivalent to Haskell's
            //. `(&)` function.
            //.
            //. ```javascript
            //. > S.T (42) (S.add (1))
            //. 43
            //.
            //. > S.map (S.T (100)) ([S.add (1), Math.sqrt])
            //. [101, 10]
            //. ```
            function T(x) {
              return function(f) {
                return f(x);
              };
            }
            _.T = {
              consts: {},
              types: [a, Fn(a)(b), b],
              impl: T,
            };

            //. ### Function

            //# curry2 :: ((a, b) -> c) -> a -> b -> c
            //.
            //. Curries the given binary function.
            //.
            //. ```javascript
            //. > S.map (S.curry2 (Math.pow) (10)) ([1, 2, 3])
            //. [10, 100, 1000]
            //. ```
            function curry2(f) {
              return function(x) {
                return function(y) {
                  return f(x, y);
                };
              };
            }
            _.curry2 = {
              consts: {},
              types: [$.Function([a, b, c]), a, b, c],
              impl: curry2,
            };

            //# curry3 :: ((a, b, c) -> d) -> a -> b -> c -> d
            //.
            //. Curries the given ternary function.
            //.
            //. ```javascript
            //. > const replaceString = S.curry3 ((what, replacement, string) =>
            //. .   string.replace (what, replacement)
            //. . )
            //.
            //. > replaceString ('banana') ('orange') ('banana icecream')
            //. 'orange icecream'
            //. ```
            function curry3(f) {
              return function(x) {
                return function(y) {
                  return function(z) {
                    return f(x, y, z);
                  };
                };
              };
            }
            _.curry3 = {
              consts: {},
              types: [$.Function([a, b, c, d]), a, b, c, d],
              impl: curry3,
            };

            //# curry4 :: ((a, b, c, d) -> e) -> a -> b -> c -> d -> e
            //.
            //. Curries the given quaternary function.
            //.
            //. ```javascript
            //. > const createRect = S.curry4 ((x, y, width, height) =>
            //. .   ({x, y, width, height})
            //. . )
            //.
            //. > createRect (0) (0) (10) (10)
            //. {x: 0, y: 0, width: 10, height: 10}
            //. ```
            function curry4(f) {
              return function(w) {
                return function(x) {
                  return function(y) {
                    return function(z) {
                      return f(w, x, y, z);
                    };
                  };
                };
              };
            }
            _.curry4 = {
              consts: {},
              types: [$.Function([a, b, c, d, e]), a, b, c, d, e],
              impl: curry4,
            };

            //# curry5 :: ((a, b, c, d, e) -> f) -> a -> b -> c -> d -> e -> f
            //.
            //. Curries the given quinary function.
            //.
            //. ```javascript
            //. > const toUrl = S.curry5 ((protocol, creds, hostname, port, pathname) =>
            //. .   protocol + '//' +
            //. .   S.maybe ('') (S.flip (S.concat) ('@')) (creds) +
            //. .   hostname +
            //. .   S.maybe ('') (S.concat (':')) (port) +
            //. .   pathname
            //. . )
            //.
            //. > toUrl ('https:') (S.Nothing) ('example.com') (S.Just ('443')) ('/foo/bar')
            //. 'https://example.com:443/foo/bar'
            //. ```
            function curry5(f) {
              return function(v) {
                return function(w) {
                  return function(x) {
                    return function(y) {
                      return function(z) {
                        return f(v, w, x, y, z);
                      };
                    };
                  };
                };
              };
            }
            _.curry5 = {
              consts: {},
              types: [$.Function([a, b, c, d, e, r]), a, b, c, d, e, r],
              impl: curry5,
            };

            //. ### Composition

            //# compose :: Semigroupoid s => s b c -> s a b -> s a c
            //.
            //. Curried version of [`Z.compose`][].
            //.
            //. When specialized to Function, `compose` composes two unary functions,
            //. from right to left (this is the B combinator from combinatory logic).
            //.
            //. The generalized type signature indicates that `compose` is compatible
            //. with any [Semigroupoid][].
            //.
            //. See also [`pipe`](#pipe).
            //.
            //. ```javascript
            //. > S.compose (Math.sqrt) (S.add (1)) (99)
            //. 10
            //. ```
            _.compose = {
              consts: { s: [Z.Semigroupoid] },
              types: [s(b)(c), s(a)(b), s(a)(c)],
              impl: curry2(Z.compose),
            };

            //# pipe :: Foldable f => f (Any -> Any) -> a -> b
            //.
            //. Takes a sequence of functions assumed to be unary and a value of any
            //. type, and returns the result of applying the sequence of transformations
            //. to the initial value.
            //.
            //. In general terms, `pipe` performs left-to-right composition of a sequence
            //. of functions. `pipe ([f, g, h]) (x)` is equivalent to `h (g (f (x)))`.
            //.
            //. ```javascript
            //. > S.pipe ([S.add (1), Math.sqrt, S.sub (1)]) (99)
            //. 9
            //. ```
            function pipe(fs) {
              return function(x) {
                return reduce(T)(x)(fs);
              };
            }
            _.pipe = {
              consts: { f: [Z.Foldable] },
              types: [f(Fn($.Any)($.Any)), a, b],
              impl: pipe,
            };

            //# pipeK :: (Foldable f, Chain m) => f (Any -> m Any) -> m a -> m b
            //.
            //. Takes a sequence of functions assumed to be unary which return values
            //. with a [Chain][], and a value of that Chain, and returns the result
            //. of applying the sequence of transformations to the initial value.
            //.
            //. In general terms, `pipeK` performs left-to-right [Kleisli][] composition
            //. of an sequence of functions. `pipeK ([f, g, h]) (x)` is equivalent to
            //. `chain (h) (chain (g) (chain (f) (x)))`.
            //.
            //. ```javascript
            //. > S.pipeK ([S.tail, S.tail, S.head]) (S.Just ([1, 2, 3, 4]))
            //. Just (3)
            //. ```
            function pipeK(fs) {
              return function(x) {
                return Z.reduce(
                  function(x, f) {
                    return Z.chain(f, x);
                  },
                  x,
                  fs
                );
              };
            }
            _.pipeK = {
              consts: { f: [Z.Foldable], m: [Z.Chain] },
              types: [f(Fn($.Any)(m($.Any))), m(a), m(b)],
              impl: pipeK,
            };

            //# on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
            //.
            //. Takes a binary function `f`, a unary function `g`, and two
            //. values `x` and `y`. Returns `f (g (x)) (g (y))`.
            //.
            //. This is the P combinator from combinatory logic.
            //.
            //. ```javascript
            //. > S.on (S.concat) (S.reverse) ([1, 2, 3]) ([4, 5, 6])
            //. [3, 2, 1, 6, 5, 4]
            //. ```
            function on(f) {
              return function(g) {
                return function(x) {
                  return function(y) {
                    return f(g(x))(g(y));
                  };
                };
              };
            }
            _.on = {
              consts: {},
              types: [Fn(b)(Fn(b)(c)), Fn(a)(b), a, a, c],
              impl: on,
            };

            //. ### Pair type
            //.
            //. Pair is the canonical product type: a value of type `Pair a b` always
            //. contains exactly two values: one of type `a`; one of type `b`.
            //.
            //. The implementation is provided by [sanctuary-pair][].

            //# PairType :: Type -> Type -> Type
            //.
            //. A [`BinaryType`][BinaryType] for use with [sanctuary-def][].

            //# Pair :: a -> b -> Pair a b
            //.
            //. Pair's sole data constructor. Additionally, it serves as the
            //. Pair [type representative][].
            //.
            //. ```javascript
            //. > S.Pair ('foo') (42)
            //. Pair ('foo') (42)
            //. ```
            _.Pair = {
              consts: {},
              types: [a, b, $Pair(a)(b)],
              impl: Pair,
            };

            //# fst :: Pair a b -> a
            //.
            //. `fst (Pair (x) (y))` is equivalent to `x`.
            //.
            //. ```javascript
            //. > S.fst (S.Pair ('foo') (42))
            //. 'foo'
            //. ```
            _.fst = {
              consts: {},
              types: [$Pair(a)(b), a],
              impl: Pair.fst,
            };

            //# snd :: Pair a b -> b
            //.
            //. `snd (Pair (x) (y))` is equivalent to `y`.
            //.
            //. ```javascript
            //. > S.snd (S.Pair ('foo') (42))
            //. 42
            //. ```
            _.snd = {
              consts: {},
              types: [$Pair(a)(b), b],
              impl: Pair.snd,
            };

            //# swap :: Pair a b -> Pair b a
            //.
            //. `swap (Pair (x) (y))` is equivalent to `Pair (y) (x)`.
            //.
            //. ```javascript
            //. > S.swap (S.Pair ('foo') (42))
            //. Pair (42) ('foo')
            //. ```
            _.swap = {
              consts: {},
              types: [$Pair(a)(b), $Pair(b)(a)],
              impl: Pair.swap,
            };

            //. ### Maybe type
            //.
            //. The Maybe type represents optional values: a value of type `Maybe a` is
            //. either Nothing (the empty value) or a Just whose value is of type `a`.
            //.
            //. The implementation is provided by [sanctuary-maybe][].

            //# MaybeType :: Type -> Type
            //.
            //. A [`UnaryType`][UnaryType] for use with [sanctuary-def][].

            //# Maybe :: TypeRep Maybe
            //.
            //. Maybe [type representative][].

            //# Nothing :: Maybe a
            //.
            //. The empty value of type `Maybe a`.
            //.
            //. ```javascript
            //. > S.Nothing
            //. Nothing
            //. ```

            //# Just :: a -> Maybe a
            //.
            //. Constructs a value of type `Maybe a` from a value of type `a`.
            //.
            //. ```javascript
            //. > S.Just (42)
            //. Just (42)
            //. ```
            _.Just = {
              consts: {},
              types: [a, $Maybe(a)],
              impl: Just,
            };

            //# isNothing :: Maybe a -> Boolean
            //.
            //. Returns `true` if the given Maybe is Nothing; `false` if it is a Just.
            //.
            //. ```javascript
            //. > S.isNothing (S.Nothing)
            //. true
            //.
            //. > S.isNothing (S.Just (42))
            //. false
            //. ```
            function isNothing(maybe) {
              return maybe.isNothing;
            }
            _.isNothing = {
              consts: {},
              types: [$Maybe(a), $.Boolean],
              impl: isNothing,
            };

            //# isJust :: Maybe a -> Boolean
            //.
            //. Returns `true` if the given Maybe is a Just; `false` if it is Nothing.
            //.
            //. ```javascript
            //. > S.isJust (S.Just (42))
            //. true
            //.
            //. > S.isJust (S.Nothing)
            //. false
            //. ```
            function isJust(maybe) {
              return maybe.isJust;
            }
            _.isJust = {
              consts: {},
              types: [$Maybe(a), $.Boolean],
              impl: isJust,
            };

            //# fromMaybe :: a -> Maybe a -> a
            //.
            //. Takes a default value and a Maybe, and returns the Maybe's value
            //. if the Maybe is a Just; the default value otherwise.
            //.
            //. See also [`fromMaybe_`](#fromMaybe_) and
            //. [`maybeToNullable`](#maybeToNullable).
            //.
            //. ```javascript
            //. > S.fromMaybe (0) (S.Just (42))
            //. 42
            //.
            //. > S.fromMaybe (0) (S.Nothing)
            //. 0
            //. ```
            _.fromMaybe = {
              consts: {},
              types: [a, $Maybe(a), a],
              impl: C(maybe)(I),
            };

            //# fromMaybe_ :: (() -> a) -> Maybe a -> a
            //.
            //. Variant of [`fromMaybe`](#fromMaybe) which takes a thunk so the default
            //. value is only computed if required.
            //.
            //. ```javascript
            //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }
            //.
            //. > S.fromMaybe_ (() => fib (30)) (S.Just (1000000))
            //. 1000000
            //.
            //. > S.fromMaybe_ (() => fib (30)) (S.Nothing)
            //. 832040
            //. ```
            _.fromMaybe_ = {
              consts: {},
              types: [$.Thunk(a), $Maybe(a), a],
              impl: C(maybe_)(I),
            };

            //# maybeToNullable :: Maybe a -> Nullable a
            //.
            //. Returns the given Maybe's value if the Maybe is a Just; `null` otherwise.
            //. [Nullable][] is defined in [sanctuary-def][].
            //.
            //. See also [`fromMaybe`](#fromMaybe).
            //.
            //. ```javascript
            //. > S.maybeToNullable (S.Just (42))
            //. 42
            //.
            //. > S.maybeToNullable (S.Nothing)
            //. null
            //. ```
            function maybeToNullable(maybe) {
              return maybe.isJust ? maybe.value : null;
            }
            _.maybeToNullable = {
              consts: {},
              types: [$Maybe(a), $.Nullable(a)],
              impl: maybeToNullable,
            };

            //# toMaybe :: a? -> Maybe a
            //.
            //. Takes a value and returns Nothing if the value is `null` or `undefined`;
            //. Just the value otherwise.
            //.
            //. ```javascript
            //. > S.toMaybe (null)
            //. Nothing
            //.
            //. > S.toMaybe (42)
            //. Just (42)
            //. ```
            function toMaybe(x) {
              return x == null ? Nothing : Just(x);
            }
            _.toMaybe = {
              consts: {},
              types: [a, $Maybe(a)],
              impl: toMaybe,
            };

            //# maybe :: b -> (a -> b) -> Maybe a -> b
            //.
            //. Takes a value of any type, a function, and a Maybe. If the Maybe is
            //. a Just, the return value is the result of applying the function to
            //. the Just's value. Otherwise, the first argument is returned.
            //.
            //. See also [`maybe_`](#maybe_).
            //.
            //. ```javascript
            //. > S.maybe (0) (S.prop ('length')) (S.Just ('refuge'))
            //. 6
            //.
            //. > S.maybe (0) (S.prop ('length')) (S.Nothing)
            //. 0
            //. ```
            function maybe(x) {
              return function(f) {
                return function(maybe) {
                  return maybe.isJust ? f(maybe.value) : x;
                };
              };
            }
            _.maybe = {
              consts: {},
              types: [b, Fn(a)(b), $Maybe(a), b],
              impl: maybe,
            };

            //# maybe_ :: (() -> b) -> (a -> b) -> Maybe a -> b
            //.
            //. Variant of [`maybe`](#maybe) which takes a thunk so the default value
            //. is only computed if required.
            //.
            //. ```javascript
            //. > function fib(n) { return n <= 1 ? n : fib (n - 2) + fib (n - 1); }
            //.
            //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Just (1000000))
            //. 1000
            //.
            //. > S.maybe_ (() => fib (30)) (Math.sqrt) (S.Nothing)
            //. 832040
            //. ```
            function maybe_(thunk) {
              return function(f) {
                return function(maybe) {
                  return maybe.isJust ? f(maybe.value) : thunk();
                };
              };
            }
            _.maybe_ = {
              consts: {},
              types: [$.Thunk(b), Fn(a)(b), $Maybe(a), b],
              impl: maybe_,
            };

            //# justs :: (Filterable f, Functor f) => f (Maybe a) -> f a
            //.
            //. Discards each element which is Nothing, and unwraps each element which is
            //. a Just. Related to Haskell's `catMaybes` function.
            //.
            //. See also [`lefts`](#lefts) and [`rights`](#rights).
            //.
            //. ```javascript
            //. > S.justs ([S.Just ('foo'), S.Nothing, S.Just ('baz')])
            //. ['foo', 'baz']
            //. ```
            function justs(maybes) {
              return map(value)(filter(isJust)(maybes));
            }
            _.justs = {
              consts: { f: [Z.Filterable, Z.Functor] },
              types: [f($Maybe(a)), f(a)],
              impl: justs,
            };

            //# mapMaybe :: (Filterable f, Functor f) => (a -> Maybe b) -> f a -> f b
            //.
            //. Takes a function and a structure, applies the function to each element
            //. of the structure, and returns the "successful" results. If the result of
            //. applying the function to an element is Nothing, the result is discarded;
            //. if the result is a Just, the Just's value is included.
            //.
            //. ```javascript
            //. > S.mapMaybe (S.head) ([[], [1, 2, 3], [], [4, 5, 6], []])
            //. [1, 4]
            //.
            //. > S.mapMaybe (S.head) ({x: [1, 2, 3], y: [], z: [4, 5, 6]})
            //. {x: 1, z: 4}
            //. ```
            _.mapMaybe = {
              consts: { f: [Z.Filterable, Z.Functor] },
              types: [Fn(a)($Maybe(b)), f(a), f(b)],
              impl: B(B(justs))(map),
            };

            //# encase :: (a -> b) -> a -> Maybe b
            //.
            //. Takes a unary function `f` which may throw and a value `x` of any type,
            //. and applies `f` to `x` inside a `try` block. If an exception is caught,
            //. the return value is Nothing; otherwise the return value is Just the
            //. result of applying `f` to `x`.
            //.
            //. See also [`encaseEither`](#encaseEither).
            //.
            //. ```javascript
            //. > S.encase (eval) ('1 + 1')
            //. Just (2)
            //.
            //. > S.encase (eval) ('1 +')
            //. Nothing
            //. ```
            function encase(f) {
              return B(eitherToMaybe)(encaseEither(I)(f));
            }
            _.encase = {
              consts: {},
              types: [Fn(a)(b), a, $Maybe(b)],
              impl: encase,
            };

            //# encase2 :: (a -> b -> c) -> a -> b -> Maybe c
            //.
            //. Binary version of [`encase`](#encase).
            _.encase2 = {
              consts: {},
              types: [Fn(a)(Fn(b)(c)), a, b, $Maybe(c)],
              impl: B(B(B(eitherToMaybe)))(encaseEither2(I)),
            };

            //# encase3 :: (a -> b -> c -> d) -> a -> b -> c -> Maybe d
            //.
            //. Ternary version of [`encase`](#encase).
            _.encase3 = {
              consts: {},
              types: [Fn(a)(Fn(b)(Fn(c)(d))), a, b, c, $Maybe(d)],
              impl: B(B(B(B(eitherToMaybe))))(encaseEither3(I)),
            };

            //# maybeToEither :: a -> Maybe b -> Either a b
            //.
            //. Converts a Maybe to an Either. Nothing becomes a Left (containing the
            //. first argument); a Just becomes a Right.
            //.
            //. See also [`eitherToMaybe`](#eitherToMaybe).
            //.
            //. ```javascript
            //. > S.maybeToEither ('Expecting an integer') (S.parseInt (10) ('xyz'))
            //. Left ('Expecting an integer')
            //.
            //. > S.maybeToEither ('Expecting an integer') (S.parseInt (10) ('42'))
            //. Right (42)
            //. ```
            function maybeToEither(x) {
              return maybe(Left(x))(Right);
            }
            _.maybeToEither = {
              consts: {},
              types: [a, $Maybe(b), $Either(a)(b)],
              impl: maybeToEither,
            };

            //. ### Either type
            //.
            //. The Either type represents values with two possibilities: a value of type
            //. `Either a b` is either a Left whose value is of type `a` or a Right whose
            //. value is of type `b`.
            //.
            //. The implementation is provided by [sanctuary-either][].

            //# EitherType :: Type -> Type -> Type
            //.
            //. A [`BinaryType`][BinaryType] for use with [sanctuary-def][].

            //# Either :: TypeRep Either
            //.
            //. Either [type representative][].

            //# Left :: a -> Either a b
            //.
            //. Constructs a value of type `Either a b` from a value of type `a`.
            //.
            //. ```javascript
            //. > S.Left ('Cannot divide by zero')
            //. Left ('Cannot divide by zero')
            //. ```
            _.Left = {
              consts: {},
              types: [a, $Either(a)(b)],
              impl: Left,
            };

            //# Right :: b -> Either a b
            //.
            //. Constructs a value of type `Either a b` from a value of type `b`.
            //.
            //. ```javascript
            //. > S.Right (42)
            //. Right (42)
            //. ```
            _.Right = {
              consts: {},
              types: [b, $Either(a)(b)],
              impl: Right,
            };

            //# isLeft :: Either a b -> Boolean
            //.
            //. Returns `true` if the given Either is a Left; `false` if it is a Right.
            //.
            //. ```javascript
            //. > S.isLeft (S.Left ('Cannot divide by zero'))
            //. true
            //.
            //. > S.isLeft (S.Right (42))
            //. false
            //. ```
            function isLeft(either) {
              return either.isLeft;
            }
            _.isLeft = {
              consts: {},
              types: [$Either(a)(b), $.Boolean],
              impl: isLeft,
            };

            //# isRight :: Either a b -> Boolean
            //.
            //. Returns `true` if the given Either is a Right; `false` if it is a Left.
            //.
            //. ```javascript
            //. > S.isRight (S.Right (42))
            //. true
            //.
            //. > S.isRight (S.Left ('Cannot divide by zero'))
            //. false
            //. ```
            function isRight(either) {
              return either.isRight;
            }
            _.isRight = {
              consts: {},
              types: [$Either(a)(b), $.Boolean],
              impl: isRight,
            };

            //# fromEither :: b -> Either a b -> b
            //.
            //. Takes a default value and an Either, and returns the Right value
            //. if the Either is a Right; the default value otherwise.
            //.
            //. ```javascript
            //. > S.fromEither (0) (S.Right (42))
            //. 42
            //.
            //. > S.fromEither (0) (S.Left (42))
            //. 0
            //. ```
            function fromEither(x) {
              return either(K(x))(I);
            }
            _.fromEither = {
              consts: {},
              types: [b, $Either(a)(b), b],
              impl: fromEither,
            };

            //# toEither :: a -> b? -> Either a b
            //.
            //. Converts an arbitrary value to an Either: a Left if the value is `null`
            //. or `undefined`; a Right otherwise. The first argument specifies the
            //. value of the Left in the "failure" case.
            //.
            //. ```javascript
            //. > S.toEither ('XYZ') (null)
            //. Left ('XYZ')
            //.
            //. > S.toEither ('XYZ') ('ABC')
            //. Right ('ABC')
            //.
            //. > S.map (S.prop ('0'))
            //. .       (S.toEither ('Invalid protocol')
            //. .                   ('ftp://example.com/'.match (/^https?:/)))
            //. Left ('Invalid protocol')
            //.
            //. > S.map (S.prop ('0'))
            //. .       (S.toEither ('Invalid protocol')
            //. .                   ('https://example.com/'.match (/^https?:/)))
            //. Right ('https:')
            //. ```
            function toEither(x) {
              return function(y) {
                return y == null ? Left(x) : Right(y);
              };
            }
            _.toEither = {
              consts: {},
              types: [a, b, $Either(a)(b)],
              impl: toEither,
            };

            //# either :: (a -> c) -> (b -> c) -> Either a b -> c
            //.
            //. Takes two functions and an Either, and returns the result of
            //. applying the first function to the Left's value, if the Either
            //. is a Left, or the result of applying the second function to the
            //. Right's value, if the Either is a Right.
            //.
            //. ```javascript
            //. > S.either (S.toUpper) (S.show) (S.Left ('Cannot divide by zero'))
            //. 'CANNOT DIVIDE BY ZERO'
            //.
            //. > S.either (S.toUpper) (S.show) (S.Right (42))
            //. '42'
            //. ```
            function either(l) {
              return function(r) {
                return function(either) {
                  return (either.isLeft ? l : r)(either.value);
                };
              };
            }
            _.either = {
              consts: {},
              types: [Fn(a)(c), Fn(b)(c), $Either(a)(b), c],
              impl: either,
            };

            //# lefts :: (Filterable f, Functor f) => f (Either a b) -> f a
            //.
            //. Discards each element which is a Right, and unwraps each element which is
            //. a Left.
            //.
            //. See also [`rights`](#rights).
            //.
            //. ```javascript
            //. > S.lefts ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])
            //. ['foo', 'bar']
            //. ```
            _.lefts = {
              consts: { f: [Z.Filterable, Z.Functor] },
              types: [f($Either(a)(b)), f(a)],
              impl: B(map(value))(filter(isLeft)),
            };

            //# rights :: (Filterable f, Functor f) => f (Either a b) -> f b
            //.
            //. Discards each element which is a Left, and unwraps each element which is
            //. a Right.
            //.
            //. See also [`lefts`](#lefts).
            //.
            //. ```javascript
            //. > S.rights ([S.Right (20), S.Left ('foo'), S.Right (10), S.Left ('bar')])
            //. [20, 10]
            //. ```
            _.rights = {
              consts: { f: [Z.Filterable, Z.Functor] },
              types: [f($Either(a)(b)), f(b)],
              impl: B(map(value))(filter(isRight)),
            };

            //# tagBy :: (a -> Boolean) -> a -> Either a a
            //.
            //. Takes a predicate and a value, and returns a Right of the value if it
            //. satisfies the predicate; a Left of the value otherwise.
            //.
            //. ```javascript
            //. > S.tagBy (S.odd) (0)
            //. Left (0)
            //
            //. > S.tagBy (S.odd) (1)
            //. Right (1)
            //. ```
            function tagBy(pred) {
              return ifElse(pred)(Right)(Left);
            }
            _.tagBy = {
              consts: {},
              types: [$.Predicate(a), a, $Either(a)(a)],
              impl: tagBy,
            };

            //# encaseEither :: (Error -> l) -> (a -> r) -> a -> Either l r
            //.
            //. Takes two unary functions, `f` and `g`, the second of which may throw,
            //. and a value `x` of any type. Applies `g` to `x` inside a `try` block.
            //. If an exception is caught, the return value is a Left containing the
            //. result of applying `f` to the caught Error object; otherwise the return
            //. value is a Right containing the result of applying `g` to `x`.
            //.
            //. See also [`encase`](#encase).
            //.
            //. ```javascript
            //. > S.encaseEither (S.I) (JSON.parse) ('["foo","bar","baz"]')
            //. Right (['foo', 'bar', 'baz'])
            //.
            //. > S.encaseEither (S.I) (JSON.parse) ('[')
            //. Left (new SyntaxError ('Unexpected end of JSON input'))
            //.
            //. > S.encaseEither (S.prop ('message')) (JSON.parse) ('[')
            //. Left ('Unexpected end of JSON input')
            //. ```
            function encaseEither(f) {
              return function(g) {
                return function(x) {
                  try {
                    return Right(g(x));
                  } catch (err) {
                    return Left(f(err));
                  }
                };
              };
            }
            _.encaseEither = {
              consts: {},
              types: [Fn($.Error)(l), Fn(a)(r), a, $Either(l)(r)],
              impl: encaseEither,
            };

            //# encaseEither2 :: (Error -> l) -> (a -> b -> r) -> a -> b -> Either l r
            //.
            //. Binary version of [`encaseEither`](#encaseEither).
            function encaseEither2(f) {
              return function(g) {
                return function(x) {
                  return function(y) {
                    try {
                      return Right(g(x)(y));
                    } catch (err) {
                      return Left(f(err));
                    }
                  };
                };
              };
            }
            _.encaseEither2 = {
              consts: {},
              types: [Fn($.Error)(l), Fn(a)(Fn(b)(r)), a, b, $Either(l)(r)],
              impl: encaseEither2,
            };

            //# encaseEither3 :: (Error -> l) -> (a -> b -> c -> r) -> a -> b -> c -> Either l r
            //.
            //. Ternary version of [`encaseEither`](#encaseEither).
            function encaseEither3(f) {
              return function(g) {
                return function(x) {
                  return function(y) {
                    return function(z) {
                      try {
                        return Right(g(x)(y)(z));
                      } catch (err) {
                        return Left(f(err));
                      }
                    };
                  };
                };
              };
            }
            _.encaseEither3 = {
              consts: {},
              types: [
                Fn($.Error)(l),
                Fn(a)(Fn(b)(Fn(c)(r))),
                a,
                b,
                c,
                $Either(l)(r),
              ],
              impl: encaseEither3,
            };

            //# eitherToMaybe :: Either a b -> Maybe b
            //.
            //. Converts an Either to a Maybe. A Left becomes Nothing; a Right becomes
            //. a Just.
            //.
            //. See also [`maybeToEither`](#maybeToEither).
            //.
            //. ```javascript
            //. > S.eitherToMaybe (S.Left ('Cannot divide by zero'))
            //. Nothing
            //.
            //. > S.eitherToMaybe (S.Right (42))
            //. Just (42)
            //. ```
            function eitherToMaybe(either) {
              return either.isLeft ? Nothing : Just(either.value);
            }
            _.eitherToMaybe = {
              consts: {},
              types: [$Either(a)(b), $Maybe(b)],
              impl: eitherToMaybe,
            };

            //. ### Logic

            //# and :: Boolean -> Boolean -> Boolean
            //.
            //. Boolean "and".
            //.
            //. ```javascript
            //. > S.and (false) (false)
            //. false
            //.
            //. > S.and (false) (true)
            //. false
            //.
            //. > S.and (true) (false)
            //. false
            //.
            //. > S.and (true) (true)
            //. true
            //. ```
            function and(x) {
              return function(y) {
                return x && y;
              };
            }
            _.and = {
              consts: {},
              types: [$.Boolean, $.Boolean, $.Boolean],
              impl: and,
            };

            //# or :: Boolean -> Boolean -> Boolean
            //.
            //. Boolean "or".
            //.
            //. ```javascript
            //. > S.or (false) (false)
            //. false
            //.
            //. > S.or (false) (true)
            //. true
            //.
            //. > S.or (true) (false)
            //. true
            //.
            //. > S.or (true) (true)
            //. true
            //. ```
            function or(x) {
              return function(y) {
                return x || y;
              };
            }
            _.or = {
              consts: {},
              types: [$.Boolean, $.Boolean, $.Boolean],
              impl: or,
            };

            //# not :: Boolean -> Boolean
            //.
            //. Boolean "not".
            //.
            //. See also [`complement`](#complement).
            //.
            //. ```javascript
            //. > S.not (false)
            //. true
            //.
            //. > S.not (true)
            //. false
            //. ```
            function not(x) {
              return !x;
            }
            _.not = {
              consts: {},
              types: [$.Boolean, $.Boolean],
              impl: not,
            };

            //# complement :: (a -> Boolean) -> a -> Boolean
            //.
            //. Takes a unary predicate and a value of any type, and returns the logical
            //. negation of applying the predicate to the value.
            //.
            //. See also [`not`](#not).
            //.
            //. ```javascript
            //. > Number.isInteger (42)
            //. true
            //.
            //. > S.complement (Number.isInteger) (42)
            //. false
            //. ```
            _.complement = {
              consts: {},
              types: [$.Predicate(a), a, $.Boolean],
              impl: B(not),
            };

            //# ifElse :: (a -> Boolean) -> (a -> b) -> (a -> b) -> a -> b
            //.
            //. Takes a unary predicate, a unary "if" function, a unary "else"
            //. function, and a value of any type, and returns the result of
            //. applying the "if" function to the value if the value satisfies
            //. the predicate; the result of applying the "else" function to the
            //. value otherwise.
            //.
            //. See also [`when`](#when) and [`unless`](#unless).
            //.
            //. ```javascript
            //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (-1)
            //. 1
            //.
            //. > S.ifElse (x => x < 0) (Math.abs) (Math.sqrt) (16)
            //. 4
            //. ```
            function ifElse(pred) {
              return function(f) {
                return function(g) {
                  return function(x) {
                    return (pred(x) ? f : g)(x);
                  };
                };
              };
            }
            _.ifElse = {
              consts: {},
              types: [$.Predicate(a), Fn(a)(b), Fn(a)(b), a, b],
              impl: ifElse,
            };

            //# when :: (a -> Boolean) -> (a -> a) -> a -> a
            //.
            //. Takes a unary predicate, a unary function, and a value of any type, and
            //. returns the result of applying the function to the value if the value
            //. satisfies the predicate; the value otherwise.
            //.
            //. See also [`unless`](#unless) and [`ifElse`](#ifElse).
            //.
            //. ```javascript
            //. > S.when (x => x >= 0) (Math.sqrt) (16)
            //. 4
            //.
            //. > S.when (x => x >= 0) (Math.sqrt) (-1)
            //. -1
            //. ```
            function when(pred) {
              return C(ifElse(pred))(I);
            }
            _.when = {
              consts: {},
              types: [$.Predicate(a), Fn(a)(a), a, a],
              impl: when,
            };

            //# unless :: (a -> Boolean) -> (a -> a) -> a -> a
            //.
            //. Takes a unary predicate, a unary function, and a value of any type, and
            //. returns the result of applying the function to the value if the value
            //. does not satisfy the predicate; the value otherwise.
            //.
            //. See also [`when`](#when) and [`ifElse`](#ifElse).
            //.
            //. ```javascript
            //. > S.unless (x => x < 0) (Math.sqrt) (16)
            //. 4
            //.
            //. > S.unless (x => x < 0) (Math.sqrt) (-1)
            //. -1
            //. ```
            function unless(pred) {
              return ifElse(pred)(I);
            }
            _.unless = {
              consts: {},
              types: [$.Predicate(a), Fn(a)(a), a, a],
              impl: unless,
            };

            //# allPass :: Foldable f => f (a -> Boolean) -> a -> Boolean
            //.
            //. Takes a structure containing zero or more predicates, and a value
            //. of any type. Returns `true` [iff][] the value satisfies all of the
            //. predicates. None of the subsequent predicates will be applied after
            //. the first predicate not satisfied.
            //.
            //. ```javascript
            //. > S.allPass ([S.test (/q/), S.test (/u/), S.test (/i/)]) ('quiessence')
            //. true
            //.
            //. > S.allPass ([S.test (/q/), S.test (/u/), S.test (/i/)]) ('fissiparous')
            //. false
            //. ```
            function allPass(preds) {
              return function(x) {
                return Z.reduce(
                  function(b, p) {
                    return b && p(x);
                  },
                  true,
                  preds
                );
              };
            }
            _.allPass = {
              consts: { f: [Z.Foldable] },
              types: [f($.Predicate(a)), a, $.Boolean],
              impl: allPass,
            };

            //# anyPass :: Foldable f => f (a -> Boolean) -> a -> Boolean
            //.
            //. Takes a structure containing zero or more predicates, and a value
            //. of any type. Returns `true` [iff][] the value satisfies any of the
            //. predicates. None of the subsequent predicates will be applied after
            //. the first predicate satisfied.
            //.
            //. ```javascript
            //. > S.anyPass ([S.test (/q/), S.test (/u/), S.test (/i/)]) ('incandescent')
            //. true
            //.
            //. > S.anyPass ([S.test (/q/), S.test (/u/), S.test (/i/)]) ('empathy')
            //. false
            //. ```
            function anyPass(preds) {
              return function(x) {
                return Z.reduce(
                  function(b, p) {
                    return b || p(x);
                  },
                  false,
                  preds
                );
              };
            }
            _.anyPass = {
              consts: { f: [Z.Foldable] },
              types: [f($.Predicate(a)), a, $.Boolean],
              impl: anyPass,
            };

            //. ### Array

            //# slice :: Integer -> Integer -> Array a -> Maybe (Array a)
            //.
            //. Takes a start index `i`, an end index `j`, and an array, and returns
            //. Just the `[i,j)` slice of the array if possible; Nothing otherwise.
            //. A negative index represents an offset from the length of the array.
            //.
            //. See also [`take`](#take), [`drop`](#drop), [`takeLast`](#takeLast),
            //. and [`dropLast`](#dropLast).
            //.
            //. ```javascript
            //. > S.slice (1) (3) (['a', 'b', 'c', 'd', 'e'])
            //. Just (['b', 'c'])
            //.
            //. > S.slice (-3) (-1) (['a', 'b', 'c', 'd', 'e'])
            //. Just (['c', 'd'])
            //.
            //. > S.slice (1) (6) (['a', 'b', 'c', 'd', 'e'])
            //. Nothing
            //. ```
            function slice(start) {
              return function(end) {
                return function(xs) {
                  var fromIdx = start < 0 ? start + xs.length : start;
                  var toIdx = end < 0 ? end + xs.length : end;

                  return Math.abs(start) <= xs.length &&
                    Math.abs(end) <= xs.length &&
                    fromIdx <= toIdx
                    ? Just(xs.slice(fromIdx, toIdx))
                    : Nothing;
                };
              };
            }
            _.slice = {
              consts: {},
              types: [$.Integer, $.Integer, $.Array(a), $Maybe($.Array(a))],
              impl: slice,
            };

            //# at :: Integer -> Array a -> Maybe a
            //.
            //. Returns Just the element of the given array at the specified index if
            //. the index is within the array's bounds; Nothing otherwise. A negative
            //. index represents an offset from the length of the array.
            //.
            //. ```javascript
            //. > S.at (2) (['a', 'b', 'c', 'd', 'e'])
            //. Just ('c')
            //.
            //. > S.at (5) (['a', 'b', 'c', 'd', 'e'])
            //. Nothing
            //.
            //. > S.at (-2) (['a', 'b', 'c', 'd', 'e'])
            //. Just ('d')
            //. ```
            function at(n) {
              return function(xs) {
                var idx = n < 0 ? xs.length + n : n;
                return idx < 0 || idx >= xs.length ? Nothing : Just(xs[idx]);
              };
            }
            _.at = {
              consts: {},
              types: [$.Integer, $.Array(a), $Maybe(a)],
              impl: at,
            };

            //# head :: Array a -> Maybe a
            //.
            //. Returns Just the first element of the given array if the array contains
            //. at least one element; Nothing otherwise.
            //.
            //. ```javascript
            //. > S.head ([1, 2, 3])
            //. Just (1)
            //.
            //. > S.head ([])
            //. Nothing
            //. ```
            function head(xs) {
              return xs.length > 0 ? Just(xs[0]) : Nothing;
            }
            _.head = {
              consts: {},
              types: [$.Array(a), $Maybe(a)],
              impl: head,
            };

            //# last :: Array a -> Maybe a
            //.
            //. Returns Just the last element of the given array if the array contains
            //. at least one element; Nothing otherwise.
            //.
            //. ```javascript
            //. > S.last ([1, 2, 3])
            //. Just (3)
            //.
            //. > S.last ([])
            //. Nothing
            //. ```
            function last(xs) {
              return xs.length > 0 ? Just(xs[xs.length - 1]) : Nothing;
            }
            _.last = {
              consts: {},
              types: [$.Array(a), $Maybe(a)],
              impl: last,
            };

            //# tail :: Array a -> Maybe (Array a)
            //.
            //. Returns Just all but the first of the given array's elements if the
            //. array contains at least one element; Nothing otherwise.
            //.
            //. ```javascript
            //. > S.tail ([1, 2, 3])
            //. Just ([2, 3])
            //.
            //. > S.tail ([])
            //. Nothing
            //. ```
            function tail(xs) {
              return xs.length > 0 ? Just(xs.slice(1)) : Nothing;
            }
            _.tail = {
              consts: {},
              types: [$.Array(a), $Maybe($.Array(a))],
              impl: tail,
            };

            //# init :: Array a -> Maybe (Array a)
            //.
            //. Returns Just all but the last of the given array's elements if the
            //. array contains at least one element; Nothing otherwise.
            //.
            //. ```javascript
            //. > S.init ([1, 2, 3])
            //. Just ([1, 2])
            //.
            //. > S.init ([])
            //. Nothing
            //. ```
            function init(xs) {
              return xs.length > 0 ? Just(xs.slice(0, -1)) : Nothing;
            }
            _.init = {
              consts: {},
              types: [$.Array(a), $Maybe($.Array(a))],
              impl: init,
            };

            //# take :: Integer -> Array a -> Maybe (Array a)
            //.
            //. Returns Just the first N elements of the given array if N is greater
            //. than or equal to zero and less than or equal to the length of the array;
            //. Nothing otherwise.
            //.
            //. ```javascript
            //. > S.take (2) (['a', 'b', 'c', 'd', 'e'])
            //. Just (['a', 'b'])
            //.
            //. > S.take (5) (['a', 'b', 'c', 'd', 'e'])
            //. Just (['a', 'b', 'c', 'd', 'e'])
            //.
            //. > S.take (6) (['a', 'b', 'c', 'd', 'e'])
            //. Nothing
            //. ```
            function take(n) {
              return function(xs) {
                return n >= 0 && n <= xs.length
                  ? Just(xs.slice(0, n))
                  : Nothing;
              };
            }
            _.take = {
              consts: {},
              types: [$.Integer, $.Array(a), $Maybe($.Array(a))],
              impl: take,
            };

            //# takeLast :: Integer -> Array a -> Maybe (Array a)
            //.
            //. Returns Just the last N elements of the given array if N is greater
            //. than or equal to zero and less than or equal to the length of the array;
            //. Nothing otherwise.
            //.
            //. ```javascript
            //. > S.takeLast (2) (['a', 'b', 'c', 'd', 'e'])
            //. Just (['d', 'e'])
            //.
            //. > S.takeLast (5) (['a', 'b', 'c', 'd', 'e'])
            //. Just (['a', 'b', 'c', 'd', 'e'])
            //.
            //. > S.takeLast (6) (['a', 'b', 'c', 'd', 'e'])
            //. Nothing
            //. ```
            function takeLast(n) {
              return function(xs) {
                return n >= 0 && n <= xs.length
                  ? Just(xs.slice(xs.length - n))
                  : Nothing;
              };
            }
            _.takeLast = {
              consts: {},
              types: [$.Integer, $.Array(a), $Maybe($.Array(a))],
              impl: takeLast,
            };

            //# drop :: Integer -> Array a -> Maybe (Array a)
            //.
            //. Returns Just all but the first N elements of the given array if N is
            //. greater than or equal to zero and less than or equal to the length of
            //. the array; Nothing otherwise.
            //.
            //. ```javascript
            //. > S.drop (2) (['a', 'b', 'c', 'd', 'e'])
            //. Just (['c', 'd', 'e'])
            //.
            //. > S.drop (5) (['a', 'b', 'c', 'd', 'e'])
            //. Just ([])
            //.
            //. > S.drop (6) (['a', 'b', 'c', 'd', 'e'])
            //. Nothing
            //. ```
            function drop(n) {
              return function(xs) {
                return n >= 0 && n <= xs.length ? Just(xs.slice(n)) : Nothing;
              };
            }
            _.drop = {
              consts: {},
              types: [$.Integer, $.Array(a), $Maybe($.Array(a))],
              impl: drop,
            };

            //# dropLast :: Integer -> Array a -> Maybe (Array a)
            //.
            //. Returns Just all but the last N elements of the given array if N is
            //. greater than or equal to zero and less than or equal to the length of
            //. the array; Nothing otherwise.
            //.
            //. ```javascript
            //. > S.dropLast (2) (['a', 'b', 'c', 'd', 'e'])
            //. Just (['a', 'b', 'c'])
            //.
            //. > S.dropLast (5) (['a', 'b', 'c', 'd', 'e'])
            //. Just ([])
            //.
            //. > S.dropLast (6) (['a', 'b', 'c', 'd', 'e'])
            //. Nothing
            //. ```
            function dropLast(n) {
              return function(xs) {
                return n >= 0 && n <= xs.length
                  ? Just(xs.slice(0, xs.length - n))
                  : Nothing;
              };
            }
            _.dropLast = {
              consts: {},
              types: [$.Integer, $.Array(a), $Maybe($.Array(a))],
              impl: dropLast,
            };

            //# size :: Foldable f => f a -> Integer
            //.
            //. Returns the number of elements of the given structure.
            //.
            //. ```javascript
            //. > S.size ([])
            //. 0
            //.
            //. > S.size (['foo', 'bar', 'baz'])
            //. 3
            //.
            //. > S.size (Nil)
            //. 0
            //.
            //. > S.size (Cons ('foo') (Cons ('bar') (Cons ('baz') (Nil))))
            //. 3
            //.
            //. > S.size (S.Nothing)
            //. 0
            //.
            //. > S.size (S.Just ('quux'))
            //. 1
            //.
            //. > S.size (S.Pair ('ignored!') ('counted!'))
            //. 1
            //. ```
            _.size = {
              consts: { f: [Z.Foldable] },
              types: [f(a), $.Integer],
              impl: Z.size,
            };

            //# append :: (Applicative f, Semigroup (f a)) => a -> f a -> f a
            //.
            //. Returns the result of appending the first argument to the second.
            //.
            //. See also [`prepend`](#prepend).
            //.
            //. ```javascript
            //. > S.append (3) ([1, 2])
            //. [1, 2, 3]
            //.
            //. > S.append (3) (Cons (1) (Cons (2) (Nil)))
            //. Cons (1) (Cons (2) (Cons (3) (Nil)))
            //.
            //. > S.append ([1]) (S.Nothing)
            //. Just ([1])
            //.
            //. > S.append ([3]) (S.Just ([1, 2]))
            //. Just ([1, 2, 3])
            //. ```
            _.append = {
              consts: { f: [Z.Applicative, Z.Semigroup] },
              types: [a, f(a), f(a)],
              impl: curry2(Z.append),
            };

            //# prepend :: (Applicative f, Semigroup (f a)) => a -> f a -> f a
            //.
            //. Returns the result of prepending the first argument to the second.
            //.
            //. See also [`append`](#append).
            //.
            //. ```javascript
            //. > S.prepend (1) ([2, 3])
            //. [1, 2, 3]
            //.
            //. > S.prepend (1) (Cons (2) (Cons (3) (Nil)))
            //. Cons (1) (Cons (2) (Cons (3) (Nil)))
            //.
            //. > S.prepend ([1]) (S.Nothing)
            //. Just ([1])
            //.
            //. > S.prepend ([1]) (S.Just ([2, 3]))
            //. Just ([1, 2, 3])
            //. ```
            _.prepend = {
              consts: { f: [Z.Applicative, Z.Semigroup] },
              types: [a, f(a), f(a)],
              impl: curry2(Z.prepend),
            };

            //# joinWith :: String -> Array String -> String
            //.
            //. Joins the strings of the second argument separated by the first argument.
            //.
            //. Properties:
            //.
            //.   - `forall s :: String, t :: String.
            //.      S.joinWith (s) (S.splitOn (s) (t)) = t`
            //.
            //. See also [`splitOn`](#splitOn).
            //.
            //. ```javascript
            //. > S.joinWith (':') (['foo', 'bar', 'baz'])
            //. 'foo:bar:baz'
            //. ```
            _.joinWith = {
              consts: {},
              types: [$.String, $.Array($.String), $.String],
              impl: invoke1("join"),
            };

            //# elem :: (Setoid a, Foldable f) => a -> f a -> Boolean
            //.
            //. Takes a value and a structure and returns `true` [iff][] the value is an
            //. element of the structure.
            //.
            //. See also [`find`](#find).
            //.
            //. ```javascript
            //. > S.elem ('c') (['a', 'b', 'c'])
            //. true
            //.
            //. > S.elem ('x') (['a', 'b', 'c'])
            //. false
            //.
            //. > S.elem (3) ({x: 1, y: 2, z: 3})
            //. true
            //.
            //. > S.elem (8) ({x: 1, y: 2, z: 3})
            //. false
            //.
            //. > S.elem (0) (S.Just (0))
            //. true
            //.
            //. > S.elem (0) (S.Just (1))
            //. false
            //.
            //. > S.elem (0) (S.Nothing)
            //. false
            //. ```
            _.elem = {
              consts: { a: [Z.Setoid], f: [Z.Foldable] },
              types: [a, f(a), $.Boolean],
              impl: curry2(Z.elem),
            };

            //# find :: Foldable f => (a -> Boolean) -> f a -> Maybe a
            //.
            //. Takes a predicate and a structure and returns Just the leftmost element
            //. of the structure which satisfies the predicate; Nothing if there is no
            //. such element.
            //.
            //. See also [`elem`](#elem).
            //.
            //. ```javascript
            //. > S.find (S.lt (0)) ([1, -2, 3, -4, 5])
            //. Just (-2)
            //.
            //. > S.find (S.lt (0)) ([1, 2, 3, 4, 5])
            //. Nothing
            //. ```
            function find(pred) {
              return function(xs) {
                return Z.reduce(
                  function(m, x) {
                    return m.isJust ? m : pred(x) ? Just(x) : Nothing;
                  },
                  Nothing,
                  xs
                );
              };
            }
            _.find = {
              consts: { f: [Z.Foldable] },
              types: [$.Predicate(a), f(a), $Maybe(a)],
              impl: find,
            };

            //# foldMap :: (Monoid m, Foldable f) => TypeRep m -> (a -> m) -> f a -> m
            //.
            //. Curried version of [`Z.foldMap`][]. Deconstructs a foldable by mapping
            //. every element to a monoid and concatenating the results.
            //.
            //. ```javascript
            //. > S.foldMap (String) (f => f.name) ([Math.sin, Math.cos, Math.tan])
            //. 'sincostan'
            //. ```
            _.foldMap = {
              consts: { b: [Z.Monoid], f: [Z.Foldable] },
              types: [TypeRep(b), Fn(a)(b), f(a), b],
              impl: curry3(Z.foldMap),
            };

            //# unfoldr :: (b -> Maybe (Pair a b)) -> b -> Array a
            //.
            //. Takes a function and a seed value, and returns an array generated by
            //. applying the function repeatedly. The array is initially empty. The
            //. function is initially applied to the seed value. Each application
            //. of the function should result in either:
            //.
            //.   - Nothing, in which case the array is returned; or
            //.
            //.   - Just a pair, in which case the first element is appended to
            //.     the array and the function is applied to the second element.
            //.
            //. ```javascript
            //. > S.unfoldr (n => n < 5 ? S.Just (S.Pair (n) (n + 1)) : S.Nothing) (1)
            //. [1, 2, 3, 4]
            //. ```
            function unfoldr(f) {
              return function(x) {
                var result = [];
                for (var m = f(x); m.isJust; m = f(m.value.snd)) {
                  result.push(m.value.fst);
                }
                return result;
              };
            }
            _.unfoldr = {
              consts: {},
              types: [Fn(b)($Maybe($Pair(a)(b))), b, $.Array(a)],
              impl: unfoldr,
            };

            //# range :: Integer -> Integer -> Array Integer
            //.
            //. Returns an array of consecutive integers starting with the first argument
            //. and ending with the second argument minus one. Returns `[]` if the second
            //. argument is less than or equal to the first argument.
            //.
            //. ```javascript
            //. > S.range (0) (10)
            //. [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
            //.
            //. > S.range (-5) (0)
            //. [-5, -4, -3, -2, -1]
            //.
            //. > S.range (0) (-5)
            //. []
            //. ```
            function range(from) {
              return function(to) {
                var result = [];
                for (var n = from; n < to; n += 1) result.push(n);
                return result;
              };
            }
            _.range = {
              consts: {},
              types: [$.Integer, $.Integer, $.Array($.Integer)],
              impl: range,
            };

            //# groupBy :: (a -> a -> Boolean) -> Array a -> Array (Array a)
            //.
            //. Splits its array argument into an array of arrays of equal,
            //. adjacent elements. Equality is determined by the function
            //. provided as the first argument. Its behaviour can be surprising
            //. for functions that aren't reflexive, transitive, and symmetric
            //. (see [equivalence][] relation).
            //.
            //. Properties:
            //.
            //.   - `forall f :: a -> a -> Boolean, xs :: Array a.
            //.      S.join (S.groupBy (f) (xs)) = xs`
            //.
            //. ```javascript
            //. > S.groupBy (S.equals) ([1, 1, 2, 1, 1])
            //. [[1, 1], [2], [1, 1]]
            //.
            //. > S.groupBy (x => y => x + y === 0) ([2, -3, 3, 3, 3, 4, -4, 4])
            //. [[2], [-3, 3, 3, 3], [4, -4], [4]]
            //. ```
            function groupBy(f) {
              return function(xs) {
                if (xs.length === 0) return [];
                var x0 = xs[0]; // :: a
                var active = [x0]; // :: Array a
                var result = [active]; // :: Array (Array a)
                for (var idx = 1; idx < xs.length; idx += 1) {
                  var x = xs[idx];
                  if (f(x0)(x)) active.push(x);
                  else result.push((active = [(x0 = x)]));
                }
                return result;
              };
            }
            _.groupBy = {
              consts: {},
              types: [Fn(a)($.Predicate(a)), $.Array(a), $.Array($.Array(a))],
              impl: groupBy,
            };

            //# reverse :: (Applicative f, Foldable f, Monoid (f a)) => f a -> f a
            //.
            //. Reverses the elements of the given structure.
            //.
            //. ```javascript
            //. > S.reverse ([1, 2, 3])
            //. [3, 2, 1]
            //.
            //. > S.reverse (Cons (1) (Cons (2) (Cons (3) (Nil))))
            //. Cons (3) (Cons (2) (Cons (1) (Nil)))
            //.
            //. > S.pipe ([S.splitOn (''), S.reverse, S.joinWith ('')]) ('abc')
            //. 'cba'
            //. ```
            _.reverse = {
              consts: { f: [Z.Applicative, Z.Foldable, Z.Monoid] },
              types: [f(a), f(a)],
              impl: Z.reverse,
            };

            //# sort :: (Ord a, Applicative m, Foldable m, Monoid (m a)) => m a -> m a
            //.
            //. Performs a [stable sort][] of the elements of the given structure, using
            //. [`Z.lte`][] for comparisons.
            //.
            //. Properties:
            //.
            //.   - `S.sort (S.sort (m)) = S.sort (m)` (idempotence)
            //.
            //. See also [`sortBy`](#sortBy).
            //.
            //. ```javascript
            //. > S.sort (['foo', 'bar', 'baz'])
            //. ['bar', 'baz', 'foo']
            //.
            //. > S.sort ([S.Left (4), S.Right (3), S.Left (2), S.Right (1)])
            //. [Left (2), Left (4), Right (1), Right (3)]
            //. ```
            _.sort = {
              consts: { a: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid] },
              types: [m(a), m(a)],
              impl: Z.sort,
            };

            //# sortBy :: (Ord b, Applicative m, Foldable m, Monoid (m a)) => (a -> b) -> m a -> m a
            //.
            //. Performs a [stable sort][] of the elements of the given structure, using
            //. [`Z.lte`][] to compare the values produced by applying the given function
            //. to each element of the structure.
            //.
            //. Properties:
            //.
            //.   - `S.sortBy (f) (S.sortBy (f) (m)) = S.sortBy (f) (m)` (idempotence)
            //.
            //. See also [`sort`](#sort).
            //.
            //. ```javascript
            //. > S.sortBy (S.prop ('rank')) ([
            //. .   {rank: 7, suit: 'spades'},
            //. .   {rank: 5, suit: 'hearts'},
            //. .   {rank: 2, suit: 'hearts'},
            //. .   {rank: 5, suit: 'spades'},
            //. . ])
            //. [ {rank: 2, suit: 'hearts'},
            //. . {rank: 5, suit: 'hearts'},
            //. . {rank: 5, suit: 'spades'},
            //. . {rank: 7, suit: 'spades'} ]
            //.
            //. > S.sortBy (S.prop ('suit')) ([
            //. .   {rank: 7, suit: 'spades'},
            //. .   {rank: 5, suit: 'hearts'},
            //. .   {rank: 2, suit: 'hearts'},
            //. .   {rank: 5, suit: 'spades'},
            //. . ])
            //. [ {rank: 5, suit: 'hearts'},
            //. . {rank: 2, suit: 'hearts'},
            //. . {rank: 7, suit: 'spades'},
            //. . {rank: 5, suit: 'spades'} ]
            //. ```
            //.
            //. If descending order is desired, one may use [`Descending`][]:
            //.
            //. ```javascript
            //. > S.sortBy (Descending) ([83, 97, 110, 99, 116, 117, 97, 114, 121])
            //. [121, 117, 116, 114, 110, 99, 97, 97, 83]
            //. ```
            _.sortBy = {
              consts: { b: [Z.Ord], m: [Z.Applicative, Z.Foldable, Z.Monoid] },
              types: [Fn(a)(b), m(a), m(a)],
              impl: curry2(Z.sortBy),
            };

            //# zip :: Array a -> Array b -> Array (Pair a b)
            //.
            //. Returns an array of pairs of corresponding elements from the given
            //. arrays. The length of the resulting array is equal to the length of
            //. the shorter input array.
            //.
            //. See also [`zipWith`](#zipWith).
            //.
            //. ```javascript
            //. > S.zip (['a', 'b']) (['x', 'y', 'z'])
            //. [Pair ('a') ('x'), Pair ('b') ('y')]
            //.
            //. > S.zip ([1, 3, 5]) ([2, 4])
            //. [Pair (1) (2), Pair (3) (4)]
            //. ```
            _.zip = {
              consts: {},
              types: [$.Array(a), $.Array(b), $.Array($Pair(a)(b))],
              impl: zipWith(Pair),
            };

            //# zipWith :: (a -> b -> c) -> Array a -> Array b -> Array c
            //.
            //. Returns the result of combining, pairwise, the given arrays using the
            //. given binary function. The length of the resulting array is equal to the
            //. length of the shorter input array.
            //.
            //. See also [`zip`](#zip).
            //.
            //. ```javascript
            //. > S.zipWith (a => b => a + b) (['a', 'b']) (['x', 'y', 'z'])
            //. ['ax', 'by']
            //.
            //. > S.zipWith (a => b => [a, b]) ([1, 3, 5]) ([2, 4])
            //. [[1, 2], [3, 4]]
            //. ```
            function zipWith(f) {
              return function(xs) {
                return function(ys) {
                  var result = [];
                  var len = Math.min(xs.length, ys.length);
                  for (var idx = 0; idx < len; idx += 1) {
                    result.push(f(xs[idx])(ys[idx]));
                  }
                  return result;
                };
              };
            }
            _.zipWith = {
              consts: {},
              types: [Fn(a)(Fn(b)(c)), $.Array(a), $.Array(b), $.Array(c)],
              impl: zipWith,
            };

            //. ### Object

            //# prop :: String -> a -> b
            //.
            //. Takes a property name and an object with known properties and returns
            //. the value of the specified property. If for some reason the object
            //. lacks the specified property, a type error is thrown.
            //.
            //. For accessing properties of uncertain objects, use [`get`](#get) instead.
            //.
            //. ```javascript
            //. > S.prop ('a') ({a: 1, b: 2})
            //. 1
            //. ```
            function prop(key) {
              return function(x) {
                var obj = toObject(x);
                if (key in obj) return obj[key];
                throw new TypeError(
                  "‘prop’ expected object to have a property named " +
                    "‘" +
                    key +
                    "’; " +
                    show(x) +
                    " does not"
                );
              };
            }
            _.prop = {
              consts: {},
              types: [$.String, a, b],
              impl: prop,
            };

            //# props :: Array String -> a -> b
            //.
            //. Takes a property path (an array of property names) and an object with
            //. known structure and returns the value at the given path. If for some
            //. reason the path does not exist, a type error is thrown.
            //.
            //. For accessing property paths of uncertain objects, use [`gets`](#gets)
            //. instead.
            //.
            //. ```javascript
            //. > S.props (['a', 'b', 'c']) ({a: {b: {c: 1}}})
            //. 1
            //. ```
            function props(path) {
              return function(x) {
                return path.reduce(function(x, key) {
                  var obj = toObject(x);
                  if (key in obj) return obj[key];
                  throw new TypeError(
                    "‘props’ expected object to have a property at " +
                      show(path) +
                      "; " +
                      show(x) +
                      " does not"
                  );
                }, x);
              };
            }
            _.props = {
              consts: {},
              types: [$.Array($.String), a, b],
              impl: props,
            };

            //# get :: (Any -> Boolean) -> String -> a -> Maybe b
            //.
            //. Takes a predicate, a property name, and an object and returns Just the
            //. value of the specified object property if it exists and the value
            //. satisfies the given predicate; Nothing otherwise.
            //.
            //. See also [`gets`](#gets) and [`prop`](#prop).
            //.
            //. ```javascript
            //. > S.get (S.is ($.Number)) ('x') ({x: 1, y: 2})
            //. Just (1)
            //.
            //. > S.get (S.is ($.Number)) ('x') ({x: '1', y: '2'})
            //. Nothing
            //.
            //. > S.get (S.is ($.Number)) ('x') ({})
            //. Nothing
            //.
            //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3]})
            //. Just ([1, 2, 3])
            //.
            //. > S.get (S.is ($.Array ($.Number))) ('x') ({x: [1, 2, 3, null]})
            //. Nothing
            //. ```
            function get(pred) {
              return B(B(filter(pred)))(get_);
            }
            _.get = {
              consts: {},
              types: [$.Predicate($.Any), $.String, a, $Maybe(b)],
              impl: get,
            };

            //# gets :: (Any -> Boolean) -> Array String -> a -> Maybe b
            //.
            //. Takes a predicate, a property path (an array of property names), and
            //. an object and returns Just the value at the given path if such a path
            //. exists and the value satisfies the given predicate; Nothing otherwise.
            //.
            //. See also [`get`](#get).
            //.
            //. ```javascript
            //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: 42}}})
            //. Just (42)
            //.
            //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({a: {b: {c: '42'}}})
            //. Nothing
            //.
            //. > S.gets (S.is ($.Number)) (['a', 'b', 'c']) ({})
            //. Nothing
            //. ```
            function gets(pred) {
              return function(keys) {
                return function(x) {
                  return Z.filter(
                    pred,
                    keys.reduce(function(maybe, key) {
                      return Z.chain(get_(key), maybe);
                    }, Just(x))
                  );
                };
              };
            }
            _.gets = {
              consts: {},
              types: [$.Predicate($.Any), $.Array($.String), a, $Maybe(b)],
              impl: gets,
            };

            //. ### StrMap
            //.
            //. StrMap is an abbreviation of _string map_. A string map is an object,
            //. such as `{foo: 1, bar: 2, baz: 3}`, whose values are all members of
            //. the same type. Formally, a value is a member of type `StrMap a` if its
            //. [type identifier][] is `'Object'` and the values of its enumerable own
            //. properties are all members of type `a`.

            //# singleton :: String -> a -> StrMap a
            //.
            //. Takes a string and a value of any type, and returns a string map with
            //. a single entry (mapping the key to the value).
            //.
            //. ```javascript
            //. > S.singleton ('foo') (42)
            //. {foo: 42}
            //. ```
            function singleton(key) {
              return function(val) {
                var strMap = {};
                strMap[key] = val;
                return strMap;
              };
            }
            _.singleton = {
              consts: {},
              types: [$.String, a, $.StrMap(a)],
              impl: singleton,
            };

            //# insert :: String -> a -> StrMap a -> StrMap a
            //.
            //. Takes a string, a value of any type, and a string map, and returns a
            //. string map comprising all the entries of the given string map plus the
            //. entry specified by the first two arguments (which takes precedence).
            //.
            //. Equivalent to Haskell's `insert` function. Similar to Clojure's `assoc`
            //. function.
            //.
            //. ```javascript
            //. > S.insert ('c') (3) ({a: 1, b: 2})
            //. {a: 1, b: 2, c: 3}
            //.
            //. > S.insert ('a') (4) ({a: 1, b: 2})
            //. {a: 4, b: 2}
            //. ```
            function insert(key) {
              return function(val) {
                return function(strMap) {
                  return Z.concat(strMap, singleton(key)(val));
                };
              };
            }
            _.insert = {
              consts: {},
              types: [$.String, a, $.StrMap(a), $.StrMap(a)],
              impl: insert,
            };

            //# remove :: String -> StrMap a -> StrMap a
            //.
            //. Takes a string and a string map, and returns a string map comprising all
            //. the entries of the given string map except the one whose key matches the
            //. given string (if such a key exists).
            //.
            //. Equivalent to Haskell's `delete` function. Similar to Clojure's `dissoc`
            //. function.
            //.
            //. ```javascript
            //. > S.remove ('c') ({a: 1, b: 2, c: 3})
            //. {a: 1, b: 2}
            //.
            //. > S.remove ('c') ({})
            //. {}
            //. ```
            function remove(key) {
              return function(strMap) {
                var result = Z.concat(strMap, {});
                delete result[key];
                return result;
              };
            }
            _.remove = {
              consts: {},
              types: [$.String, $.StrMap(a), $.StrMap(a)],
              impl: remove,
            };

            //# keys :: StrMap a -> Array String
            //.
            //. Returns the keys of the given string map, in arbitrary order.
            //.
            //. ```javascript
            //. > S.sort (S.keys ({b: 2, c: 3, a: 1}))
            //. ['a', 'b', 'c']
            //. ```
            _.keys = {
              consts: {},
              types: [$.StrMap(a), $.Array($.String)],
              impl: Object.keys,
            };

            //# values :: StrMap a -> Array a
            //.
            //. Returns the values of the given string map, in arbitrary order.
            //.
            //. ```javascript
            //. > S.sort (S.values ({a: 1, c: 3, b: 2}))
            //. [1, 2, 3]
            //. ```
            function values(strMap) {
              return Z.map(function(k) {
                return strMap[k];
              }, Object.keys(strMap));
            }
            _.values = {
              consts: {},
              types: [$.StrMap(a), $.Array(a)],
              impl: values,
            };

            //# pairs :: StrMap a -> Array (Pair String a)
            //.
            //. Returns the key–value pairs of the given string map, in arbitrary order.
            //.
            //. ```javascript
            //. > S.sort (S.pairs ({b: 2, a: 1, c: 3}))
            //. [Pair ('a') (1), Pair ('b') (2), Pair ('c') (3)]
            //. ```
            function pairs(strMap) {
              return Z.map(function(k) {
                return Pair(k)(strMap[k]);
              }, Object.keys(strMap));
            }
            _.pairs = {
              consts: {},
              types: [$.StrMap(a), $.Array($Pair($.String)(a))],
              impl: pairs,
            };

            //# fromPairs :: Foldable f => f (Pair String a) -> StrMap a
            //.
            //. Returns a string map containing the key–value pairs specified by the
            //. given [Foldable][]. If a key appears in multiple pairs, the rightmost
            //. pair takes precedence.
            //.
            //. ```javascript
            //. > S.fromPairs ([S.Pair ('a') (1), S.Pair ('b') (2), S.Pair ('c') (3)])
            //. {a: 1, b: 2, c: 3}
            //.
            //. > S.fromPairs ([S.Pair ('x') (1), S.Pair ('x') (2)])
            //. {x: 2}
            //. ```
            function fromPairs(pairs) {
              return Z.reduce(
                function(strMap, pair) {
                  strMap[pair.fst] = pair.snd;
                  return strMap;
                },
                {},
                pairs
              );
            }
            _.fromPairs = {
              consts: { f: [Z.Foldable] },
              types: [f($Pair($.String)(a)), $.StrMap(a)],
              impl: fromPairs,
            };

            //. ### Number

            //# negate :: ValidNumber -> ValidNumber
            //.
            //. Negates its argument.
            //.
            //. ```javascript
            //. > S.negate (12.5)
            //. -12.5
            //.
            //. > S.negate (-42)
            //. 42
            //. ```
            function negate(n) {
              return -n;
            }
            _.negate = {
              consts: {},
              types: [$.ValidNumber, $.ValidNumber],
              impl: negate,
            };

            //# add :: FiniteNumber -> FiniteNumber -> FiniteNumber
            //.
            //. Returns the sum of two (finite) numbers.
            //.
            //. ```javascript
            //. > S.add (1) (1)
            //. 2
            //. ```
            function add(x) {
              return function(y) {
                return x + y;
              };
            }
            _.add = {
              consts: {},
              types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],
              impl: add,
            };

            //# sum :: Foldable f => f FiniteNumber -> FiniteNumber
            //.
            //. Returns the sum of the given array of (finite) numbers.
            //.
            //. ```javascript
            //. > S.sum ([1, 2, 3, 4, 5])
            //. 15
            //.
            //. > S.sum ([])
            //. 0
            //.
            //. > S.sum (S.Just (42))
            //. 42
            //.
            //. > S.sum (S.Nothing)
            //. 0
            //. ```
            _.sum = {
              consts: { f: [Z.Foldable] },
              types: [f($.FiniteNumber), $.FiniteNumber],
              impl: reduce(add)(0),
            };

            //# sub :: FiniteNumber -> FiniteNumber -> FiniteNumber
            //.
            //. Takes a finite number `n` and returns the _subtract `n`_ function.
            //.
            //. ```javascript
            //. > S.map (S.sub (1)) ([1, 2, 3])
            //. [0, 1, 2]
            //. ```
            function sub(y) {
              return function(x) {
                return x - y;
              };
            }
            _.sub = {
              consts: {},
              types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],
              impl: sub,
            };

            //# mult :: FiniteNumber -> FiniteNumber -> FiniteNumber
            //.
            //. Returns the product of two (finite) numbers.
            //.
            //. ```javascript
            //. > S.mult (4) (2)
            //. 8
            //. ```
            function mult(x) {
              return function(y) {
                return x * y;
              };
            }
            _.mult = {
              consts: {},
              types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],
              impl: mult,
            };

            //# product :: Foldable f => f FiniteNumber -> FiniteNumber
            //.
            //. Returns the product of the given array of (finite) numbers.
            //.
            //. ```javascript
            //. > S.product ([1, 2, 3, 4, 5])
            //. 120
            //.
            //. > S.product ([])
            //. 1
            //.
            //. > S.product (S.Just (42))
            //. 42
            //.
            //. > S.product (S.Nothing)
            //. 1
            //. ```
            _.product = {
              consts: { f: [Z.Foldable] },
              types: [f($.FiniteNumber), $.FiniteNumber],
              impl: reduce(mult)(1),
            };

            //# div :: NonZeroFiniteNumber -> FiniteNumber -> FiniteNumber
            //.
            //. Takes a non-zero finite number `n` and returns the _divide by `n`_
            //. function.
            //.
            //. ```javascript
            //. > S.map (S.div (2)) ([0, 1, 2, 3])
            //. [0, 0.5, 1, 1.5]
            //. ```
            function div(y) {
              return function(x) {
                return x / y;
              };
            }
            _.div = {
              consts: {},
              types: [$.NonZeroFiniteNumber, $.FiniteNumber, $.FiniteNumber],
              impl: div,
            };

            //# pow :: FiniteNumber -> FiniteNumber -> FiniteNumber
            //.
            //. Takes a finite number `n` and returns the _power of `n`_ function.
            //.
            //. ```javascript
            //. > S.map (S.pow (2)) ([-3, -2, -1, 0, 1, 2, 3])
            //. [9, 4, 1, 0, 1, 4, 9]
            //.
            //. > S.map (S.pow (0.5)) ([1, 4, 9, 16, 25])
            //. [1, 2, 3, 4, 5]
            //. ```
            function pow(exp) {
              return function(base) {
                return Math.pow(base, exp);
              };
            }
            _.pow = {
              consts: {},
              types: [$.FiniteNumber, $.FiniteNumber, $.FiniteNumber],
              impl: pow,
            };

            //# mean :: Foldable f => f FiniteNumber -> Maybe FiniteNumber
            //.
            //. Returns the mean of the given array of (finite) numbers.
            //.
            //. ```javascript
            //. > S.mean ([1, 2, 3, 4, 5])
            //. Just (3)
            //.
            //. > S.mean ([])
            //. Nothing
            //.
            //. > S.mean (S.Just (42))
            //. Just (42)
            //.
            //. > S.mean (S.Nothing)
            //. Nothing
            //. ```
            function mean(foldable) {
              var result = Z.reduce(
                function(acc, n) {
                  acc.total += n;
                  acc.count += 1;
                  return acc;
                },
                { total: 0, count: 0 },
                foldable
              );
              return result.count > 0
                ? Just(result.total / result.count)
                : Nothing;
            }
            _.mean = {
              consts: { f: [Z.Foldable] },
              types: [f($.FiniteNumber), $Maybe($.FiniteNumber)],
              impl: mean,
            };

            //. ### Integer

            //# even :: Integer -> Boolean
            //.
            //. Returns `true` if the given integer is even; `false` if it is odd.
            //.
            //. ```javascript
            //. > S.even (42)
            //. true
            //.
            //. > S.even (99)
            //. false
            //. ```
            function even(n) {
              return n % 2 === 0;
            }
            _.even = {
              consts: {},
              types: [$.Integer, $.Boolean],
              impl: even,
            };

            //# odd :: Integer -> Boolean
            //.
            //. Returns `true` if the given integer is odd; `false` if it is even.
            //.
            //. ```javascript
            //. > S.odd (99)
            //. true
            //.
            //. > S.odd (42)
            //. false
            //. ```
            function odd(n) {
              return n % 2 !== 0;
            }
            _.odd = {
              consts: {},
              types: [$.Integer, $.Boolean],
              impl: odd,
            };

            //. ### Parse

            //# parseDate :: String -> Maybe ValidDate
            //.
            //. Takes a string and returns Just the date represented by the string
            //. if it does in fact represent a date; Nothing otherwise.
            //.
            //. ```javascript
            //. > S.parseDate ('2011-01-19T17:40:00Z')
            //. Just (new Date ('2011-01-19T17:40:00.000Z'))
            //.
            //. > S.parseDate ('today')
            //. Nothing
            //. ```
            function parseDate(s) {
              var date = new Date(s);
              return isNaN(date.valueOf()) ? Nothing : Just(date);
            }
            _.parseDate = {
              consts: {},
              types: [$.String, $Maybe($.ValidDate)],
              impl: parseDate,
            };

            //  requiredNonCapturingGroup :: Array String -> String
            function requiredNonCapturingGroup(xs) {
              return "(?:" + xs.join("|") + ")";
            }

            //  optionalNonCapturingGroup :: Array String -> String
            function optionalNonCapturingGroup(xs) {
              return requiredNonCapturingGroup(xs) + "?";
            }

            //  validFloatRepr :: RegExp
            var validFloatRepr = new RegExp(
              "^" + // start-of-string anchor
              "\\s*" + // any number of leading whitespace characters
              "[+-]?" + // optional sign
              requiredNonCapturingGroup([
                "Infinity", // "Infinity"
                "NaN", // "NaN"
                requiredNonCapturingGroup([
                  "[0-9]+", // number
                  "[0-9]+[.][0-9]+", // number with interior decimal point
                  "[0-9]+[.]", // number with trailing decimal point
                  "[.][0-9]+", // number with leading decimal point
                ]) +
                  optionalNonCapturingGroup([
                    "[Ee]" + // "E" or "e"
                    "[+-]?" + // optional sign
                      "[0-9]+", // exponent
                  ]),
              ]) +
              "\\s*" + // any number of trailing whitespace characters
                "$" // end-of-string anchor
            );

            //# parseFloat :: String -> Maybe Number
            //.
            //. Takes a string and returns Just the number represented by the string
            //. if it does in fact represent a number; Nothing otherwise.
            //.
            //. ```javascript
            //. > S.parseFloat ('-123.45')
            //. Just (-123.45)
            //.
            //. > S.parseFloat ('foo.bar')
            //. Nothing
            //. ```
            function parseFloat_(s) {
              return validFloatRepr.test(s) ? Just(parseFloat(s)) : Nothing;
            }
            _.parseFloat = {
              consts: {},
              types: [$.String, $Maybe($.Number)],
              impl: parseFloat_,
            };

            //  Radix :: Type
            var Radix = $.NullaryType("sanctuary/Radix")("")(function(x) {
              return $.Integer._test(x) && x >= 2 && x <= 36;
            });

            //# parseInt :: Radix -> String -> Maybe Integer
            //.
            //. Takes a radix (an integer between 2 and 36 inclusive) and a string,
            //. and returns Just the number represented by the string if it does in
            //. fact represent a number in the base specified by the radix; Nothing
            //. otherwise.
            //.
            //. This function is stricter than [`parseInt`][parseInt]: a string
            //. is considered to represent an integer only if all its non-prefix
            //. characters are members of the character set specified by the radix.
            //.
            //. ```javascript
            //. > S.parseInt (10) ('-42')
            //. Just (-42)
            //.
            //. > S.parseInt (16) ('0xFF')
            //. Just (255)
            //.
            //. > S.parseInt (16) ('0xGG')
            //. Nothing
            //. ```
            function parseInt_(radix) {
              return function(s) {
                var charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".slice(
                  0,
                  radix
                );
                var pattern = new RegExp("^[" + charset + "]+$", "i");

                var t = s.replace(/^[+-]/, "");
                if (pattern.test(radix === 16 ? t.replace(/^0x/i, "") : t)) {
                  var n = parseInt(s, radix);
                  if ($.Integer._test(n)) return Just(n);
                }
                return Nothing;
              };
            }
            _.parseInt = {
              consts: {},
              types: [Radix, $.String, $Maybe($.Integer)],
              impl: parseInt_,
            };

            //# parseJson :: (Any -> Boolean) -> String -> Maybe a
            //.
            //. Takes a predicate and a string which may or may not be valid JSON, and
            //. returns Just the result of applying `JSON.parse` to the string *if* the
            //. result satisfies the predicate; Nothing otherwise.
            //.
            //. ```javascript
            //. > S.parseJson (S.is ($.Array ($.Integer))) ('[')
            //. Nothing
            //.
            //. > S.parseJson (S.is ($.Array ($.Integer))) ('["1","2","3"]')
            //. Nothing
            //.
            //. > S.parseJson (S.is ($.Array ($.Integer))) ('[0,1.5,3,4.5]')
            //. Nothing
            //.
            //. > S.parseJson (S.is ($.Array ($.Integer))) ('[1,2,3]')
            //. Just ([1, 2, 3])
            //. ```
            function parseJson(pred) {
              return B(filter(pred))(encase(JSON.parse));
            }
            _.parseJson = {
              consts: {},
              types: [$.Predicate($.Any), $.String, $Maybe(a)],
              impl: parseJson,
            };

            //. ### RegExp

            //  Match :: Type
            var Match = $.RecordType({
              match: $.String,
              groups: $.Array($Maybe($.String)),
            });

            //  toMatch :: Array String? -> Match
            function toMatch(ss) {
              return { match: ss[0], groups: Z.map(toMaybe, ss.slice(1)) };
            }

            //  withRegex :: (RegExp, () -> a) -> a
            function withRegex(pattern, thunk) {
              var lastIndex = pattern.lastIndex;
              var result = thunk();
              pattern.lastIndex = lastIndex;
              return result;
            }

            //# regex :: RegexFlags -> String -> RegExp
            //.
            //. Takes a [RegexFlags][] and a pattern, and returns a RegExp.
            //.
            //. ```javascript
            //. > S.regex ('g') (':\\d+:')
            //. /:\d+:/g
            //. ```
            function regex(flags) {
              return function(source) {
                return new RegExp(source, flags);
              };
            }
            _.regex = {
              consts: {},
              types: [$.RegexFlags, $.String, $.RegExp],
              impl: regex,
            };

            //# regexEscape :: String -> String
            //.
            //. Takes a string which may contain regular expression metacharacters,
            //. and returns a string with those metacharacters escaped.
            //.
            //. Properties:
            //.
            //.   - `forall s :: String.
            //.      S.test (S.regex ('') (S.regexEscape (s))) (s) = true`
            //.
            //. ```javascript
            //. > S.regexEscape ('-=*{XYZ}*=-')
            //. '\\-=\\*\\{XYZ\\}\\*=\\-'
            //. ```
            function regexEscape(s) {
              return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            }
            _.regexEscape = {
              consts: {},
              types: [$.String, $.String],
              impl: regexEscape,
            };

            //# test :: RegExp -> String -> Boolean
            //.
            //. Takes a pattern and a string, and returns `true` [iff][] the pattern
            //. matches the string.
            //.
            //. ```javascript
            //. > S.test (/^a/) ('abacus')
            //. true
            //.
            //. > S.test (/^a/) ('banana')
            //. false
            //. ```
            function test(pattern) {
              return function(s) {
                return withRegex(pattern, function() {
                  return pattern.test(s);
                });
              };
            }
            _.test = {
              consts: {},
              types: [$.RegExp, $.String, $.Boolean],
              impl: test,
            };

            //# match :: NonGlobalRegExp -> String -> Maybe { match :: String, groups :: Array (Maybe String) }
            //.
            //. Takes a pattern and a string, and returns Just a match record if the
            //. pattern matches the string; Nothing otherwise.
            //.
            //. `groups :: Array (Maybe String)` acknowledges the existence of optional
            //. capturing groups.
            //.
            //. Properties:
            //.
            //.   - `forall p :: Pattern, s :: String.
            //.      S.head (S.matchAll (S.regex ('g') (p)) (s))
            //.      = S.match (S.regex ('') (p)) (s)`
            //.
            //. See also [`matchAll`](#matchAll).
            //.
            //. ```javascript
            //. > S.match (/(good)?bye/) ('goodbye')
            //. Just ({match: 'goodbye', groups: [Just ('good')]})
            //.
            //. > S.match (/(good)?bye/) ('bye')
            //. Just ({match: 'bye', groups: [Nothing]})
            //. ```
            function match(pattern) {
              return function(s) {
                return Z.map(toMatch, toMaybe(s.match(pattern)));
              };
            }
            _.match = {
              consts: {},
              types: [$.NonGlobalRegExp, $.String, $Maybe(Match)],
              impl: match,
            };

            //# matchAll :: GlobalRegExp -> String -> Array { match :: String, groups :: Array (Maybe String) }
            //.
            //. Takes a pattern and a string, and returns an array of match records.
            //.
            //. `groups :: Array (Maybe String)` acknowledges the existence of optional
            //. capturing groups.
            //.
            //. See also [`match`](#match).
            //.
            //. ```javascript
            //. > S.matchAll (/@([a-z]+)/g) ('Hello, world!')
            //. []
            //.
            //. > S.matchAll (/@([a-z]+)/g) ('Hello, @foo! Hello, @bar! Hello, @baz!')
            //. [ {match: '@foo', groups: [Just ('foo')]},
            //. . {match: '@bar', groups: [Just ('bar')]},
            //. . {match: '@baz', groups: [Just ('baz')]} ]
            //. ```
            function matchAll(pattern) {
              return function(s) {
                return withRegex(pattern, function() {
                  return unfoldr(function(_) {
                    return Z.map(function(ss) {
                      return Pair(toMatch(ss))(null);
                    }, toMaybe(pattern.exec(s)));
                  })([]);
                });
              };
            }
            _.matchAll = {
              consts: {},
              types: [$.GlobalRegExp, $.String, $.Array(Match)],
              impl: matchAll,
            };

            //. ### String

            //# toUpper :: String -> String
            //.
            //. Returns the upper-case equivalent of its argument.
            //.
            //. See also [`toLower`](#toLower).
            //.
            //. ```javascript
            //. > S.toUpper ('ABC def 123')
            //. 'ABC DEF 123'
            //. ```
            _.toUpper = {
              consts: {},
              types: [$.String, $.String],
              impl: invoke0("toUpperCase"),
            };

            //# toLower :: String -> String
            //.
            //. Returns the lower-case equivalent of its argument.
            //.
            //. See also [`toUpper`](#toUpper).
            //.
            //. ```javascript
            //. > S.toLower ('ABC def 123')
            //. 'abc def 123'
            //. ```
            _.toLower = {
              consts: {},
              types: [$.String, $.String],
              impl: invoke0("toLowerCase"),
            };

            //# trim :: String -> String
            //.
            //. Strips leading and trailing whitespace characters.
            //.
            //. ```javascript
            //. > S.trim ('\t\t foo bar \n')
            //. 'foo bar'
            //. ```
            _.trim = {
              consts: {},
              types: [$.String, $.String],
              impl: invoke0("trim"),
            };

            //# stripPrefix :: String -> String -> Maybe String
            //.
            //. Returns Just the portion of the given string (the second argument) left
            //. after removing the given prefix (the first argument) if the string starts
            //. with the prefix; Nothing otherwise.
            //.
            //. See also [`stripSuffix`](#stripSuffix).
            //.
            //. ```javascript
            //. > S.stripPrefix ('https://') ('https://sanctuary.js.org')
            //. Just ('sanctuary.js.org')
            //.
            //. > S.stripPrefix ('https://') ('http://sanctuary.js.org')
            //. Nothing
            //. ```
            function stripPrefix(prefix) {
              return function(s) {
                var idx = prefix.length;
                return s.slice(0, idx) === prefix
                  ? Just(s.slice(idx))
                  : Nothing;
              };
            }
            _.stripPrefix = {
              consts: {},
              types: [$.String, $.String, $Maybe($.String)],
              impl: stripPrefix,
            };

            //# stripSuffix :: String -> String -> Maybe String
            //.
            //. Returns Just the portion of the given string (the second argument) left
            //. after removing the given suffix (the first argument) if the string ends
            //. with the suffix; Nothing otherwise.
            //.
            //. See also [`stripPrefix`](#stripPrefix).
            //.
            //. ```javascript
            //. > S.stripSuffix ('.md') ('README.md')
            //. Just ('README')
            //.
            //. > S.stripSuffix ('.md') ('README')
            //. Nothing
            //. ```
            function stripSuffix(suffix) {
              return function(s) {
                var idx = s.length - suffix.length; // value may be negative
                return s.slice(idx) === suffix
                  ? Just(s.slice(0, idx))
                  : Nothing;
              };
            }
            _.stripSuffix = {
              consts: {},
              types: [$.String, $.String, $Maybe($.String)],
              impl: stripSuffix,
            };

            //# words :: String -> Array String
            //.
            //. Takes a string and returns the array of words the string contains
            //. (words are delimited by whitespace characters).
            //.
            //. See also [`unwords`](#unwords).
            //.
            //. ```javascript
            //. > S.words (' foo bar baz ')
            //. ['foo', 'bar', 'baz']
            //. ```
            function words(s) {
              var words = s.split(/\s+/);
              var len = words.length;
              return words.slice(
                words[0] === "" ? 1 : 0,
                words[len - 1] === "" ? len - 1 : len
              );
            }
            _.words = {
              consts: {},
              types: [$.String, $.Array($.String)],
              impl: words,
            };

            //# unwords :: Array String -> String
            //.
            //. Takes an array of words and returns the result of joining the words
            //. with separating spaces.
            //.
            //. See also [`words`](#words).
            //.
            //. ```javascript
            //. > S.unwords (['foo', 'bar', 'baz'])
            //. 'foo bar baz'
            //. ```
            _.unwords = {
              consts: {},
              types: [$.Array($.String), $.String],
              impl: invoke1("join")(" "),
            };

            //# lines :: String -> Array String
            //.
            //. Takes a string and returns the array of lines the string contains
            //. (lines are delimited by newlines: `'\n'` or `'\r\n'` or `'\r'`).
            //. The resulting strings do not contain newlines.
            //.
            //. See also [`unlines`](#unlines).
            //.
            //. ```javascript
            //. > S.lines ('foo\nbar\nbaz\n')
            //. ['foo', 'bar', 'baz']
            //. ```
            function lines(s) {
              return s === ""
                ? []
                : s.replace(/\r\n?/g, "\n").match(/^(?=[\s\S]).*/gm);
            }
            _.lines = {
              consts: {},
              types: [$.String, $.Array($.String)],
              impl: lines,
            };

            //# unlines :: Array String -> String
            //.
            //. Takes an array of lines and returns the result of joining the lines
            //. after appending a terminating line feed (`'\n'`) to each.
            //.
            //. See also [`lines`](#lines).
            //.
            //. ```javascript
            //. > S.unlines (['foo', 'bar', 'baz'])
            //. 'foo\nbar\nbaz\n'
            //. ```
            function unlines(xs) {
              return xs.reduce(function(s, x) {
                return s + x + "\n";
              }, "");
            }
            _.unlines = {
              consts: {},
              types: [$.Array($.String), $.String],
              impl: unlines,
            };

            //# splitOn :: String -> String -> Array String
            //.
            //. Returns the substrings of its second argument separated by occurrences
            //. of its first argument.
            //.
            //. See also [`joinWith`](#joinWith) and [`splitOnRegex`](#splitOnRegex).
            //.
            //. ```javascript
            //. > S.splitOn ('::') ('foo::bar::baz')
            //. ['foo', 'bar', 'baz']
            //. ```
            _.splitOn = {
              consts: {},
              types: [$.String, $.String, $.Array($.String)],
              impl: invoke1("split"),
            };

            //# splitOnRegex :: GlobalRegExp -> String -> Array String
            //.
            //. Takes a pattern and a string, and returns the result of splitting the
            //. string at every non-overlapping occurrence of the pattern.
            //.
            //. Properties:
            //.
            //.   - `forall s :: String, t :: String.
            //.      S.joinWith (s)
            //.                 (S.splitOnRegex (S.regex ('g') (S.regexEscape (s))) (t))
            //.      = t`
            //.
            //. See also [`splitOn`](#splitOn).
            //.
            //. ```javascript
            //. > S.splitOnRegex (/[,;][ ]*/g) ('foo, bar, baz')
            //. ['foo', 'bar', 'baz']
            //.
            //. > S.splitOnRegex (/[,;][ ]*/g) ('foo;bar;baz')
            //. ['foo', 'bar', 'baz']
            //. ```
            function splitOnRegex(pattern) {
              return function(s) {
                return withRegex(pattern, function() {
                  var result = [];
                  var lastIndex = 0;
                  var match;
                  while ((match = pattern.exec(s)) != null) {
                    if (pattern.lastIndex === lastIndex && match[0] === "") {
                      if (pattern.lastIndex === s.length) return result;
                      pattern.lastIndex += 1;
                    } else {
                      result.push(s.slice(lastIndex, match.index));
                      lastIndex = match.index + match[0].length;
                    }
                  }
                  result.push(s.slice(lastIndex));
                  return result;
                });
              };
            }
            _.splitOnRegex = {
              consts: {},
              types: [$.GlobalRegExp, $.String, $.Array($.String)],
              impl: splitOnRegex,
            };

            return create({
              checkTypes:
                /* global process:false */
                typeof process === "undefined" ||
                process == null ||
                process.env == null ||
                "development" !== "production",
              env: Z.concat($.env, [
                $.FiniteNumber,
                $.NonZeroFiniteNumber,
                $Either($.Unknown)($.Unknown),
                Fn($.Unknown)($.Unknown),
                $.GlobalRegExp,
                $.NonGlobalRegExp,
                $.Integer,
                $.NonNegativeInteger,
                $Maybe($.Unknown),
                $.Array2($.Unknown)($.Unknown),
                $Pair($.Unknown)($.Unknown),
                $.RegexFlags,
                $.Type,
                $.TypeClass,
                $.ValidDate,
                $.ValidNumber,
              ]),
            });
          });

          //. [#438]:                     https://github.com/sanctuary-js/sanctuary/issues/438
          //. [Apply]:                    v:fantasyland/fantasy-land#apply
          //. [BinaryType]:               v:sanctuary-js/sanctuary-def#BinaryType
          //. [Chain]:                    v:fantasyland/fantasy-land#chain
          //. [Either]:                   #either-type
          //. [Fantasy Land]:             v:fantasyland/fantasy-land
          //. [Foldable]:                 v:fantasyland/fantasy-land#foldable
          //. [GIGO]:                     https://en.wikipedia.org/wiki/Garbage_in,_garbage_out
          //. [Haskell]:                  https://www.haskell.org/
          //. [Kleisli]:                  https://en.wikipedia.org/wiki/Kleisli_category
          //. [Maybe]:                    #maybe-type
          //. [Nullable]:                 v:sanctuary-js/sanctuary-def#Nullable
          //. [PureScript]:               http://www.purescript.org/
          //. [Ramda]:                    http://ramdajs.com/
          //. [RegexFlags]:               v:sanctuary-js/sanctuary-def#RegexFlags
          //. [Semigroupoid]:             v:fantasyland/fantasy-land#semigroupoid
          //. [UnaryType]:                v:sanctuary-js/sanctuary-def#UnaryType
          //. [`$.test`]:                 v:sanctuary-js/sanctuary-def#test
          //. [`Descending`]:             v:sanctuary-js/sanctuary-descending#Descending
          //. [`R.__`]:                   http://ramdajs.com/docs/#__
          //. [`R.bind`]:                 http://ramdajs.com/docs/#bind
          //. [`R.invoker`]:              http://ramdajs.com/docs/#invoker
          //. [`Z.alt`]:                  v:sanctuary-js/sanctuary-type-classes#alt
          //. [`Z.ap`]:                   v:sanctuary-js/sanctuary-type-classes#ap
          //. [`Z.apFirst`]:              v:sanctuary-js/sanctuary-type-classes#apFirst
          //. [`Z.apSecond`]:             v:sanctuary-js/sanctuary-type-classes#apSecond
          //. [`Z.bimap`]:                v:sanctuary-js/sanctuary-type-classes#bimap
          //. [`Z.chain`]:                v:sanctuary-js/sanctuary-type-classes#chain
          //. [`Z.chainRec`]:             v:sanctuary-js/sanctuary-type-classes#chainRec
          //. [`Z.compose`]:              v:sanctuary-js/sanctuary-type-classes#compose
          //. [`Z.concat`]:               v:sanctuary-js/sanctuary-type-classes#concat
          //. [`Z.contramap`]:            v:sanctuary-js/sanctuary-type-classes#contramap
          //. [`Z.dropWhile`]:            v:sanctuary-js/sanctuary-type-classes#dropWhile
          //. [`Z.duplicate`]:            v:sanctuary-js/sanctuary-type-classes#duplicate
          //. [`Z.empty`]:                v:sanctuary-js/sanctuary-type-classes#empty
          //. [`Z.equals`]:               v:sanctuary-js/sanctuary-type-classes#equals
          //. [`Z.extend`]:               v:sanctuary-js/sanctuary-type-classes#extend
          //. [`Z.extract`]:              v:sanctuary-js/sanctuary-type-classes#extract
          //. [`Z.filter`]:               v:sanctuary-js/sanctuary-type-classes#filter
          //. [`Z.flip`]:                 v:sanctuary-js/sanctuary-type-classes#flip
          //. [`Z.foldMap`]:              v:sanctuary-js/sanctuary-type-classes#foldMap
          //. [`Z.gt`]:                   v:sanctuary-js/sanctuary-type-classes#gt
          //. [`Z.gte`]:                  v:sanctuary-js/sanctuary-type-classes#gte
          //. [`Z.id`]:                   v:sanctuary-js/sanctuary-type-classes#id
          //. [`Z.invert`]:               v:sanctuary-js/sanctuary-type-classes#invert
          //. [`Z.join`]:                 v:sanctuary-js/sanctuary-type-classes#join
          //. [`Z.lt`]:                   v:sanctuary-js/sanctuary-type-classes#lt
          //. [`Z.lte`]:                  v:sanctuary-js/sanctuary-type-classes#lte
          //. [`Z.map`]:                  v:sanctuary-js/sanctuary-type-classes#map
          //. [`Z.mapLeft`]:              v:sanctuary-js/sanctuary-type-classes#mapLeft
          //. [`Z.of`]:                   v:sanctuary-js/sanctuary-type-classes#of
          //. [`Z.promap`]:               v:sanctuary-js/sanctuary-type-classes#promap
          //. [`Z.reject`]:               v:sanctuary-js/sanctuary-type-classes#reject
          //. [`Z.sequence`]:             v:sanctuary-js/sanctuary-type-classes#sequence
          //. [`Z.takeWhile`]:            v:sanctuary-js/sanctuary-type-classes#takeWhile
          //. [`Z.traverse`]:             v:sanctuary-js/sanctuary-type-classes#traverse
          //. [`Z.zero`]:                 v:sanctuary-js/sanctuary-type-classes#zero
          //. [`show`]:                   v:sanctuary-js/sanctuary-show#show
          //. [equivalence]:              https://en.wikipedia.org/wiki/Equivalence_relation
          //. [iff]:                      https://en.wikipedia.org/wiki/If_and_only_if
          //. [parseInt]:                 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt
          //. [partial functions]:        https://en.wikipedia.org/wiki/Partial_function
          //. [ramda/ramda#683]:          https://github.com/ramda/ramda/issues/683
          //. [ramda/ramda#1413]:         https://github.com/ramda/ramda/issues/1413
          //. [ramda/ramda#1419]:         https://github.com/ramda/ramda/pull/1419
          //. [sanctuary-def]:            v:sanctuary-js/sanctuary-def
          //. [sanctuary-either]:         v:sanctuary-js/sanctuary-either
          //. [sanctuary-maybe]:          v:sanctuary-js/sanctuary-maybe
          //. [sanctuary-pair]:           v:sanctuary-js/sanctuary-pair
          //. [sanctuary-show]:           v:sanctuary-js/sanctuary-show
          //. [sanctuary-type-classes]:   v:sanctuary-js/sanctuary-type-classes
          //. [stable sort]:              https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
          //. [thrush]:                   https://github.com/raganwald-deprecated/homoiconic/blob/master/2008-10-30/thrush.markdown
          //. [total functions]:          https://en.wikipedia.org/wiki/Partial_function#Total_function
          //. [type checking]:            #type-checking
          //. [type identifier]:          v:sanctuary-js/sanctuary-type-identifiers
          //. [type representative]:      v:fantasyland/fantasy-land#type-representatives
          //. [variadic functions]:       https://en.wikipedia.org/wiki/Variadic_function

          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../process/browser.js */ "./node_modules/process/browser.js"
          )
        ));

        /***/
      },

    /***/ "./node_modules/util/support/isBufferBrowser.js":
      /*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        module.exports = function isBuffer(arg) {
          return (
            arg &&
            typeof arg === "object" &&
            typeof arg.copy === "function" &&
            typeof arg.fill === "function" &&
            typeof arg.readUInt8 === "function"
          );
        };

        /***/
      },

    /***/ "./node_modules/util/util.js":
      /*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
      /*! no static exports found */
      /***/ function(module, exports, __webpack_require__) {
        /* WEBPACK VAR INJECTION */ (function(global, process) {
          // Copyright Joyent, Inc. and other Node contributors.
          //
          // Permission is hereby granted, free of charge, to any person obtaining a
          // copy of this software and associated documentation files (the
          // "Software"), to deal in the Software without restriction, including
          // without limitation the rights to use, copy, modify, merge, publish,
          // distribute, sublicense, and/or sell copies of the Software, and to permit
          // persons to whom the Software is furnished to do so, subject to the
          // following conditions:
          //
          // The above copyright notice and this permission notice shall be included
          // in all copies or substantial portions of the Software.
          //
          // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
          // USE OR OTHER DEALINGS IN THE SOFTWARE.

          var formatRegExp = /%[sdj%]/g;
          exports.format = function(f) {
            if (!isString(f)) {
              var objects = [];
              for (var i = 0; i < arguments.length; i++) {
                objects.push(inspect(arguments[i]));
              }
              return objects.join(" ");
            }

            var i = 1;
            var args = arguments;
            var len = args.length;
            var str = String(f).replace(formatRegExp, function(x) {
              if (x === "%%") return "%";
              if (i >= len) return x;
              switch (x) {
                case "%s":
                  return String(args[i++]);
                case "%d":
                  return Number(args[i++]);
                case "%j":
                  try {
                    return JSON.stringify(args[i++]);
                  } catch (_) {
                    return "[Circular]";
                  }
                default:
                  return x;
              }
            });
            for (var x = args[i]; i < len; x = args[++i]) {
              if (isNull(x) || !isObject(x)) {
                str += " " + x;
              } else {
                str += " " + inspect(x);
              }
            }
            return str;
          };

          // Mark that a method should not be used.
          // Returns a modified function which warns once by default.
          // If --no-deprecation is set, then it is a no-op.
          exports.deprecate = function(fn, msg) {
            // Allow for deprecating things in the process of starting up.
            if (isUndefined(global.process)) {
              return function() {
                return exports.deprecate(fn, msg).apply(this, arguments);
              };
            }

            if (process.noDeprecation === true) {
              return fn;
            }

            var warned = false;
            function deprecated() {
              if (!warned) {
                if (process.throwDeprecation) {
                  throw new Error(msg);
                } else if (process.traceDeprecation) {
                  console.trace(msg);
                } else {
                  console.error(msg);
                }
                warned = true;
              }
              return fn.apply(this, arguments);
            }

            return deprecated;
          };

          var debugs = {};
          var debugEnviron;
          exports.debuglog = function(set) {
            if (isUndefined(debugEnviron))
              debugEnviron = process.env.NODE_DEBUG || "";
            set = set.toUpperCase();
            if (!debugs[set]) {
              if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                var pid = process.pid;
                debugs[set] = function() {
                  var msg = exports.format.apply(exports, arguments);
                  console.error("%s %d: %s", set, pid, msg);
                };
              } else {
                debugs[set] = function() {};
              }
            }
            return debugs[set];
          };

          /**
           * Echos the value of a value. Trys to print the value out
           * in the best way possible given the different types.
           *
           * @param {Object} obj The object to print out.
           * @param {Object} opts Optional options object that alters the output.
           */
          /* legacy: obj, showHidden, depth, colors*/
          function inspect(obj, opts) {
            // default options
            var ctx = {
              seen: [],
              stylize: stylizeNoColor,
            };
            // legacy...
            if (arguments.length >= 3) ctx.depth = arguments[2];
            if (arguments.length >= 4) ctx.colors = arguments[3];
            if (isBoolean(opts)) {
              // legacy...
              ctx.showHidden = opts;
            } else if (opts) {
              // got an "options" object
              exports._extend(ctx, opts);
            }
            // set default options
            if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
            if (isUndefined(ctx.depth)) ctx.depth = 2;
            if (isUndefined(ctx.colors)) ctx.colors = false;
            if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
            if (ctx.colors) ctx.stylize = stylizeWithColor;
            return formatValue(ctx, obj, ctx.depth);
          }
          exports.inspect = inspect;

          // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
          inspect.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39],
          };

          // Don't use 'blue' not visible on cmd.exe
          inspect.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            // "name": intentionally not styling
            regexp: "red",
          };

          function stylizeWithColor(str, styleType) {
            var style = inspect.styles[styleType];

            if (style) {
              return (
                "\u001b[" +
                inspect.colors[style][0] +
                "m" +
                str +
                "\u001b[" +
                inspect.colors[style][1] +
                "m"
              );
            } else {
              return str;
            }
          }

          function stylizeNoColor(str, styleType) {
            return str;
          }

          function arrayToHash(array) {
            var hash = {};

            array.forEach(function(val, idx) {
              hash[val] = true;
            });

            return hash;
          }

          function formatValue(ctx, value, recurseTimes) {
            // Provide a hook for user-specified inspect functions.
            // Check that value is an object with an inspect function on it
            if (
              ctx.customInspect &&
              value &&
              isFunction(value.inspect) &&
              // Filter out the util module, it's inspect function is special
              value.inspect !== exports.inspect &&
              // Also filter out any prototype objects using the circular check.
              !(value.constructor && value.constructor.prototype === value)
            ) {
              var ret = value.inspect(recurseTimes, ctx);
              if (!isString(ret)) {
                ret = formatValue(ctx, ret, recurseTimes);
              }
              return ret;
            }

            // Primitive types cannot have properties
            var primitive = formatPrimitive(ctx, value);
            if (primitive) {
              return primitive;
            }

            // Look up the keys of the object.
            var keys = Object.keys(value);
            var visibleKeys = arrayToHash(keys);

            if (ctx.showHidden) {
              keys = Object.getOwnPropertyNames(value);
            }

            // IE doesn't make error fields non-enumerable
            // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
            if (
              isError(value) &&
              (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)
            ) {
              return formatError(value);
            }

            // Some type of object without properties can be shortcutted.
            if (keys.length === 0) {
              if (isFunction(value)) {
                var name = value.name ? ": " + value.name : "";
                return ctx.stylize("[Function" + name + "]", "special");
              }
              if (isRegExp(value)) {
                return ctx.stylize(
                  RegExp.prototype.toString.call(value),
                  "regexp"
                );
              }
              if (isDate(value)) {
                return ctx.stylize(Date.prototype.toString.call(value), "date");
              }
              if (isError(value)) {
                return formatError(value);
              }
            }

            var base = "",
              array = false,
              braces = ["{", "}"];

            // Make Array say that they are Array
            if (isArray(value)) {
              array = true;
              braces = ["[", "]"];
            }

            // Make functions say that they are functions
            if (isFunction(value)) {
              var n = value.name ? ": " + value.name : "";
              base = " [Function" + n + "]";
            }

            // Make RegExps say that they are RegExps
            if (isRegExp(value)) {
              base = " " + RegExp.prototype.toString.call(value);
            }

            // Make dates with properties first say the date
            if (isDate(value)) {
              base = " " + Date.prototype.toUTCString.call(value);
            }

            // Make error with message first say the error
            if (isError(value)) {
              base = " " + formatError(value);
            }

            if (keys.length === 0 && (!array || value.length == 0)) {
              return braces[0] + base + braces[1];
            }

            if (recurseTimes < 0) {
              if (isRegExp(value)) {
                return ctx.stylize(
                  RegExp.prototype.toString.call(value),
                  "regexp"
                );
              } else {
                return ctx.stylize("[Object]", "special");
              }
            }

            ctx.seen.push(value);

            var output;
            if (array) {
              output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
            } else {
              output = keys.map(function(key) {
                return formatProperty(
                  ctx,
                  value,
                  recurseTimes,
                  visibleKeys,
                  key,
                  array
                );
              });
            }

            ctx.seen.pop();

            return reduceToSingleString(output, base, braces);
          }

          function formatPrimitive(ctx, value) {
            if (isUndefined(value))
              return ctx.stylize("undefined", "undefined");
            if (isString(value)) {
              var simple =
                "'" +
                JSON.stringify(value)
                  .replace(/^"|"$/g, "")
                  .replace(/'/g, "\\'")
                  .replace(/\\"/g, '"') +
                "'";
              return ctx.stylize(simple, "string");
            }
            if (isNumber(value)) return ctx.stylize("" + value, "number");
            if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
            // For some reason typeof null is "object", so special case here.
            if (isNull(value)) return ctx.stylize("null", "null");
          }

          function formatError(value) {
            return "[" + Error.prototype.toString.call(value) + "]";
          }

          function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
            var output = [];
            for (var i = 0, l = value.length; i < l; ++i) {
              if (hasOwnProperty(value, String(i))) {
                output.push(
                  formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    String(i),
                    true
                  )
                );
              } else {
                output.push("");
              }
            }
            keys.forEach(function(key) {
              if (!key.match(/^\d+$/)) {
                output.push(
                  formatProperty(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    key,
                    true
                  )
                );
              }
            });
            return output;
          }

          function formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            array
          ) {
            var name, str, desc;
            desc = Object.getOwnPropertyDescriptor(value, key) || {
              value: value[key],
            };
            if (desc.get) {
              if (desc.set) {
                str = ctx.stylize("[Getter/Setter]", "special");
              } else {
                str = ctx.stylize("[Getter]", "special");
              }
            } else {
              if (desc.set) {
                str = ctx.stylize("[Setter]", "special");
              }
            }
            if (!hasOwnProperty(visibleKeys, key)) {
              name = "[" + key + "]";
            }
            if (!str) {
              if (ctx.seen.indexOf(desc.value) < 0) {
                if (isNull(recurseTimes)) {
                  str = formatValue(ctx, desc.value, null);
                } else {
                  str = formatValue(ctx, desc.value, recurseTimes - 1);
                }
                if (str.indexOf("\n") > -1) {
                  if (array) {
                    str = str
                      .split("\n")
                      .map(function(line) {
                        return "  " + line;
                      })
                      .join("\n")
                      .substr(2);
                  } else {
                    str =
                      "\n" +
                      str
                        .split("\n")
                        .map(function(line) {
                          return "   " + line;
                        })
                        .join("\n");
                  }
                }
              } else {
                str = ctx.stylize("[Circular]", "special");
              }
            }
            if (isUndefined(name)) {
              if (array && key.match(/^\d+$/)) {
                return str;
              }
              name = JSON.stringify("" + key);
              if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                name = name.substr(1, name.length - 2);
                name = ctx.stylize(name, "name");
              } else {
                name = name
                  .replace(/'/g, "\\'")
                  .replace(/\\"/g, '"')
                  .replace(/(^"|"$)/g, "'");
                name = ctx.stylize(name, "string");
              }
            }

            return name + ": " + str;
          }

          function reduceToSingleString(output, base, braces) {
            var numLinesEst = 0;
            var length = output.reduce(function(prev, cur) {
              numLinesEst++;
              if (cur.indexOf("\n") >= 0) numLinesEst++;
              return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
            }, 0);

            if (length > 60) {
              return (
                braces[0] +
                (base === "" ? "" : base + "\n ") +
                " " +
                output.join(",\n  ") +
                " " +
                braces[1]
              );
            }

            return braces[0] + base + " " + output.join(", ") + " " + braces[1];
          }

          // NOTE: These type checking functions intentionally don't use `instanceof`
          // because it is fragile and can be easily faked with `Object.create()`.
          function isArray(ar) {
            return Array.isArray(ar);
          }
          exports.isArray = isArray;

          function isBoolean(arg) {
            return typeof arg === "boolean";
          }
          exports.isBoolean = isBoolean;

          function isNull(arg) {
            return arg === null;
          }
          exports.isNull = isNull;

          function isNullOrUndefined(arg) {
            return arg == null;
          }
          exports.isNullOrUndefined = isNullOrUndefined;

          function isNumber(arg) {
            return typeof arg === "number";
          }
          exports.isNumber = isNumber;

          function isString(arg) {
            return typeof arg === "string";
          }
          exports.isString = isString;

          function isSymbol(arg) {
            return typeof arg === "symbol";
          }
          exports.isSymbol = isSymbol;

          function isUndefined(arg) {
            return arg === void 0;
          }
          exports.isUndefined = isUndefined;

          function isRegExp(re) {
            return isObject(re) && objectToString(re) === "[object RegExp]";
          }
          exports.isRegExp = isRegExp;

          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          exports.isObject = isObject;

          function isDate(d) {
            return isObject(d) && objectToString(d) === "[object Date]";
          }
          exports.isDate = isDate;

          function isError(e) {
            return (
              isObject(e) &&
              (objectToString(e) === "[object Error]" || e instanceof Error)
            );
          }
          exports.isError = isError;

          function isFunction(arg) {
            return typeof arg === "function";
          }
          exports.isFunction = isFunction;

          function isPrimitive(arg) {
            return (
              arg === null ||
              typeof arg === "boolean" ||
              typeof arg === "number" ||
              typeof arg === "string" ||
              typeof arg === "symbol" || // ES6 symbol
              typeof arg === "undefined"
            );
          }
          exports.isPrimitive = isPrimitive;

          exports.isBuffer = __webpack_require__(
            /*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js"
          );

          function objectToString(o) {
            return Object.prototype.toString.call(o);
          }

          function pad(n) {
            return n < 10 ? "0" + n.toString(10) : n.toString(10);
          }

          var months = [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec",
          ];

          // 26 Feb 16:19:34
          function timestamp() {
            var d = new Date();
            var time = [
              pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds()),
            ].join(":");
            return [d.getDate(), months[d.getMonth()], time].join(" ");
          }

          // log is just a thin wrapper to console.log that prepends a timestamp
          exports.log = function() {
            console.log(
              "%s - %s",
              timestamp(),
              exports.format.apply(exports, arguments)
            );
          };

          /**
           * Inherit the prototype methods from one constructor into another.
           *
           * The Function.prototype.inherits from lang.js rewritten as a standalone
           * function (not on Function.prototype). NOTE: If this file is to be loaded
           * during bootstrapping this function needs to be rewritten using some native
           * functions as prototype setup using normal JavaScript does not work as
           * expected during bootstrapping (see mirror.js in r114903).
           *
           * @param {function} ctor Constructor function which needs to inherit the
           *     prototype.
           * @param {function} superCtor Constructor function to inherit prototype from.
           */
          exports.inherits = __webpack_require__(
            /*! inherits */ "./node_modules/inherits/inherits_browser.js"
          );

          exports._extend = function(origin, add) {
            // Don't do anything if add isn't an object
            if (!add || !isObject(add)) return origin;

            var keys = Object.keys(add);
            var i = keys.length;
            while (i--) {
              origin[keys[i]] = add[keys[i]];
            }
            return origin;
          };

          function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }

          /* WEBPACK VAR INJECTION */
        }.call(
          this,
          __webpack_require__(
            /*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"
          ),
          __webpack_require__(
            /*! ./../process/browser.js */ "./node_modules/process/browser.js"
          )
        ));

        /***/
      },

    /***/ "./node_modules/webpack/buildin/amd-options.js":
      /*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        /* WEBPACK VAR INJECTION */ (function(__webpack_amd_options__) {
          /* globals __webpack_amd_options__ */
          module.exports = __webpack_amd_options__;

          /* WEBPACK VAR INJECTION */
        }.call(this, {}));

        /***/
      },

    /***/ "./node_modules/webpack/buildin/global.js":
      /*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
      /*! no static exports found */
      /***/ function(module, exports) {
        var g;

        // This works in non-strict mode
        g = (function() {
          return this;
        })();

        try {
          // This works if eval is allowed (see CSP)
          g = g || new Function("return this")();
        } catch (e) {
          // This works if the window reference is available
          if (typeof window === "object") g = window;
        }

        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}

        module.exports = g;

        /***/
      },

    /***/ "./src/index.js":
      /*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
      /*! no exports provided */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony import */ var _print_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
          /*! ./print.js */ "./src/print.js"
        );
        /* eslint-env node */

        const { reduce, concat, map } = __webpack_require__(
          /*! sanctuary */ "./node_modules/sanctuary/index.js"
        );

        function join(list, separator) {
          return reduce(concat)("")(map(x => concat(x)(separator))(list));
        }

        function component() {
          const element = document.createElement("div");
          const btn = document.createElement("button");

          element.innerHTML = join(["Hello", "Webpack"], " ");

          btn.innerHTML = "Click me and check the console";
          btn.onclick = _print_js__WEBPACK_IMPORTED_MODULE_0__["default"];
          element.appendChild(btn);

          return element;
        }

        document.body.appendChild(component());

        /***/
      },

    /***/ "./src/print.js":
      /*!**********************!*\
  !*** ./src/print.js ***!
  \**********************/
      /*! exports provided: default */
      /***/ function(module, __webpack_exports__, __webpack_require__) {
        "use strict";
        __webpack_require__.r(__webpack_exports__);
        /* harmony export (binding) */ __webpack_require__.d(
          __webpack_exports__,
          "default",
          function() {
            return printMe;
          }
        );
        /* eslint-env node */

        function printMe() {
          console.log("I get called from print.js!");
        }

        /***/
      },

    /******/
  }
);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LWRlZi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LWVpdGhlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LW1heWJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktcGFpci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5LXNob3cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvbm9kZV9tb2R1bGVzL3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FuY3R1YXJ5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9wcmludC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBMEMsZ0NBQWdDO0FBQzFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQXdELGtCQUFrQjtBQUMxRTtBQUNBLHlEQUFpRCxjQUFjO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBeUMsaUNBQWlDO0FBQzFFLHdIQUFnSCxtQkFBbUIsRUFBRTtBQUNySTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOzs7QUFHQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVOzs7Ozs7Ozs7Ozs7QUN2THRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFNBQVM7QUFDMUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTLHFCQUFxQjtBQUNsRCxvQkFBb0IsU0FBUyxxQkFBcUI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDOWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDbGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEOztBQUVBOztBQUVBO0FBQ0EsTUFBTSxLQUEwQjtBQUNoQyx3QkFBd0IsbUJBQU8sRUFBRSw4REFBZ0I7QUFDakQsd0JBQXdCLG1CQUFPLEVBQUUsOEVBQXdCO0FBQ3pELEdBQUcsVUFBVSxLQUE0QixJQUFJLGdHQUFVO0FBQ3ZELElBQUksaUNBQVEsQ0FBQyxtRkFBZ0IsRUFBRSxtR0FBd0IsQ0FBQyxvQ0FBRSxDQUFDO0FBQUE7QUFBQTtBQUFBLG9HQUFDO0FBQzVELEdBQUc7QUFDSDtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9DQUFvQyxFQUFFO0FBQzVELHNCQUFzQixnQkFBZ0IsRUFBRTtBQUN4QyxzQkFBc0IsZ0JBQWdCLEVBQUU7QUFDeEM7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUEwQjtBQUM5QixJQUFJLG1CQUFPLEVBQUUseUNBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxNQUFNLEtBQTBCO0FBQ2hDO0FBQ0EsR0FBRyxVQUFVLEtBQTRCLElBQUksZ0dBQVU7QUFDdkQsSUFBSSxpQ0FBTyxFQUFFLG9DQUFFLENBQUM7QUFBQTtBQUFBO0FBQUEsb0dBQUM7QUFDakIsR0FBRztBQUNIO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDLEVBQUU7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsaUNBQWlDLEVBQUU7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYyxFQUFFO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMEJBQTBCLEVBQUU7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZCQUE2QixFQUFFO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkJBQTZCLEVBQUU7QUFDbEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsK0NBQStDLDBCQUEwQjtBQUN6RSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzV3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QixFQUFFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtDQUErQztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwrQ0FBK0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEUsT0FBTztBQUNQO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtQkFBbUIsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CLEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQ0FBZ0M7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsT0FBTyxtQkFBbUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBaUQsRUFBRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN4cUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1CQUFPLENBQUMsMEVBQW9COztBQUUvQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsNkRBQVU7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN6a0JBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNEQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUFBOztBQUVpQztBQUNqQyxPQUFPLHNCQUFzQixHQUFHLG1CQUFPLENBQUMsb0RBQVc7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxnQkFBZ0IsaURBQU87QUFDdkI7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ3RCQTtBQUFBO0FBQUE7O0FBRWU7QUFDZjtBQUNBIiwiZmlsZSI6ImFwcC5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qICAgICAgICAgICAgICBfX18gICAgICAgICAgICAgICAgIF9fX19fX1xuICAgICAgICAgICAgICAgLyAgL1xcICAgICAgICAgICAgICAgLyAgX19fL1xcXG4gICAgICAgIF9fX19fXy8gIC8gLyBfX19fX19fICAgIF9fLyAgL19fX1xcL1xuICAgICAgIC8gIF9fXyAgIC8gLyAvICBfX18gIFxcICAvXyAgIF9fL1xcXG4gICAgICAvICAvXFxfLyAgLyAvIC8gIC9fXy8gIC9cXCBcXC8gIC9cXF9cXC9cbiAgICAgLyAgLyAvLyAgLyAvIC8gIF9fX19fXy8gLyAvICAvIC9cbiAgICAvICAvXy8vICAvIC8gLyAgL19fX19fX1xcLyAvICAvIC9cbiAgICBcXF9fX19fX18vIC8gIFxcX19fX19fXy9cXCAgL19fLyAvXG4gICAgIFxcX19fX19fXFwvICAgIFxcX19fX19fXFwvICBcXF9fKi9cblxuLy8uICMgc2FuY3R1YXJ5LWRlZlxuLy8uXG4vLy4gc2FuY3R1YXJ5LWRlZiBpcyBhIHJ1bi10aW1lIHR5cGUgc3lzdGVtIGZvciBKYXZhU2NyaXB0LiBJdCBmYWNpbGl0YXRlc1xuLy8uIHRoZSBkZWZpbml0aW9uIG9mIGN1cnJpZWQgSmF2YVNjcmlwdCBmdW5jdGlvbnMgd2hpY2ggYXJlIGV4cGxpY2l0IGFib3V0XG4vLy4gdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gd2hpY2ggdGhleSBtYXkgYmUgYXBwbGllZCBhbmQgdGhlIHR5cGVzIG9mXG4vLy4gdGhvc2UgYXJndW1lbnRzLlxuLy8uXG4vLy4gSXQgaXMgY29udmVudGlvbmFsIHRvIGltcG9ydCB0aGUgcGFja2FnZSBhcyBgJGA6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gY29uc3QgJCA9IHJlcXVpcmUgKCdzYW5jdHVhcnktZGVmJyk7XG4vLy4gYGBgXG4vLy5cbi8vLiBUaGUgbmV4dCBzdGVwIGlzIHRvIGRlZmluZSBhbiBlbnZpcm9ubWVudC4gQW4gZW52aXJvbm1lbnQgaXMgYW4gYXJyYXlcbi8vLiBvZiBbdHlwZXNdW10uIFtgZW52YF1bXSBpcyBhbiBlbnZpcm9ubWVudCBjb250YWluaW5nIGFsbCB0aGUgYnVpbHQtaW5cbi8vLiBKYXZhU2NyaXB0IHR5cGVzLiBJdCBtYXkgYmUgdXNlZCBhcyB0aGUgYmFzaXMgZm9yIGVudmlyb25tZW50cyB3aGljaFxuLy8uIGluY2x1ZGUgY3VzdG9tIHR5cGVzIGluIGFkZGl0aW9uIHRvIHRoZSBidWlsdC1pbiB0eXBlczpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBJbnRlZ2VyIDo6IFR5cGVcbi8vLiBjb25zdCBJbnRlZ2VyID0gJy4uLic7XG4vLy5cbi8vLiAvLyAgICBOb25aZXJvSW50ZWdlciA6OiBUeXBlXG4vLy4gY29uc3QgTm9uWmVyb0ludGVnZXIgPSAnLi4uJztcbi8vLlxuLy8uIC8vICAgIGVudiA6OiBBcnJheSBUeXBlXG4vLy4gY29uc3QgZW52ID0gJC5lbnYuY29uY2F0IChbSW50ZWdlciwgTm9uWmVyb0ludGVnZXJdKTtcbi8vLiBgYGBcbi8vLlxuLy8uIFR5cGUgY29uc3RydWN0b3JzIHN1Y2ggYXMgYExpc3QgOjogVHlwZSAtPiBUeXBlYCBjYW5ub3QgYmUgaW5jbHVkZWQgaW5cbi8vLiBhbiBlbnZpcm9ubWVudCBhcyB0aGV5J3JlIG5vdCBvZiB0aGUgY29ycmVjdCB0eXBlLiBPbmUgY291bGQsIHRob3VnaCxcbi8vLiB1c2UgYSB0eXBlIGNvbnN0cnVjdG9yIHRvIGRlZmluZSBhIGZpeGVkIG51bWJlciBvZiBjb25jcmV0ZSB0eXBlczpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBlbnYgOjogQXJyYXkgVHlwZVxuLy8uIGNvbnN0IGVudiA9ICQuZW52LmNvbmNhdCAoW1xuLy8uICAgTGlzdCAoJC5OdW1iZXIpLCAgICAgICAgICAgICAgICAvLyA6OiBUeXBlXG4vLy4gICBMaXN0ICgkLlN0cmluZyksICAgICAgICAgICAgICAgIC8vIDo6IFR5cGVcbi8vLiAgIExpc3QgKExpc3QgKCQuTnVtYmVyKSksICAgICAgICAgLy8gOjogVHlwZVxuLy8uICAgTGlzdCAoTGlzdCAoJC5TdHJpbmcpKSwgICAgICAgICAvLyA6OiBUeXBlXG4vLy4gICBMaXN0IChMaXN0IChMaXN0ICgkLk51bWJlcikpKSwgIC8vIDo6IFR5cGVcbi8vLiAgIExpc3QgKExpc3QgKExpc3QgKCQuU3RyaW5nKSkpLCAgLy8gOjogVHlwZVxuLy8uIF0pO1xuLy8uIGBgYFxuLy8uXG4vLy4gTm90IG9ubHkgd291bGQgdGhpcyBiZSB0ZWRpb3VzLCBidXQgb25lIGNvdWxkIG5ldmVyIGVudW1lcmF0ZSBhbGwgcG9zc2libGVcbi8vLiB0eXBlcyBhcyB0aGVyZSBhcmUgaW5maW5pdGVseSBtYW55LiBJbnN0ZWFkLCBvbmUgc2hvdWxkIHVzZSBbYFVua25vd25gXVtdOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vICAgIGVudiA6OiBBcnJheSBUeXBlXG4vLy4gY29uc3QgZW52ID0gJC5lbnYuY29uY2F0IChbTGlzdCAoJC5Vbmtub3duKV0pO1xuLy8uIGBgYFxuLy8uXG4vLy4gVGhlIG5leHQgc3RlcCBpcyB0byBkZWZpbmUgYSBgZGVmYCBmdW5jdGlvbiBmb3IgdGhlIGVudmlyb25tZW50OlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIGNvbnN0IGRlZiA9ICQuY3JlYXRlICh7Y2hlY2tUeXBlczogdHJ1ZSwgZW52fSk7XG4vLy4gYGBgXG4vLy5cbi8vLiBUaGUgYGNoZWNrVHlwZXNgIG9wdGlvbiBkZXRlcm1pbmVzIHdoZXRoZXIgdHlwZSBjaGVja2luZyBpcyBlbmFibGVkLlxuLy8uIFRoaXMgYWxsb3dzIG9uZSB0byBvbmx5IHBheSB0aGUgcGVyZm9ybWFuY2UgY29zdCBvZiBydW4tdGltZSB0eXBlIGNoZWNraW5nXG4vLy4gZHVyaW5nIGRldmVsb3BtZW50LiBGb3IgZXhhbXBsZTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBjb25zdCBkZWYgPSAkLmNyZWF0ZSAoe1xuLy8uICAgY2hlY2tUeXBlczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcsXG4vLy4gICBlbnYsXG4vLy4gfSk7XG4vLy4gYGBgXG4vLy5cbi8vLiBgZGVmYCBpcyBhIGZ1bmN0aW9uIGZvciBkZWZpbmluZyBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vICAgIGFkZCA6OiBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuLy8uIGNvbnN0IGFkZCA9XG4vLy4gZGVmICgnYWRkJylcbi8vLiAgICAgKHt9KVxuLy8uICAgICAoWyQuTnVtYmVyLCAkLk51bWJlciwgJC5OdW1iZXJdKVxuLy8uICAgICAoeCA9PiB5ID0+IHggKyB5KTtcbi8vLiBgYGBcbi8vLlxuLy8uIGBbJC5OdW1iZXIsICQuTnVtYmVyLCAkLk51bWJlcl1gIHNwZWNpZmllcyB0aGF0IGBhZGRgIHRha2VzIHR3byBhcmd1bWVudHNcbi8vLiBvZiB0eXBlIGBOdW1iZXJgLCBvbmUgYXQgYSB0aW1lLCBhbmQgcmV0dXJucyBhIHZhbHVlIG9mIHR5cGUgYE51bWJlcmAuXG4vLy5cbi8vLiBBcHBseWluZyBgYWRkYCB0byB0d28gYXJndW1lbnRzLCBvbmUgYXQgYSB0aW1lLCBnaXZlcyB0aGUgZXhwZWN0ZWQgcmVzdWx0OlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIGFkZCAoMikgKDIpO1xuLy8uIC8vID0+IDRcbi8vLiBgYGBcbi8vLlxuLy8uIEFwcGx5aW5nIGBhZGRgIHRvIG11bHRpcGxlIGFyZ3VtZW50cyBhdCBvbmNlIHJlc3VsdHMgaW4gYW4gZXhjZXB0aW9uIGJlaW5nXG4vLy4gdGhyb3duOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIGFkZCAoMiwgMiwgMik7XG4vLy4gLy8gISBUeXBlRXJyb3I6IOKAmGFkZOKAmSBhcHBsaWVkIHRvIHRoZSB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXG4vLy4gLy9cbi8vLiAvLyAgIGFkZCA6OiBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuLy8uIC8vICAgICAgICAgIF5eXl5eXlxuLy8uIC8vICAgICAgICAgICAgMVxuLy8uIC8vXG4vLy4gLy8gICBFeHBlY3RlZCBvbmUgYXJndW1lbnQgYnV0IHJlY2VpdmVkIHRocmVlIGFyZ3VtZW50czpcbi8vLiAvL1xuLy8uIC8vICAgICAtIDJcbi8vLiAvLyAgICAgLSAyXG4vLy4gLy8gICAgIC0gMlxuLy8uIGBgYFxuLy8uXG4vLy4gQXBwbHlpbmcgYGFkZGAgdG8gb25lIGFyZ3VtZW50IHByb2R1Y2VzIGEgZnVuY3Rpb24gYXdhaXRpbmcgdGhlIHJlbWFpbmluZ1xuLy8uIGFyZ3VtZW50LiBUaGlzIGlzIGtub3duIGFzIHBhcnRpYWwgYXBwbGljYXRpb24uIFBhcnRpYWwgYXBwbGljYXRpb24gYWxsb3dzXG4vLy4gbW9yZSBzcGVjaWZpYyBmdW5jdGlvbnMgdG8gYmUgZGVmaW5lZCBpbiB0ZXJtcyBvZiBtb3JlIGdlbmVyYWwgb25lczpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgICBpbmMgOjogTnVtYmVyIC0+IE51bWJlclxuLy8uIGNvbnN0IGluYyA9IGFkZCAoMSk7XG4vLy5cbi8vLiBpbmMgKDcpO1xuLy8uIC8vID0+IDhcbi8vLiBgYGBcbi8vLlxuLy8uIEphdmFTY3JpcHQncyBpbXBsaWNpdCB0eXBlIGNvZXJjaW9uIG9mdGVuIG9iZnVzY2F0ZXMgdGhlIHNvdXJjZSBvZiB0eXBlXG4vLy4gZXJyb3JzLiBDb25zaWRlciB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vICAgIF9hZGQgOjogTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbi8vLiBjb25zdCBfYWRkID0geCA9PiB5ID0+IHggKyB5O1xuLy8uIGBgYFxuLy8uXG4vLy4gVGhlIHR5cGUgc2lnbmF0dXJlIGluZGljYXRlcyB0aGF0IGBfYWRkYCB0YWtlcyBhcmd1bWVudHMgb2YgdHlwZSBgTnVtYmVyYCxcbi8vLiBidXQgdGhpcyBpcyBub3QgZW5mb3JjZWQuIFRoaXMgYWxsb3dzIHR5cGUgZXJyb3JzIHRvIGJlIHNpbGVudGx5IGlnbm9yZWQ6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gX2FkZCAoJzInKSAoJzInKTtcbi8vLiAvLyA9PiAnMjInXG4vLy4gYGBgXG4vLy5cbi8vLiBgYWRkYCwgb24gdGhlIG90aGVyIGhhbmQsIHRocm93cyBpZiBhcHBsaWVkIHRvIGFyZ3VtZW50cyBvZiB0aGUgd3Jvbmdcbi8vLiB0eXBlczpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBhZGQgKCcyJykgKCcyJyk7XG4vLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbi8vLiAvL1xuLy8uIC8vICAgYWRkIDo6IE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4vLy4gLy8gICAgICAgICAgXl5eXl5eXG4vLy4gLy8gICAgICAgICAgICAxXG4vLy4gLy9cbi8vLiAvLyAgIDEpICBcIjJcIiA6OiBTdHJpbmdcbi8vLiAvL1xuLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmE51bWJlcuKAmS5cbi8vLiBgYGBcbi8vLlxuLy8uIFR5cGUgY2hlY2tpbmcgaXMgcGVyZm9ybWVkIGFzIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQgKHJhdGhlciB0aGFuIG9uY2UgYWxsXG4vLy4gYXJndW1lbnRzIGhhdmUgYmVlbiBwcm92aWRlZCksIHNvIHR5cGUgZXJyb3JzIGFyZSByZXBvcnRlZCBlYXJseTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBhZGQgKCdYJyk7XG4vLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbi8vLiAvL1xuLy8uIC8vICAgYWRkIDo6IE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4vLy4gLy8gICAgICAgICAgXl5eXl5eXG4vLy4gLy8gICAgICAgICAgICAxXG4vLy4gLy9cbi8vLiAvLyAgIDEpICBcIlhcIiA6OiBTdHJpbmdcbi8vLiAvL1xuLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmE51bWJlcuKAmS5cbi8vLiBgYGBcblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYgKHJlcXVpcmUgKCdzYW5jdHVhcnktZWl0aGVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LXNob3cnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUgKFsnc2FuY3R1YXJ5LWVpdGhlcicsXG4gICAgICAgICAgICAgJ3NhbmN0dWFyeS1zaG93JyxcbiAgICAgICAgICAgICAnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycsXG4gICAgICAgICAgICAgJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJ10sXG4gICAgICAgICAgICBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeURlZiA9IGYgKHNlbGYuc2FuY3R1YXJ5RWl0aGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYW5jdHVhcnlTaG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYW5jdHVhcnlUeXBlQ2xhc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2FuY3R1YXJ5VHlwZUlkZW50aWZpZXJzKTtcbiAgfVxuXG59IChmdW5jdGlvbihFaXRoZXIsIHNob3csIFosIHR5cGUpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBNYXRoLnBvdyAoMiwgNTMpIC0gMTtcbiAgdmFyIE1JTl9TQUZFX0lOVEVHRVIgPSAtTUFYX1NBRkVfSU5URUdFUjtcblxuICB2YXIgc2xpY2UgICAgICAgICAgICAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSAgICA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciB0b1N0cmluZyAgICAgICAgICA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgdmFyIGluc3BlY3QgPSAoZnVuY3Rpb24oKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIHV0aWwgPSByZXF1aXJlICgndXRpbCcpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh0eXBlb2YgdXRpbC5pbnNwZWN0LmN1c3RvbSA9PT0gJ3N5bWJvbCcpIHJldHVybiB1dGlsLmluc3BlY3QuY3VzdG9tO1xuICAgIH1cbiAgICByZXR1cm4gJ2luc3BlY3QnO1xuICB9ICgpKTtcblxuICAvLyAgTGVmdCA6OiBhIC0+IEVpdGhlciBhIGJcbiAgdmFyIExlZnQgPSBFaXRoZXIuTGVmdDtcblxuICAvLyAgUmlnaHQgOjogYiAtPiBFaXRoZXIgYSBiXG4gIHZhciBSaWdodCA9IEVpdGhlci5SaWdodDtcblxuICAvLyAgSyA6OiBhIC0+IGIgLT4gYVxuICBmdW5jdGlvbiBLKHgpIHsgcmV0dXJuIGZ1bmN0aW9uKHkpIHsgcmV0dXJuIHg7IH07IH1cblxuICAvLyAgVyA6OiAoYSAtPiBhIC0+IGIpIC0+IGEgLT4gYlxuICBmdW5jdGlvbiBXKGYpIHsgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGYgKHgpICh4KTsgfTsgfVxuXG4gIC8vICBhbHdheXMwIDo6IGEgLT4gKCkgLT4gYVxuICBmdW5jdGlvbiBhbHdheXMwKHgpIHsgcmV0dXJuIGZ1bmN0aW9uKCkgeyByZXR1cm4geDsgfTsgfVxuXG4gIC8vICBhbHdheXMyIDo6IGEgLT4gKGIsIGMpIC0+IGFcbiAgZnVuY3Rpb24gYWx3YXlzMih4KSB7IHJldHVybiBmdW5jdGlvbih5LCB6KSB7IHJldHVybiB4OyB9OyB9XG5cbiAgLy8gIGNvbXBvc2UgOjogKGIgLT4gYywgYSAtPiBiKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBjb21wb3NlKGYsIGcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGYgKGcgKHgpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIGlkIDo6IGEgLT4gYVxuICBmdW5jdGlvbiBpZCh4KSB7IHJldHVybiB4OyB9XG5cbiAgLy8gIGluaXQgOjogQXJyYXkgYSAtPiBBcnJheSBhXG4gIGZ1bmN0aW9uIGluaXQoeHMpIHsgcmV0dXJuIHhzLnNsaWNlICgwLCAtMSk7IH1cblxuICAvLyAgaXNFbXB0eSA6OiBBcnJheSBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gaXNFbXB0eSh4cykgeyByZXR1cm4geHMubGVuZ3RoID09PSAwOyB9XG5cbiAgLy8gIGlzUHJlZml4IDo6IEFycmF5IGEgLT4gQXJyYXkgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIGlzUHJlZml4KGNhbmRpZGF0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgaWYgKGNhbmRpZGF0ZS5sZW5ndGggPiB4cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGNhbmRpZGF0ZS5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICAgIGlmIChjYW5kaWRhdGVbaWR4XSAhPT0geHNbaWR4XSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBqb2luV2l0aCA6OiAoU3RyaW5nLCBBcnJheSBTdHJpbmcpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBqb2luV2l0aChzZXBhcmF0b3IsIHNzKSB7XG4gICAgcmV0dXJuIHNzLmpvaW4gKHNlcGFyYXRvcik7XG4gIH1cblxuICAvLyAgbGFzdCA6OiBBcnJheSBhIC0+IGFcbiAgZnVuY3Rpb24gbGFzdCh4cykgeyByZXR1cm4geHNbeHMubGVuZ3RoIC0gMV07IH1cblxuICAvLyAgbWVtYmVyT2YgOjogQXJyYXkgYSAtPiBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gbWVtYmVyT2YoeHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHhzLnNvbWUgKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFouZXF1YWxzICh4LCB5KTsgfSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBvciA6OiAoQXJyYXkgYSwgQXJyYXkgYSkgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBvcih4cywgeXMpIHsgcmV0dXJuIGlzRW1wdHkgKHhzKSA/IHlzIDogeHM7IH1cblxuICAvLyAgc3RyUmVwZWF0IDo6IChTdHJpbmcsIEludGVnZXIpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBzdHJSZXBlYXQocywgdGltZXMpIHtcbiAgICByZXR1cm4gam9pbldpdGggKHMsIEFycmF5ICh0aW1lcyArIDEpKTtcbiAgfVxuXG4gIC8vICByIDo6IENoYXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiByKGMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHN0clJlcGVhdCAoYywgcy5sZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAgXyA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIHZhciBfID0gciAoJyAnKTtcblxuICAvLyAgc29ydGVkS2V5cyA6OiBPYmplY3QgLT4gQXJyYXkgU3RyaW5nXG4gIGZ1bmN0aW9uIHNvcnRlZEtleXMobykge1xuICAgIHJldHVybiAoT2JqZWN0LmtleXMgKG8pKS5zb3J0ICgpO1xuICB9XG5cbiAgLy8gIHN0cmlwT3V0ZXJtb3N0UGFyZW5zIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gc3RyaXBPdXRlcm1vc3RQYXJlbnMocykge1xuICAgIHJldHVybiBzLnNsaWNlICgnKCcubGVuZ3RoLCAtJyknLmxlbmd0aCk7XG4gIH1cblxuICAvLyAgdG9NYXJrZG93bkxpc3QgOjogKFN0cmluZywgU3RyaW5nLCBhIC0+IFN0cmluZywgQXJyYXkgYSkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHRvTWFya2Rvd25MaXN0KGVtcHR5LCBzLCBmLCB4cykge1xuICAgIHJldHVybiBpc0VtcHR5ICh4cykgP1xuICAgICAgZW1wdHkgOlxuICAgICAgWi5yZWR1Y2UgKGZ1bmN0aW9uKHMsIHgpIHsgcmV0dXJuIHMgKyAnICAtICcgKyBmICh4KSArICdcXG4nOyB9LCBzLCB4cyk7XG4gIH1cblxuICAvLyAgdHJpbVRyYWlsaW5nU3BhY2VzIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gdHJpbVRyYWlsaW5nU3BhY2VzKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlICgvWyBdKyQvZ20sICcnKTtcbiAgfVxuXG4gIC8vICB1bmxlc3MgOjogKEJvb2xlYW4sIChhIC0+IGEpLCBhKSAtPiBhXG4gIGZ1bmN0aW9uIHVubGVzcyhib29sLCBmLCB4KSB7XG4gICAgcmV0dXJuIGJvb2wgPyB4IDogZiAoeCk7XG4gIH1cblxuICAvLyAgd2hlbiA6OiAoQm9vbGVhbiwgKGEgLT4gYSksIGEpIC0+IGFcbiAgZnVuY3Rpb24gd2hlbihib29sLCBmLCB4KSB7XG4gICAgcmV0dXJuIGJvb2wgPyBmICh4KSA6IHg7XG4gIH1cblxuICAvLyAgd3JhcCA6OiBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gd3JhcChwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3VmZml4KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcHJlZml4ICsgcyArIHN1ZmZpeDtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIC8vICBwYXJlbnRoZXNpemUgOjogU3RyaW5nIC0+IFN0cmluZ1xuICB2YXIgcGFyZW50aGVzaXplID0gd3JhcCAoJygnKSAoJyknKTtcblxuICAvLyAgcSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIHZhciBxID0gd3JhcCAoJ1xcdTIwMTgnKSAoJ1xcdTIwMTknKTtcblxuICAvLyAgc3RyaXBOYW1lc3BhY2UgOjogU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBzdHJpcE5hbWVzcGFjZShzKSB7IHJldHVybiBzLnNsaWNlIChzLmluZGV4T2YgKCcvJykgKyAxKTsgfVxuXG4gIC8vICBfVHlwZSA6OiAuLi4gLT4gVHlwZVxuICBmdW5jdGlvbiBfVHlwZShcbiAgICB0eXBlLCAgICAgICAvLyA6OiBTdHJpbmdcbiAgICBuYW1lLCAgICAgICAvLyA6OiBTdHJpbmdcbiAgICB1cmwsICAgICAgICAvLyA6OiBTdHJpbmdcbiAgICBmb3JtYXQsICAgICAvLyA6OiAoU3RyaW5nIC0+IFN0cmluZywgU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmcpIC0+IFN0cmluZ1xuICAgIHRlc3QsICAgICAgIC8vIDo6IEFueSAtPiBCb29sZWFuXG4gICAga2V5cywgICAgICAgLy8gOjogQXJyYXkgU3RyaW5nXG4gICAgdHlwZXMgICAgICAgLy8gOjogU3RyTWFwIHsgZXh0cmFjdG9yIDo6IGEgLT4gQXJyYXkgYiwgdHlwZSA6OiBUeXBlIH1cbiAgKSB7XG4gICAgdGhpcy5fdGVzdCA9IHRlc3Q7XG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy50eXBlcyA9IHR5cGVzO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG5cbiAgX1R5cGVbJ0BAdHlwZSddID0gJ3NhbmN0dWFyeS1kZWYvVHlwZSc7XG5cbiAgLy8gIFR5cGUjZmFudGFzeS1sYW5kL2VxdWFscyA6OiBUeXBlIH4+IFR5cGUgLT4gQm9vbGVhblxuICBfVHlwZS5wcm90b3R5cGVbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIFouZXF1YWxzICh0aGlzLnR5cGUsIG90aGVyLnR5cGUpICYmXG4gICAgICBaLmVxdWFscyAodGhpcy5uYW1lLCBvdGhlci5uYW1lKSAmJlxuICAgICAgWi5lcXVhbHMgKHRoaXMudXJsLCBvdGhlci51cmwpICYmXG4gICAgICBaLmVxdWFscyAodGhpcy5rZXlzLCBvdGhlci5rZXlzKSAmJlxuICAgICAgdGhpcy5rZXlzLmV2ZXJ5IChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJldHVybiBaLmVxdWFscyAodGhpcy50eXBlc1trXS50eXBlLCBvdGhlci50eXBlc1trXS50eXBlKTtcbiAgICAgIH0sIHRoaXMpXG4gICAgKTtcbiAgfTtcblxuICBfVHlwZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbih4KSB7XG4gICAgaWYgKCEodGhpcy5fdGVzdCAoeCkpKSByZXR1cm4gTGVmdCAoe3ZhbHVlOiB4LCBwcm9wUGF0aDogW119KTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLmtleXMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgdmFyIGsgPSB0aGlzLmtleXNbaWR4XTtcbiAgICAgIHZhciB0ID0gdGhpcy50eXBlc1trXTtcbiAgICAgIGZvciAodmFyIGlkeDIgPSAwLCB5cyA9IHQuZXh0cmFjdG9yICh4KTsgaWR4MiA8IHlzLmxlbmd0aDsgaWR4MiArPSAxKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0LnR5cGUudmFsaWRhdGUgKHlzW2lkeDJdKTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc0xlZnQpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWUudmFsdWU7XG4gICAgICAgICAgdmFyIHByb3BQYXRoID0gWi5jb25jYXQgKFtrXSwgcmVzdWx0LnZhbHVlLnByb3BQYXRoKTtcbiAgICAgICAgICByZXR1cm4gTGVmdCAoe3ZhbHVlOiB2YWx1ZSwgcHJvcFBhdGg6IHByb3BQYXRofSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFJpZ2h0ICh4KTtcbiAgfTtcblxuICBfVHlwZS5wcm90b3R5cGVbJ0BAc2hvdyddID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybWF0IChpZCwgSyAoaWQpKTtcbiAgfTtcblxuICB2YXIgQklOQVJZICAgICAgICA9ICdCSU5BUlknO1xuICB2YXIgRlVOQ1RJT04gICAgICA9ICdGVU5DVElPTic7XG4gIHZhciBJTkNPTlNJU1RFTlQgID0gJ0lOQ09OU0lTVEVOVCc7XG4gIHZhciBOT19BUkdVTUVOVFMgID0gJ05PX0FSR1VNRU5UUyc7XG4gIHZhciBOVUxMQVJZICAgICAgID0gJ05VTExBUlknO1xuICB2YXIgUkVDT1JEICAgICAgICA9ICdSRUNPUkQnO1xuICB2YXIgVU5BUlkgICAgICAgICA9ICdVTkFSWSc7XG4gIHZhciBVTktOT1dOICAgICAgID0gJ1VOS05PV04nO1xuICB2YXIgVkFSSUFCTEUgICAgICA9ICdWQVJJQUJMRSc7XG5cbiAgLy8gIEluY29uc2lzdGVudCA6OiBUeXBlXG4gIHZhciBJbmNvbnNpc3RlbnQgPVxuICBuZXcgX1R5cGUgKElOQ09OU0lTVEVOVCwgJycsICcnLCBhbHdheXMyICgnPz8/JyksIEsgKGZhbHNlKSwgW10sIHt9KTtcblxuICAvLyAgTm9Bcmd1bWVudHMgOjogVHlwZVxuICB2YXIgTm9Bcmd1bWVudHMgPVxuICBuZXcgX1R5cGUgKE5PX0FSR1VNRU5UUywgJycsICcnLCBhbHdheXMyICgnKCknKSwgSyAodHJ1ZSksIFtdLCB7fSk7XG5cbiAgLy8gIHR5cGVFcSA6OiBTdHJpbmcgLT4gYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIHR5cGVFcShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0eXBlICh4KSA9PT0gbmFtZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHR5cGVvZkVxIDo6IFN0cmluZyAtPiBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gdHlwZW9mRXEodHlwZW9mXykge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09IHR5cGVvZl87XG4gICAgfTtcbiAgfVxuXG4gIC8vICBmdW5jdGlvblVybCA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIGZ1bmN0aW9uVXJsKG5hbWUpIHtcbiAgICB2YXIgdmVyc2lvbiA9ICcwLjE4LjEnOyAgLy8gdXBkYXRlZCBwcm9ncmFtbWF0aWNhbGx5XG4gICAgcmV0dXJuICdodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYvdHJlZS92JyArIHZlcnNpb24gK1xuICAgICAgICAgICAnIycgKyBzdHJpcE5hbWVzcGFjZSAobmFtZSk7XG4gIH1cblxuICAvLyAgTnVsbGFyeVR5cGVXaXRoVXJsIDo6IChTdHJpbmcsIEFueSAtPiBCb29sZWFuKSAtPiBUeXBlXG4gIGZ1bmN0aW9uIE51bGxhcnlUeXBlV2l0aFVybChuYW1lLCB0ZXN0KSB7XG4gICAgcmV0dXJuIE51bGxhcnlUeXBlIChuYW1lKSAoZnVuY3Rpb25VcmwgKG5hbWUpKSAodGVzdCk7XG4gIH1cblxuICAvLyAgRW51bVR5cGVXaXRoVXJsIDo6IChTdHJpbmcsIEFycmF5IEFueSkgLT4gVHlwZVxuICBmdW5jdGlvbiBFbnVtVHlwZVdpdGhVcmwobmFtZSwgbWVtYmVycykge1xuICAgIHJldHVybiBFbnVtVHlwZSAobmFtZSkgKGZ1bmN0aW9uVXJsIChuYW1lKSkgKG1lbWJlcnMpO1xuICB9XG5cbiAgLy8gIFVuYXJ5VHlwZVdpdGhVcmwgOjpcbiAgLy8gICAgKFN0cmluZywgQW55IC0+IEJvb2xlYW4sIHQgYSAtPiBBcnJheSBhKSAtPiAoVHlwZSAtPiBUeXBlKVxuICBmdW5jdGlvbiBVbmFyeVR5cGVXaXRoVXJsKG5hbWUsIHRlc3QsIF8xKSB7XG4gICAgcmV0dXJuIFVuYXJ5VHlwZSAobmFtZSkgKGZ1bmN0aW9uVXJsIChuYW1lKSkgKHRlc3QpIChfMSk7XG4gIH1cblxuICAvLyAgQmluYXJ5VHlwZVdpdGhVcmwgOjpcbiAgLy8gICAgKFN0cmluZywgQW55IC0+IEJvb2xlYW4sIHQgYSBiIC0+IEFycmF5IGEsIHQgYSBiIC0+IEFycmF5IGIpIC0+XG4gIC8vICAgICAgKChUeXBlLCBUeXBlKSAtPiBUeXBlKVxuICBmdW5jdGlvbiBCaW5hcnlUeXBlV2l0aFVybChuYW1lLCB0ZXN0LCBfMSwgXzIpIHtcbiAgICByZXR1cm4gQmluYXJ5VHlwZSAobmFtZSkgKGZ1bmN0aW9uVXJsIChuYW1lKSkgKHRlc3QpIChfMSkgKF8yKTtcbiAgfVxuXG4gIC8vLiAjIyMgVHlwZXNcbiAgLy8uXG4gIC8vLiBDb25jZXB0dWFsbHksIGEgdHlwZSBpcyBhIHNldCBvZiB2YWx1ZXMuIE9uZSBjYW4gdGhpbmsgb2YgYSB2YWx1ZSBvZlxuICAvLy4gdHlwZSBgVHlwZWAgYXMgYSBmdW5jdGlvbiBvZiB0eXBlIGBBbnkgLT4gQm9vbGVhbmAgd2hpY2ggdGVzdHMgdmFsdWVzXG4gIC8vLiBmb3IgbWVtYmVyc2hpcCBpbiB0aGUgc2V0ICh0aG91Z2ggdGhpcyBpcyBhbiBvdmVyc2ltcGxpZmljYXRpb24pLlxuXG4gIC8vIyBBbnkgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBKYXZhU2NyaXB0IHZhbHVlLlxuICB2YXIgQW55ID0gTnVsbGFyeVR5cGVXaXRoVXJsICgnc2FuY3R1YXJ5LWRlZi9BbnknLCBLICh0cnVlKSk7XG5cbiAgLy8jIEFueUZ1bmN0aW9uIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgRnVuY3Rpb24gdmFsdWUuXG4gIHZhciBBbnlGdW5jdGlvbiA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ0Z1bmN0aW9uJywgdHlwZW9mRXEgKCdmdW5jdGlvbicpKTtcblxuICAvLyMgQXJndW1lbnRzIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2Bhcmd1bWVudHNgXVthcmd1bWVudHNdIG9iamVjdC5cbiAgdmFyIEFyZ3VtZW50cyA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ0FyZ3VtZW50cycsIHR5cGVFcSAoJ0FyZ3VtZW50cycpKTtcblxuICAvLyMgQXJyYXkgOjogVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gQ29uc3RydWN0b3IgZm9yIGhvbW9nZW5lb3VzIEFycmF5IHR5cGVzLlxuICB2YXIgQXJyYXlfID0gVW5hcnlUeXBlV2l0aFVybCAoJ0FycmF5JywgdHlwZUVxICgnQXJyYXknKSwgaWQpO1xuXG4gIC8vIyBBcnJheTAgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgd2hvc2Ugc29sZSBtZW1iZXIgaXMgYFtdYC5cbiAgdmFyIEFycmF5MCA9IE51bGxhcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvQXJyYXkwJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiB0eXBlRXEgKCdBcnJheScpICh4KSAmJiB4Lmxlbmd0aCA9PT0gMDsgfVxuICApO1xuXG4gIC8vIyBBcnJheTEgOjogVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gQ29uc3RydWN0b3IgZm9yIHNpbmdsZXRvbiBBcnJheSB0eXBlcy5cbiAgdmFyIEFycmF5MSA9IFVuYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL0FycmF5MScsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gdHlwZUVxICgnQXJyYXknKSAoeCkgJiYgeC5sZW5ndGggPT09IDE7IH0sXG4gICAgaWRcbiAgKTtcblxuICAvLyMgQXJyYXkyIDo6IFR5cGUgLT4gVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gQ29uc3RydWN0b3IgZm9yIGhldGVyb2dlbmVvdXMgQXJyYXkgdHlwZXMgb2YgbGVuZ3RoIDIuIGBbJ2ZvbycsIHRydWVdYCBpc1xuICAvLy4gYSBtZW1iZXIgb2YgYEFycmF5MiBTdHJpbmcgQm9vbGVhbmAuXG4gIHZhciBBcnJheTIgPSBCaW5hcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvQXJyYXkyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiB0eXBlRXEgKCdBcnJheScpICh4KSAmJiB4Lmxlbmd0aCA9PT0gMjsgfSxcbiAgICBmdW5jdGlvbihhcnJheTIpIHsgcmV0dXJuIFthcnJheTJbMF1dOyB9LFxuICAgIGZ1bmN0aW9uKGFycmF5MikgeyByZXR1cm4gW2FycmF5MlsxXV07IH1cbiAgKTtcblxuICAvLyMgQm9vbGVhbiA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGB0cnVlYCBhbmQgYGZhbHNlYC5cbiAgdmFyIEJvb2xlYW5fID0gTnVsbGFyeVR5cGVXaXRoVXJsICgnQm9vbGVhbicsIHR5cGVvZkVxICgnYm9vbGVhbicpKTtcblxuICAvLyMgRGF0ZSA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IERhdGUgdmFsdWUuXG4gIHZhciBEYXRlXyA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ0RhdGUnLCB0eXBlRXEgKCdEYXRlJykpO1xuXG4gIC8vIyBFcnJvciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IEVycm9yIHZhbHVlLCBpbmNsdWRpbmcgdmFsdWVzIG9mIG1vcmUgc3BlY2lmaWNcbiAgLy8uIGNvbnN0cnVjdG9ycyBzdWNoIGFzIFtgU3ludGF4RXJyb3JgXVtdIGFuZCBbYFR5cGVFcnJvcmBdW10uXG4gIHZhciBFcnJvcl8gPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdFcnJvcicsIHR5cGVFcSAoJ0Vycm9yJykpO1xuXG4gIC8vIyBGaW5pdGVOdW1iZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYFZhbGlkTnVtYmVyYF1bXSB2YWx1ZSBleGNlcHQgYEluZmluaXR5YCBhbmRcbiAgLy8uIGAtSW5maW5pdHlgLlxuICB2YXIgRmluaXRlTnVtYmVyID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9GaW5pdGVOdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFZhbGlkTnVtYmVyLl90ZXN0ICh4KSAmJiBpc0Zpbml0ZSAoeCk7IH1cbiAgKTtcblxuICAvLyAgYXVnbWVudFRodW5rIDo6IE5vbkVtcHR5IChBcnJheSBUeXBlKSAtPiBOb25FbXB0eSAoQXJyYXkgVHlwZSlcbiAgZnVuY3Rpb24gYXVnbWVudFRodW5rKHR5cGVzKSB7XG4gICAgcmV0dXJuIHR5cGVzLmxlbmd0aCA9PT0gMSA/IFouY29uY2F0IChbTm9Bcmd1bWVudHNdLCB0eXBlcykgOiB0eXBlcztcbiAgfVxuXG4gIC8vIyBGdW5jdGlvbiA6OiBOb25FbXB0eSAoQXJyYXkgVHlwZSkgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciBGdW5jdGlvbiB0eXBlcy5cbiAgLy8uXG4gIC8vLiBFeGFtcGxlczpcbiAgLy8uXG4gIC8vLiAgIC0gYCQuRnVuY3Rpb24gKFskLkRhdGUsICQuU3RyaW5nXSlgIHJlcHJlc2VudHMgdGhlIGBEYXRlIC0+IFN0cmluZ2BcbiAgLy8uICAgICB0eXBlOyBhbmRcbiAgLy8uICAgLSBgJC5GdW5jdGlvbiAoW2EsIGIsIGFdKWAgcmVwcmVzZW50cyB0aGUgYChhLCBiKSAtPiBhYCB0eXBlLlxuICBmdW5jdGlvbiBGdW5jdGlvbl8oX3R5cGVzKSB7XG4gICAgdmFyIHR5cGVzID0gYXVnbWVudFRodW5rIChfdHlwZXMpO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0KG91dGVyLCBpbm5lcikge1xuICAgICAgdmFyIHhzID0gdHlwZXMubWFwIChmdW5jdGlvbih0LCBpZHgpIHtcbiAgICAgICAgcmV0dXJuIHVubGVzcyAodC50eXBlID09PSBSRUNPUkQgfHwgaXNFbXB0eSAodC5rZXlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgc3RyaXBPdXRlcm1vc3RQYXJlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgIGlubmVyICgnJCcgKyBzaG93IChpZHggKyAxKSkgKHNob3cgKHQpKSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBwYXJlbnRoZXNpemUgPSB3cmFwIChvdXRlciAoJygnKSkgKG91dGVyICgnKScpKTtcbiAgICAgIHJldHVybiBwYXJlbnRoZXNpemUgKHVubGVzcyAodHlwZXMubGVuZ3RoID09PSAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRoZXNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5XaXRoIChvdXRlciAoJywgJyksIGluaXQgKHhzKSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyICgnIC0+ICcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgKHhzKSk7XG4gICAgfVxuXG4gICAgdmFyIHRlc3QgPSBBbnlGdW5jdGlvbi5fdGVzdDtcblxuICAgIHZhciAka2V5cyA9IFtdO1xuICAgIHZhciAkdHlwZXMgPSB7fTtcbiAgICB0eXBlcy5mb3JFYWNoIChmdW5jdGlvbih0LCBpZHgpIHtcbiAgICAgIHZhciBrID0gJyQnICsgc2hvdyAoaWR4ICsgMSk7XG4gICAgICAka2V5cy5wdXNoIChrKTtcbiAgICAgICR0eXBlc1trXSA9IHtleHRyYWN0b3I6IEsgKFtdKSwgdHlwZTogdH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IF9UeXBlIChGVU5DVElPTiwgJycsICcnLCBmb3JtYXQsIHRlc3QsICRrZXlzLCAkdHlwZXMpO1xuICB9XG5cbiAgLy8jIEdsb2JhbFJlZ0V4cCA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgUmVnRXhwYF1bXSB2YWx1ZSB3aG9zZSBgZ2xvYmFsYCBmbGFnIGlzIGB0cnVlYC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYE5vbkdsb2JhbFJlZ0V4cGBdW10uXG4gIHZhciBHbG9iYWxSZWdFeHAgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL0dsb2JhbFJlZ0V4cCcsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gUmVnRXhwXy5fdGVzdCAoeCkgJiYgeC5nbG9iYWw7IH1cbiAgKTtcblxuICAvLyMgSHRtbEVsZW1lbnQgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbSFRNTCBlbGVtZW50XVtdLlxuICB2YXIgSHRtbEVsZW1lbnQgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL0h0bWxFbGVtZW50JyxcbiAgICBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gL15cXFtvYmplY3QgSFRNTC4rRWxlbWVudFxcXSQvLnRlc3QgKHRvU3RyaW5nLmNhbGwgKHgpKTtcbiAgICB9XG4gICk7XG5cbiAgLy8jIEludGVnZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBpbnRlZ2VyIGluIHRoZSByYW5nZVxuICAvLy4gW1tgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVJgXVttaW5dIC4uIFtgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgXVttYXhdXS5cbiAgdmFyIEludGVnZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL0ludGVnZXInLFxuICAgIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBWYWxpZE51bWJlci5fdGVzdCAoeCkgJiZcbiAgICAgICAgICAgICBNYXRoLmZsb29yICh4KSA9PT0geCAmJlxuICAgICAgICAgICAgIHggPj0gTUlOX1NBRkVfSU5URUdFUiAmJlxuICAgICAgICAgICAgIHggPD0gTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG4gICk7XG5cbiAgLy8jIE5lZ2F0aXZlRmluaXRlTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BGaW5pdGVOdW1iZXJgXVtdIHZhbHVlIGxlc3MgdGhhbiB6ZXJvLlxuICB2YXIgTmVnYXRpdmVGaW5pdGVOdW1iZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL05lZ2F0aXZlRmluaXRlTnVtYmVyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBGaW5pdGVOdW1iZXIuX3Rlc3QgKHgpICYmIHggPCAwOyB9XG4gICk7XG5cbiAgLy8jIE5lZ2F0aXZlSW50ZWdlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgSW50ZWdlcmBdW10gdmFsdWUgbGVzcyB0aGFuIHplcm8uXG4gIHZhciBOZWdhdGl2ZUludGVnZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL05lZ2F0aXZlSW50ZWdlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gSW50ZWdlci5fdGVzdCAoeCkgJiYgeCA8IDA7IH1cbiAgKTtcblxuICAvLyMgTmVnYXRpdmVOdW1iZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYE51bWJlcmBdW10gdmFsdWUgbGVzcyB0aGFuIHplcm8uXG4gIHZhciBOZWdhdGl2ZU51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvTmVnYXRpdmVOdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE51bWJlcl8uX3Rlc3QgKHgpICYmIHggPCAwOyB9XG4gICk7XG5cbiAgLy8jIE5vbkVtcHR5IDo6IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciBub24tZW1wdHkgdHlwZXMuIGAkLk5vbkVtcHR5ICgkLlN0cmluZylgLCBmb3IgZXhhbXBsZSwgaXNcbiAgLy8uIHRoZSB0eXBlIGNvbXByaXNpbmcgZXZlcnkgW2BTdHJpbmdgXVtdIHZhbHVlIGV4Y2VwdCBgJydgLlxuICAvLy5cbiAgLy8uIFRoZSBnaXZlbiB0eXBlIG11c3Qgc2F0aXNmeSB0aGUgW01vbm9pZF1bXSBhbmQgW1NldG9pZF1bXSBzcGVjaWZpY2F0aW9ucy5cbiAgdmFyIE5vbkVtcHR5ID0gVW5hcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvTm9uRW1wdHknLFxuICAgIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBaLk1vbm9pZC50ZXN0ICh4KSAmJlxuICAgICAgICAgICAgIFouU2V0b2lkLnRlc3QgKHgpICYmXG4gICAgICAgICAgICAgIShaLmVxdWFscyAoeCwgWi5lbXB0eSAoeC5jb25zdHJ1Y3RvcikpKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKG1vbm9pZCkgeyByZXR1cm4gW21vbm9pZF07IH1cbiAgKTtcblxuICAvLyMgTm9uR2xvYmFsUmVnRXhwIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BSZWdFeHBgXVtdIHZhbHVlIHdob3NlIGBnbG9iYWxgIGZsYWcgaXMgYGZhbHNlYC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYEdsb2JhbFJlZ0V4cGBdW10uXG4gIHZhciBOb25HbG9iYWxSZWdFeHAgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL05vbkdsb2JhbFJlZ0V4cCcsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gUmVnRXhwXy5fdGVzdCAoeCkgJiYgIXguZ2xvYmFsOyB9XG4gICk7XG5cbiAgLy8jIE5vbk5lZ2F0aXZlSW50ZWdlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IG5vbi1uZWdhdGl2ZSBbYEludGVnZXJgXVtdIHZhbHVlIChpbmNsdWRpbmcgYC0wYCkuXG4gIC8vLiBBbHNvIGtub3duIGFzIHRoZSBzZXQgb2YgbmF0dXJhbCBudW1iZXJzIHVuZGVyIElTTyA4MDAwMC0yOjIwMDkuXG4gIHZhciBOb25OZWdhdGl2ZUludGVnZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL05vbk5lZ2F0aXZlSW50ZWdlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gSW50ZWdlci5fdGVzdCAoeCkgJiYgeCA+PSAwOyB9XG4gICk7XG5cbiAgLy8jIE5vblplcm9GaW5pdGVOdW1iZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYEZpbml0ZU51bWJlcmBdW10gdmFsdWUgZXhjZXB0IGAwYCBhbmQgYC0wYC5cbiAgdmFyIE5vblplcm9GaW5pdGVOdW1iZXIgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL05vblplcm9GaW5pdGVOdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIEZpbml0ZU51bWJlci5fdGVzdCAoeCkgJiYgeCAhPT0gMDsgfVxuICApO1xuXG4gIC8vIyBOb25aZXJvSW50ZWdlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgSW50ZWdlcmBdW10gdmFsdWUgZXhjZXB0IGAwYCBhbmQgYC0wYC5cbiAgdmFyIE5vblplcm9JbnRlZ2VyID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9Ob25aZXJvSW50ZWdlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gSW50ZWdlci5fdGVzdCAoeCkgJiYgeCAhPT0gMDsgfVxuICApO1xuXG4gIC8vIyBOb25aZXJvVmFsaWROdW1iZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYFZhbGlkTnVtYmVyYF1bXSB2YWx1ZSBleGNlcHQgYDBgIGFuZCBgLTBgLlxuICB2YXIgTm9uWmVyb1ZhbGlkTnVtYmVyID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9Ob25aZXJvVmFsaWROdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFZhbGlkTnVtYmVyLl90ZXN0ICh4KSAmJiB4ICE9PSAwOyB9XG4gICk7XG5cbiAgLy8jIE51bGwgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgd2hvc2Ugc29sZSBtZW1iZXIgaXMgYG51bGxgLlxuICB2YXIgTnVsbCA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ051bGwnLCB0eXBlRXEgKCdOdWxsJykpO1xuXG4gIC8vIyBOdWxsYWJsZSA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RvciBmb3IgdHlwZXMgd2hpY2ggaW5jbHVkZSBgbnVsbGAgYXMgYSBtZW1iZXIuXG4gIHZhciBOdWxsYWJsZSA9IFVuYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL051bGxhYmxlJyxcbiAgICBLICh0cnVlKSxcbiAgICBmdW5jdGlvbihudWxsYWJsZSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgcmV0dXJuIG51bGxhYmxlID09PSBudWxsID8gW10gOiBbbnVsbGFibGVdO1xuICAgIH1cbiAgKTtcblxuICAvLyMgTnVtYmVyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgcHJpbWl0aXZlIE51bWJlciB2YWx1ZSAoaW5jbHVkaW5nIGBOYU5gKS5cbiAgdmFyIE51bWJlcl8gPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdOdW1iZXInLCB0eXBlb2ZFcSAoJ251bWJlcicpKTtcblxuICAvLyMgT2JqZWN0IDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgXCJwbGFpblwiIE9iamVjdCB2YWx1ZS4gU3BlY2lmaWNhbGx5LCB2YWx1ZXNcbiAgLy8uIGNyZWF0ZWQgdmlhOlxuICAvLy5cbiAgLy8uICAgLSBvYmplY3QgbGl0ZXJhbCBzeW50YXg7XG4gIC8vLiAgIC0gW2BPYmplY3QuY3JlYXRlYF1bXTsgb3JcbiAgLy8uICAgLSB0aGUgYG5ld2Agb3BlcmF0b3IgaW4gY29uanVuY3Rpb24gd2l0aCBgT2JqZWN0YCBvciBhIGN1c3RvbVxuICAvLy4gICAgIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICB2YXIgT2JqZWN0XyA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ09iamVjdCcsIHR5cGVFcSAoJ09iamVjdCcpKTtcblxuICAvLyMgUG9zaXRpdmVGaW5pdGVOdW1iZXIgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYEZpbml0ZU51bWJlcmBdW10gdmFsdWUgZ3JlYXRlciB0aGFuIHplcm8uXG4gIHZhciBQb3NpdGl2ZUZpbml0ZU51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvUG9zaXRpdmVGaW5pdGVOdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIEZpbml0ZU51bWJlci5fdGVzdCAoeCkgJiYgeCA+IDA7IH1cbiAgKTtcblxuICAvLyMgUG9zaXRpdmVJbnRlZ2VyIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgW2BJbnRlZ2VyYF1bXSB2YWx1ZSBncmVhdGVyIHRoYW4gemVyby5cbiAgdmFyIFBvc2l0aXZlSW50ZWdlciA9IE51bGxhcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvUG9zaXRpdmVJbnRlZ2VyJyxcbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiBJbnRlZ2VyLl90ZXN0ICh4KSAmJiB4ID4gMDsgfVxuICApO1xuXG4gIC8vIyBQb3NpdGl2ZU51bWJlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgTnVtYmVyYF1bXSB2YWx1ZSBncmVhdGVyIHRoYW4gemVyby5cbiAgdmFyIFBvc2l0aXZlTnVtYmVyID0gTnVsbGFyeVR5cGVXaXRoVXJsIChcbiAgICAnc2FuY3R1YXJ5LWRlZi9Qb3NpdGl2ZU51bWJlcicsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gTnVtYmVyXy5fdGVzdCAoeCkgJiYgeCA+IDA7IH1cbiAgKTtcblxuICAvLyMgUmVnRXhwIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbXByaXNpbmcgZXZlcnkgUmVnRXhwIHZhbHVlLlxuICB2YXIgUmVnRXhwXyA9IE51bGxhcnlUeXBlV2l0aFVybCAoJ1JlZ0V4cCcsIHR5cGVFcSAoJ1JlZ0V4cCcpKTtcblxuICAvLyMgUmVnZXhGbGFncyA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIHRoZSBjYW5vbmljYWwgUmVnRXhwIGZsYWdzOlxuICAvLy5cbiAgLy8uICAgLSBgJydgXG4gIC8vLiAgIC0gYCdnJ2BcbiAgLy8uICAgLSBgJ2knYFxuICAvLy4gICAtIGAnbSdgXG4gIC8vLiAgIC0gYCdnaSdgXG4gIC8vLiAgIC0gYCdnbSdgXG4gIC8vLiAgIC0gYCdpbSdgXG4gIC8vLiAgIC0gYCdnaW0nYFxuICB2YXIgUmVnZXhGbGFncyA9IEVudW1UeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvUmVnZXhGbGFncycsXG4gICAgWycnLCAnZycsICdpJywgJ20nLCAnZ2knLCAnZ20nLCAnaW0nLCAnZ2ltJ11cbiAgKTtcblxuICAvLyMgU3RyTWFwIDo6IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdG9yIGZvciBob21vZ2VuZW91cyBPYmplY3QgdHlwZXMuXG4gIC8vLlxuICAvLy4gYHtmb286IDEsIGJhcjogMiwgYmF6OiAzfWAsIGZvciBleGFtcGxlLCBpcyBhIG1lbWJlciBvZiBgU3RyTWFwIE51bWJlcmA7XG4gIC8vLiBge2ZvbzogMSwgYmFyOiAyLCBiYXo6ICdYWFgnfWAgaXMgbm90LlxuICB2YXIgU3RyTWFwID0gVW5hcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvU3RyTWFwJyxcbiAgICBPYmplY3RfLl90ZXN0LFxuICAgIGZ1bmN0aW9uKHN0ck1hcCkge1xuICAgICAgcmV0dXJuIFoucmVkdWNlIChmdW5jdGlvbih4cywgeCkgeyB4cy5wdXNoICh4KTsgcmV0dXJuIHhzOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgc3RyTWFwKTtcbiAgICB9XG4gICk7XG5cbiAgLy8jIFN0cmluZyA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IHByaW1pdGl2ZSBTdHJpbmcgdmFsdWUuXG4gIHZhciBTdHJpbmdfID0gTnVsbGFyeVR5cGVXaXRoVXJsICgnU3RyaW5nJywgdHlwZW9mRXEgKCdzdHJpbmcnKSk7XG5cbiAgLy8jIFN5bWJvbCA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFN5bWJvbCB2YWx1ZS5cbiAgdmFyIFN5bWJvbF8gPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdTeW1ib2wnLCB0eXBlb2ZFcSAoJ3N5bWJvbCcpKTtcblxuICAvLyMgVHlwZSA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IGBUeXBlYCB2YWx1ZS5cbiAgdmFyIFR5cGUgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKCdUeXBlJywgdHlwZUVxICgnc2FuY3R1YXJ5LWRlZi9UeXBlJykpO1xuXG4gIC8vIyBUeXBlQ2xhc3MgOjogVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29tcHJpc2luZyBldmVyeSBbYFR5cGVDbGFzc2BdW10gdmFsdWUuXG4gIHZhciBUeXBlQ2xhc3MgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdUeXBlQ2xhc3MnLFxuICAgIHR5cGVFcSAoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvVHlwZUNsYXNzJylcbiAgKTtcblxuICAvLyMgVW5kZWZpbmVkIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIHdob3NlIHNvbGUgbWVtYmVyIGlzIGB1bmRlZmluZWRgLlxuICB2YXIgVW5kZWZpbmVkID0gTnVsbGFyeVR5cGVXaXRoVXJsICgnVW5kZWZpbmVkJywgdHlwZUVxICgnVW5kZWZpbmVkJykpO1xuXG4gIC8vIyBVbmtub3duIDo6IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIHVzZWQgdG8gcmVwcmVzZW50IG1pc3NpbmcgdHlwZSBpbmZvcm1hdGlvbi4gVGhlIHR5cGUgb2YgYFtdYCxcbiAgLy8uIGZvciBleGFtcGxlLCBpcyBgQXJyYXkgPz8/YC5cbiAgLy8uXG4gIC8vLiBNYXkgYmUgdXNlZCB3aXRoIHR5cGUgY29uc3RydWN0b3JzIHdoZW4gZGVmaW5pbmcgZW52aXJvbm1lbnRzLiBHaXZlbiBhXG4gIC8vLiB0eXBlIGNvbnN0cnVjdG9yIGBMaXN0IDo6IFR5cGUgLT4gVHlwZWAsIG9uZSBjb3VsZCB1c2UgYExpc3QgKCQuVW5rbm93bilgXG4gIC8vLiB0byBpbmNsdWRlIGFuIGluZmluaXRlIG51bWJlciBvZiB0eXBlcyBpbiBhbiBlbnZpcm9ubWVudDpcbiAgLy8uXG4gIC8vLiAgIC0gYExpc3QgTnVtYmVyYFxuICAvLy4gICAtIGBMaXN0IFN0cmluZ2BcbiAgLy8uICAgLSBgTGlzdCAoTGlzdCBOdW1iZXIpYFxuICAvLy4gICAtIGBMaXN0IChMaXN0IFN0cmluZylgXG4gIC8vLiAgIC0gYExpc3QgKExpc3QgKExpc3QgTnVtYmVyKSlgXG4gIC8vLiAgIC0gYExpc3QgKExpc3QgKExpc3QgU3RyaW5nKSlgXG4gIC8vLiAgIC0gYC4uLmBcbiAgdmFyIFVua25vd24gPVxuICBuZXcgX1R5cGUgKFVOS05PV04sICcnLCAnJywgYWx3YXlzMiAoJ1Vua25vd24nKSwgSyAodHJ1ZSksIFtdLCB7fSk7XG5cbiAgLy8jIFZhbGlkRGF0ZSA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgRGF0ZWBdW10gdmFsdWUgZXhjZXB0IGBuZXcgRGF0ZSAoTmFOKWAuXG4gIHZhciBWYWxpZERhdGUgPSBOdWxsYXJ5VHlwZVdpdGhVcmwgKFxuICAgICdzYW5jdHVhcnktZGVmL1ZhbGlkRGF0ZScsXG4gICAgZnVuY3Rpb24oeCkgeyByZXR1cm4gRGF0ZV8uX3Rlc3QgKHgpICYmICFpc05hTiAoeC52YWx1ZU9mICgpKTsgfVxuICApO1xuXG4gIC8vIyBWYWxpZE51bWJlciA6OiBUeXBlXG4gIC8vLlxuICAvLy4gVHlwZSBjb21wcmlzaW5nIGV2ZXJ5IFtgTnVtYmVyYF1bXSB2YWx1ZSBleGNlcHQgYE5hTmAuXG4gIHZhciBWYWxpZE51bWJlciA9IE51bGxhcnlUeXBlV2l0aFVybCAoXG4gICAgJ3NhbmN0dWFyeS1kZWYvVmFsaWROdW1iZXInLFxuICAgIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE51bWJlcl8uX3Rlc3QgKHgpICYmICFpc05hTiAoeCk7IH1cbiAgKTtcblxuICAvLyMgZW52IDo6IEFycmF5IFR5cGVcbiAgLy8uXG4gIC8vLiBBbiBhcnJheSBvZiBbdHlwZXNdW106XG4gIC8vLlxuICAvLy4gICAtIDxjb2RlPltBbnlGdW5jdGlvbl0oI0FueUZ1bmN0aW9uKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bQXJndW1lbnRzXSgjQXJndW1lbnRzKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bQXJyYXldKCNBcnJheSkgKFtVbmtub3duXSgjVW5rbm93bikpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltCb29sZWFuXSgjQm9vbGVhbik8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W0RhdGVdKCNEYXRlKTwvY29kZT5cbiAgLy8uICAgLSA8Y29kZT5bRXJyb3JdKCNFcnJvcik8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W0h0bWxFbGVtZW50XSgjSHRtbEVsZW1lbnQpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltOdWxsXSgjTnVsbCk8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W051bWJlcl0oI051bWJlcik8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W09iamVjdF0oI09iamVjdCk8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W1JlZ0V4cF0oI1JlZ0V4cCk8L2NvZGU+XG4gIC8vLiAgIC0gPGNvZGU+W1N0ck1hcF0oI1N0ck1hcCkgKFtVbmtub3duXSgjVW5rbm93bikpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltTdHJpbmddKCNTdHJpbmcpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltTeW1ib2xdKCNTeW1ib2wpPC9jb2RlPlxuICAvLy4gICAtIDxjb2RlPltVbmRlZmluZWRdKCNVbmRlZmluZWQpPC9jb2RlPlxuICB2YXIgZW52ID0gW1xuICAgIEFueUZ1bmN0aW9uLFxuICAgIEFyZ3VtZW50cyxcbiAgICBBcnJheV8gKFVua25vd24pLFxuICAgIEJvb2xlYW5fLFxuICAgIERhdGVfLFxuICAgIEVycm9yXyxcbiAgICBIdG1sRWxlbWVudCxcbiAgICBOdWxsLFxuICAgIE51bWJlcl8sXG4gICAgT2JqZWN0XyxcbiAgICBSZWdFeHBfLFxuICAgIFN0ck1hcCAoVW5rbm93biksXG4gICAgU3RyaW5nXyxcbiAgICBTeW1ib2xfLFxuICAgIFVuZGVmaW5lZFxuICBdO1xuXG4gIC8vICBVbmNoZWNrZWQgOjogU3RyaW5nIC0+IFR5cGVcbiAgZnVuY3Rpb24gVW5jaGVja2VkKHMpIHsgcmV0dXJuIE51bGxhcnlUeXBlIChzKSAoJycpIChLICh0cnVlKSk7IH1cblxuICAvLyAgcHJvZHVjdGlvbiA6OiBCb29sZWFuXG4gIHZhciBwcm9kdWN0aW9uID1cbiAgICB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAvKiBnbG9iYWwgcHJvY2VzczpmYWxzZSAqL1xuICAgIHByb2Nlc3MgIT0gbnVsbCAmJlxuICAgIHByb2Nlc3MuZW52ICE9IG51bGwgJiZcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG4gIHZhciBkZWYgPSBfY3JlYXRlICh7Y2hlY2tUeXBlczogIXByb2R1Y3Rpb24sIGVudjogZW52fSk7XG5cbiAgLy8gIG51bWJlcnMgOjogQXJyYXkgU3RyaW5nXG4gIHZhciBudW1iZXJzID0gW1xuICAgICd6ZXJvJyxcbiAgICAnb25lJyxcbiAgICAndHdvJyxcbiAgICAndGhyZWUnLFxuICAgICdmb3VyJyxcbiAgICAnZml2ZScsXG4gICAgJ3NpeCcsXG4gICAgJ3NldmVuJyxcbiAgICAnZWlnaHQnLFxuICAgICduaW5lJ1xuICBdO1xuXG4gIC8vICBudW1BcmdzIDo6IEludGVnZXIgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIG51bUFyZ3Mobikge1xuICAgIHJldHVybiAobiA8IG51bWJlcnMubGVuZ3RoID8gbnVtYmVyc1tuXSA6IHNob3cgKG4pKSArICcgJyArXG4gICAgICAgICAgIChuID09PSAxID8gJ2FyZ3VtZW50JyA6ICdhcmd1bWVudHMnKTtcbiAgfVxuXG4gIC8vICBleHBhbmRVbmtub3duIDo6IC4uLiAtPiBBcnJheSBUeXBlXG4gIGZ1bmN0aW9uIGV4cGFuZFVua25vd24oXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICBzZWVuLCAgICAgICAgICAgLy8gOjogQXJyYXkgT2JqZWN0XG4gICAgdmFsdWUsICAgICAgICAgIC8vIDo6IEFueVxuICAgIHIgICAgICAgICAgICAgICAvLyA6OiB7IGV4dHJhY3RvciA6OiBhIC0+IEFycmF5IGIsIHR5cGUgOjogVHlwZSB9XG4gICkge1xuICAgIHJldHVybiByLnR5cGUudHlwZSA9PT0gVU5LTk9XTiA/XG4gICAgICBfZGV0ZXJtaW5lQWN0dWFsVHlwZXMgKGVudiwgc2Vlbiwgci5leHRyYWN0b3IgKHZhbHVlKSkgOlxuICAgICAgW3IudHlwZV07XG4gIH1cblxuICAvLyAgX2RldGVybWluZUFjdHVhbFR5cGVzIDo6IC4uLiAtPiBBcnJheSBUeXBlXG4gIGZ1bmN0aW9uIF9kZXRlcm1pbmVBY3R1YWxUeXBlcyhcbiAgICBlbnYsICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHNlZW4sICAgICAgICAgICAvLyA6OiBBcnJheSBPYmplY3RcbiAgICB2YWx1ZXMgICAgICAgICAgLy8gOjogQXJyYXkgQW55XG4gICkge1xuICAgIGZ1bmN0aW9uIHJlZmluZSh0eXBlcywgdmFsdWUpIHtcbiAgICAgIHZhciBzZWVuJDtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9IG51bGwgfHxcbiAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gIEFib3J0IGlmIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIGVuY291bnRlcmVkOyBhZGQgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gIG9iamVjdCB0byB0aGUgYXJyYXkgb2Ygc2VlbiBvYmplY3RzIG90aGVyd2lzZS5cbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZiAodmFsdWUpID49IDApIHJldHVybiBbXTtcbiAgICAgICAgc2VlbiQgPSBaLmNvbmNhdCAoc2VlbiwgW3ZhbHVlXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWVuJCA9IHNlZW47XG4gICAgICB9XG4gICAgICByZXR1cm4gWi5jaGFpbiAoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHQubmFtZSA9PT0gJ3NhbmN0dWFyeS1kZWYvTnVsbGFibGUnIHx8ICh0LnZhbGlkYXRlICh2YWx1ZSkpLmlzTGVmdCA/XG4gICAgICAgICAgICBbXSA6XG4gICAgICAgICAgdC50eXBlID09PSBVTkFSWSA/XG4gICAgICAgICAgICBaLm1hcCAoZnJvbVVuYXJ5VHlwZSAodCksXG4gICAgICAgICAgICAgICAgICAgZXhwYW5kVW5rbm93biAoZW52LCBzZWVuJCwgdmFsdWUsIHQudHlwZXMuJDEpKSA6XG4gICAgICAgICAgdC50eXBlID09PSBCSU5BUlkgP1xuICAgICAgICAgICAgeHByb2QgKHQsXG4gICAgICAgICAgICAgICAgICAgZXhwYW5kVW5rbm93biAoZW52LCBzZWVuJCwgdmFsdWUsIHQudHlwZXMuJDEpLFxuICAgICAgICAgICAgICAgICAgIGV4cGFuZFVua25vd24gKGVudiwgc2VlbiQsIHZhbHVlLCB0LnR5cGVzLiQyKSkgOlxuICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgIFt0XVxuICAgICAgICApO1xuICAgICAgfSwgdHlwZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBpc0VtcHR5ICh2YWx1ZXMpID9cbiAgICAgIFtVbmtub3duXSA6XG4gICAgICBvciAoWi5yZWR1Y2UgKHJlZmluZSwgZW52LCB2YWx1ZXMpLCBbSW5jb25zaXN0ZW50XSk7XG4gIH1cblxuICAvLyAgaXNDb25zaXN0ZW50IDo6IFR5cGUgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBpc0NvbnNpc3RlbnQodCkge1xuICAgIHJldHVybiB0LnR5cGUgPT09IFVOQVJZICAgPyBpc0NvbnNpc3RlbnQgKHQudHlwZXMuJDEudHlwZSkgOlxuICAgICAgICAgICB0LnR5cGUgPT09IEJJTkFSWSAgPyBpc0NvbnNpc3RlbnQgKHQudHlwZXMuJDEudHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNDb25zaXN0ZW50ICh0LnR5cGVzLiQyLnR5cGUpIDpcbiAgICAgICAgICAgLyogZWxzZSAqLyAgICAgICAgICAgdC50eXBlICE9PSBJTkNPTlNJU1RFTlQ7XG4gIH1cblxuICAvLyAgZGV0ZXJtaW5lQWN0dWFsVHlwZXNTdHJpY3QgOjogKEFycmF5IFR5cGUsIEFycmF5IEFueSkgLT4gQXJyYXkgVHlwZVxuICBmdW5jdGlvbiBkZXRlcm1pbmVBY3R1YWxUeXBlc1N0cmljdChlbnYsIHZhbHVlcykge1xuICAgIHJldHVybiBaLmZpbHRlciAoaXNDb25zaXN0ZW50LFxuICAgICAgICAgICAgICAgICAgICAgX2RldGVybWluZUFjdHVhbFR5cGVzIChlbnYsIFtdLCB2YWx1ZXMpKTtcbiAgfVxuXG4gIC8vICBkZXRlcm1pbmVBY3R1YWxUeXBlc0xvb3NlIDo6IChBcnJheSBUeXBlLCBBcnJheSBBbnkpIC0+IEFycmF5IFR5cGVcbiAgZnVuY3Rpb24gZGV0ZXJtaW5lQWN0dWFsVHlwZXNMb29zZShlbnYsIHZhbHVlcykge1xuICAgIHJldHVybiBaLnJlamVjdCAoZnVuY3Rpb24odCkgeyByZXR1cm4gdC50eXBlID09PSBJTkNPTlNJU1RFTlQ7IH0sXG4gICAgICAgICAgICAgICAgICAgICBfZGV0ZXJtaW5lQWN0dWFsVHlwZXMgKGVudiwgW10sIHZhbHVlcykpO1xuICB9XG5cbiAgLy8gIFR5cGVJbmZvID0geyBuYW1lIDo6IFN0cmluZ1xuICAvLyAgICAgICAgICAgICAsIGNvbnN0cmFpbnRzIDo6IFN0ck1hcCAoQXJyYXkgVHlwZUNsYXNzKVxuICAvLyAgICAgICAgICAgICAsIHR5cGVzIDo6IE5vbkVtcHR5IChBcnJheSBUeXBlKSB9XG4gIC8vXG4gIC8vICBUeXBlVmFyTWFwID0gU3RyTWFwIHsgdHlwZXMgOjogQXJyYXkgVHlwZVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAsIHZhbHVlc0J5UGF0aCA6OiBTdHJNYXAgKEFycmF5IEFueSkgfVxuICAvL1xuICAvLyAgUHJvcFBhdGggPSBBcnJheSAoTnVtYmVyIHwgU3RyaW5nKVxuXG4gIC8vICB1cGRhdGVUeXBlVmFyTWFwIDo6IC4uLiAtPiBUeXBlVmFyTWFwXG4gIGZ1bmN0aW9uIHVwZGF0ZVR5cGVWYXJNYXAoXG4gICAgZW52LCAgICAgICAgICAgIC8vIDo6IEFycmF5IFR5cGVcbiAgICB0eXBlVmFyTWFwLCAgICAgLy8gOjogVHlwZVZhck1hcFxuICAgIHR5cGVWYXIsICAgICAgICAvLyA6OiBUeXBlXG4gICAgaW5kZXgsICAgICAgICAgIC8vIDo6IEludGVnZXJcbiAgICBwcm9wUGF0aCwgICAgICAgLy8gOjogUHJvcFBhdGhcbiAgICB2YWx1ZXMgICAgICAgICAgLy8gOjogQXJyYXkgQW55XG4gICkge1xuICAgIHZhciAkdHlwZVZhck1hcCA9IHt9O1xuICAgIGZvciAodmFyIHR5cGVWYXJOYW1lIGluIHR5cGVWYXJNYXApIHtcbiAgICAgIHZhciBlbnRyeSA9IHR5cGVWYXJNYXBbdHlwZVZhck5hbWVdO1xuICAgICAgdmFyICRlbnRyeSA9IHt0eXBlczogZW50cnkudHlwZXMuc2xpY2UgKCksIHZhbHVlc0J5UGF0aDoge319O1xuICAgICAgZm9yICh2YXIgayBpbiBlbnRyeS52YWx1ZXNCeVBhdGgpIHtcbiAgICAgICAgJGVudHJ5LnZhbHVlc0J5UGF0aFtrXSA9IGVudHJ5LnZhbHVlc0J5UGF0aFtrXS5zbGljZSAoKTtcbiAgICAgIH1cbiAgICAgICR0eXBlVmFyTWFwW3R5cGVWYXJOYW1lXSA9ICRlbnRyeTtcbiAgICB9XG4gICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbCAoJHR5cGVWYXJNYXAsIHR5cGVWYXIubmFtZSkpKSB7XG4gICAgICAkdHlwZVZhck1hcFt0eXBlVmFyLm5hbWVdID0ge3R5cGVzOiBlbnYuc2xpY2UgKCksIHZhbHVlc0J5UGF0aDoge319O1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeSAoWi5jb25jYXQgKFtpbmRleF0sIHByb3BQYXRoKSk7XG4gICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbCAoJHR5cGVWYXJNYXBbdHlwZVZhci5uYW1lXS52YWx1ZXNCeVBhdGgsIGtleSkpKSB7XG4gICAgICAkdHlwZVZhck1hcFt0eXBlVmFyLm5hbWVdLnZhbHVlc0J5UGF0aFtrZXldID0gW107XG4gICAgfVxuXG4gICAgdmFyIGlzTnVsbGFyeVR5cGVWYXIgPSBpc0VtcHR5ICh0eXBlVmFyLmtleXMpO1xuICAgIHZhciBpc1ZhbGlkID0gdGVzdCAoZW52KTtcblxuICAgIGZ1bmN0aW9uIGV4cGFuZFVua25vd25TdHJpY3QodmFsdWUsIHIpIHtcbiAgICAgIHJldHVybiBaLmZpbHRlciAoaXNDb25zaXN0ZW50LCBleHBhbmRVbmtub3duIChlbnYsIFtdLCB2YWx1ZSwgcikpO1xuICAgIH1cblxuICAgIHZhbHVlcy5mb3JFYWNoIChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgJHR5cGVWYXJNYXBbdHlwZVZhci5uYW1lXS52YWx1ZXNCeVBhdGhba2V5XS5wdXNoICh2YWx1ZSk7XG4gICAgICAkdHlwZVZhck1hcFt0eXBlVmFyLm5hbWVdLnR5cGVzID0gWi5jaGFpbiAoZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHQua2V5cy5sZW5ndGggPCB0eXBlVmFyLmtleXMubGVuZ3RoIHx8ICFpc1ZhbGlkICh0KSAodmFsdWUpID9cbiAgICAgICAgICAgIFtdIDpcbiAgICAgICAgICBpc051bGxhcnlUeXBlVmFyICYmIHQudHlwZSA9PT0gVU5BUlkgP1xuICAgICAgICAgICAgWi5tYXAgKGZyb21VbmFyeVR5cGUgKHQpLFxuICAgICAgICAgICAgICAgICAgIGV4cGFuZFVua25vd25TdHJpY3QgKHZhbHVlLCB0LnR5cGVzLiQxKSkgOlxuICAgICAgICAgIGlzTnVsbGFyeVR5cGVWYXIgJiYgdC50eXBlID09PSBCSU5BUlkgP1xuICAgICAgICAgICAgeHByb2QgKHQsXG4gICAgICAgICAgICAgICAgICAgZXhwYW5kVW5rbm93blN0cmljdCAodmFsdWUsIHQudHlwZXMuJDEpLFxuICAgICAgICAgICAgICAgICAgIGV4cGFuZFVua25vd25TdHJpY3QgKHZhbHVlLCB0LnR5cGVzLiQyKSkgOlxuICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgIFt0XVxuICAgICAgICApO1xuICAgICAgfSwgJHR5cGVWYXJNYXBbdHlwZVZhci5uYW1lXS50eXBlcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gJHR5cGVWYXJNYXA7XG4gIH1cblxuICAvLyAgdW5kZXJsaW5lVHlwZVZhcnMgOjogKFR5cGVJbmZvLCBTdHJNYXAgKEFycmF5IEFueSkpIC0+IFN0cmluZ1xuICBmdW5jdGlvbiB1bmRlcmxpbmVUeXBlVmFycyh0eXBlSW5mbywgdmFsdWVzQnlQYXRoKSB7XG4gICAgLy8gIE5vdGU6IFNvcnRpbmcgdGhlc2Uga2V5cyBsZXhpY29ncmFwaGljYWxseSBpcyBub3QgXCJjb3JyZWN0XCIsIGJ1dCBpdFxuICAgIC8vICBkb2VzIHRoZSByaWdodCB0aGluZyBmb3IgaW5kZXhlcyBsZXNzIHRoYW4gMTAuXG4gICAgdmFyIHBhdGhzID0gWi5tYXAgKEpTT04ucGFyc2UsIHNvcnRlZEtleXMgKHZhbHVlc0J5UGF0aCkpO1xuICAgIHJldHVybiB1bmRlcmxpbmUgKFxuICAgICAgdHlwZUluZm8sXG4gICAgICBLIChLIChfKSksXG4gICAgICBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocHJvcFBhdGgpIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ZWRQcm9wUGF0aCA9IFouY29uY2F0IChbaW5kZXhdLCBwcm9wUGF0aCk7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhzLnNvbWUgKGlzUHJlZml4IChpbmRleGVkUHJvcFBhdGgpKSkge1xuICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IEpTT04uc3RyaW5naWZ5IChpbmRleGVkUHJvcFBhdGgpO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbCAodmFsdWVzQnlQYXRoLCBrZXkpKSkgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICBpZiAoIShpc0VtcHR5ICh2YWx1ZXNCeVBhdGhba2V5XSkpKSByZXR1cm4gZiAocyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfIChzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICApO1xuICB9XG5cbiAgLy8gIHNhdGlzZmFjdG9yeVR5cGVzIDo6IC4uLiAtPiBFaXRoZXIgKCgpIC0+IEVycm9yKVxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHR5cGVWYXJNYXAgOjogVHlwZVZhck1hcFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHR5cGVzIDo6IEFycmF5IFR5cGUgfVxuICBmdW5jdGlvbiBzYXRpc2ZhY3RvcnlUeXBlcyhcbiAgICBlbnYsICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHR5cGVJbmZvLCAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIHR5cGVWYXJNYXAsICAgICAvLyA6OiBUeXBlVmFyTWFwXG4gICAgZXhwVHlwZSwgICAgICAgIC8vIDo6IFR5cGVcbiAgICBpbmRleCwgICAgICAgICAgLy8gOjogSW50ZWdlclxuICAgIHByb3BQYXRoLCAgICAgICAvLyA6OiBQcm9wUGF0aFxuICAgIHZhbHVlcyAgICAgICAgICAvLyA6OiBBcnJheSBBbnlcbiAgKSB7XG4gICAgdmFyIHJlY3VyID0gc2F0aXNmYWN0b3J5VHlwZXM7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB2YWx1ZXMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGV4cFR5cGUudmFsaWRhdGUgKHZhbHVlc1tpZHhdKTtcbiAgICAgIGlmIChyZXN1bHQuaXNMZWZ0KSB7XG4gICAgICAgIHJldHVybiBMZWZ0IChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbHVlIChlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWi5jb25jYXQgKHByb3BQYXRoLCByZXN1bHQudmFsdWUucHJvcFBhdGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC52YWx1ZS52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAoZXhwVHlwZS50eXBlKSB7XG5cbiAgICAgIGNhc2UgVkFSSUFCTEU6XG4gICAgICAgIHZhciB0eXBlVmFyTmFtZSA9IGV4cFR5cGUubmFtZTtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gdHlwZUluZm8uY29uc3RyYWludHM7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsIChjb25zdHJhaW50cywgdHlwZVZhck5hbWUpKSB7XG4gICAgICAgICAgdmFyIHR5cGVDbGFzc2VzID0gY29uc3RyYWludHNbdHlwZVZhck5hbWVdO1xuICAgICAgICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgdmFsdWVzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlkeDIgPSAwOyBpZHgyIDwgdHlwZUNsYXNzZXMubGVuZ3RoOyBpZHgyICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKCF0eXBlQ2xhc3Nlc1tpZHgyXS50ZXN0ICh2YWx1ZXNbaWR4XSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTGVmdCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZUNsYXNzQ29uc3RyYWludFZpb2xhdGlvbiAoXG4gICAgICAgICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIHR5cGVDbGFzc2VzW2lkeDJdLFxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcFBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpZHhdLFxuICAgICAgICAgICAgICAgICAgICB0eXBlVmFyTWFwXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHR5cGVWYXJNYXAkID0gdXBkYXRlVHlwZVZhck1hcCAoZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcyk7XG5cbiAgICAgICAgdmFyIG9rVHlwZXMgPSB0eXBlVmFyTWFwJFt0eXBlVmFyTmFtZV0udHlwZXM7XG4gICAgICAgIHJldHVybiBpc0VtcHR5IChva1R5cGVzKSA/XG4gICAgICAgICAgTGVmdCAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZVZhckNvbnN0cmFpbnRWaW9sYXRpb24gKFxuICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgcHJvcFBhdGgsXG4gICAgICAgICAgICAgIHR5cGVWYXJNYXAkW3R5cGVWYXJOYW1lXS52YWx1ZXNCeVBhdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSkgOlxuICAgICAgICAgIFoucmVkdWNlIChmdW5jdGlvbihlLCB0KSB7XG4gICAgICAgICAgICByZXR1cm4gWi5jaGFpbiAoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAvLyAgVGhlIGBhYCBpbiBgRnVuY3RvciBmID0+IGYgYWAgY29ycmVzcG9uZHMgdG8gdGhlIGBhYFxuICAgICAgICAgICAgICAvLyAgaW4gYE1heWJlIGFgIGJ1dCB0byB0aGUgYGJgIGluIGBFaXRoZXIgYSBiYC4gQSB0eXBlXG4gICAgICAgICAgICAgIC8vICB2YXJpYWJsZSdzICQxIHdpbGwgY29ycmVzcG9uZCB0byBlaXRoZXIgJDEgb3IgJDIgb2ZcbiAgICAgICAgICAgICAgLy8gIHRoZSBhY3R1YWwgdHlwZSBkZXBlbmRpbmcgb24gdGhlIGFjdHVhbCB0eXBlJ3MgYXJpdHkuXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0LmtleXMubGVuZ3RoIC0gZXhwVHlwZS5rZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cFR5cGUua2V5cy5yZWR1Y2UgKGZ1bmN0aW9uKGUsIGssIGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBleHRyYWN0b3IgPSB0LnR5cGVzW3Qua2V5c1tvZmZzZXQgKyBpZHhdXS5leHRyYWN0b3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFoucmVkdWNlIChmdW5jdGlvbihlLCB4KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gWi5jaGFpbiAoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjdXIgKGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwVHlwZS50eXBlc1trXS50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFouY29uY2F0IChwcm9wUGF0aCwgW2tdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbeF0pO1xuICAgICAgICAgICAgICAgICAgfSwgZSk7XG4gICAgICAgICAgICAgICAgfSwgZSwgWi5jaGFpbiAoZXh0cmFjdG9yLCB2YWx1ZXMpKTtcbiAgICAgICAgICAgICAgfSwgUmlnaHQgKHIpKTtcbiAgICAgICAgICAgIH0sIGUpO1xuICAgICAgICAgIH0sIFJpZ2h0ICh7dHlwZVZhck1hcDogdHlwZVZhck1hcCQsIHR5cGVzOiBva1R5cGVzfSksIG9rVHlwZXMpO1xuXG4gICAgICBjYXNlIFVOQVJZOlxuICAgICAgICByZXR1cm4gWi5tYXAgKFxuICAgICAgICAgIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZVZhck1hcDogcmVzdWx0LnR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgIHR5cGVzOiBaLm1hcCAoZnJvbVVuYXJ5VHlwZSAoZXhwVHlwZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3IgKHJlc3VsdC50eXBlcywgW2V4cFR5cGUudHlwZXMuJDEudHlwZV0pKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3VyIChlbnYsXG4gICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICB0eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICBleHBUeXBlLnR5cGVzLiQxLnR5cGUsXG4gICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICBaLmNvbmNhdCAocHJvcFBhdGgsIFsnJDEnXSksXG4gICAgICAgICAgICAgICAgIFouY2hhaW4gKGV4cFR5cGUudHlwZXMuJDEuZXh0cmFjdG9yLCB2YWx1ZXMpKVxuICAgICAgICApO1xuXG4gICAgICBjYXNlIEJJTkFSWTpcbiAgICAgICAgcmV0dXJuIFouY2hhaW4gKFxuICAgICAgICAgIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyICQxcyA9IHJlc3VsdC50eXBlcztcbiAgICAgICAgICAgIHJldHVybiBaLm1hcCAoXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciAkMnMgPSByZXN1bHQudHlwZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHR5cGVWYXJNYXA6IHJlc3VsdC50eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICAgdHlwZXM6IHhwcm9kIChleHBUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciAoJDFzLCBbZXhwVHlwZS50eXBlcy4kMS50eXBlXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yICgkMnMsIFtleHBUeXBlLnR5cGVzLiQyLnR5cGVdKSlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZWN1ciAoZW52LFxuICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQudHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgICAgIGV4cFR5cGUudHlwZXMuJDIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgWi5jb25jYXQgKHByb3BQYXRoLCBbJyQyJ10pLFxuICAgICAgICAgICAgICAgICAgICAgWi5jaGFpbiAoZXhwVHlwZS50eXBlcy4kMi5leHRyYWN0b3IsIHZhbHVlcykpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVjdXIgKGVudixcbiAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgIHR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgICAgIGV4cFR5cGUudHlwZXMuJDEudHlwZSxcbiAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgIFouY29uY2F0IChwcm9wUGF0aCwgWyckMSddKSxcbiAgICAgICAgICAgICAgICAgWi5jaGFpbiAoZXhwVHlwZS50eXBlcy4kMS5leHRyYWN0b3IsIHZhbHVlcykpXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgUkVDT1JEOlxuICAgICAgICByZXR1cm4gWi5yZWR1Y2UgKGZ1bmN0aW9uKGUsIGspIHtcbiAgICAgICAgICByZXR1cm4gWi5jaGFpbiAoZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgcmV0dXJuIHJlY3VyIChlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICByLnR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4cFR5cGUudHlwZXNba10udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFouY29uY2F0IChwcm9wUGF0aCwgW2tdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgWi5jaGFpbiAoZXhwVHlwZS50eXBlc1trXS5leHRyYWN0b3IsIHZhbHVlcykpO1xuICAgICAgICAgIH0sIGUpO1xuICAgICAgICB9LCBSaWdodCAoe3R5cGVWYXJNYXA6IHR5cGVWYXJNYXAsIHR5cGVzOiBbZXhwVHlwZV19KSwgZXhwVHlwZS5rZXlzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFJpZ2h0ICh7dHlwZVZhck1hcDogdHlwZVZhck1hcCwgdHlwZXM6IFtleHBUeXBlXX0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIyB0ZXN0IDo6IEFycmF5IFR5cGUgLT4gVHlwZSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhbiBlbnZpcm9ubWVudCwgYSB0eXBlLCBhbmQgYW55IHZhbHVlLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVcbiAgLy8uIGlzIGEgbWVtYmVyIG9mIHRoZSB0eXBlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGUgZW52aXJvbm1lbnQgaXMgb25seSBzaWduaWZpY2FudCBpZiB0aGUgdHlwZSBjb250YWluc1xuICAvLy4gW3R5cGUgdmFyaWFibGVzXVtdLlxuICAvLy5cbiAgLy8uIE9uZSBtYXkgZGVmaW5lIGEgbW9yZSByZXN0cmljdGl2ZSB0eXBlIGluIHRlcm1zIG9mIGEgbW9yZSBnZW5lcmFsIG9uZTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiAvLyAgICBOb25OZWdhdGl2ZUludGVnZXIgOjogVHlwZVxuICAvLy4gY29uc3QgTm9uTmVnYXRpdmVJbnRlZ2VyID0gJC5OdWxsYXJ5VHlwZVxuICAvLy4gICAoJ215LXBhY2thZ2UvTm9uTmVnYXRpdmVJbnRlZ2VyJylcbiAgLy8uICAgKCdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNOb25OZWdhdGl2ZUludGVnZXInKVxuICAvLy4gICAoeCA9PiAkLnRlc3QgKFtdKSAoJC5JbnRlZ2VyKSAoeCkgJiYgeCA+PSAwKTtcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFVzaW5nIHR5cGVzIGFzIHByZWRpY2F0ZXMgaXMgdXNlZnVsIGluIG90aGVyIGNvbnRleHRzIHRvby4gT25lIGNvdWxkLFxuICAvLy4gZm9yIGV4YW1wbGUsIGRlZmluZSBhIFtyZWNvcmQgdHlwZV1bXSBmb3IgZWFjaCBlbmRwb2ludCBvZiBhIFJFU1QgQVBJXG4gIC8vLiBhbmQgdmFsaWRhdGUgdGhlIGJvZGllcyBvZiBpbmNvbWluZyBQT1NUIHJlcXVlc3RzIGFnYWluc3QgdGhlc2UgdHlwZXMuXG4gIGZ1bmN0aW9uIHRlc3QoZW52KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciB0eXBlSW5mbyA9IHtuYW1lOiAnbmFtZScsIGNvbnN0cmFpbnRzOiB7fSwgdHlwZXM6IFt0XX07XG4gICAgICAgIHJldHVybiAoc2F0aXNmYWN0b3J5VHlwZXMgKGVudiwgdHlwZUluZm8sIHt9LCB0LCAwLCBbXSwgW3hdKSkuaXNSaWdodDtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIC8vLiAjIyMgVHlwZSBjb25zdHJ1Y3RvcnNcbiAgLy8uXG4gIC8vLiBzYW5jdHVhcnktZGVmIHByb3ZpZGVzIHNldmVyYWwgZnVuY3Rpb25zIGZvciBkZWZpbmluZyB0eXBlcy5cblxuICAvLyMgTnVsbGFyeVR5cGUgOjogU3RyaW5nIC0+IFN0cmluZyAtPiAoQW55IC0+IEJvb2xlYW4pIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBUeXBlIGNvbnN0cnVjdG9yIGZvciB0eXBlcyB3aXRoIG5vIHR5cGUgdmFyaWFibGVzIChzdWNoIGFzIFtgTnVtYmVyYF1bXSkuXG4gIC8vLlxuICAvLy4gVG8gZGVmaW5lIGEgbnVsbGFyeSB0eXBlIGB0YCBvbmUgbXVzdCBwcm92aWRlOlxuICAvLy5cbiAgLy8uICAgLSB0aGUgbmFtZSBvZiBgdGAgKGV4cG9zZWQgYXMgYHQubmFtZWApO1xuICAvLy5cbiAgLy8uICAgLSB0aGUgZG9jdW1lbnRhdGlvbiBVUkwgb2YgYHRgIChleHBvc2VkIGFzIGB0LnVybGApOyBhbmRcbiAgLy8uXG4gIC8vLiAgIC0gYSBwcmVkaWNhdGUgd2hpY2ggYWNjZXB0cyBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBhbmQgcmV0dXJucyBgdHJ1ZWAgaWZcbiAgLy8uICAgICAoYW5kIG9ubHkgaWYpIHRoZSB2YWx1ZSBpcyBhIG1lbWJlciBvZiBgdGAuXG4gIC8vLlxuICAvLy4gRm9yIGV4YW1wbGU6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gLy8gICAgSW50ZWdlciA6OiBUeXBlXG4gIC8vLiBjb25zdCBJbnRlZ2VyID0gJC5OdWxsYXJ5VHlwZVxuICAvLy4gICAoJ215LXBhY2thZ2UvSW50ZWdlcicpXG4gIC8vLiAgICgnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjSW50ZWdlcicpXG4gIC8vLiAgICh4ID0+IHR5cGVvZiB4ID09PSAnbnVtYmVyJyAmJlxuICAvLy4gICAgICAgICBNYXRoLmZsb29yICh4KSA9PT0geCAmJlxuICAvLy4gICAgICAgICB4ID49IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSICYmXG4gIC8vLiAgICAgICAgIHggPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAvLy5cbiAgLy8uIC8vICAgIE5vblplcm9JbnRlZ2VyIDo6IFR5cGVcbiAgLy8uIGNvbnN0IE5vblplcm9JbnRlZ2VyID0gJC5OdWxsYXJ5VHlwZVxuICAvLy4gICAoJ215LXBhY2thZ2UvTm9uWmVyb0ludGVnZXInKVxuICAvLy4gICAoJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI05vblplcm9JbnRlZ2VyJylcbiAgLy8uICAgKHggPT4gJC50ZXN0IChbXSkgKEludGVnZXIpICh4KSAmJiB4ICE9PSAwKTtcbiAgLy8uXG4gIC8vLiAvLyAgICByZW0gOjogSW50ZWdlciAtPiBOb25aZXJvSW50ZWdlciAtPiBJbnRlZ2VyXG4gIC8vLiBjb25zdCByZW0gPVxuICAvLy4gZGVmICgncmVtJylcbiAgLy8uICAgICAoe30pXG4gIC8vLiAgICAgKFtJbnRlZ2VyLCBOb25aZXJvSW50ZWdlciwgSW50ZWdlcl0pXG4gIC8vLiAgICAgKHggPT4geSA9PiB4ICUgeSk7XG4gIC8vLlxuICAvLy4gcmVtICg0MikgKDUpO1xuICAvLy4gLy8gPT4gMlxuICAvLy5cbiAgLy8uIHJlbSAoMC41KTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiBJbnZhbGlkIHZhbHVlXG4gIC8vLiAvL1xuICAvLy4gLy8gICByZW0gOjogSW50ZWdlciAtPiBOb25aZXJvSW50ZWdlciAtPiBJbnRlZ2VyXG4gIC8vLiAvLyAgICAgICAgICBeXl5eXl5eXG4gIC8vLiAvLyAgICAgICAgICAgICAxXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAgMC41IDo6IE51bWJlclxuICAvLy4gLy9cbiAgLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmEludGVnZXLigJkuXG4gIC8vLlxuICAvLy4gcmVtICg0MikgKDApO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIHJlbSA6OiBJbnRlZ2VyIC0+IE5vblplcm9JbnRlZ2VyIC0+IEludGVnZXJcbiAgLy8uIC8vICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eXl5cbiAgLy8uIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAvLy4gLy9cbiAgLy8uIC8vICAgMSkgIDAgOjogTnVtYmVyXG4gIC8vLiAvL1xuICAvLy4gLy8gICBUaGUgdmFsdWUgYXQgcG9zaXRpb24gMSBpcyBub3QgYSBtZW1iZXIgb2Yg4oCYTm9uWmVyb0ludGVnZXLigJkuXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTnVsbGFyeVR5cGUobmFtZSkge1xuICAgIGZ1bmN0aW9uIGZvcm1hdChvdXRlciwgaW5uZXIpIHtcbiAgICAgIHJldHVybiBvdXRlciAoc3RyaXBOYW1lc3BhY2UgKG5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVybCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfVHlwZSAoTlVMTEFSWSwgbmFtZSwgdXJsLCBmb3JtYXQsIHRlc3QsIFtdLCB7fSk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICB2YXIgQ2hlY2tlZE51bGxhcnlUeXBlID1cbiAgZGVmICgnTnVsbGFyeVR5cGUnKVxuICAgICAgKHt9KVxuICAgICAgKFtTdHJpbmdfLCBTdHJpbmdfLCBGdW5jdGlvbl8gKFtBbnksIEJvb2xlYW5fXSksIFR5cGVdKVxuICAgICAgKE51bGxhcnlUeXBlKTtcblxuICAvLyMgVW5hcnlUeXBlIDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gKEFueSAtPiBCb29sZWFuKSAtPiAodCBhIC0+IEFycmF5IGEpIC0+IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29uc3RydWN0b3IgZm9yIHR5cGVzIHdpdGggb25lIHR5cGUgdmFyaWFibGUgKHN1Y2ggYXMgW2BBcnJheWBdW10pLlxuICAvLy5cbiAgLy8uIFRvIGRlZmluZSBhIHVuYXJ5IHR5cGUgYHQgYWAgb25lIG11c3QgcHJvdmlkZTpcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIG5hbWUgb2YgYHRgIChleHBvc2VkIGFzIGB0Lm5hbWVgKTtcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIGRvY3VtZW50YXRpb24gVVJMIG9mIGB0YCAoZXhwb3NlZCBhcyBgdC51cmxgKTtcbiAgLy8uXG4gIC8vLiAgIC0gYSBwcmVkaWNhdGUgd2hpY2ggYWNjZXB0cyBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBhbmQgcmV0dXJucyBgdHJ1ZWBcbiAgLy8uICAgICBpZiAoYW5kIG9ubHkgaWYpIHRoZSB2YWx1ZSBpcyBhIG1lbWJlciBvZiBgdCB4YCBmb3Igc29tZSB0eXBlIGB4YDtcbiAgLy8uXG4gIC8vLiAgIC0gYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbnkgdmFsdWUgb2YgdHlwZSBgdCBhYCBhbmQgcmV0dXJucyBhbiBhcnJheVxuICAvLy4gICAgIG9mIHRoZSB2YWx1ZXMgb2YgdHlwZSBgYWAgY29udGFpbmVkIGluIHRoZSBgdGAgKGV4cG9zZWQgYXNcbiAgLy8uICAgICBgdC50eXBlcy4kMS5leHRyYWN0b3JgKTsgYW5kXG4gIC8vLlxuICAvLy4gICAtIHRoZSB0eXBlIG9mIGBhYCAoZXhwb3NlZCBhcyBgdC50eXBlcy4kMS50eXBlYCkuXG4gIC8vLlxuICAvLy4gRm9yIGV4YW1wbGU6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gY29uc3Qgc2hvdyA9IHJlcXVpcmUgKCdzYW5jdHVhcnktc2hvdycpO1xuICAvLy4gY29uc3QgdHlwZSA9IHJlcXVpcmUgKCdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycycpO1xuICAvLy5cbiAgLy8uIC8vICAgIG1heWJlVHlwZUlkZW50IDo6IFN0cmluZ1xuICAvLy4gY29uc3QgbWF5YmVUeXBlSWRlbnQgPSAnbXktcGFja2FnZS9NYXliZSc7XG4gIC8vLlxuICAvLy4gLy8gICAgTWF5YmUgOjogVHlwZSAtPiBUeXBlXG4gIC8vLiBjb25zdCBNYXliZSA9ICQuVW5hcnlUeXBlXG4gIC8vLiAgIChtYXliZVR5cGVJZGVudClcbiAgLy8uICAgKCdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNNYXliZScpXG4gIC8vLiAgICh4ID0+IHR5cGUgKHgpID09PSBtYXliZVR5cGVJZGVudClcbiAgLy8uICAgKG1heWJlID0+IG1heWJlLmlzSnVzdCA/IFttYXliZS52YWx1ZV0gOiBbXSk7XG4gIC8vLlxuICAvLy4gLy8gICAgTWF5YmVUeXBlUmVwIDo6IFR5cGVSZXAgTWF5YmVcbiAgLy8uIGNvbnN0IE1heWJlVHlwZVJlcCA9IHsnQEB0eXBlJzogbWF5YmVUeXBlSWRlbnR9O1xuICAvLy5cbiAgLy8uIC8vICAgIE5vdGhpbmcgOjogTWF5YmUgYVxuICAvLy4gY29uc3QgTm90aGluZyA9IHtcbiAgLy8uICAgJ2NvbnN0cnVjdG9yJzogTWF5YmVUeXBlUmVwLFxuICAvLy4gICAnaXNKdXN0JzogZmFsc2UsXG4gIC8vLiAgICdpc05vdGhpbmcnOiB0cnVlLFxuICAvLy4gICAnQEBzaG93JzogKCkgPT4gJ05vdGhpbmcnLFxuICAvLy4gfTtcbiAgLy8uXG4gIC8vLiAvLyAgICBKdXN0IDo6IGEgLT4gTWF5YmUgYVxuICAvLy4gY29uc3QgSnVzdCA9IHggPT4gKHtcbiAgLy8uICAgJ2NvbnN0cnVjdG9yJzogTWF5YmVUeXBlUmVwLFxuICAvLy4gICAnaXNKdXN0JzogdHJ1ZSxcbiAgLy8uICAgJ2lzTm90aGluZyc6IGZhbHNlLFxuICAvLy4gICAnQEBzaG93JzogKCkgPT4gYEp1c3QgKCR7c2hvdyAoeCl9KWAsXG4gIC8vLiAgICd2YWx1ZSc6IHgsXG4gIC8vLiB9KTtcbiAgLy8uXG4gIC8vLiAvLyAgICBmcm9tTWF5YmUgOjogYSAtPiBNYXliZSBhIC0+IGFcbiAgLy8uIGNvbnN0IGZyb21NYXliZSA9XG4gIC8vLiBkZWYgKCdmcm9tTWF5YmUnKVxuICAvLy4gICAgICh7fSlcbiAgLy8uICAgICAoW2EsIE1heWJlIChhKSwgYV0pXG4gIC8vLiAgICAgKHggPT4gbSA9PiBtLmlzSnVzdCA/IG0udmFsdWUgOiB4KTtcbiAgLy8uXG4gIC8vLiBmcm9tTWF5YmUgKDApIChKdXN0ICg0MikpO1xuICAvLy4gLy8gPT4gNDJcbiAgLy8uXG4gIC8vLiBmcm9tTWF5YmUgKDApIChOb3RoaW5nKTtcbiAgLy8uIC8vID0+IDBcbiAgLy8uXG4gIC8vLiBmcm9tTWF5YmUgKDApIChKdXN0ICgnWFhYJykpO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IFR5cGUtdmFyaWFibGUgY29uc3RyYWludCB2aW9sYXRpb25cbiAgLy8uIC8vXG4gIC8vLiAvLyAgIGZyb21NYXliZSA6OiBhIC0+IE1heWJlIGEgLT4gYVxuICAvLy4gLy8gICAgICAgICAgICAgICAgXiAgICAgICAgICBeXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAxICAgICAgICAgIDJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDEpICAwIDo6IE51bWJlclxuICAvLy4gLy9cbiAgLy8uIC8vICAgMikgIFwiWFhYXCIgOjogU3RyaW5nXG4gIC8vLiAvL1xuICAvLy4gLy8gICBTaW5jZSB0aGVyZSBpcyBubyB0eXBlIG9mIHdoaWNoIGFsbCB0aGUgYWJvdmUgdmFsdWVzIGFyZSBtZW1iZXJzLCB0aGUgdHlwZS12YXJpYWJsZSBjb25zdHJhaW50IGhhcyBiZWVuIHZpb2xhdGVkLlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFVuYXJ5VHlwZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVybCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKF8xKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCQxKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXQob3V0ZXIsIGlubmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBvdXRlciAoJygnICsgc3RyaXBOYW1lc3BhY2UgKG5hbWUpICsgJyAnKSArXG4gICAgICAgICAgICAgICAgICAgICBpbm5lciAoJyQxJykgKHNob3cgKCQxKSkgK1xuICAgICAgICAgICAgICAgICAgICAgb3V0ZXIgKCcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHlwZXMgPSB7JDE6IHtleHRyYWN0b3I6IF8xLCB0eXBlOiAkMX19O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfVHlwZSAoVU5BUlksIG5hbWUsIHVybCwgZm9ybWF0LCB0ZXN0LCBbJyQxJ10sIHR5cGVzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIENoZWNrZWRVbmFyeVR5cGUgPVxuICBkZWYgKCdVbmFyeVR5cGUnKVxuICAgICAgKHt9KVxuICAgICAgKFtTdHJpbmdfLFxuICAgICAgICBTdHJpbmdfLFxuICAgICAgICBGdW5jdGlvbl8gKFtBbnksIEJvb2xlYW5fXSksXG4gICAgICAgIEZ1bmN0aW9uXyAoW1VuY2hlY2tlZCAoJ3QgYScpLCBBcnJheV8gKFVuY2hlY2tlZCAoJ2EnKSldKSxcbiAgICAgICAgQW55RnVuY3Rpb25dKVxuICAgICAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgIHJldHVybiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgICAgICAgICByZXR1cm4gY29tcG9zZSAoZGVmIChzdHJpcE5hbWVzcGFjZSAobmFtZSkpICh7fSkgKFtUeXBlLCBUeXBlXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFVuYXJ5VHlwZSAobmFtZSkgKHVybCkgKHRlc3QpKTtcbiAgICAgICAgICAgfTtcbiAgICAgICAgIH07XG4gICAgICAgfSk7XG5cbiAgLy8gIGZyb21VbmFyeVR5cGUgOjogVHlwZSAtPiAoVHlwZSAtPiBUeXBlKVxuICBmdW5jdGlvbiBmcm9tVW5hcnlUeXBlKHQpIHtcbiAgICByZXR1cm4gVW5hcnlUeXBlICh0Lm5hbWUpICh0LnVybCkgKHQuX3Rlc3QpICh0LnR5cGVzLiQxLmV4dHJhY3Rvcik7XG4gIH1cblxuICAvLyMgQmluYXJ5VHlwZSA6OiBTdHJpbmcgLT4gU3RyaW5nIC0+IChBbnkgLT4gQm9vbGVhbikgLT4gKHQgYSBiIC0+IEFycmF5IGEpIC0+ICh0IGEgYiAtPiBBcnJheSBiKSAtPiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29uc3RydWN0b3IgZm9yIHR5cGVzIHdpdGggdHdvIHR5cGUgdmFyaWFibGVzIChzdWNoIGFzXG4gIC8vLiBbYEFycmF5MmBdW10pLlxuICAvLy5cbiAgLy8uIFRvIGRlZmluZSBhIGJpbmFyeSB0eXBlIGB0IGEgYmAgb25lIG11c3QgcHJvdmlkZTpcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIG5hbWUgb2YgYHRgIChleHBvc2VkIGFzIGB0Lm5hbWVgKTtcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIGRvY3VtZW50YXRpb24gVVJMIG9mIGB0YCAoZXhwb3NlZCBhcyBgdC51cmxgKTtcbiAgLy8uXG4gIC8vLiAgIC0gYSBwcmVkaWNhdGUgd2hpY2ggYWNjZXB0cyBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBhbmQgcmV0dXJucyBgdHJ1ZWBcbiAgLy8uICAgICBpZiAoYW5kIG9ubHkgaWYpIHRoZSB2YWx1ZSBpcyBhIG1lbWJlciBvZiBgdCB4IHlgIGZvciBzb21lIHR5cGVzXG4gIC8vLiAgICAgYHhgIGFuZCBgeWA7XG4gIC8vLlxuICAvLy4gICAtIGEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW55IHZhbHVlIG9mIHR5cGUgYHQgYSBiYCBhbmQgcmV0dXJucyBhbiBhcnJheVxuICAvLy4gICAgIG9mIHRoZSB2YWx1ZXMgb2YgdHlwZSBgYWAgY29udGFpbmVkIGluIHRoZSBgdGAgKGV4cG9zZWQgYXNcbiAgLy8uICAgICBgdC50eXBlcy4kMS5leHRyYWN0b3JgKTtcbiAgLy8uXG4gIC8vLiAgIC0gYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhbnkgdmFsdWUgb2YgdHlwZSBgdCBhIGJgIGFuZCByZXR1cm5zIGFuIGFycmF5XG4gIC8vLiAgICAgb2YgdGhlIHZhbHVlcyBvZiB0eXBlIGBiYCBjb250YWluZWQgaW4gdGhlIGB0YCAoZXhwb3NlZCBhc1xuICAvLy4gICAgIGB0LnR5cGVzLiQyLmV4dHJhY3RvcmApO1xuICAvLy5cbiAgLy8uICAgLSB0aGUgdHlwZSBvZiBgYWAgKGV4cG9zZWQgYXMgYHQudHlwZXMuJDEudHlwZWApOyBhbmRcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIHR5cGUgb2YgYGJgIChleHBvc2VkIGFzIGB0LnR5cGVzLiQyLnR5cGVgKS5cbiAgLy8uXG4gIC8vLiBGb3IgZXhhbXBsZTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiBjb25zdCB0eXBlID0gcmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJyk7XG4gIC8vLlxuICAvLy4gLy8gICAgcGFpclR5cGVJZGVudCA6OiBTdHJpbmdcbiAgLy8uIGNvbnN0IHBhaXJUeXBlSWRlbnQgPSAnbXktcGFja2FnZS9QYWlyJztcbiAgLy8uXG4gIC8vLiAvLyAgICAkUGFpciA6OiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICAvLy4gY29uc3QgJFBhaXIgPSAkLkJpbmFyeVR5cGVcbiAgLy8uICAgKHBhaXJUeXBlSWRlbnQpXG4gIC8vLiAgICgnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjUGFpcicpXG4gIC8vLiAgICh4ID0+IHR5cGUgKHgpID09PSBwYWlyVHlwZUlkZW50KVxuICAvLy4gICAoKHtmc3R9KSA9PiBbZnN0XSlcbiAgLy8uICAgKCh7c25kfSkgPT4gW3NuZF0pO1xuICAvLy5cbiAgLy8uIC8vICAgIFBhaXJUeXBlUmVwIDo6IFR5cGVSZXAgUGFpclxuICAvLy4gY29uc3QgUGFpclR5cGVSZXAgPSB7J0BAdHlwZSc6IHBhaXJUeXBlSWRlbnR9O1xuICAvLy5cbiAgLy8uIC8vICAgIFBhaXIgOjogYSAtPiBiIC0+IFBhaXIgYSBiXG4gIC8vLiBjb25zdCBQYWlyID1cbiAgLy8uIGRlZiAoJ1BhaXInKVxuICAvLy4gICAgICh7fSlcbiAgLy8uICAgICAoW2EsIGIsICRQYWlyIChhKSAoYildKVxuICAvLy4gICAgIChmc3QgPT4gc25kID0+ICh7XG4gIC8vLiAgICAgICAgJ2NvbnN0cnVjdG9yJzogUGFpclR5cGVSZXAsXG4gIC8vLiAgICAgICAgJ2ZzdCc6IGZzdCxcbiAgLy8uICAgICAgICAnc25kJzogc25kLFxuICAvLy4gICAgICAgICdAQHNob3cnOiAoKSA9PiBgUGFpciAoJHtzaG93IChmc3QpfSkgKCR7c2hvdyAoc25kKX0pYCxcbiAgLy8uICAgICAgfSkpO1xuICAvLy5cbiAgLy8uIC8vICAgIFJhbmsgOjogVHlwZVxuICAvLy4gY29uc3QgUmFuayA9ICQuTnVsbGFyeVR5cGVcbiAgLy8uICAgKCdteS1wYWNrYWdlL1JhbmsnKVxuICAvLy4gICAoJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI1JhbmsnKVxuICAvLy4gICAoeCA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiZcbiAgLy8uICAgICAgICAgL14oQXwyfDN8NHw1fDZ8N3w4fDl8MTB8SnxRfEspJC8udGVzdCAoeCkpO1xuICAvLy5cbiAgLy8uIC8vICAgIFN1aXQgOjogVHlwZVxuICAvLy4gY29uc3QgU3VpdCA9ICQuTnVsbGFyeVR5cGVcbiAgLy8uICAgKCdteS1wYWNrYWdlL1N1aXQnKVxuICAvLy4gICAoJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI1N1aXQnKVxuICAvLy4gICAoeCA9PiB0eXBlb2YgeCA9PT0gJ3N0cmluZycgJiZcbiAgLy8uICAgICAgICAgL15bXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2Nl0kLy50ZXN0ICh4KSk7XG4gIC8vLlxuICAvLy4gLy8gICAgQ2FyZCA6OiBUeXBlXG4gIC8vLiBjb25zdCBDYXJkID0gJFBhaXIgKFJhbmspIChTdWl0KTtcbiAgLy8uXG4gIC8vLiAvLyAgICBzaG93Q2FyZCA6OiBDYXJkIC0+IFN0cmluZ1xuICAvLy4gY29uc3Qgc2hvd0NhcmQgPVxuICAvLy4gZGVmICgnc2hvd0NhcmQnKVxuICAvLy4gICAgICh7fSlcbiAgLy8uICAgICAoW0NhcmQsICQuU3RyaW5nXSlcbiAgLy8uICAgICAoY2FyZCA9PiBjYXJkLmZzdCArIGNhcmQuc25kKTtcbiAgLy8uXG4gIC8vLiBzaG93Q2FyZCAoUGFpciAoJ0EnKSAoJ+KZoCcpKTtcbiAgLy8uIC8vID0+ICdB4pmgJ1xuICAvLy5cbiAgLy8uIHNob3dDYXJkIChQYWlyICgnWCcpICgn4pmgJykpO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIHNob3dDYXJkIDo6IFBhaXIgUmFuayBTdWl0IC0+IFN0cmluZ1xuICAvLy4gLy8gICAgICAgICAgICAgICAgICAgIF5eXl5cbiAgLy8uIC8vICAgICAgICAgICAgICAgICAgICAgMVxuICAvLy4gLy9cbiAgLy8uIC8vICAgMSkgIFwiWFwiIDo6IFN0cmluZ1xuICAvLy4gLy9cbiAgLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmFJhbmvigJkuXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gQmluYXJ5VHlwZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVybCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKF8xKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKF8yKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oJDEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCQyKSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0KG91dGVyLCBpbm5lcikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyICgnKCcgKyBzdHJpcE5hbWVzcGFjZSAobmFtZSkgKyAnICcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lciAoJyQxJykgKHNob3cgKCQxKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyICgnICcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lciAoJyQyJykgKHNob3cgKCQyKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyICgnKScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9UeXBlIChCSU5BUlksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWyckMScsICckMiddLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHskMToge2V4dHJhY3RvcjogXzEsIHR5cGU6ICQxfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJDI6IHtleHRyYWN0b3I6IF8yLCB0eXBlOiAkMn19KTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHZhciBDaGVja2VkQmluYXJ5VHlwZSA9XG4gIGRlZiAoJ0JpbmFyeVR5cGUnKVxuICAgICAgKHt9KVxuICAgICAgKFtTdHJpbmdfLFxuICAgICAgICBTdHJpbmdfLFxuICAgICAgICBGdW5jdGlvbl8gKFtBbnksIEJvb2xlYW5fXSksXG4gICAgICAgIEZ1bmN0aW9uXyAoW1VuY2hlY2tlZCAoJ3QgYSBiJyksIEFycmF5XyAoVW5jaGVja2VkICgnYScpKV0pLFxuICAgICAgICBGdW5jdGlvbl8gKFtVbmNoZWNrZWQgKCd0IGEgYicpLCBBcnJheV8gKFVuY2hlY2tlZCAoJ2InKSldKSxcbiAgICAgICAgQW55RnVuY3Rpb25dKVxuICAgICAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgIHJldHVybiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oXzEpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihfMikge1xuICAgICAgICAgICAgICAgICByZXR1cm4gZGVmIChzdHJpcE5hbWVzcGFjZSAobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHt9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChbVHlwZSwgVHlwZSwgVHlwZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKEJpbmFyeVR5cGUgKG5hbWUpICh1cmwpICh0ZXN0KSAoXzEpIChfMikpO1xuICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICB9O1xuICAgICAgICAgICB9O1xuICAgICAgICAgfTtcbiAgICAgICB9KTtcblxuICAvLyAgeHByb2QgOjogKFR5cGUsIEFycmF5IFR5cGUsIEFycmF5IFR5cGUpIC0+IEFycmF5IFR5cGVcbiAgZnVuY3Rpb24geHByb2QodCwgJDFzLCAkMnMpIHtcbiAgICByZXR1cm4gWi5jaGFpbiAoXG4gICAgICBmdW5jdGlvbihzcGVjaWFsaXplKSB7IHJldHVybiBaLm1hcCAoc3BlY2lhbGl6ZSwgJDJzKTsgfSxcbiAgICAgIFoubWFwIChCaW5hcnlUeXBlICh0Lm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAodC51cmwpXG4gICAgICAgICAgICAgICAgICAgICAgICAodC5fdGVzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICh0LnR5cGVzLiQxLmV4dHJhY3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICh0LnR5cGVzLiQyLmV4dHJhY3RvciksXG4gICAgICAgICAgICAgJDFzKVxuICAgICk7XG4gIH1cblxuICAvLyMgRW51bVR5cGUgOjogU3RyaW5nIC0+IFN0cmluZyAtPiBBcnJheSBBbnkgLT4gVHlwZVxuICAvLy5cbiAgLy8uIFR5cGUgY29uc3RydWN0b3IgZm9yIFtlbnVtZXJhdGVkIHR5cGVzXVtdIChzdWNoIGFzIFtgUmVnZXhGbGFnc2BdW10pLlxuICAvLy5cbiAgLy8uIFRvIGRlZmluZSBhbiBlbnVtZXJhdGVkIHR5cGUgYHRgIG9uZSBtdXN0IHByb3ZpZGU6XG4gIC8vLlxuICAvLy4gICAtIHRoZSBuYW1lIG9mIGB0YCAoZXhwb3NlZCBhcyBgdC5uYW1lYCk7XG4gIC8vLlxuICAvLy4gICAtIHRoZSBkb2N1bWVudGF0aW9uIFVSTCBvZiBgdGAgKGV4cG9zZWQgYXMgYHQudXJsYCk7IGFuZFxuICAvLy5cbiAgLy8uICAgLSBhbiBhcnJheSBvZiBkaXN0aW5jdCB2YWx1ZXMuXG4gIC8vLlxuICAvLy4gRm9yIGV4YW1wbGU6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gLy8gICAgRGVub21pbmF0aW9uIDo6IFR5cGVcbiAgLy8uIGNvbnN0IERlbm9taW5hdGlvbiA9ICQuRW51bVR5cGVcbiAgLy8uICAgKCdteS1wYWNrYWdlL0Rlbm9taW5hdGlvbicpXG4gIC8vLiAgICgnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjRGVub21pbmF0aW9uJylcbiAgLy8uICAgKFsxMCwgMjAsIDUwLCAxMDAsIDIwMF0pO1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIEVudW1UeXBlKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odXJsKSB7XG4gICAgICByZXR1cm4gY29tcG9zZSAoTnVsbGFyeVR5cGUgKG5hbWUpICh1cmwpLCBtZW1iZXJPZik7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBDaGVja2VkRW51bVR5cGUgPVxuICBkZWYgKCdFbnVtVHlwZScpXG4gICAgICAoe30pXG4gICAgICAoW1N0cmluZ18sIFN0cmluZ18sIEFycmF5XyAoQW55KSwgVHlwZV0pXG4gICAgICAoRW51bVR5cGUpO1xuXG4gIC8vIyBSZWNvcmRUeXBlIDo6IFN0ck1hcCBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBgUmVjb3JkVHlwZWAgaXMgdXNlZCB0byBjb25zdHJ1Y3QgcmVjb3JkIHR5cGVzLiBUaGUgdHlwZSBkZWZpbml0aW9uXG4gIC8vLiBzcGVjaWZpZXMgdGhlIG5hbWUgYW5kIHR5cGUgb2YgZWFjaCByZXF1aXJlZCBmaWVsZC4gQSBmaWVsZCBpcyBhblxuICAvLy4gZW51bWVyYWJsZSBwcm9wZXJ0eSAoZWl0aGVyIGFuIG93biBwcm9wZXJ0eSBvciBhbiBpbmhlcml0ZWQgcHJvcGVydHkpLlxuICAvLy5cbiAgLy8uIFRvIGRlZmluZSBhIHJlY29yZCB0eXBlIG9uZSBtdXN0IHByb3ZpZGU6XG4gIC8vLlxuICAvLy4gICAtIGFuIG9iamVjdCBtYXBwaW5nIGZpZWxkIG5hbWUgdG8gdHlwZS5cbiAgLy8uXG4gIC8vLiBGb3IgZXhhbXBsZTpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiAvLyAgICBQb2ludCA6OiBUeXBlXG4gIC8vLiBjb25zdCBQb2ludCA9ICQuUmVjb3JkVHlwZSAoe3g6ICQuRmluaXRlTnVtYmVyLCB5OiAkLkZpbml0ZU51bWJlcn0pO1xuICAvLy5cbiAgLy8uIC8vICAgIGRpc3QgOjogUG9pbnQgLT4gUG9pbnQgLT4gRmluaXRlTnVtYmVyXG4gIC8vLiBjb25zdCBkaXN0ID1cbiAgLy8uIGRlZiAoJ2Rpc3QnKVxuICAvLy4gICAgICh7fSlcbiAgLy8uICAgICAoW1BvaW50LCBQb2ludCwgJC5GaW5pdGVOdW1iZXJdKVxuICAvLy4gICAgIChwID0+IHEgPT4gTWF0aC5zcXJ0IChNYXRoLnBvdyAocC54IC0gcS54LCAyKSArXG4gIC8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgucG93IChwLnkgLSBxLnksIDIpKSk7XG4gIC8vLlxuICAvLy4gZGlzdCAoe3g6IDAsIHk6IDB9KSAoe3g6IDMsIHk6IDR9KTtcbiAgLy8uIC8vID0+IDVcbiAgLy8uXG4gIC8vLiBkaXN0ICh7eDogMCwgeTogMH0pICh7eDogMywgeTogNCwgY29sb3I6ICdyZWQnfSk7XG4gIC8vLiAvLyA9PiA1XG4gIC8vLlxuICAvLy4gZGlzdCAoe3g6IDAsIHk6IDB9KSAoe3g6IE5hTiwgeTogTmFOfSk7XG4gIC8vLiAvLyAhIFR5cGVFcnJvcjogSW52YWxpZCB2YWx1ZVxuICAvLy4gLy9cbiAgLy8uIC8vICAgZGlzdCA6OiB7IHggOjogRmluaXRlTnVtYmVyLCB5IDo6IEZpbml0ZU51bWJlciB9IC0+IHsgeCA6OiBGaW5pdGVOdW1iZXIsIHkgOjogRmluaXRlTnVtYmVyIH0gLT4gRmluaXRlTnVtYmVyXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAgTmFOIDo6IE51bWJlclxuICAvLy4gLy9cbiAgLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmEZpbml0ZU51bWJlcuKAmS5cbiAgLy8uXG4gIC8vLiBkaXN0ICgwKTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiBJbnZhbGlkIHZhbHVlXG4gIC8vLiAvL1xuICAvLy4gLy8gICBkaXN0IDo6IHsgeCA6OiBGaW5pdGVOdW1iZXIsIHkgOjogRmluaXRlTnVtYmVyIH0gLT4geyB4IDo6IEZpbml0ZU51bWJlciwgeSA6OiBGaW5pdGVOdW1iZXIgfSAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uIC8vICAgICAgICAgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDEpICAwIDo6IE51bWJlclxuICAvLy4gLy9cbiAgLy8uIC8vICAgVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIOKAmHsgeCA6OiBGaW5pdGVOdW1iZXIsIHkgOjogRmluaXRlTnVtYmVyIH3igJkuXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUmVjb3JkVHlwZShmaWVsZHMpIHtcbiAgICB2YXIga2V5cyA9IHNvcnRlZEtleXMgKGZpZWxkcyk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQob3V0ZXIsIGlubmVyKSB7XG4gICAgICBpZiAoaXNFbXB0eSAoa2V5cykpIHJldHVybiBvdXRlciAoJ3t9Jyk7XG4gICAgICB2YXIgcmVwcnMgPSBaLm1hcCAoZnVuY3Rpb24oaykge1xuICAgICAgICB2YXIgdCA9IGZpZWxkc1trXTtcbiAgICAgICAgcmV0dXJuIG91dGVyICgnICcpICtcbiAgICAgICAgICAgICAgIG91dGVyICgvXig/IVxcZClbJFxcd10rJC8udGVzdCAoaykgPyBrIDogc2hvdyAoaykpICtcbiAgICAgICAgICAgICAgIG91dGVyICgnIDo6ICcpICtcbiAgICAgICAgICAgICAgIHVubGVzcyAodC50eXBlID09PSBSRUNPUkQgfHwgaXNFbXB0eSAodC5rZXlzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgc3RyaXBPdXRlcm1vc3RQYXJlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgIGlubmVyIChrKSAoc2hvdyAodCkpKTtcbiAgICAgIH0sIGtleXMpO1xuICAgICAgcmV0dXJuIHdyYXAgKG91dGVyICgneycpKSAob3V0ZXIgKCcgfScpKSAoam9pbldpdGggKG91dGVyICgnLCcpLCByZXBycykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRlc3QoeCkge1xuICAgICAgdmFyIG1pc3NpbmcgPSB7fTtcbiAgICAgIGtleXMuZm9yRWFjaCAoZnVuY3Rpb24oaykgeyBtaXNzaW5nW2tdID0gazsgfSk7XG4gICAgICBmb3IgKHZhciBrIGluIHgpIGRlbGV0ZSBtaXNzaW5nW2tdO1xuICAgICAgcmV0dXJuIGlzRW1wdHkgKE9iamVjdC5rZXlzIChtaXNzaW5nKSk7XG4gICAgfVxuXG4gICAgdmFyICR0eXBlcyA9IHt9O1xuICAgIGtleXMuZm9yRWFjaCAoZnVuY3Rpb24oaykge1xuICAgICAgJHR5cGVzW2tdID0ge2V4dHJhY3RvcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gW3hba11dOyB9LCB0eXBlOiBmaWVsZHNba119O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBfVHlwZSAoUkVDT1JELCAnJywgJycsIGZvcm1hdCwgdGVzdCwga2V5cywgJHR5cGVzKTtcbiAgfVxuXG4gIHZhciBDaGVja2VkUmVjb3JkVHlwZSA9XG4gIGRlZiAoJ1JlY29yZFR5cGUnKSAoe30pIChbU3RyTWFwIChUeXBlKSwgVHlwZV0pIChSZWNvcmRUeXBlKTtcblxuICAvLyMgVHlwZVZhcmlhYmxlIDo6IFN0cmluZyAtPiBUeXBlXG4gIC8vLlxuICAvLy4gUG9seW1vcnBoaXNtIGlzIHBvd2VyZnVsLiBOb3QgYmVpbmcgYWJsZSB0byBkZWZpbmUgYSBmdW5jdGlvbiBmb3JcbiAgLy8uIGFsbCB0eXBlcyB3b3VsZCBiZSB2ZXJ5IGxpbWl0aW5nIGluZGVlZDogb25lIGNvdWxkbid0IGV2ZW4gZGVmaW5lIHRoZVxuICAvLy4gaWRlbnRpdHkgZnVuY3Rpb24hXG4gIC8vLlxuICAvLy4gQmVmb3JlIGRlZmluaW5nIGEgcG9seW1vcnBoaWMgZnVuY3Rpb24gb25lIG11c3QgZGVmaW5lIG9uZSBvciBtb3JlIHR5cGVcbiAgLy8uIHZhcmlhYmxlczpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiBjb25zdCBhID0gJC5UeXBlVmFyaWFibGUgKCdhJyk7XG4gIC8vLiBjb25zdCBiID0gJC5UeXBlVmFyaWFibGUgKCdiJyk7XG4gIC8vLlxuICAvLy4gLy8gICAgaWQgOjogYSAtPiBhXG4gIC8vLiBjb25zdCBpZCA9IGRlZiAoJ2lkJykgKHt9KSAoW2EsIGFdKSAoeCA9PiB4KTtcbiAgLy8uXG4gIC8vLiBpZCAoNDIpO1xuICAvLy4gLy8gPT4gNDJcbiAgLy8uXG4gIC8vLiBpZCAobnVsbCk7XG4gIC8vLiAvLyA9PiBudWxsXG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBUaGUgc2FtZSB0eXBlIHZhcmlhYmxlIG1heSBiZSB1c2VkIGluIG11bHRpcGxlIHBvc2l0aW9ucywgY3JlYXRpbmcgYVxuICAvLy4gY29uc3RyYWludDpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiAvLyAgICBjbXAgOjogYSAtPiBhIC0+IE51bWJlclxuICAvLy4gY29uc3QgY21wID1cbiAgLy8uIGRlZiAoJ2NtcCcpXG4gIC8vLiAgICAgKHt9KVxuICAvLy4gICAgIChbYSwgYSwgJC5OdW1iZXJdKVxuICAvLy4gICAgICh4ID0+IHkgPT4geCA8IHkgPyAtMSA6IHggPiB5ID8gMSA6IDApO1xuICAvLy5cbiAgLy8uIGNtcCAoNDIpICg0Mik7XG4gIC8vLiAvLyA9PiAwXG4gIC8vLlxuICAvLy4gY21wICgnYScpICgneicpO1xuICAvLy4gLy8gPT4gLTFcbiAgLy8uXG4gIC8vLiBjbXAgKCd6JykgKCdhJyk7XG4gIC8vLiAvLyA9PiAxXG4gIC8vLlxuICAvLy4gY21wICgwKSAoJzEnKTtcbiAgLy8uIC8vICEgVHlwZUVycm9yOiBUeXBlLXZhcmlhYmxlIGNvbnN0cmFpbnQgdmlvbGF0aW9uXG4gIC8vLiAvL1xuICAvLy4gLy8gICBjbXAgOjogYSAtPiBhIC0+IE51bWJlclxuICAvLy4gLy8gICAgICAgICAgXiAgICBeXG4gIC8vLiAvLyAgICAgICAgICAxICAgIDJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDEpICAwIDo6IE51bWJlclxuICAvLy4gLy9cbiAgLy8uIC8vICAgMikgIFwiMVwiIDo6IFN0cmluZ1xuICAvLy4gLy9cbiAgLy8uIC8vICAgU2luY2UgdGhlcmUgaXMgbm8gdHlwZSBvZiB3aGljaCBhbGwgdGhlIGFib3ZlIHZhbHVlcyBhcmUgbWVtYmVycywgdGhlIHR5cGUtdmFyaWFibGUgY29uc3RyYWludCBoYXMgYmVlbiB2aW9sYXRlZC5cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBUeXBlVmFyaWFibGUobmFtZSkge1xuICAgIHJldHVybiBuZXcgX1R5cGUgKFZBUklBQkxFLCBuYW1lLCAnJywgYWx3YXlzMiAobmFtZSksIEsgKHRydWUpLCBbXSwge30pO1xuICB9XG5cbiAgdmFyIENoZWNrZWRUeXBlVmFyaWFibGUgPVxuICBkZWYgKCdUeXBlVmFyaWFibGUnKSAoe30pIChbU3RyaW5nXywgVHlwZV0pIChUeXBlVmFyaWFibGUpO1xuXG4gIC8vIyBVbmFyeVR5cGVWYXJpYWJsZSA6OiBTdHJpbmcgLT4gVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gQ29tYmluZXMgW2BVbmFyeVR5cGVgXVtdIGFuZCBbYFR5cGVWYXJpYWJsZWBdW10uXG4gIC8vLlxuICAvLy4gVG8gZGVmaW5lIGEgdW5hcnkgdHlwZSB2YXJpYWJsZSBgdCBhYCBvbmUgbXVzdCBwcm92aWRlOlxuICAvLy5cbiAgLy8uICAgLSBhIG5hbWUgKGNvbnZlbnRpb25hbGx5IG1hdGNoaW5nIGBeW2Etel0kYCk7IGFuZFxuICAvLy5cbiAgLy8uICAgLSB0aGUgdHlwZSBvZiBgYWAgKGV4cG9zZWQgYXMgYHQudHlwZXMuJDEudHlwZWApLlxuICAvLy5cbiAgLy8uIENvbnNpZGVyIHRoZSB0eXBlIG9mIGEgZ2VuZXJhbGl6ZWQgYG1hcGA6XG4gIC8vLlxuICAvLy4gYGBgaGFza2VsbFxuICAvLy4gbWFwIDo6IEZ1bmN0b3IgZiA9PiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBgZmAgaXMgYSB1bmFyeSB0eXBlIHZhcmlhYmxlLiBXaXRoIHR3byAobnVsbGFyeSkgdHlwZSB2YXJpYWJsZXMsIG9uZVxuICAvLy4gdW5hcnkgdHlwZSB2YXJpYWJsZSwgYW5kIG9uZSBbdHlwZSBjbGFzc11bXSBpdCdzIHBvc3NpYmxlIHRvIGRlZmluZSBhXG4gIC8vLiBmdWxseSBwb2x5bW9ycGhpYyBgbWFwYCBmdW5jdGlvbjpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiBjb25zdCAkID0gcmVxdWlyZSAoJ3NhbmN0dWFyeS1kZWYnKTtcbiAgLy8uIGNvbnN0IFogPSByZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycpO1xuICAvLy5cbiAgLy8uIGNvbnN0IGEgPSAkLlR5cGVWYXJpYWJsZSAoJ2EnKTtcbiAgLy8uIGNvbnN0IGIgPSAkLlR5cGVWYXJpYWJsZSAoJ2InKTtcbiAgLy8uIGNvbnN0IGYgPSAkLlVuYXJ5VHlwZVZhcmlhYmxlICgnZicpO1xuICAvLy5cbiAgLy8uIC8vICAgIG1hcCA6OiBGdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICAvLy4gY29uc3QgbWFwID1cbiAgLy8uIGRlZiAoJ21hcCcpXG4gIC8vLiAgICAgKHtmOiBbWi5GdW5jdG9yXX0pXG4gIC8vLiAgICAgKFskLkZ1bmN0aW9uIChbYSwgYl0pLCBmIChhKSwgZiAoYildKVxuICAvLy4gICAgIChmID0+IGZ1bmN0b3IgPT4gWi5tYXAgKGYsIGZ1bmN0b3IpKTtcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFdoZXJlYXMgYSByZWd1bGFyIHR5cGUgdmFyaWFibGUgaXMgZnVsbHkgcmVzb2x2ZWQgKGBhYCBtaWdodCBiZWNvbWVcbiAgLy8uIGBBcnJheSAoQXJyYXkgU3RyaW5nKWAsIGZvciBleGFtcGxlKSwgYSB1bmFyeSB0eXBlIHZhcmlhYmxlIGRlZmVycyB0b1xuICAvLy4gaXRzIHR5cGUgYXJndW1lbnQsIHdoaWNoIG1heSBpdHNlbGYgYmUgYSB0eXBlIHZhcmlhYmxlLiBUaGUgdHlwZSBhcmd1bWVudFxuICAvLy4gY29ycmVzcG9uZHMgdG8gdGhlIHR5cGUgYXJndW1lbnQgb2YgYSB1bmFyeSB0eXBlIG9yIHRoZSAqc2Vjb25kKiB0eXBlXG4gIC8vLiBhcmd1bWVudCBvZiBhIGJpbmFyeSB0eXBlLiBUaGUgc2Vjb25kIHR5cGUgYXJndW1lbnQgb2YgYE1hcCBrIHZgLCBmb3JcbiAgLy8uIGV4YW1wbGUsIGlzIGB2YC4gT25lIGNvdWxkIHJlcGxhY2UgYEZ1bmN0b3IgPT4gZmAgd2l0aCBgTWFwIGtgIG9yIHdpdGhcbiAgLy8uIGBNYXAgSW50ZWdlcmAsIGJ1dCBub3Qgd2l0aCBgTWFwYC5cbiAgLy8uXG4gIC8vLiBUaGlzIHNoYWxsb3cgaW5zcGVjdGlvbiBtYWtlcyBpdCBwb3NzaWJsZSB0byBjb25zdHJhaW4gYSB2YWx1ZSdzIFwib3V0ZXJcIlxuICAvLy4gYW5kIFwiaW5uZXJcIiB0eXBlcyBpbmRlcGVuZGVudGx5LlxuICBmdW5jdGlvbiBVbmFyeVR5cGVWYXJpYWJsZShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCQxKSB7XG4gICAgICBmdW5jdGlvbiBmb3JtYXQob3V0ZXIsIGlubmVyKSB7XG4gICAgICAgIHJldHVybiBvdXRlciAoJygnICsgbmFtZSArICcgJykgK1xuICAgICAgICAgICAgICAgaW5uZXIgKCckMScpIChzaG93ICgkMSkpICtcbiAgICAgICAgICAgICAgIG91dGVyICgnKScpO1xuICAgICAgfVxuICAgICAgdmFyIHR5cGVzID0geyQxOiB7ZXh0cmFjdG9yOiBLIChbXSksIHR5cGU6ICQxfX07XG4gICAgICByZXR1cm4gbmV3IF9UeXBlIChWQVJJQUJMRSwgbmFtZSwgJycsIGZvcm1hdCwgSyAodHJ1ZSksIFsnJDEnXSwgdHlwZXMpO1xuICAgIH07XG4gIH1cblxuICB2YXIgQ2hlY2tlZFVuYXJ5VHlwZVZhcmlhYmxlID1cbiAgZGVmICgnVW5hcnlUeXBlVmFyaWFibGUnKVxuICAgICAgKHt9KVxuICAgICAgKFtTdHJpbmdfLCBBbnlGdW5jdGlvbl0pXG4gICAgICAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgcmV0dXJuIGRlZiAobmFtZSkgKHt9KSAoW1R5cGUsIFR5cGVdKSAoVW5hcnlUeXBlVmFyaWFibGUgKG5hbWUpKTtcbiAgICAgICB9KTtcblxuICAvLyMgQmluYXJ5VHlwZVZhcmlhYmxlIDo6IFN0cmluZyAtPiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIENvbWJpbmVzIFtgQmluYXJ5VHlwZWBdW10gYW5kIFtgVHlwZVZhcmlhYmxlYF1bXS5cbiAgLy8uXG4gIC8vLiBUbyBkZWZpbmUgYSBiaW5hcnkgdHlwZSB2YXJpYWJsZSBgdCBhIGJgIG9uZSBtdXN0IHByb3ZpZGU6XG4gIC8vLlxuICAvLy4gICAtIGEgbmFtZSAoY29udmVudGlvbmFsbHkgbWF0Y2hpbmcgYF5bYS16XSRgKTtcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIHR5cGUgb2YgYGFgIChleHBvc2VkIGFzIGB0LnR5cGVzLiQxLnR5cGVgKTsgYW5kXG4gIC8vLlxuICAvLy4gICAtIHRoZSB0eXBlIG9mIGBiYCAoZXhwb3NlZCBhcyBgdC50eXBlcy4kMi50eXBlYCkuXG4gIC8vLlxuICAvLy4gVGhlIG1vcmUgZGV0YWlsZWQgZXhwbGFuYXRpb24gb2YgW2BVbmFyeVR5cGVWYXJpYWJsZWBdW10gYWxzbyBhcHBsaWVzIHRvXG4gIC8vLiBgQmluYXJ5VHlwZVZhcmlhYmxlYC5cbiAgZnVuY3Rpb24gQmluYXJ5VHlwZVZhcmlhYmxlKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oJDEpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigkMikge1xuICAgICAgICBmdW5jdGlvbiBmb3JtYXQob3V0ZXIsIGlubmVyKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyICgnKCcgKyBuYW1lICsgJyAnKSArXG4gICAgICAgICAgICAgICAgIGlubmVyICgnJDEnKSAoc2hvdyAoJDEpKSArXG4gICAgICAgICAgICAgICAgIG91dGVyICgnICcpICtcbiAgICAgICAgICAgICAgICAgaW5uZXIgKCckMicpIChzaG93ICgkMikpICtcbiAgICAgICAgICAgICAgICAgb3V0ZXIgKCcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleXMgPSBbJyQxJywgJyQyJ107XG4gICAgICAgIHZhciB0eXBlcyA9IHskMToge2V4dHJhY3RvcjogSyAoW10pLCB0eXBlOiAkMX0sXG4gICAgICAgICAgICAgICAgICAgICAkMjoge2V4dHJhY3RvcjogSyAoW10pLCB0eXBlOiAkMn19O1xuICAgICAgICByZXR1cm4gbmV3IF9UeXBlIChWQVJJQUJMRSwgbmFtZSwgJycsIGZvcm1hdCwgSyAodHJ1ZSksIGtleXMsIHR5cGVzKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuXG4gIHZhciBDaGVja2VkQmluYXJ5VHlwZVZhcmlhYmxlID1cbiAgZGVmICgnQmluYXJ5VHlwZVZhcmlhYmxlJylcbiAgICAgICh7fSlcbiAgICAgIChbU3RyaW5nXywgQW55RnVuY3Rpb25dKVxuICAgICAgKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgIHJldHVybiBkZWYgKG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICh7fSlcbiAgICAgICAgICAgICAgICAgICAgKFtUeXBlLCBUeXBlLCBUeXBlXSlcbiAgICAgICAgICAgICAgICAgICAgKEJpbmFyeVR5cGVWYXJpYWJsZSAobmFtZSkpO1xuICAgICAgIH0pO1xuXG4gIC8vIyBUaHVuayA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBgJC5UaHVuayAoVClgIGlzIHNob3J0aGFuZCBmb3IgYCQuRnVuY3Rpb24gKFtUXSlgLCB0aGUgdHlwZSBjb21wcmlzaW5nXG4gIC8vLiBldmVyeSBudWxsYXJ5IGZ1bmN0aW9uICh0aHVuaykgd2hpY2ggcmV0dXJucyBhIHZhbHVlIG9mIHR5cGUgYFRgLlxuICB2YXIgVGh1bmsgPVxuICBkZWYgKCdUaHVuaycpXG4gICAgICAoe30pXG4gICAgICAoW1R5cGUsIFR5cGVdKVxuICAgICAgKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIEZ1bmN0aW9uXyAoW3RdKTsgfSk7XG5cbiAgLy8jIFByZWRpY2F0ZSA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBgJC5QcmVkaWNhdGUgKFQpYCBpcyBzaG9ydGhhbmQgZm9yIGAkLkZ1bmN0aW9uIChbVCwgJC5Cb29sZWFuXSlgLCB0aGVcbiAgLy8uIHR5cGUgY29tcHJpc2luZyBldmVyeSBwcmVkaWNhdGUgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYSB2YWx1ZSBvZiB0eXBlIGBUYC5cbiAgdmFyIFByZWRpY2F0ZSA9XG4gIGRlZiAoJ1ByZWRpY2F0ZScpXG4gICAgICAoe30pXG4gICAgICAoW1R5cGUsIFR5cGVdKVxuICAgICAgKGZ1bmN0aW9uKHQpIHsgcmV0dXJuIEZ1bmN0aW9uXyAoW3QsIEJvb2xlYW5fXSk7IH0pO1xuXG4gIC8vLiAjIyMgVHlwZSBjbGFzc2VzXG4gIC8vLlxuICAvLy4gYGNvbmNhdFNgLCBkZWZpbmVkIGVhcmxpZXIsIGlzIGEgZnVuY3Rpb24gd2hpY2ggY29uY2F0ZW5hdGVzIHR3byBzdHJpbmdzLlxuICAvLy4gVGhpcyBpcyBvdmVybHkgcmVzdHJpY3RpdmUsIHNpbmNlIG90aGVyIHR5cGVzIHN1cHBvcnQgY29uY2F0ZW5hdGlvblxuICAvLy4gKEFycmF5LCBmb3IgZXhhbXBsZSkuXG4gIC8vLlxuICAvLy4gT25lIGNvdWxkIHVzZSBhIHR5cGUgdmFyaWFibGUgdG8gZGVmaW5lIGEgcG9seW1vcnBoaWMgXCJjb25jYXRcIiBmdW5jdGlvbjpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiAvLyAgICBfY29uY2F0IDo6IGEgLT4gYSAtPiBhXG4gIC8vLiBjb25zdCBfY29uY2F0ID1cbiAgLy8uIGRlZiAoJ19jb25jYXQnKVxuICAvLy4gICAgICh7fSlcbiAgLy8uICAgICAoW2EsIGEsIGFdKVxuICAvLy4gICAgICh4ID0+IHkgPT4geC5jb25jYXQgKHkpKTtcbiAgLy8uXG4gIC8vLiBfY29uY2F0ICgnZml6eicpICgnYnV6eicpO1xuICAvLy4gLy8gPT4gJ2ZpenpidXp6J1xuICAvLy5cbiAgLy8uIF9jb25jYXQgKFsxLCAyXSkgKFszLCA0XSk7XG4gIC8vLiAvLyA9PiBbMSwgMiwgMywgNF1cbiAgLy8uXG4gIC8vLiBfY29uY2F0IChbMSwgMl0pICgnYnV6eicpO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IFR5cGUtdmFyaWFibGUgY29uc3RyYWludCB2aW9sYXRpb25cbiAgLy8uIC8vXG4gIC8vLiAvLyAgIF9jb25jYXQgOjogYSAtPiBhIC0+IGFcbiAgLy8uIC8vICAgICAgICAgICAgICBeICAgIF5cbiAgLy8uIC8vICAgICAgICAgICAgICAxICAgIDJcbiAgLy8uIC8vXG4gIC8vLiAvLyAgIDEpICBbMSwgMl0gOjogQXJyYXkgTnVtYmVyXG4gIC8vLiAvL1xuICAvLy4gLy8gICAyKSAgXCJidXp6XCIgOjogU3RyaW5nXG4gIC8vLiAvL1xuICAvLy4gLy8gICBTaW5jZSB0aGVyZSBpcyBubyB0eXBlIG9mIHdoaWNoIGFsbCB0aGUgYWJvdmUgdmFsdWVzIGFyZSBtZW1iZXJzLCB0aGUgdHlwZS12YXJpYWJsZSBjb25zdHJhaW50IGhhcyBiZWVuIHZpb2xhdGVkLlxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gVGhlIHR5cGUgb2YgYF9jb25jYXRgIGlzIG1pc2xlYWRpbmc6IGl0IHN1Z2dlc3RzIHRoYXQgaXQgY2FuIG9wZXJhdGUgb25cbiAgLy8uIGFueSB0d28gdmFsdWVzIG9mICphbnkqIG9uZSB0eXBlLiBJbiBmYWN0IHRoZXJlJ3MgYW4gaW1wbGljaXQgY29uc3RyYWludCxcbiAgLy8uIHNpbmNlIHRoZSB0eXBlIG11c3Qgc3VwcG9ydCBjb25jYXRlbmF0aW9uIChpbiBbbWF0aGVtYXRpY2FsXVtzZW1pZ3JvdXBdXG4gIC8vLiB0ZXJtcywgdGhlIHR5cGUgbXVzdCBoYXZlIGEgW3NlbWlncm91cF1bRkw6U2VtaWdyb3VwXSkuIFZpb2xhdGluZyB0aGlzXG4gIC8vLiBpbXBsaWNpdCBjb25zdHJhaW50IHJlc3VsdHMgaW4gYSBydW4tdGltZSBlcnJvciBpbiB0aGUgaW1wbGVtZW50YXRpb246XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gX2NvbmNhdCAobnVsbCkgKG51bGwpO1xuICAvLy4gLy8gISBUeXBlRXJyb3I6IENhbm5vdCByZWFkIHByb3BlcnR5ICdjb25jYXQnIG9mIG51bGxcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFRoZSBzb2x1dGlvbiBpcyB0byBjb25zdHJhaW4gYGFgIGJ5IGZpcnN0IGRlZmluaW5nIGEgW2BUeXBlQ2xhc3NgXVtdXG4gIC8vLiB2YWx1ZSwgdGhlbiBzcGVjaWZ5aW5nIHRoZSBjb25zdHJhaW50IGluIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBcImNvbmNhdFwiXG4gIC8vLiBmdW5jdGlvbjpcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiBjb25zdCBaID0gcmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBTZW1pZ3JvdXAgOjogVHlwZUNsYXNzXG4gIC8vLiBjb25zdCBTZW1pZ3JvdXAgPSBaLlR5cGVDbGFzcyAoXG4gIC8vLiAgICdteS1wYWNrYWdlL1NlbWlncm91cCcsXG4gIC8vLiAgICdodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNTZW1pZ3JvdXAnLFxuICAvLy4gICBbXSxcbiAgLy8uICAgeCA9PiB4ICE9IG51bGwgJiYgdHlwZW9mIHguY29uY2F0ID09PSAnZnVuY3Rpb24nXG4gIC8vLiApO1xuICAvLy5cbiAgLy8uIC8vICAgIGNvbmNhdCA6OiBTZW1pZ3JvdXAgYSA9PiBhIC0+IGEgLT4gYVxuICAvLy4gY29uc3QgY29uY2F0ID1cbiAgLy8uIGRlZiAoJ2NvbmNhdCcpXG4gIC8vLiAgICAgKHthOiBbU2VtaWdyb3VwXX0pXG4gIC8vLiAgICAgKFthLCBhLCBhXSlcbiAgLy8uICAgICAoeCA9PiB5ID0+IHguY29uY2F0ICh5KSk7XG4gIC8vLlxuICAvLy4gY29uY2F0IChbMSwgMl0pIChbMywgNF0pO1xuICAvLy4gLy8gPT4gWzEsIDIsIDMsIDRdXG4gIC8vLlxuICAvLy4gY29uY2F0IChudWxsKSAobnVsbCk7XG4gIC8vLiAvLyAhIFR5cGVFcnJvcjogVHlwZS1jbGFzcyBjb25zdHJhaW50IHZpb2xhdGlvblxuICAvLy4gLy9cbiAgLy8uIC8vICAgY29uY2F0IDo6IFNlbWlncm91cCBhID0+IGEgLT4gYSAtPiBhXG4gIC8vLiAvLyAgICAgICAgICAgICBeXl5eXl5eXl5eXiAgICBeXG4gIC8vLiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gIC8vLiAvL1xuICAvLy4gLy8gICAxKSAgbnVsbCA6OiBOdWxsXG4gIC8vLiAvL1xuICAvLy4gLy8gICDigJhjb25jYXTigJkgcmVxdWlyZXMg4oCYYeKAmSB0byBzYXRpc2Z5IHRoZSBTZW1pZ3JvdXAgdHlwZS1jbGFzcyBjb25zdHJhaW50OyB0aGUgdmFsdWUgYXQgcG9zaXRpb24gMSBkb2VzIG5vdC5cbiAgLy8uIC8vXG4gIC8vLiAvLyAgIFNlZSBodHRwOi8vZXhhbXBsZS5jb20vbXktcGFja2FnZSNTZW1pZ3JvdXAgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBteS1wYWNrYWdlL1NlbWlncm91cCB0eXBlIGNsYXNzLlxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gTXVsdGlwbGUgY29uc3RyYWludHMgbWF5IGJlIHBsYWNlZCBvbiBhIHR5cGUgdmFyaWFibGUgYnkgaW5jbHVkaW5nXG4gIC8vLiBtdWx0aXBsZSBgVHlwZUNsYXNzYCB2YWx1ZXMgaW4gdGhlIGFycmF5IChlLmcuIGB7YTogW0ZvbywgQmFyLCBCYXpdfWApLlxuXG4gIC8vICBpbnZhbGlkQXJndW1lbnRzQ291bnQgOjogKFR5cGVJbmZvLCBJbnRlZ2VyLCBJbnRlZ2VyLCBBcnJheSBBbnkpIC0+IEVycm9yXG4gIC8vXG4gIC8vICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW4gYGN1cnJ5YCB3aGVuIGEgZnVuY3Rpb24gZGVmaW5lZCB2aWEgYGRlZmBcbiAgLy8gIGlzIGFwcGxpZWQgdG8gdG9vIG1hbnkgYXJndW1lbnRzLlxuICBmdW5jdGlvbiBpbnZhbGlkQXJndW1lbnRzQ291bnQodHlwZUluZm8sIGluZGV4LCBudW1BcmdzRXhwZWN0ZWQsIGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvciAodHJpbVRyYWlsaW5nU3BhY2VzIChcbiAgICAgIHEgKHR5cGVJbmZvLm5hbWUpICsgJyBhcHBsaWVkIHRvIHRoZSB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzXFxuXFxuJyArXG4gICAgICB1bmRlcmxpbmUgKFxuICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgSyAoSyAoXykpLFxuICAgICAgICBmdW5jdGlvbihpbmRleF8pIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgcmV0dXJuIEsgKEsgKGluZGV4XyA9PT0gaW5kZXggPyBmIDogXykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICkgKyAnXFxuJyArXG4gICAgICAnRXhwZWN0ZWQgJyArIG51bUFyZ3MgKG51bUFyZ3NFeHBlY3RlZCkgK1xuICAgICAgJyBidXQgcmVjZWl2ZWQgJyArIG51bUFyZ3MgKGFyZ3MubGVuZ3RoKSArXG4gICAgICB0b01hcmtkb3duTGlzdCAoJy5cXG4nLCAnOlxcblxcbicsIHNob3csIGFyZ3MpXG4gICAgKSk7XG4gIH1cblxuICAvLyAgY29uc3RyYWludHNSZXByIDo6IC4uLiAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gY29uc3RyYWludHNSZXByKFxuICAgIGNvbnN0cmFpbnRzLCAgICAvLyA6OiBTdHJNYXAgKEFycmF5IFR5cGVDbGFzcylcbiAgICBvdXRlciwgICAgICAgICAgLy8gOjogU3RyaW5nIC0+IFN0cmluZ1xuICAgIGlubmVyICAgICAgICAgICAvLyA6OiBTdHJpbmcgLT4gVHlwZUNsYXNzIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgKSB7XG4gICAgdmFyICRyZXBycyA9IFtdO1xuICAgIChzb3J0ZWRLZXlzIChjb25zdHJhaW50cykpLmZvckVhY2ggKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBmID0gaW5uZXIgKGspO1xuICAgICAgY29uc3RyYWludHNba10uZm9yRWFjaCAoZnVuY3Rpb24odHlwZUNsYXNzKSB7XG4gICAgICAgICRyZXBycy5wdXNoIChcbiAgICAgICAgICBmICh0eXBlQ2xhc3MpIChzdHJpcE5hbWVzcGFjZSAodHlwZUNsYXNzLm5hbWUpICsgJyAnICsgaylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB3aGVuICgkcmVwcnMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcyArIG91dGVyICgnID0+ICcpOyB9LFxuICAgICAgICAgICAgICAgICB3aGVuICgkcmVwcnMubGVuZ3RoID4gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgd3JhcCAob3V0ZXIgKCcoJykpIChvdXRlciAoJyknKSksXG4gICAgICAgICAgICAgICAgICAgICAgIGpvaW5XaXRoIChvdXRlciAoJywgJyksICRyZXBycykpKTtcbiAgfVxuXG4gIC8vICBsYWJlbCA6OiBTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBsYWJlbChsYWJlbCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgZGVsdGEgPSBzLmxlbmd0aCAtIGxhYmVsLmxlbmd0aDtcbiAgICAgIHJldHVybiBzdHJSZXBlYXQgKCcgJywgTWF0aC5mbG9vciAoZGVsdGEgLyAyKSkgKyBsYWJlbCArXG4gICAgICAgICAgICAgc3RyUmVwZWF0ICgnICcsIE1hdGguY2VpbCAoZGVsdGEgLyAyKSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICB0eXBlVmFyTmFtZXMgOjogVHlwZSAtPiBBcnJheSBTdHJpbmdcbiAgZnVuY3Rpb24gdHlwZVZhck5hbWVzKHQpIHtcbiAgICByZXR1cm4gWi5jb25jYXQgKFxuICAgICAgdC50eXBlID09PSBWQVJJQUJMRSA/IFt0Lm5hbWVdIDogW10sXG4gICAgICBaLmNoYWluIChmdW5jdGlvbihrKSB7IHJldHVybiB0eXBlVmFyTmFtZXMgKHQudHlwZXNba10udHlwZSk7IH0sIHQua2V5cylcbiAgICApO1xuICB9XG5cbiAgLy8gIHNob3dUeXBlV2l0aCA6OiBUeXBlSW5mbyAtPiBUeXBlIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBzaG93VHlwZVdpdGgodHlwZUluZm8pIHtcbiAgICB2YXIgbmFtZXMgPSBaLmNoYWluICh0eXBlVmFyTmFtZXMsIHR5cGVJbmZvLnR5cGVzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgdmFyIGNvZGUgPSAnYScuY2hhckNvZGVBdCAoMCk7XG4gICAgICByZXR1cm4gdW5sZXNzIChcbiAgICAgICAgdC50eXBlID09PSBGVU5DVElPTiB8fCB0LnR5cGUgPT09IFJFQ09SRCB8fCBpc0VtcHR5ICh0LmtleXMpLFxuICAgICAgICBzdHJpcE91dGVybW9zdFBhcmVucyxcbiAgICAgICAgKHNob3cgKHQpKS5yZXBsYWNlICgvXFxiVW5rbm93blxcYi9nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGx1c3BsdXNcbiAgICAgICAgICBkbyB2YXIgbmFtZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUgKGNvZGUrKyk7XG4gICAgICAgICAgd2hpbGUgKG5hbWVzLmluZGV4T2YgKG5hbWUpID49IDApO1xuICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHNob3dUeXBlUXVvdGVkIDo6IFR5cGUgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIHNob3dUeXBlUXVvdGVkKHQpIHtcbiAgICByZXR1cm4gcSAodW5sZXNzICh0LnR5cGUgPT09IFJFQ09SRCB8fCBpc0VtcHR5ICh0LmtleXMpLFxuICAgICAgICAgICAgICAgICAgICAgIHN0cmlwT3V0ZXJtb3N0UGFyZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIHNob3cgKHQpKSk7XG4gIH1cblxuICAvLyAgc2hvd1ZhbHVlc0FuZFR5cGVzIDo6IC4uLiAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gc2hvd1ZhbHVlc0FuZFR5cGVzKFxuICAgIGVudiwgICAgICAgICAgICAvLyA6OiBBcnJheSBUeXBlXG4gICAgdHlwZUluZm8sICAgICAgIC8vIDo6IFR5cGVJbmZvXG4gICAgdmFsdWVzLCAgICAgICAgIC8vIDo6IEFycmF5IEFueVxuICAgIHBvcyAgICAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICkge1xuICAgIHZhciBzaG93VHlwZSA9IHNob3dUeXBlV2l0aCAodHlwZUluZm8pO1xuICAgIHJldHVybiBzaG93IChwb3MpICsgJykgICcgKyBqb2luV2l0aCAoJ1xcbiAgICAnLCBaLm1hcCAoZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHR5cGVzID0gZGV0ZXJtaW5lQWN0dWFsVHlwZXNMb29zZSAoZW52LCBbeF0pO1xuICAgICAgcmV0dXJuIHNob3cgKHgpICsgJyA6OiAnICsgam9pbldpdGggKCcsICcsIFoubWFwIChzaG93VHlwZSwgdHlwZXMpKTtcbiAgICB9LCB2YWx1ZXMpKTtcbiAgfVxuXG4gIC8vICB0eXBlU2lnbmF0dXJlIDo6IFR5cGVJbmZvIC0+IFN0cmluZ1xuICBmdW5jdGlvbiB0eXBlU2lnbmF0dXJlKHR5cGVJbmZvKSB7XG4gICAgdmFyIHJlcHJzID0gWi5tYXAgKHNob3dUeXBlV2l0aCAodHlwZUluZm8pLCB0eXBlSW5mby50eXBlcyk7XG4gICAgdmFyIGFyaXR5ID0gcmVwcnMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gdHlwZUluZm8ubmFtZSArICcgOjogJyArXG4gICAgICAgICAgICAgY29uc3RyYWludHNSZXByICh0eXBlSW5mby5jb25zdHJhaW50cywgaWQsIEsgKEsgKGlkKSkpICtcbiAgICAgICAgICAgICB3aGVuIChhcml0eSA9PT0gMCxcbiAgICAgICAgICAgICAgICAgICBwYXJlbnRoZXNpemUsXG4gICAgICAgICAgICAgICAgICAgam9pbldpdGggKCcgLT4gJywgaW5pdCAocmVwcnMpKSkgK1xuICAgICAgICAgICAgICcgLT4gJyArIGxhc3QgKHJlcHJzKTtcbiAgfVxuXG4gIC8vICBfdW5kZXJsaW5lIDo6IC4uLiAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gX3VuZGVybGluZShcbiAgICB0LCAgICAgICAgICAgICAgLy8gOjogVHlwZVxuICAgIHByb3BQYXRoLCAgICAgICAvLyA6OiBQcm9wUGF0aFxuICAgIGZvcm1hdFR5cGUzICAgICAvLyA6OiBUeXBlIC0+IEFycmF5IFN0cmluZyAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gICkge1xuICAgIHJldHVybiB1bmxlc3MgKHQudHlwZSA9PT0gUkVDT1JEIHx8XG4gICAgICAgICAgICAgICAgICAgICBpc0VtcHR5ICh0LmtleXMpIHx8XG4gICAgICAgICAgICAgICAgICAgICB0LnR5cGUgPT09IEZVTkNUSU9OICYmIGlzRW1wdHkgKHByb3BQYXRoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgIWlzRW1wdHkgKHByb3BQYXRoKSxcbiAgICAgICAgICAgICAgICAgICBzdHJpcE91dGVybW9zdFBhcmVucyxcbiAgICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlMyAodCkgKHByb3BQYXRoKSAodC5mb3JtYXQgKF8sIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBLIChfdW5kZXJsaW5lICh0LnR5cGVzW2tdLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWi5jb25jYXQgKHByb3BQYXRoLCBba10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdFR5cGUzKSk7XG4gICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgfVxuXG4gIC8vICB1bmRlcmxpbmUgOjogLi4uIC0+IFN0cmluZ1xuICBmdW5jdGlvbiB1bmRlcmxpbmUoXG4gICAgdHlwZUluZm8sICAgICAgICAgICAgICAgLy8gOjogVHlwZUluZm9cbiAgICB1bmRlcmxpbmVDb25zdHJhaW50LCAgICAvLyA6OiBTdHJpbmcgLT4gVHlwZUNsYXNzIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgICBmb3JtYXRUeXBlNVxuICAgIC8vIDo6IEludGVnZXIgLT4gKFN0cmluZyAtPiBTdHJpbmcpIC0+IFR5cGUgLT4gUHJvcFBhdGggLT4gU3RyaW5nIC0+IFN0cmluZ1xuICApIHtcbiAgICB2YXIgc3QgPSB0eXBlSW5mby50eXBlcy5yZWR1Y2UgKGZ1bmN0aW9uKHN0LCB0LCBpbmRleCkge1xuICAgICAgdmFyIGZvcm1hdFR5cGU0ID0gZm9ybWF0VHlwZTUgKGluZGV4KTtcbiAgICAgIHN0Lm51bWJlcnMucHVzaCAoX3VuZGVybGluZSAodCwgW10sIGZvcm1hdFR5cGU0IChmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBsYWJlbCAoc2hvdyAoc3QuY291bnRlciArPSAxKSkgKHMpO1xuICAgICAgfSkpKTtcbiAgICAgIHN0LmNhcmV0cy5wdXNoIChfdW5kZXJsaW5lICh0LCBbXSwgVyAoZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB2YXIgcmVwciA9IHNob3cgKHR5cGUpO1xuICAgICAgICB2YXIgcGFyZW50aGVzaXplZCA9IHJlcHIuc2xpY2UgKDAsIDEpICsgcmVwci5zbGljZSAoLTEpID09PSAnKCknO1xuICAgICAgICByZXR1cm4gZm9ybWF0VHlwZTQgKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gcGFyZW50aGVzaXplZCAmJiByZXByICE9PSAnKCknICYmIHMubGVuZ3RoID09PSByZXByLmxlbmd0aCA/XG4gICAgICAgICAgICBfICgnKCcpICsgciAoJ14nKSAocy5zbGljZSAoMSwgLTEpKSArIF8gKCcpJykgOlxuICAgICAgICAgICAgciAoJ14nKSAocyk7XG4gICAgICAgIH0pO1xuICAgICAgfSkpKTtcbiAgICAgIHJldHVybiBzdDtcbiAgICB9LCB7Y2FyZXRzOiBbXSwgbnVtYmVyczogW10sIGNvdW50ZXI6IDB9KTtcblxuICAgIHJldHVybiB0eXBlU2lnbmF0dXJlICh0eXBlSW5mbykgKyAnXFxuJyArXG4gICAgICAgICAgIF8gKHR5cGVJbmZvLm5hbWUgKyAnIDo6ICcpICtcbiAgICAgICAgICAgICAgY29uc3RyYWludHNSZXByICh0eXBlSW5mby5jb25zdHJhaW50cywgXywgdW5kZXJsaW5lQ29uc3RyYWludCkgK1xuICAgICAgICAgICAgICBqb2luV2l0aCAoXyAoJyAtPiAnKSwgc3QuY2FyZXRzKSArICdcXG4nICtcbiAgICAgICAgICAgXyAodHlwZUluZm8ubmFtZSArICcgOjogJykgK1xuICAgICAgICAgICAgICBjb25zdHJhaW50c1JlcHIgKHR5cGVJbmZvLmNvbnN0cmFpbnRzLCBfLCBLIChLIChfKSkpICtcbiAgICAgICAgICAgICAgam9pbldpdGggKF8gKCcgLT4gJyksIHN0Lm51bWJlcnMpICsgJ1xcbic7XG4gIH1cblxuICAvLyAgcmVzb2x2ZVByb3BQYXRoIDo6IChUeXBlLCBBcnJheSBTdHJpbmcpIC0+IFR5cGVcbiAgZnVuY3Rpb24gcmVzb2x2ZVByb3BQYXRoKHQsIHByb3BQYXRoKSB7XG4gICAgcmV0dXJuIFoucmVkdWNlIChmdW5jdGlvbih0LCBwcm9wKSB7IHJldHVybiB0LnR5cGVzW3Byb3BdLnR5cGU7IH0sXG4gICAgICAgICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAgICAgICAgcHJvcFBhdGgpO1xuICB9XG5cbiAgLy8gIGZvcm1hdFR5cGU2IDo6XG4gIC8vICAgIFByb3BQYXRoIC0+IEludGVnZXIgLT4gKFN0cmluZyAtPiBTdHJpbmcpIC0+XG4gIC8vICAgICAgVHlwZSAtPiBQcm9wUGF0aCAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIGZvcm1hdFR5cGU2KGluZGV4ZWRQcm9wUGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbihpbmRleF8pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHByb3BQYXRoXykge1xuICAgICAgICAgICAgdmFyIGluZGV4ZWRQcm9wUGF0aF8gPSBaLmNvbmNhdCAoW2luZGV4X10sIHByb3BQYXRoXyk7XG4gICAgICAgICAgICB2YXIgcCA9IGlzUHJlZml4IChpbmRleGVkUHJvcFBhdGhfKSAoaW5kZXhlZFByb3BQYXRoKTtcbiAgICAgICAgICAgIHZhciBxID0gaXNQcmVmaXggKGluZGV4ZWRQcm9wUGF0aCkgKGluZGV4ZWRQcm9wUGF0aF8pO1xuICAgICAgICAgICAgcmV0dXJuIHAgJiYgcSA/IGYgOiBwID8gaWQgOiBfO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICAvLyAgc2VlIDo6IChTdHJpbmcsIHsgbmFtZSA6OiBTdHJpbmcsIHVybCA6OiBTdHJpbmc/IH0pIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBzZWUobGFiZWwsIHJlY29yZCkge1xuICAgIHJldHVybiByZWNvcmQudXJsID09IG51bGwgfHwgcmVjb3JkLnVybCA9PT0gJycgP1xuICAgICAgICAgICAnJyA6XG4gICAgICAgICAgICdcXG5TZWUgJyArIHJlY29yZC51cmwgK1xuICAgICAgICAgICAnIGZvciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgJyArIHJlY29yZC5uYW1lICsgJyAnICsgbGFiZWwgKyAnLlxcbic7XG4gIH1cblxuICAvLyAgdHlwZUNsYXNzQ29uc3RyYWludFZpb2xhdGlvbiA6OiAuLi4gLT4gRXJyb3JcbiAgZnVuY3Rpb24gdHlwZUNsYXNzQ29uc3RyYWludFZpb2xhdGlvbihcbiAgICBlbnYsICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHR5cGVJbmZvLCAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIHR5cGVDbGFzcywgICAgICAvLyA6OiBUeXBlQ2xhc3NcbiAgICBpbmRleCwgICAgICAgICAgLy8gOjogSW50ZWdlclxuICAgIHByb3BQYXRoLCAgICAgICAvLyA6OiBQcm9wUGF0aFxuICAgIHZhbHVlLCAgICAgICAgICAvLyA6OiBBbnlcbiAgICB0eXBlVmFyTWFwICAgICAgLy8gOjogVHlwZVZhck1hcFxuICApIHtcbiAgICB2YXIgZXhwVHlwZSA9IHJlc29sdmVQcm9wUGF0aCAodHlwZUluZm8udHlwZXNbaW5kZXhdLCBwcm9wUGF0aCk7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IgKHRyaW1UcmFpbGluZ1NwYWNlcyAoXG4gICAgICAnVHlwZS1jbGFzcyBjb25zdHJhaW50IHZpb2xhdGlvblxcblxcbicgK1xuICAgICAgdW5kZXJsaW5lICh0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgZnVuY3Rpb24odHZuKSB7XG4gICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHRjKSB7XG4gICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICB0dm4gPT09IGV4cFR5cGUubmFtZSAmJiB0Yy5uYW1lID09PSB0eXBlQ2xhc3MubmFtZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgciAoJ14nKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgX1xuICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlNiAoWi5jb25jYXQgKFtpbmRleF0sIHByb3BQYXRoKSkpICtcbiAgICAgICdcXG4nICtcbiAgICAgIHNob3dWYWx1ZXNBbmRUeXBlcyAoZW52LCB0eXBlSW5mbywgW3ZhbHVlXSwgMSkgKyAnXFxuXFxuJyArXG4gICAgICBxICh0eXBlSW5mby5uYW1lKSArICcgcmVxdWlyZXMgJyArXG4gICAgICBxIChleHBUeXBlLm5hbWUpICsgJyB0byBzYXRpc2Z5IHRoZSAnICtcbiAgICAgIHN0cmlwTmFtZXNwYWNlICh0eXBlQ2xhc3MubmFtZSkgKyAnIHR5cGUtY2xhc3MgY29uc3RyYWludDsgJyArXG4gICAgICAndGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgZG9lcyBub3QuXFxuJyArXG4gICAgICBzZWUgKCd0eXBlIGNsYXNzJywgdHlwZUNsYXNzKVxuICAgICkpO1xuICB9XG5cbiAgLy8gIHR5cGVWYXJDb25zdHJhaW50VmlvbGF0aW9uIDo6IC4uLiAtPiBFcnJvclxuICBmdW5jdGlvbiB0eXBlVmFyQ29uc3RyYWludFZpb2xhdGlvbihcbiAgICBlbnYsICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHR5cGVJbmZvLCAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIGluZGV4LCAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICAgcHJvcFBhdGgsICAgICAgIC8vIDo6IFByb3BQYXRoXG4gICAgdmFsdWVzQnlQYXRoICAgIC8vIDo6IFN0ck1hcCAoQXJyYXkgQW55KVxuICApIHtcbiAgICAvLyAgSWYgd2UgYXBwbHkgYW4g4oCYYSAtPiBhIC0+IGEgLT4gYeKAmSBmdW5jdGlvbiB0byBMZWZ0ICgneCcpLCBSaWdodCAoMSksXG4gICAgLy8gIGFuZCBSaWdodCAobnVsbCkgd2UnZCBsaWtlIHRvIGF2b2lkIHVuZGVybGluaW5nIHRoZSBmaXJzdCBhcmd1bWVudFxuICAgIC8vICBwb3NpdGlvbiwgc2luY2UgTGVmdCAoJ3gnKSBpcyBjb21wYXRpYmxlIHdpdGggdGhlIG90aGVyIOKAmGHigJkgdmFsdWVzLlxuICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeSAoWi5jb25jYXQgKFtpbmRleF0sIHByb3BQYXRoKSk7XG4gICAgdmFyIHZhbHVlcyA9IHZhbHVlc0J5UGF0aFtrZXldO1xuXG4gICAgLy8gIE5vdGU6IFNvcnRpbmcgdGhlc2Uga2V5cyBsZXhpY29ncmFwaGljYWxseSBpcyBub3QgXCJjb3JyZWN0XCIsIGJ1dCBpdFxuICAgIC8vICBkb2VzIHRoZSByaWdodCB0aGluZyBmb3IgaW5kZXhlcyBsZXNzIHRoYW4gMTAuXG4gICAgdmFyIGtleXMgPSBaLmZpbHRlciAoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIHZhbHVlc18gPSB2YWx1ZXNCeVBhdGhba107XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyAgS2VlcCBYLCB0aGUgcG9zaXRpb24gYXQgd2hpY2ggdGhlIHZpb2xhdGlvbiB3YXMgb2JzZXJ2ZWQuXG4gICAgICAgIGsgPT09IGtleSB8fFxuICAgICAgICAvLyAgS2VlcCBwb3NpdGlvbnMgd2hvc2UgdmFsdWVzIGFyZSBpbmNvbXBhdGlibGUgd2l0aCB0aGUgdmFsdWVzIGF0IFguXG4gICAgICAgIGlzRW1wdHkgKGRldGVybWluZUFjdHVhbFR5cGVzU3RyaWN0IChlbnYsIFouY29uY2F0ICh2YWx1ZXMsIHZhbHVlc18pKSlcbiAgICAgICk7XG4gICAgfSwgc29ydGVkS2V5cyAodmFsdWVzQnlQYXRoKSk7XG5cbiAgICB2YXIgdW5kZXJsaW5lZFR5cGVWYXJzID1cbiAgICB1bmRlcmxpbmVUeXBlVmFycyAodHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgIFoucmVkdWNlIChmdW5jdGlvbigkdmFsdWVzQnlQYXRoLCBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgJHZhbHVlc0J5UGF0aFtrXSA9IHZhbHVlc0J5UGF0aFtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHZhbHVlc0J5UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgfSwge30sIGtleXMpKTtcblxuICAgIHJldHVybiBuZXcgVHlwZUVycm9yICh0cmltVHJhaWxpbmdTcGFjZXMgKFxuICAgICAgdmFsdWVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgaXNFbXB0eSAoZGV0ZXJtaW5lQWN0dWFsVHlwZXNMb29zZSAoZW52LCB2YWx1ZXMpKSA/XG4gICAgICAgICdVbnJlY29nbml6ZWQgdmFsdWVcXG5cXG4nICtcbiAgICAgICAgdW5kZXJsaW5lZFR5cGVWYXJzICsgJ1xcbicgK1xuICAgICAgICAnMSkgICcgKyBzaG93ICh2YWx1ZXNbMF0pICsgJyA6OiAobm8gdHlwZXMpXFxuXFxuJyArXG4gICAgICAgIHRvTWFya2Rvd25MaXN0IChcbiAgICAgICAgICAnVGhlIGVudmlyb25tZW50IGlzIGVtcHR5ISAnICtcbiAgICAgICAgICAnUG9seW1vcnBoaWMgZnVuY3Rpb25zIHJlcXVpcmUgYSBub24tZW1wdHkgZW52aXJvbm1lbnQuXFxuJyxcbiAgICAgICAgICAnVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mIGFueSB0eXBlIGluICcgK1xuICAgICAgICAgICd0aGUgZW52aXJvbm1lbnQuXFxuXFxuJyArXG4gICAgICAgICAgJ1RoZSBlbnZpcm9ubWVudCBjb250YWlucyB0aGUgZm9sbG93aW5nIHR5cGVzOlxcblxcbicsXG4gICAgICAgICAgc2hvd1R5cGVXaXRoICh0eXBlSW5mbyksXG4gICAgICAgICAgZW52XG4gICAgICAgICkgOlxuICAgICAgLy8gZWxzZVxuICAgICAgICAnVHlwZS12YXJpYWJsZSBjb25zdHJhaW50IHZpb2xhdGlvblxcblxcbicgK1xuICAgICAgICB1bmRlcmxpbmVkVHlwZVZhcnMgKyAnXFxuJyArXG4gICAgICAgIChaLnJlZHVjZSAoZnVuY3Rpb24oc3QsIGspIHtcbiAgICAgICAgICB2YXIgdmFsdWVzID0gdmFsdWVzQnlQYXRoW2tdO1xuICAgICAgICAgIHJldHVybiBpc0VtcHR5ICh2YWx1ZXMpID8gc3QgOiB7XG4gICAgICAgICAgICBpZHg6IHN0LmlkeCArIDEsXG4gICAgICAgICAgICBzOiBzdC5zICtcbiAgICAgICAgICAgICAgIHNob3dWYWx1ZXNBbmRUeXBlcyAoZW52LCB0eXBlSW5mbywgdmFsdWVzLCBzdC5pZHggKyAxKSArXG4gICAgICAgICAgICAgICAnXFxuXFxuJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0sIHtpZHg6IDAsIHM6ICcnfSwga2V5cykpLnMgK1xuICAgICAgICAnU2luY2UgdGhlcmUgaXMgbm8gdHlwZSBvZiB3aGljaCBhbGwgdGhlIGFib3ZlIHZhbHVlcyBhcmUgJyArXG4gICAgICAgICdtZW1iZXJzLCB0aGUgdHlwZS12YXJpYWJsZSBjb25zdHJhaW50IGhhcyBiZWVuIHZpb2xhdGVkLlxcbidcbiAgICApKTtcbiAgfVxuXG4gIC8vICBpbnZhbGlkVmFsdWUgOjogLi4uIC0+IEVycm9yXG4gIGZ1bmN0aW9uIGludmFsaWRWYWx1ZShcbiAgICBlbnYsICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHR5cGVJbmZvLCAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIGluZGV4LCAgICAgICAgICAvLyA6OiBJbnRlZ2VyXG4gICAgcHJvcFBhdGgsICAgICAgIC8vIDo6IFByb3BQYXRoXG4gICAgdmFsdWUgICAgICAgICAgIC8vIDo6IEFueVxuICApIHtcbiAgICB2YXIgdCA9IHJlc29sdmVQcm9wUGF0aCAodHlwZUluZm8udHlwZXNbaW5kZXhdLCBwcm9wUGF0aCk7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IgKHRyaW1UcmFpbGluZ1NwYWNlcyAoXG4gICAgICAnSW52YWxpZCB2YWx1ZVxcblxcbicgK1xuICAgICAgdW5kZXJsaW5lICh0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgSyAoSyAoXykpLFxuICAgICAgICAgICAgICAgICBmb3JtYXRUeXBlNiAoWi5jb25jYXQgKFtpbmRleF0sIHByb3BQYXRoKSkpICtcbiAgICAgICdcXG4nICtcbiAgICAgIHNob3dWYWx1ZXNBbmRUeXBlcyAoZW52LCB0eXBlSW5mbywgW3ZhbHVlXSwgMSkgKyAnXFxuXFxuJyArXG4gICAgICAnVGhlIHZhbHVlIGF0IHBvc2l0aW9uIDEgaXMgbm90IGEgbWVtYmVyIG9mICcgK1xuICAgICAgc2hvd1R5cGVRdW90ZWQgKHQpICsgJy5cXG4nICtcbiAgICAgIHNlZSAoJ3R5cGUnLCB0KVxuICAgICkpO1xuICB9XG5cbiAgLy8gIGludmFsaWRBcmd1bWVudHNMZW5ndGggOjogLi4uIC0+IEVycm9yXG4gIC8vXG4gIC8vICBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW4gYHdyYXBGdW5jdGlvbkNvbmRgIHRvIGVuc3VyZSB0aGF0IGhpZ2hlci1vcmRlclxuICAvLyAgZnVuY3Rpb25zIGRlZmluZWQgdmlhIGBkZWZgIG9ubHkgZXZlciBhcHBseSBhIGZ1bmN0aW9uIGFyZ3VtZW50IHRvIHRoZVxuICAvLyAgY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzLlxuICBmdW5jdGlvbiBpbnZhbGlkQXJndW1lbnRzTGVuZ3RoKFxuICAgIHR5cGVJbmZvLCAgICAgICAgICAgLy8gOjogVHlwZUluZm9cbiAgICBpbmRleCwgICAgICAgICAgICAgIC8vIDo6IEludGVnZXJcbiAgICBudW1BcmdzRXhwZWN0ZWQsICAgIC8vIDo6IEludGVnZXJcbiAgICBhcmdzICAgICAgICAgICAgICAgIC8vIDo6IEFycmF5IEFueVxuICApIHtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvciAodHJpbVRyYWlsaW5nU3BhY2VzIChcbiAgICAgIHEgKHR5cGVJbmZvLm5hbWUpICtcbiAgICAgICcgYXBwbGllZCAnICsgc2hvd1R5cGVRdW90ZWQgKHR5cGVJbmZvLnR5cGVzW2luZGV4XSkgK1xuICAgICAgJyB0byB0aGUgd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1xcblxcbicgK1xuICAgICAgdW5kZXJsaW5lIChcbiAgICAgICAgdHlwZUluZm8sXG4gICAgICAgIEsgKEsgKF8pKSxcbiAgICAgICAgZnVuY3Rpb24oaW5kZXhfKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwcm9wUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhfID09PSBpbmRleCA/XG4gICAgICAgICAgICAgICAgICAgIHQuZm9ybWF0IChfLCBmdW5jdGlvbihrKSB7IHJldHVybiBrID09PSAnJDEnID8gZiA6IF87IH0pIDpcbiAgICAgICAgICAgICAgICAgICAgXyAocyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgKSArICdcXG4nICtcbiAgICAgICdFeHBlY3RlZCAnICsgbnVtQXJncyAobnVtQXJnc0V4cGVjdGVkKSArXG4gICAgICAnIGJ1dCByZWNlaXZlZCAnICsgbnVtQXJncyAoYXJncy5sZW5ndGgpICtcbiAgICAgIHRvTWFya2Rvd25MaXN0ICgnLlxcbicsICc6XFxuXFxuJywgc2hvdywgYXJncylcbiAgICApKTtcbiAgfVxuXG4gIC8vICBhc3NlcnRSaWdodCA6OiBFaXRoZXIgKCgpIC0+IEVycm9yKSBhIC0+IGEgIVxuICBmdW5jdGlvbiBhc3NlcnRSaWdodChlaXRoZXIpIHtcbiAgICBpZiAoZWl0aGVyLmlzTGVmdCkgdGhyb3cgZWl0aGVyLnZhbHVlICgpO1xuICAgIHJldHVybiBlaXRoZXIudmFsdWU7XG4gIH1cblxuICAvLyAgd2l0aFR5cGVDaGVja2luZyA6OiAuLi4gLT4gRnVuY3Rpb25cbiAgZnVuY3Rpb24gd2l0aFR5cGVDaGVja2luZyhcbiAgICBlbnYsICAgICAgICAgICAgLy8gOjogQXJyYXkgVHlwZVxuICAgIHR5cGVJbmZvLCAgICAgICAvLyA6OiBUeXBlSW5mb1xuICAgIGltcGwgICAgICAgICAgICAvLyA6OiBGdW5jdGlvblxuICApIHtcbiAgICB2YXIgbiA9IHR5cGVJbmZvLnR5cGVzLmxlbmd0aCAtIDE7XG5cbiAgICAvLyAgd3JhcEZ1bmN0aW9uQ29uZCA6OiAoVHlwZVZhck1hcCwgSW50ZWdlciwgYSkgLT4gYVxuICAgIGZ1bmN0aW9uIHdyYXBGdW5jdGlvbkNvbmQoX3R5cGVWYXJNYXAsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVJbmZvLnR5cGVzW2luZGV4XS50eXBlICE9PSBGVU5DVElPTikgcmV0dXJuIHZhbHVlO1xuXG4gICAgICB2YXIgZXhwVHlwZSA9IHR5cGVJbmZvLnR5cGVzW2luZGV4XTtcblxuICAgICAgLy8gIGNoZWNrVmFsdWUgOjogKFR5cGVWYXJNYXAsIEludGVnZXIsIFN0cmluZywgYSkgLT4gRWl0aGVyICgoKSAtPiBFcnJvcikgVHlwZVZhck1hcFxuICAgICAgZnVuY3Rpb24gY2hlY2tWYWx1ZSh0eXBlVmFyTWFwLCBpbmRleCwgaywgeCkge1xuICAgICAgICB2YXIgcHJvcFBhdGggPSBba107XG4gICAgICAgIHZhciB0ID0gZXhwVHlwZS50eXBlc1trXS50eXBlO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHQudHlwZSA9PT0gVkFSSUFCTEUgP1xuICAgICAgICAgICAgWi5jaGFpbiAoXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKHR5cGVWYXJNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNFbXB0eSAodHlwZVZhck1hcFt0Lm5hbWVdLnR5cGVzKSA/XG4gICAgICAgICAgICAgICAgICBMZWZ0IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVWYXJDb25zdHJhaW50VmlvbGF0aW9uIChcbiAgICAgICAgICAgICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvcFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZVZhck1hcFt0Lm5hbWVdLnZhbHVlc0J5UGF0aFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSkgOlxuICAgICAgICAgICAgICAgICAgUmlnaHQgKHR5cGVWYXJNYXApO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBSaWdodCAodXBkYXRlVHlwZVZhck1hcCAoZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZVZhck1hcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BQYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3hdKSlcbiAgICAgICAgICAgICkgOlxuICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgIFoubWFwIChcbiAgICAgICAgICAgICAgZnVuY3Rpb24ocikgeyByZXR1cm4gci50eXBlVmFyTWFwOyB9LFxuICAgICAgICAgICAgICBzYXRpc2ZhY3RvcnlUeXBlcyAoZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbeF0pXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpc1RodW5rID0gZXhwVHlwZS50eXBlcy4kMS50eXBlLnR5cGUgPT09IE5PX0FSR1VNRU5UUztcbiAgICAgIHZhciBudW1BcmdzRXhwZWN0ZWQgPSBpc1RodW5rID8gMCA6IGV4cFR5cGUua2V5cy5sZW5ndGggLSAxO1xuICAgICAgdmFyIHR5cGVWYXJNYXAgPSBfdHlwZVZhck1hcDtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSBudW1BcmdzRXhwZWN0ZWQpIHtcbiAgICAgICAgICB0aHJvdyBpbnZhbGlkQXJndW1lbnRzTGVuZ3RoICh0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1BcmdzRXhwZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2UuY2FsbCAoYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgdHlwZVZhck1hcCA9IGFzc2VydFJpZ2h0IChcbiAgICAgICAgICAoaW5pdCAoZXhwVHlwZS5rZXlzKSkucmVkdWNlIChmdW5jdGlvbihlaXRoZXIsIGssIGlkeCkge1xuICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaWR4XTtcbiAgICAgICAgICAgIHJldHVybiBaLmNoYWluIChmdW5jdGlvbih0eXBlVmFyTWFwKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjaGVja1ZhbHVlICh0eXBlVmFyTWFwLCBpbmRleCwgaywgYXJnKTtcbiAgICAgICAgICAgIH0sIGVpdGhlcik7XG4gICAgICAgICAgfSwgUmlnaHQgKHR5cGVWYXJNYXApKVxuICAgICAgICApO1xuXG4gICAgICAgIHZhciBvdXRwdXQgPSB2YWx1ZS5hcHBseSAodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIGsgPSBsYXN0IChleHBUeXBlLmtleXMpO1xuICAgICAgICB0eXBlVmFyTWFwID0gYXNzZXJ0UmlnaHQgKGNoZWNrVmFsdWUgKHR5cGVWYXJNYXAsIGluZGV4LCBrLCBvdXRwdXQpKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gIHdyYXBOZXh0IDo6IChUeXBlVmFyTWFwLCBBcnJheSBBbnksIEludGVnZXIpIC0+IChhIC0+IGIpXG4gICAgZnVuY3Rpb24gd3JhcE5leHQoX3R5cGVWYXJNYXAsIF92YWx1ZXMsIGluZGV4KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwgKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IGludmFsaWRBcmd1bWVudHNDb3VudCAodHlwZUluZm8sIGluZGV4LCAxLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHlwZVZhck1hcCA9IChhc3NlcnRSaWdodCAoXG4gICAgICAgICAgc2F0aXNmYWN0b3J5VHlwZXMgKGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90eXBlVmFyTWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSW5mby50eXBlc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncylcbiAgICAgICAgKSkudHlwZVZhck1hcDtcblxuICAgICAgICB2YXIgdmFsdWVzID0gWi5jb25jYXQgKF92YWx1ZXMsIGFyZ3MpO1xuICAgICAgICBpZiAoaW5kZXggKyAxID09PSBuKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzLnJlZHVjZSAoZnVuY3Rpb24oZiwgeCwgaWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gZiAod3JhcEZ1bmN0aW9uQ29uZCAodHlwZVZhck1hcCwgaWR4LCB4KSk7XG4gICAgICAgICAgfSwgaW1wbCk7XG4gICAgICAgICAgdHlwZVZhck1hcCA9IChhc3NlcnRSaWdodCAoXG4gICAgICAgICAgICBzYXRpc2ZhY3RvcnlUeXBlcyAoZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVWYXJNYXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZUluZm8udHlwZXNbbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdmFsdWVdKVxuICAgICAgICAgICkpLnR5cGVWYXJNYXA7XG4gICAgICAgICAgcmV0dXJuIHdyYXBGdW5jdGlvbkNvbmQgKHR5cGVWYXJNYXAsIG4sIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gd3JhcE5leHQgKHR5cGVWYXJNYXAsIHZhbHVlcywgaW5kZXggKyAxKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgd3JhcHBlZCA9IHR5cGVJbmZvLnR5cGVzWzBdLnR5cGUgPT09IE5PX0FSR1VNRU5UUyA/XG4gICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICB0aHJvdyBpbnZhbGlkQXJndW1lbnRzQ291bnQgKHR5cGVJbmZvLCAwLCAwLCBzbGljZS5jYWxsIChhcmd1bWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSBpbXBsICgpO1xuICAgICAgICB2YXIgdHlwZVZhck1hcCA9IGFzc2VydFJpZ2h0IChcbiAgICAgICAgICBzYXRpc2ZhY3RvcnlUeXBlcyAoZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVJbmZvLnR5cGVzW25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXSlcbiAgICAgICAgKS50eXBlVmFyTWFwO1xuICAgICAgICByZXR1cm4gd3JhcEZ1bmN0aW9uQ29uZCAodHlwZVZhck1hcCwgbiwgdmFsdWUpO1xuICAgICAgfSA6XG4gICAgICB3cmFwTmV4dCAoe30sIFtdLCAwKTtcblxuICAgIHdyYXBwZWRbaW5zcGVjdF0gPSB3cmFwcGVkLnRvU3RyaW5nID0gYWx3YXlzMCAodHlwZVNpZ25hdHVyZSAodHlwZUluZm8pKTtcblxuICAgIHJldHVybiB3cmFwcGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZShvcHRzKSB7XG4gICAgZnVuY3Rpb24gZGVmKG5hbWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb25zdHJhaW50cykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXhwVHlwZXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdHMuY2hlY2tUeXBlcyA/XG4gICAgICAgICAgICAgIHdpdGhUeXBlQ2hlY2tpbmcgKG9wdHMuZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVzOiBhdWdtZW50VGh1bmsgKGV4cFR5cGVzKX0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltcGwpIDpcbiAgICAgICAgICAgICAgaW1wbDtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZiAoZGVmLm5hbWUpXG4gICAgICAgICAgICAgICAoe30pXG4gICAgICAgICAgICAgICAoW1N0cmluZ18sXG4gICAgICAgICAgICAgICAgIFN0ck1hcCAoQXJyYXlfIChUeXBlQ2xhc3MpKSxcbiAgICAgICAgICAgICAgICAgTm9uRW1wdHkgKEFycmF5XyAoVHlwZSkpLFxuICAgICAgICAgICAgICAgICBBbnlGdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgQW55RnVuY3Rpb25dKVxuICAgICAgICAgICAgICAgKGRlZik7XG4gIH1cblxuICB2YXIgY3JlYXRlID1cbiAgZGVmICgnY3JlYXRlJylcbiAgICAgICh7fSlcbiAgICAgIChbUmVjb3JkVHlwZSAoe2NoZWNrVHlwZXM6IEJvb2xlYW5fLCBlbnY6IEFycmF5XyAoQW55KX0pLCBBbnlGdW5jdGlvbl0pXG4gICAgICAoX2NyZWF0ZSk7XG5cbiAgLy8gIGZyb21VbmNoZWNrZWRVbmFyeVR5cGUgOjogKFR5cGUgLT4gVHlwZSkgLT4gVHlwZSAtPiBUeXBlXG4gIGZ1bmN0aW9uIGZyb21VbmNoZWNrZWRVbmFyeVR5cGUodHlwZUNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIHQgPSB0eXBlQ29uc3RydWN0b3IgKFVua25vd24pO1xuICAgIHZhciBfMSA9IHQudHlwZXMuJDEuZXh0cmFjdG9yO1xuICAgIHJldHVybiBDaGVja2VkVW5hcnlUeXBlICh0Lm5hbWUpICh0LnVybCkgKHQuX3Rlc3QpIChfMSk7XG4gIH1cblxuICAvLyAgZnJvbVVuY2hlY2tlZEJpbmFyeVR5cGUgOjogKFR5cGUgLT4gVHlwZSAtPiBUeXBlKSAtPiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICBmdW5jdGlvbiBmcm9tVW5jaGVja2VkQmluYXJ5VHlwZSh0eXBlQ29uc3RydWN0b3IpIHtcbiAgICB2YXIgdCA9IHR5cGVDb25zdHJ1Y3RvciAoVW5rbm93bikgKFVua25vd24pO1xuICAgIHZhciBfMSA9IHQudHlwZXMuJDEuZXh0cmFjdG9yO1xuICAgIHZhciBfMiA9IHQudHlwZXMuJDIuZXh0cmFjdG9yO1xuICAgIHJldHVybiBDaGVja2VkQmluYXJ5VHlwZSAodC5uYW1lKSAodC51cmwpICh0Ll90ZXN0KSAoXzEpIChfMik7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIEFueTogQW55LFxuICAgIEFueUZ1bmN0aW9uOiBBbnlGdW5jdGlvbixcbiAgICBBcmd1bWVudHM6IEFyZ3VtZW50cyxcbiAgICBBcnJheTogZnJvbVVuY2hlY2tlZFVuYXJ5VHlwZSAoQXJyYXlfKSxcbiAgICBBcnJheTA6IEFycmF5MCxcbiAgICBBcnJheTE6IGZyb21VbmNoZWNrZWRVbmFyeVR5cGUgKEFycmF5MSksXG4gICAgQXJyYXkyOiBmcm9tVW5jaGVja2VkQmluYXJ5VHlwZSAoQXJyYXkyKSxcbiAgICBCb29sZWFuOiBCb29sZWFuXyxcbiAgICBEYXRlOiBEYXRlXyxcbiAgICBFcnJvcjogRXJyb3JfLFxuICAgIEZpbml0ZU51bWJlcjogRmluaXRlTnVtYmVyLFxuICAgIEZ1bmN0aW9uOiBkZWYgKCdGdW5jdGlvbicpICh7fSkgKFtBcnJheV8gKFR5cGUpLCBUeXBlXSkgKEZ1bmN0aW9uXyksXG4gICAgR2xvYmFsUmVnRXhwOiBHbG9iYWxSZWdFeHAsXG4gICAgSHRtbEVsZW1lbnQ6IEh0bWxFbGVtZW50LFxuICAgIEludGVnZXI6IEludGVnZXIsXG4gICAgTmVnYXRpdmVGaW5pdGVOdW1iZXI6IE5lZ2F0aXZlRmluaXRlTnVtYmVyLFxuICAgIE5lZ2F0aXZlSW50ZWdlcjogTmVnYXRpdmVJbnRlZ2VyLFxuICAgIE5lZ2F0aXZlTnVtYmVyOiBOZWdhdGl2ZU51bWJlcixcbiAgICBOb25FbXB0eTogTm9uRW1wdHksXG4gICAgTm9uR2xvYmFsUmVnRXhwOiBOb25HbG9iYWxSZWdFeHAsXG4gICAgTm9uTmVnYXRpdmVJbnRlZ2VyOiBOb25OZWdhdGl2ZUludGVnZXIsXG4gICAgTm9uWmVyb0Zpbml0ZU51bWJlcjogTm9uWmVyb0Zpbml0ZU51bWJlcixcbiAgICBOb25aZXJvSW50ZWdlcjogTm9uWmVyb0ludGVnZXIsXG4gICAgTm9uWmVyb1ZhbGlkTnVtYmVyOiBOb25aZXJvVmFsaWROdW1iZXIsXG4gICAgTnVsbDogTnVsbCxcbiAgICBOdWxsYWJsZTogZnJvbVVuY2hlY2tlZFVuYXJ5VHlwZSAoTnVsbGFibGUpLFxuICAgIE51bWJlcjogTnVtYmVyXyxcbiAgICBPYmplY3Q6IE9iamVjdF8sXG4gICAgUG9zaXRpdmVGaW5pdGVOdW1iZXI6IFBvc2l0aXZlRmluaXRlTnVtYmVyLFxuICAgIFBvc2l0aXZlSW50ZWdlcjogUG9zaXRpdmVJbnRlZ2VyLFxuICAgIFBvc2l0aXZlTnVtYmVyOiBQb3NpdGl2ZU51bWJlcixcbiAgICBSZWdFeHA6IFJlZ0V4cF8sXG4gICAgUmVnZXhGbGFnczogUmVnZXhGbGFncyxcbiAgICBTdHJNYXA6IGZyb21VbmNoZWNrZWRVbmFyeVR5cGUgKFN0ck1hcCksXG4gICAgU3RyaW5nOiBTdHJpbmdfLFxuICAgIFN5bWJvbDogU3ltYm9sXyxcbiAgICBUeXBlOiBUeXBlLFxuICAgIFR5cGVDbGFzczogVHlwZUNsYXNzLFxuICAgIFVuZGVmaW5lZDogVW5kZWZpbmVkLFxuICAgIFVua25vd246IFVua25vd24sXG4gICAgVmFsaWREYXRlOiBWYWxpZERhdGUsXG4gICAgVmFsaWROdW1iZXI6IFZhbGlkTnVtYmVyLFxuICAgIGVudjogZW52LFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIHRlc3Q6IGRlZiAoJ3Rlc3QnKSAoe30pIChbQXJyYXlfIChUeXBlKSwgVHlwZSwgQW55LCBCb29sZWFuX10pICh0ZXN0KSxcbiAgICBOdWxsYXJ5VHlwZTogQ2hlY2tlZE51bGxhcnlUeXBlLFxuICAgIFVuYXJ5VHlwZTogQ2hlY2tlZFVuYXJ5VHlwZSxcbiAgICBCaW5hcnlUeXBlOiBDaGVja2VkQmluYXJ5VHlwZSxcbiAgICBFbnVtVHlwZTogQ2hlY2tlZEVudW1UeXBlLFxuICAgIFJlY29yZFR5cGU6IENoZWNrZWRSZWNvcmRUeXBlLFxuICAgIFR5cGVWYXJpYWJsZTogQ2hlY2tlZFR5cGVWYXJpYWJsZSxcbiAgICBVbmFyeVR5cGVWYXJpYWJsZTogQ2hlY2tlZFVuYXJ5VHlwZVZhcmlhYmxlLFxuICAgIEJpbmFyeVR5cGVWYXJpYWJsZTogQ2hlY2tlZEJpbmFyeVR5cGVWYXJpYWJsZSxcbiAgICBUaHVuazogVGh1bmssXG4gICAgUHJlZGljYXRlOiBQcmVkaWNhdGVcbiAgfTtcblxufSkpO1xuXG4vLy4gW0ZMOlNlbWlncm91cF06ICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZW1pZ3JvdXBcbi8vLiBbSFRNTCBlbGVtZW50XTogICAgICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnRcbi8vLiBbTW9ub2lkXTogICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21vbm9pZFxuLy8uIFtTZXRvaWRdOiAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2V0b2lkXG4vLy4gW2BBcnJheWBdOiAgICAgICAgICAgICAgI0FycmF5XG4vLy4gW2BBcnJheTJgXTogICAgICAgICAgICAgI0FycmF5MlxuLy8uIFtgQmluYXJ5VHlwZWBdOiAgICAgICAgICNCaW5hcnlUeXBlXG4vLy4gW2BEYXRlYF06ICAgICAgICAgICAgICAgI0RhdGVcbi8vLiBbYEZpbml0ZU51bWJlcmBdOiAgICAgICAjRmluaXRlTnVtYmVyXG4vLy4gW2BHbG9iYWxSZWdFeHBgXTogICAgICAgI0dsb2JhbFJlZ0V4cFxuLy8uIFtgSW50ZWdlcmBdOiAgICAgICAgICAgICNJbnRlZ2VyXG4vLy4gW2BOb25HbG9iYWxSZWdFeHBgXTogICAgI05vbkdsb2JhbFJlZ0V4cFxuLy8uIFtgTnVtYmVyYF06ICAgICAgICAgICAgICNOdW1iZXJcbi8vLiBbYE9iamVjdC5jcmVhdGVgXTogICAgICBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvY3JlYXRlXG4vLy4gW2BSZWdFeHBgXTogICAgICAgICAgICAgI1JlZ0V4cFxuLy8uIFtgUmVnZXhGbGFnc2BdOiAgICAgICAgICNSZWdleEZsYWdzXG4vLy4gW2BTdHJpbmdgXTogICAgICAgICAgICAgI1N0cmluZ1xuLy8uIFtgU3ludGF4RXJyb3JgXTogICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N5bnRheEVycm9yXG4vLy4gW2BUeXBlQ2xhc3NgXTogICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3NhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI1R5cGVDbGFzc1xuLy8uIFtgVHlwZUVycm9yYF06ICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1R5cGVFcnJvclxuLy8uIFtgVHlwZVZhcmlhYmxlYF06ICAgICAgICNUeXBlVmFyaWFibGVcbi8vLiBbYFVuYXJ5VHlwZWBdOiAgICAgICAgICAjVW5hcnlUeXBlXG4vLy4gW2BVbmFyeVR5cGVWYXJpYWJsZWBdOiAgI1VuYXJ5VHlwZVZhcmlhYmxlXG4vLy4gW2BVbmtub3duYF06ICAgICAgICAgICAgI1Vua25vd25cbi8vLiBbYFZhbGlkTnVtYmVyYF06ICAgICAgICAjVmFsaWROdW1iZXJcbi8vLiBbYGVudmBdOiAgICAgICAgICAgICAgICAjZW52XG4vLy4gW2FyZ3VtZW50c106ICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL2FyZ3VtZW50c1xuLy8uIFtlbnVtZXJhdGVkIHR5cGVzXTogICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VudW1lcmF0ZWRfdHlwZVxuLy8uIFttYXhdOiAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9NQVhfU0FGRV9JTlRFR0VSXG4vLy4gW21pbl06ICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL01JTl9TQUZFX0lOVEVHRVJcbi8vLiBbcmVjb3JkIHR5cGVdOiAgICAgICAgICAjUmVjb3JkVHlwZVxuLy8uIFtzZW1pZ3JvdXBdOiAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NlbWlncm91cFxuLy8uIFt0eXBlIGNsYXNzXTogICAgICAgICAgICN0eXBlLWNsYXNzZXNcbi8vLiBbdHlwZSB2YXJpYWJsZXNdOiAgICAgICAjVHlwZVZhcmlhYmxlXG4vLy4gW3R5cGVzXTogICAgICAgICAgICAgICAgI3R5cGVzXG4iLCIvKlxuICAgICAgICAgX19fX19fXyAgICBfX18gICAgX19fX19fX19fICAgIF9fXyAgIF9fXyAgICBfX19fX19fICAgIF9fX19fX1xuICAgICAgICAvICBfX19fL1xcICAvICAvXFwgIC9fXyAgIF9fXy9cXCAgLyAgL1xcIC8gIC9cXCAgLyAgX19fXy9cXCAgLyAgX18gIFxcXG4gICAgICAgLyAgL1xcX19fXFwvIC8gIC8gLyAgXFxfLyAgL1xcX19cXC8gLyAgL18vLyAgLyAvIC8gIC9cXF9fX1xcLyAvICAvXFwvICAvXFxcbiAgICAgIC8gIF9fX18vXFwgIC8gIC8gLyAgICAvICAvIC8gICAgLyAgX19fICAgLyAvIC8gIF9fX18vXFwgIC8gICAgICBfLyAvXG4gICAgIC8gIC9cXF9fX1xcLyAvICAvIC8gICAgLyAgLyAvICAgIC8gIC9cXF8vICAvIC8gLyAgL1xcX19fXFwvIC8gIC98ICB8XFxcXC9cbiAgICAvX19fX19fL1xcICAvX18vIC8gICAgL19fLyAvICAgIC9fXy8gLy9fXy8gLyAvX19fX19fL1xcICAvX18vIHxfX3wgfFxuICAgIFxcX19fX19fXFwvICBcXF9fXFwvICAgICBcXF9fXFwvICAgICBcXF9fXFwvIFxcX19cXC8gIFxcX19fX19fXFwvICBcXF9fXFwvIFxcX19cXHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4vLy4gPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmRcIj48aW1nIGFsdD1cIkZhbnRhc3kgTGFuZFwiIHNyYz1cImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQvbWFzdGVyL2xvZ28ucG5nXCIgd2lkdGg9XCI3NVwiIGhlaWdodD1cIjc1XCIgYWxpZ249XCJsZWZ0XCI+PC9hPlxuLy8uXG4vLy4gIyBzYW5jdHVhcnktZWl0aGVyXG4vLy5cbi8vLiBUaGUgRWl0aGVyIHR5cGUgcmVwcmVzZW50cyB2YWx1ZXMgd2l0aCB0d28gcG9zc2liaWxpdGllczogYSB2YWx1ZSBvZiB0eXBlXG4vLy4gYEVpdGhlciBhIGJgIGlzIGVpdGhlciBhIExlZnQgd2hvc2UgdmFsdWUgaXMgb2YgdHlwZSBgYWAgb3IgYSBSaWdodCB3aG9zZVxuLy8uIHZhbHVlIGlzIG9mIHR5cGUgYGJgLlxuXG4oZnVuY3Rpb24oZikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZiAocmVxdWlyZSAoJ3NhbmN0dWFyeS1zaG93JyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgIT0gbnVsbCkge1xuICAgIGRlZmluZSAoWydzYW5jdHVhcnktc2hvdycsICdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJ10sIGYpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc2FuY3R1YXJ5RWl0aGVyID0gZiAoc2VsZi5zYW5jdHVhcnlTaG93LCBzZWxmLnNhbmN0dWFyeVR5cGVDbGFzc2VzKTtcbiAgfVxuXG59IChmdW5jdGlvbihzaG93LCBaKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIF9fZG9jdGVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgJCA9IF9fZG9jdGVzdC5yZXF1aXJlICgnc2FuY3R1YXJ5LWRlZicpO1xuICAgIHZhciB0eXBlID0gX19kb2N0ZXN0LnJlcXVpcmUgKCdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycycpO1xuICAgIHZhciBTID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIFMgPSBfX2RvY3Rlc3QucmVxdWlyZSAoJ3NhbmN0dWFyeScpO1xuICAgICAgdmFyIEVpdGhlclR5cGUgPSAkLkJpbmFyeVR5cGVcbiAgICAgICAgKCdzYW5jdHVhcnktZWl0aGVyL0VpdGhlcicpXG4gICAgICAgICgnJylcbiAgICAgICAgKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHR5cGUgKHgpID09PSBFaXRoZXJbJ0BAdHlwZSddOyB9KVxuICAgICAgICAoZnVuY3Rpb24oZSkgeyByZXR1cm4gZS5pc0xlZnQgPyBbZS52YWx1ZV0gOiBbXTsgfSlcbiAgICAgICAgKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUuaXNMZWZ0ID8gW10gOiBbZS52YWx1ZV07IH0pO1xuICAgICAgdmFyIGVudiA9IFouY29uY2F0IChTLmVudixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgWyQuVHlwZUNsYXNzLCBFaXRoZXJUeXBlICgkLlVua25vd24pICgkLlVua25vd24pXSk7XG4gICAgICByZXR1cm4gUy5jcmVhdGUgKHtjaGVja1R5cGVzOiB0cnVlLCBlbnY6IGVudn0pO1xuICAgIH0gKCkpO1xuICB9XG5cbiAgdmFyIEVpdGhlciA9IHt9O1xuXG4gIHZhciBMZWZ0JHByb3RvdHlwZSA9IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICAgICdjb25zdHJ1Y3Rvcic6ICAgICAgICAgICAgRWl0aGVyLFxuICAgICdpc0xlZnQnOiAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnaXNSaWdodCc6ICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdAQHNob3cnOiAgICAgICAgICAgICAgICAgTGVmdCRwcm90b3R5cGUkc2hvdyxcbiAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgIExlZnQkcHJvdG90eXBlJG1hcCxcbiAgICAnZmFudGFzeS1sYW5kL2JpbWFwJzogICAgIExlZnQkcHJvdG90eXBlJGJpbWFwLFxuICAgICdmYW50YXN5LWxhbmQvYXAnOiAgICAgICAgTGVmdCRwcm90b3R5cGUkYXAsXG4gICAgJ2ZhbnRhc3ktbGFuZC9jaGFpbic6ICAgICBMZWZ0JHByb3RvdHlwZSRjaGFpbixcbiAgICAnZmFudGFzeS1sYW5kL2FsdCc6ICAgICAgIExlZnQkcHJvdG90eXBlJGFsdCxcbiAgICAnZmFudGFzeS1sYW5kL3JlZHVjZSc6ICAgIExlZnQkcHJvdG90eXBlJHJlZHVjZSxcbiAgICAnZmFudGFzeS1sYW5kL3RyYXZlcnNlJzogIExlZnQkcHJvdG90eXBlJHRyYXZlcnNlLFxuICAgICdmYW50YXN5LWxhbmQvZXh0ZW5kJzogICAgTGVmdCRwcm90b3R5cGUkZXh0ZW5kXG4gICAgLyogZXNsaW50LWVuYWJsZSBrZXktc3BhY2luZyAqL1xuICB9O1xuXG4gIHZhciBSaWdodCRwcm90b3R5cGUgPSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgICAnY29uc3RydWN0b3InOiAgICAgICAgICAgIEVpdGhlcixcbiAgICAnaXNMZWZ0JzogICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdpc1JpZ2h0JzogICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnQEBzaG93JzogICAgICAgICAgICAgICAgIFJpZ2h0JHByb3RvdHlwZSRzaG93LFxuICAgICdmYW50YXN5LWxhbmQvbWFwJzogICAgICAgUmlnaHQkcHJvdG90eXBlJG1hcCxcbiAgICAnZmFudGFzeS1sYW5kL2JpbWFwJzogICAgIFJpZ2h0JHByb3RvdHlwZSRiaW1hcCxcbiAgICAnZmFudGFzeS1sYW5kL2FwJzogICAgICAgIFJpZ2h0JHByb3RvdHlwZSRhcCxcbiAgICAnZmFudGFzeS1sYW5kL2NoYWluJzogICAgIFJpZ2h0JHByb3RvdHlwZSRjaGFpbixcbiAgICAnZmFudGFzeS1sYW5kL2FsdCc6ICAgICAgIFJpZ2h0JHByb3RvdHlwZSRhbHQsXG4gICAgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnOiAgICBSaWdodCRwcm90b3R5cGUkcmVkdWNlLFxuICAgICdmYW50YXN5LWxhbmQvdHJhdmVyc2UnOiAgUmlnaHQkcHJvdG90eXBlJHRyYXZlcnNlLFxuICAgICdmYW50YXN5LWxhbmQvZXh0ZW5kJzogICAgUmlnaHQkcHJvdG90eXBlJGV4dGVuZFxuICAgIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgfTtcblxuICB2YXIgdXRpbCA9XG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0JyA/XG4gICAgcmVxdWlyZSAoJ3V0aWwnKSA6XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307XG4gIHZhciBpbnNwZWN0ID1cbiAgICB1dGlsLmluc3BlY3QgIT0gbnVsbCAmJiB0eXBlb2YgdXRpbC5pbnNwZWN0LmN1c3RvbSA9PT0gJ3N5bWJvbCcgP1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuaW5zcGVjdC5jdXN0b20gOlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovICdpbnNwZWN0JztcbiAgTGVmdCRwcm90b3R5cGVbaW5zcGVjdF0gPSBMZWZ0JHByb3RvdHlwZSRzaG93O1xuICBSaWdodCRwcm90b3R5cGVbaW5zcGVjdF0gPSBSaWdodCRwcm90b3R5cGUkc2hvdztcblxuICAvLy4gYEVpdGhlciBhIGJgIHNhdGlzZmllcyB0aGUgZm9sbG93aW5nIFtGYW50YXN5IExhbmRdW10gc3BlY2lmaWNhdGlvbnM6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb25zdCBVc2VsZXNzID0gcmVxdWlyZSAoJ3NhbmN0dWFyeS11c2VsZXNzJylcbiAgLy8uXG4gIC8vLiA+IFMubWFwIChrID0+IGsgKyAnICcucmVwZWF0ICgxNiAtIGsubGVuZ3RoKSArXG4gIC8vLiAuICAgICAgICAgICAgIChaW2tdLnRlc3QgKFJpZ2h0IChVc2VsZXNzKSkgPyAnXFx1MjcwNSAgICcgOlxuICAvLy4gLiAgICAgICAgICAgICAgWltrXS50ZXN0IChSaWdodCAoWydmb28nXSkpID8gJ1xcdTI3MDUgKiAnIDpcbiAgLy8uIC4gICAgICAgICAgICAgIC8qIG90aGVyd2lzZSAqLyAgICAgICAgICAgICAgICdcXHUyNzRDICAgJykpXG4gIC8vLiAuICAgICAgIChTLmtleXMgKFouZmlsdGVyICgkLnRlc3QgKFtdKSAoJC5UeXBlQ2xhc3MpLCBaKSkpXG4gIC8vLiBbICdTZXRvaWQgICAgICAgICAg4pyFICogJywgIC8vIGlmIOKAmGHigJkgYW5kIOKAmGLigJkgc2F0aXNmeSBTZXRvaWRcbiAgLy8uIC4gJ09yZCAgICAgICAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBhbmQg4oCYYuKAmSBzYXRpc2Z5IE9yZFxuICAvLy4gLiAnU2VtaWdyb3Vwb2lkICAgIOKdjCAgICcsXG4gIC8vLiAuICdDYXRlZ29yeSAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ1NlbWlncm91cCAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBhbmQg4oCYYuKAmSBzYXRpc2Z5IFNlbWlncm91cFxuICAvLy4gLiAnTW9ub2lkICAgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdHcm91cCAgICAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0ZpbHRlcmFibGUgICAgICDinYwgICAnLFxuICAvLy4gLiAnRnVuY3RvciAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdCaWZ1bmN0b3IgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ1Byb2Z1bmN0b3IgICAgICDinYwgICAnLFxuICAvLy4gLiAnQXBwbHkgICAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdBcHBsaWNhdGl2ZSAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0NoYWluICAgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnQ2hhaW5SZWMgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdNb25hZCAgICAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0FsdCAgICAgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnUGx1cyAgICAgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdBbHRlcm5hdGl2ZSAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0ZvbGRhYmxlICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnVHJhdmVyc2FibGUgICAgIOKchSAgICcsXG4gIC8vLiAuICdFeHRlbmQgICAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0NvbW9uYWQgICAgICAgICDinYwgICAnLFxuICAvLy4gLiAnQ29udHJhdmFyaWFudCAgIOKdjCAgICcgXVxuICAvLy4gYGBgXG5cbiAgLy8jIEVpdGhlciA6OiBUeXBlUmVwIEVpdGhlclxuICAvLy5cbiAgLy8uIEVpdGhlciBbdHlwZSByZXByZXNlbnRhdGl2ZV1bXS5cblxuICAvLyMgRWl0aGVyLkxlZnQgOjogYSAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gQ29uc3RydWN0cyBhIHZhbHVlIG9mIHR5cGUgYEVpdGhlciBhIGJgIGZyb20gYSB2YWx1ZSBvZiB0eXBlIGBhYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IExlZnQgKCdzcXJ0IHVuZGVmaW5lZCBmb3IgLTEnKVxuICAvLy4gTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpXG4gIC8vLiBgYGBcbiAgdmFyIExlZnQgPSBFaXRoZXIuTGVmdCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGxlZnQgPSBPYmplY3QuY3JlYXRlIChMZWZ0JHByb3RvdHlwZSk7XG4gICAgaWYgKFouU2V0b2lkLnRlc3QgKHZhbHVlKSkge1xuICAgICAgbGVmdFsnZmFudGFzeS1sYW5kL2VxdWFscyddID0gTGVmdCRwcm90b3R5cGUkZXF1YWxzO1xuICAgICAgaWYgKFouT3JkLnRlc3QgKHZhbHVlKSkge1xuICAgICAgICBsZWZ0WydmYW50YXN5LWxhbmQvbHRlJ10gPSBMZWZ0JHByb3RvdHlwZSRsdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChaLlNlbWlncm91cC50ZXN0ICh2YWx1ZSkpIHtcbiAgICAgIGxlZnRbJ2ZhbnRhc3ktbGFuZC9jb25jYXQnXSA9IExlZnQkcHJvdG90eXBlJGNvbmNhdDtcbiAgICB9XG4gICAgbGVmdC52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBsZWZ0O1xuICB9O1xuXG4gIC8vIyBFaXRoZXIuUmlnaHQgOjogYiAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gQ29uc3RydWN0cyBhIHZhbHVlIG9mIHR5cGUgYEVpdGhlciBhIGJgIGZyb20gYSB2YWx1ZSBvZiB0eXBlIGBiYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFJpZ2h0ICg0MilcbiAgLy8uIFJpZ2h0ICg0MilcbiAgLy8uIGBgYFxuICB2YXIgUmlnaHQgPSBFaXRoZXIuUmlnaHQgPSBmdW5jdGlvbiBSaWdodCh2YWx1ZSkge1xuICAgIHZhciByaWdodCA9IE9iamVjdC5jcmVhdGUgKFJpZ2h0JHByb3RvdHlwZSk7XG4gICAgaWYgKFouU2V0b2lkLnRlc3QgKHZhbHVlKSkge1xuICAgICAgcmlnaHRbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9IFJpZ2h0JHByb3RvdHlwZSRlcXVhbHM7XG4gICAgICBpZiAoWi5PcmQudGVzdCAodmFsdWUpKSB7XG4gICAgICAgIHJpZ2h0WydmYW50YXN5LWxhbmQvbHRlJ10gPSBSaWdodCRwcm90b3R5cGUkbHRlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoWi5TZW1pZ3JvdXAudGVzdCAodmFsdWUpKSB7XG4gICAgICByaWdodFsnZmFudGFzeS1sYW5kL2NvbmNhdCddID0gUmlnaHQkcHJvdG90eXBlJGNvbmNhdDtcbiAgICB9XG4gICAgcmlnaHQudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgLy8jIEVpdGhlci5AQHR5cGUgOjogU3RyaW5nXG4gIC8vLlxuICAvLy4gRWl0aGVyIFt0eXBlIGlkZW50aWZpZXJdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0eXBlIChSaWdodCAoNDIpKVxuICAvLy4gJ3NhbmN0dWFyeS1laXRoZXIvRWl0aGVyQDEnXG4gIC8vLlxuICAvLy4gPiB0eXBlLnBhcnNlICh0eXBlIChSaWdodCAoNDIpKSlcbiAgLy8uIHtuYW1lc3BhY2U6ICdzYW5jdHVhcnktZWl0aGVyJywgbmFtZTogJ0VpdGhlcicsIHZlcnNpb246IDF9XG4gIC8vLiBgYGBcbiAgRWl0aGVyWydAQHR5cGUnXSA9ICdzYW5jdHVhcnktZWl0aGVyL0VpdGhlckAxJztcblxuICAvLyMgRWl0aGVyLmZhbnRhc3ktbGFuZC9vZiA6OiBiIC0+IEVpdGhlciBhIGJcbiAgLy8uXG4gIC8vLiAgIC0gYG9mIChFaXRoZXIpICh4KWAgaXMgZXF1aXZhbGVudCB0byBgUmlnaHQgKHgpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5vZiAoRWl0aGVyKSAoNDIpXG4gIC8vLiBSaWdodCAoNDIpXG4gIC8vLiBgYGBcbiAgRWl0aGVyWydmYW50YXN5LWxhbmQvb2YnXSA9IFJpZ2h0O1xuXG4gIGZ1bmN0aW9uIG5leHQoeCkgeyByZXR1cm4ge3RhZzogbmV4dCwgdmFsdWU6IHh9OyB9XG4gIGZ1bmN0aW9uIGRvbmUoeCkgeyByZXR1cm4ge3RhZzogZG9uZSwgdmFsdWU6IHh9OyB9XG5cbiAgLy8jIEVpdGhlci5mYW50YXN5LWxhbmQvY2hhaW5SZWMgOjogKChhIC0+IGMsIGIgLT4gYywgYSkgLT4gRWl0aGVyIGQgYywgYSkgLT4gRWl0aGVyIGQgYlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gWi5jaGFpblJlYyAoXG4gIC8vLiAuICAgRWl0aGVyLFxuICAvLy4gLiAgIChuZXh0LCBkb25lLCB4KSA9PlxuICAvLy4gLiAgICAgeCA8PSAxID8gTGVmdCAoJyEhJykgOiBSaWdodCAoeCA+PSAxMDAwID8gZG9uZSAoeCkgOiBuZXh0ICh4ICogeCkpLFxuICAvLy4gLiAgIDFcbiAgLy8uIC4gKVxuICAvLy4gTGVmdCAoJyEhJylcbiAgLy8uXG4gIC8vLiA+IFouY2hhaW5SZWMgKFxuICAvLy4gLiAgIEVpdGhlcixcbiAgLy8uIC4gICAobmV4dCwgZG9uZSwgeCkgPT5cbiAgLy8uIC4gICAgIHggPD0gMSA/IExlZnQgKCchIScpIDogUmlnaHQgKHggPj0gMTAwMCA/IGRvbmUgKHgpIDogbmV4dCAoeCAqIHgpKSxcbiAgLy8uIC4gICAyXG4gIC8vLiAuIClcbiAgLy8uIFJpZ2h0ICg2NTUzNilcbiAgLy8uIGBgYFxuICBFaXRoZXJbJ2ZhbnRhc3ktbGFuZC9jaGFpblJlYyddID0gZnVuY3Rpb24oZiwgeCkge1xuICAgIHZhciByID0gbmV4dCAoeCk7XG4gICAgd2hpbGUgKHIudGFnID09PSBuZXh0KSB7XG4gICAgICB2YXIgZWl0aGVyID0gZiAobmV4dCwgZG9uZSwgci52YWx1ZSk7XG4gICAgICBpZiAoZWl0aGVyLmlzTGVmdCkgcmV0dXJuIGVpdGhlcjtcbiAgICAgIHIgPSBlaXRoZXIudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBSaWdodCAoci52YWx1ZSk7XG4gIH07XG5cbiAgLy8jIEVpdGhlciNAQHNob3cgOjogKFNob3dhYmxlIGEsIFNob3dhYmxlIGIpID0+IEVpdGhlciBhIGIgfj4gKCkgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gICAtIGBzaG93IChMZWZ0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYCdMZWZ0ICgnICsgc2hvdyAoeCkgKyAnKSdgXG4gIC8vLiAgIC0gYHNob3cgKFJpZ2h0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYCdSaWdodCAoJyArIHNob3cgKHgpICsgJyknYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gc2hvdyAoTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpKVxuICAvLy4gJ0xlZnQgKFwic3FydCB1bmRlZmluZWQgZm9yIC0xXCIpJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAoUmlnaHQgKFsxLCAyLCAzXSkpXG4gIC8vLiAnUmlnaHQgKFsxLCAyLCAzXSknXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTGVmdCRwcm90b3R5cGUkc2hvdygpIHtcbiAgICByZXR1cm4gJ0xlZnQgKCcgKyBzaG93ICh0aGlzLnZhbHVlKSArICcpJztcbiAgfVxuICBmdW5jdGlvbiBSaWdodCRwcm90b3R5cGUkc2hvdygpIHtcbiAgICByZXR1cm4gJ1JpZ2h0ICgnICsgc2hvdyAodGhpcy52YWx1ZSkgKyAnKSc7XG4gIH1cblxuICAvLyMgRWl0aGVyI2ZhbnRhc3ktbGFuZC9lcXVhbHMgOjogKFNldG9pZCBhLCBTZXRvaWQgYikgPT4gRWl0aGVyIGEgYiB+PiBFaXRoZXIgYSBiIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiAgIC0gYExlZnQgKHgpYCBpcyBlcXVhbCB0byBgTGVmdCAoeSlgIFtpZmZdW10gYHhgIGlzIGVxdWFsIHRvIGB5YFxuICAvLy4gICAgIGFjY29yZGluZyB0byBbYFouZXF1YWxzYF1bXVxuICAvLy4gICAtIGBSaWdodCAoeClgIGlzIGVxdWFsIHRvIGBSaWdodCAoeSlgIFtpZmZdW10gYHhgIGlzIGVxdWFsIHRvIGB5YFxuICAvLy4gICAgIGFjY29yZGluZyB0byBbYFouZXF1YWxzYF1bXVxuICAvLy4gICAtIGBMZWZ0ICh4KWAgaXMgbmV2ZXIgZXF1YWwgdG8gYFJpZ2h0ICh5KWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZXF1YWxzIChMZWZ0IChbMSwgMiwgM10pKSAoTGVmdCAoWzEsIDIsIDNdKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuZXF1YWxzIChSaWdodCAoWzEsIDIsIDNdKSkgKFJpZ2h0IChbMSwgMiwgM10pKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMgKExlZnQgKFsxLCAyLCAzXSkpIChSaWdodCAoWzEsIDIsIDNdKSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTGVmdCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzTGVmdCAmJiBaLmVxdWFscyAodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIFJpZ2h0JHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNSaWdodCAmJiBaLmVxdWFscyAodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvbHRlIDo6IChPcmQgYSwgT3JkIGIpID0+IEVpdGhlciBhIGIgfj4gRWl0aGVyIGEgYiAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gICAtIGBMZWZ0ICh4KWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBMZWZ0ICh5KWAgW2lmZl1bXSBgeGAgaXMgbGVzc1xuICAvLy4gICAgIHRoYW4gb3IgZXF1YWwgdG8gYHlgIGFjY29yZGluZyB0byBbYFoubHRlYF1bXVxuICAvLy4gICAtIGBSaWdodCAoeClgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgUmlnaHQgKHkpYCBbaWZmXVtdIGB4YCBpcyBsZXNzXG4gIC8vLiAgICAgdGhhbiBvciBlcXVhbCB0byBgeWAgYWNjb3JkaW5nIHRvIFtgWi5sdGVgXVtdXG4gIC8vLiAgIC0gYExlZnQgKHgpYCBpcyBhbHdheXMgbGVzcyB0aGFuIGBSaWdodCAoeSlgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbHRlciAoUy5sdGUgKExlZnQgKDEpKSkgKFtMZWZ0ICgwKSwgTGVmdCAoMSksIExlZnQgKDIpXSlcbiAgLy8uIFtMZWZ0ICgwKSwgTGVmdCAoMSldXG4gIC8vLlxuICAvLy4gPiBTLmZpbHRlciAoUy5sdGUgKFJpZ2h0ICgxKSkpIChbUmlnaHQgKDApLCBSaWdodCAoMSksIFJpZ2h0ICgyKV0pXG4gIC8vLiBbUmlnaHQgKDApLCBSaWdodCAoMSldXG4gIC8vLlxuICAvLy4gPiBTLmZpbHRlciAoUy5sdGUgKExlZnQgKDEpKSkgKFtSaWdodCAoMCksIFJpZ2h0ICgxKSwgUmlnaHQgKDIpXSlcbiAgLy8uIFtdXG4gIC8vLlxuICAvLy4gPiBTLmZpbHRlciAoUy5sdGUgKFJpZ2h0ICgxKSkpIChbTGVmdCAoMCksIExlZnQgKDEpLCBMZWZ0ICgyKV0pXG4gIC8vLiBbTGVmdCAoMCksIExlZnQgKDEpLCBMZWZ0ICgyKV1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBMZWZ0JHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNSaWdodCB8fCBaLmx0ZSAodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIFJpZ2h0JHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNSaWdodCAmJiBaLmx0ZSAodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvY29uY2F0IDo6IChTZW1pZ3JvdXAgYSwgU2VtaWdyb3VwIGIpID0+IEVpdGhlciBhIGIgfj4gRWl0aGVyIGEgYiAtPiBFaXRoZXIgYSBiXG4gIC8vLlxuICAvLy4gICAtIGBjb25jYXQgKExlZnQgKHgpKSAoTGVmdCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvXG4gIC8vLiAgICAgYExlZnQgKGNvbmNhdCAoeCkgKHkpKWBcbiAgLy8uICAgLSBgY29uY2F0IChSaWdodCAoeCkpIChSaWdodCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvXG4gIC8vLiAgICAgYFJpZ2h0IChjb25jYXQgKHgpICh5KSlgXG4gIC8vLiAgIC0gYGNvbmNhdCAoTGVmdCAoeCkpIChSaWdodCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBSaWdodCAoeSlgXG4gIC8vLiAgIC0gYGNvbmNhdCAoUmlnaHQgKHgpKSAoTGVmdCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBSaWdodCAoeClgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmNvbmNhdCAoTGVmdCAoJ2FiYycpKSAoTGVmdCAoJ2RlZicpKVxuICAvLy4gTGVmdCAoJ2FiY2RlZicpXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdCAoUmlnaHQgKFsxLCAyLCAzXSkpIChSaWdodCAoWzQsIDUsIDZdKSlcbiAgLy8uIFJpZ2h0IChbMSwgMiwgMywgNCwgNSwgNl0pXG4gIC8vLlxuICAvLy4gPiBTLmNvbmNhdCAoTGVmdCAoJ2FiYycpKSAoUmlnaHQgKFsxLCAyLCAzXSkpXG4gIC8vLiBSaWdodCAoWzEsIDIsIDNdKVxuICAvLy5cbiAgLy8uID4gUy5jb25jYXQgKFJpZ2h0IChbMSwgMiwgM10pKSAoTGVmdCAoJ2FiYycpKVxuICAvLy4gUmlnaHQgKFsxLCAyLCAzXSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBMZWZ0JHByb3RvdHlwZSRjb25jYXQob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNMZWZ0ID8gTGVmdCAoWi5jb25jYXQgKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKSkgOiBvdGhlcjtcbiAgfVxuICBmdW5jdGlvbiBSaWdodCRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzUmlnaHQgPyBSaWdodCAoWi5jb25jYXQgKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKSkgOiB0aGlzO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvbWFwIDo6IEVpdGhlciBhIGIgfj4gKGIgLT4gYykgLT4gRWl0aGVyIGEgY1xuICAvLy5cbiAgLy8uICAgLSBgbWFwIChmKSAoTGVmdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBMZWZ0ICh4KWBcbiAgLy8uICAgLSBgbWFwIChmKSAoUmlnaHQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgUmlnaHQgKGYgKHgpKWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwIChTLmFkZCAoMSkpIChMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJykpXG4gIC8vLiBMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJylcbiAgLy8uXG4gIC8vLiA+IFMubWFwIChTLmFkZCAoMSkpIChSaWdodCAoOTkpKVxuICAvLy4gUmlnaHQgKDEwMClcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBMZWZ0JHByb3RvdHlwZSRtYXAoZikge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIFJpZ2h0JHByb3RvdHlwZSRtYXAoZikge1xuICAgIHJldHVybiBSaWdodCAoZiAodGhpcy52YWx1ZSkpO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvYmltYXAgOjogRWl0aGVyIGEgYyB+PiAoYSAtPiBiLCBjIC0+IGQpIC0+IEVpdGhlciBiIGRcbiAgLy8uXG4gIC8vLiAgIC0gYGJpbWFwIChmKSAoZykgKExlZnQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgTGVmdCAoZiAoeCkpYFxuICAvLy4gICAtIGBiaW1hcCAoZikgKGcpIChSaWdodCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBSaWdodCAoZyAoeCkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5iaW1hcCAoUy50b1VwcGVyKSAoUy5hZGQgKDEpKSAoTGVmdCAoJ2FiYycpKVxuICAvLy4gTGVmdCAoJ0FCQycpXG4gIC8vLlxuICAvLy4gPiBTLmJpbWFwIChTLnRvVXBwZXIpIChTLmFkZCAoMSkpIChSaWdodCAoOTkpKVxuICAvLy4gUmlnaHQgKDEwMClcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBMZWZ0JHByb3RvdHlwZSRiaW1hcChmLCBnKSB7XG4gICAgcmV0dXJuIExlZnQgKGYgKHRoaXMudmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBSaWdodCRwcm90b3R5cGUkYmltYXAoZiwgZykge1xuICAgIHJldHVybiBSaWdodCAoZyAodGhpcy52YWx1ZSkpO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvYXAgOjogRWl0aGVyIGEgYiB+PiBFaXRoZXIgYSAoYiAtPiBjKSAtPiBFaXRoZXIgYSBjXG4gIC8vLlxuICAvLy4gICAtIGBhcCAoTGVmdCAoeCkpIChMZWZ0ICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYExlZnQgKHgpYFxuICAvLy4gICAtIGBhcCAoTGVmdCAoeCkpIChSaWdodCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBMZWZ0ICh4KWBcbiAgLy8uICAgLSBgYXAgKFJpZ2h0IChmKSkgKExlZnQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgTGVmdCAoeClgXG4gIC8vLiAgIC0gYGFwIChSaWdodCAoZikpIChSaWdodCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBSaWdodCAoZiAoeCkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hcCAoTGVmdCAoJ2RpdiB1bmRlZmluZWQgZm9yIDAnKSkgKExlZnQgKCdzcXJ0IHVuZGVmaW5lZCBmb3IgLTEnKSlcbiAgLy8uIExlZnQgKCdkaXYgdW5kZWZpbmVkIGZvciAwJylcbiAgLy8uXG4gIC8vLiA+IFMuYXAgKExlZnQgKCdkaXYgdW5kZWZpbmVkIGZvciAwJykpIChSaWdodCAoOTkpKVxuICAvLy4gTGVmdCAoJ2RpdiB1bmRlZmluZWQgZm9yIDAnKVxuICAvLy5cbiAgLy8uID4gUy5hcCAoUmlnaHQgKFMuYWRkICgxKSkpIChMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJykpXG4gIC8vLiBMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJylcbiAgLy8uXG4gIC8vLiA+IFMuYXAgKFJpZ2h0IChTLmFkZCAoMSkpKSAoUmlnaHQgKDk5KSlcbiAgLy8uIFJpZ2h0ICgxMDApXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTGVmdCRwcm90b3R5cGUkYXAob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNMZWZ0ID8gb3RoZXIgOiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIFJpZ2h0JHByb3RvdHlwZSRhcChvdGhlcikge1xuICAgIHJldHVybiBvdGhlci5pc0xlZnQgPyBvdGhlciA6IFJpZ2h0IChvdGhlci52YWx1ZSAodGhpcy52YWx1ZSkpO1xuICB9XG5cbiAgLy8jIEVpdGhlciNmYW50YXN5LWxhbmQvY2hhaW4gOjogRWl0aGVyIGEgYiB+PiAoYiAtPiBFaXRoZXIgYSBjKSAtPiBFaXRoZXIgYSBjXG4gIC8vLlxuICAvLy4gICAtIGBjaGFpbiAoZikgKExlZnQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgTGVmdCAoeClgXG4gIC8vLiAgIC0gYGNoYWluIChmKSAoUmlnaHQgKHgpKWAgaXMgZXF1aXZhbGVudCB0byBgZiAoeClgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb25zdCBzcXJ0ID0gbiA9PiBuIDwgMCA/IExlZnQgKCdzcXJ0IHVuZGVmaW5lZCBmb3IgJyArIHNob3cgKG4pKVxuICAvLy4gLiAgICAgICAgICAgICAgICAgICAgICAgICA6IFJpZ2h0IChNYXRoLnNxcnQgKG4pKVxuICAvLy5cbiAgLy8uID4gUy5jaGFpbiAoc3FydCkgKExlZnQgKCdkaXYgdW5kZWZpbmVkIGZvciAwJykpXG4gIC8vLiBMZWZ0ICgnZGl2IHVuZGVmaW5lZCBmb3IgMCcpXG4gIC8vLlxuICAvLy4gPiBTLmNoYWluIChzcXJ0KSAoUmlnaHQgKC0xKSlcbiAgLy8uIExlZnQgKCdzcXJ0IHVuZGVmaW5lZCBmb3IgLTEnKVxuICAvLy5cbiAgLy8uID4gUy5jaGFpbiAoc3FydCkgKFJpZ2h0ICgyNSkpXG4gIC8vLiBSaWdodCAoNSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBMZWZ0JHByb3RvdHlwZSRjaGFpbihmKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gUmlnaHQkcHJvdG90eXBlJGNoYWluKGYpIHtcbiAgICByZXR1cm4gZiAodGhpcy52YWx1ZSk7XG4gIH1cblxuICAvLyMgRWl0aGVyI2ZhbnRhc3ktbGFuZC9hbHQgOjogRWl0aGVyIGEgYiB+PiBFaXRoZXIgYSBiIC0+IEVpdGhlciBhIGJcbiAgLy8uXG4gIC8vLiAgIC0gYGFsdCAoTGVmdCAoeCkpIChMZWZ0ICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYExlZnQgKHkpYFxuICAvLy4gICAtIGBhbHQgKExlZnQgKHgpKSAoUmlnaHQgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgUmlnaHQgKHkpYFxuICAvLy4gICAtIGBhbHQgKFJpZ2h0ICh4KSkgKExlZnQgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgUmlnaHQgKHgpYFxuICAvLy4gICAtIGBhbHQgKFJpZ2h0ICh4KSkgKFJpZ2h0ICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYFJpZ2h0ICh4KWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYWx0IChMZWZ0ICgnQScpKSAoTGVmdCAoJ0InKSlcbiAgLy8uIExlZnQgKCdCJylcbiAgLy8uXG4gIC8vLiA+IFMuYWx0IChMZWZ0ICgnQycpKSAoUmlnaHQgKDEpKVxuICAvLy4gUmlnaHQgKDEpXG4gIC8vLlxuICAvLy4gPiBTLmFsdCAoUmlnaHQgKDIpKSAoTGVmdCAoJ0QnKSlcbiAgLy8uIFJpZ2h0ICgyKVxuICAvLy5cbiAgLy8uID4gUy5hbHQgKFJpZ2h0ICgzKSkgKFJpZ2h0ICg0KSlcbiAgLy8uIFJpZ2h0ICgzKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIExlZnQkcHJvdG90eXBlJGFsdChvdGhlcikge1xuICAgIHJldHVybiBvdGhlcjtcbiAgfVxuICBmdW5jdGlvbiBSaWdodCRwcm90b3R5cGUkYWx0KG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyMgRWl0aGVyI2ZhbnRhc3ktbGFuZC9yZWR1Y2UgOjogRWl0aGVyIGEgYiB+PiAoKGMsIGIpIC0+IGMsIGMpIC0+IGNcbiAgLy8uXG4gIC8vLiAgIC0gYHJlZHVjZSAoZikgKHgpIChMZWZ0ICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYHhgXG4gIC8vLiAgIC0gYHJlZHVjZSAoZikgKHgpIChSaWdodCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBmICh4KSAoeSlgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlZHVjZSAoUy5jb25jYXQpIChbMV0pIChMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJykpXG4gIC8vLiBbMV1cbiAgLy8uXG4gIC8vLiA+IFMucmVkdWNlIChTLmNvbmNhdCkgKFsxXSkgKFJpZ2h0IChbMl0pKVxuICAvLy4gWzEsIDJdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTGVmdCRwcm90b3R5cGUkcmVkdWNlKGYsIHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuICBmdW5jdGlvbiBSaWdodCRwcm90b3R5cGUkcmVkdWNlKGYsIHgpIHtcbiAgICByZXR1cm4gZiAoeCwgdGhpcy52YWx1ZSk7XG4gIH1cblxuICAvLyMgRWl0aGVyI2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSA6OiBBcHBsaWNhdGl2ZSBmID0+IEVpdGhlciBhIGIgfj4gKFR5cGVSZXAgZiwgYiAtPiBmIGMpIC0+IGYgKEVpdGhlciBhIGMpXG4gIC8vLlxuICAvLy4gICAtIGB0cmF2ZXJzZSAoQSkgKGYpIChMZWZ0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYG9mIChBKSAoTGVmdCAoeCkpYFxuICAvLy4gICAtIGB0cmF2ZXJzZSAoQSkgKGYpIChSaWdodCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBtYXAgKFJpZ2h0KSAoZiAoeCkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50cmF2ZXJzZSAoQXJyYXkpIChTLndvcmRzKSAoTGVmdCAoJ3NxcnQgdW5kZWZpbmVkIGZvciAtMScpKVxuICAvLy4gW0xlZnQgKCdzcXJ0IHVuZGVmaW5lZCBmb3IgLTEnKV1cbiAgLy8uXG4gIC8vLiA+IFMudHJhdmVyc2UgKEFycmF5KSAoUy53b3JkcykgKFJpZ2h0ICgnZm9vIGJhciBiYXonKSlcbiAgLy8uIFtSaWdodCAoJ2ZvbycpLCBSaWdodCAoJ2JhcicpLCBSaWdodCAoJ2JheicpXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIExlZnQkcHJvdG90eXBlJHRyYXZlcnNlKHR5cGVSZXAsIGYpIHtcbiAgICByZXR1cm4gWi5vZiAodHlwZVJlcCwgdGhpcyk7XG4gIH1cbiAgZnVuY3Rpb24gUmlnaHQkcHJvdG90eXBlJHRyYXZlcnNlKHR5cGVSZXAsIGYpIHtcbiAgICByZXR1cm4gWi5tYXAgKFJpZ2h0LCBmICh0aGlzLnZhbHVlKSk7XG4gIH1cblxuICAvLyMgRWl0aGVyI2ZhbnRhc3ktbGFuZC9leHRlbmQgOjogRWl0aGVyIGEgYiB+PiAoRWl0aGVyIGEgYiAtPiBjKSAtPiBFaXRoZXIgYSBjXG4gIC8vLlxuICAvLy4gICAtIGBleHRlbmQgKGYpIChMZWZ0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYExlZnQgKHgpYFxuICAvLy4gICAtIGBleHRlbmQgKGYpIChSaWdodCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBSaWdodCAoZiAoUmlnaHQgKHgpKSlgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmV4dGVuZCAoUy5yZWR1Y2UgKFMuYWRkKSAoMSkpIChMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJykpXG4gIC8vLiBMZWZ0ICgnc3FydCB1bmRlZmluZWQgZm9yIC0xJylcbiAgLy8uXG4gIC8vLiA+IFMuZXh0ZW5kIChTLnJlZHVjZSAoUy5hZGQpICgxKSkgKFJpZ2h0ICg5OSkpXG4gIC8vLiBSaWdodCAoMTAwKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIExlZnQkcHJvdG90eXBlJGV4dGVuZChmKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gUmlnaHQkcHJvdG90eXBlJGV4dGVuZChmKSB7XG4gICAgcmV0dXJuIFJpZ2h0IChmICh0aGlzKSk7XG4gIH1cblxuICByZXR1cm4gRWl0aGVyO1xuXG59KSk7XG5cbi8vLiBbRmFudGFzeSBMYW5kXTogICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmRcbi8vLiBbYFouZXF1YWxzYF06ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNlcXVhbHNcbi8vLiBbYFoubHRlYF06ICAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNsdGVcbi8vLiBbaWZmXTogICAgICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSWZfYW5kX29ubHlfaWZcbi8vLiBbdHlwZSBpZGVudGlmaWVyXTogICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnNcbi8vLiBbdHlwZSByZXByZXNlbnRhdGl2ZV06ICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHlwZS1yZXByZXNlbnRhdGl2ZXNcbiIsIi8qXG4gICAgLF9fX19fXyAgX19fX19fLCAgLF9fX19fX19fLCxfX19fXywsX19fX18sLF9fX19fX19fX18gICxfX19fX19fX19fLFxuICAgIHwgICAgICBcXC8gICAgICB8ICB8ICAgICAgICB8fCAgICAgfHwgICAgIHx8ICAgICAgICAgIFxcIHwgICAgICAgICAgfFxuICAgIHxfLCAgICAgICAgICAsX3wgIHxfICAgICAgX3x8XyAgICB8fCAgICBffHxfLCAgIF9fICAgIHx8XywgICBfX19fX3xcbiAgICAgIHwgICBcXCAgLyAgIHwgICAgIC8gICAgICBcXCAgIFxcICAgXFwvICAgLyAgICB8ICAgICAgICAvICAgfCAgICAgIHxcbiAgICAsX3wgICAgfHwgICAgfF8sLF8vICAgL1xcICAgXFxfLCBcXCAgICAgIC8gICAsX3wgICBfXyAgIFxcICxffCAgIF9fX3xfLFxuICAgIHwgICAgICB8fCAgICAgIHx8ICAgICB8fCAgICAgfCAgfCAgICB8ICAgIHwgICAgICAgICAgIHx8ICAgICAgICAgIHxcbiAgICB8X19fX19ffHxfX19fX198fF9fX19ffHxfX19fX3wgIHxfX19ffCAgICB8X19fX19fX19fXy8gfF9fX19fX19fX198XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cblxuLy8uIDxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kXCI+PGltZyBhbHQ9XCJGYW50YXN5IExhbmRcIiBzcmM9XCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kL21hc3Rlci9sb2dvLnBuZ1wiIHdpZHRoPVwiNzVcIiBoZWlnaHQ9XCI3NVwiIGFsaWduPVwibGVmdFwiPjwvYT5cbi8vLlxuLy8uICMgc2FuY3R1YXJ5LW1heWJlXG4vLy5cbi8vLiBUaGUgTWF5YmUgdHlwZSByZXByZXNlbnRzIG9wdGlvbmFsIHZhbHVlczogYSB2YWx1ZSBvZiB0eXBlIGBNYXliZSBhYCBpc1xuLy8uIGVpdGhlciBOb3RoaW5nICh0aGUgZW1wdHkgdmFsdWUpIG9yIGEgSnVzdCB3aG9zZSB2YWx1ZSBpcyBvZiB0eXBlIGBhYC5cblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYgKHJlcXVpcmUgKCdzYW5jdHVhcnktc2hvdycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUgKFsnc2FuY3R1YXJ5LXNob3cnLCAnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyddLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeU1heWJlID0gZiAoc2VsZi5zYW5jdHVhcnlTaG93LCBzZWxmLnNhbmN0dWFyeVR5cGVDbGFzc2VzKTtcbiAgfVxuXG59IChmdW5jdGlvbihzaG93LCBaKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIF9fZG9jdGVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgJCA9IF9fZG9jdGVzdC5yZXF1aXJlICgnc2FuY3R1YXJ5LWRlZicpO1xuICAgIHZhciB0eXBlID0gX19kb2N0ZXN0LnJlcXVpcmUgKCdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycycpO1xuICAgIHZhciBTID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIFMgPSBfX2RvY3Rlc3QucmVxdWlyZSAoJ3NhbmN0dWFyeScpO1xuICAgICAgdmFyIE1heWJlVHlwZSA9ICQuVW5hcnlUeXBlXG4gICAgICAgICgnc2FuY3R1YXJ5LW1heWJlL01heWJlJylcbiAgICAgICAgKCcnKVxuICAgICAgICAoZnVuY3Rpb24oeCkgeyByZXR1cm4gdHlwZSAoeCkgPT09IE1heWJlWydAQHR5cGUnXTsgfSlcbiAgICAgICAgKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0uaXNKdXN0ID8gW20udmFsdWVdIDogW107IH0pO1xuICAgICAgdmFyIGVudiA9IFouY29uY2F0IChTLmVudiwgWyQuVHlwZUNsYXNzLCBNYXliZVR5cGUgKCQuVW5rbm93bildKTtcbiAgICAgIHJldHVybiBTLmNyZWF0ZSAoe2NoZWNrVHlwZXM6IHRydWUsIGVudjogZW52fSk7XG4gICAgfSAoKSk7XG4gIH1cblxuICB2YXIgTWF5YmUgPSB7fTtcblxuICB2YXIgTm90aGluZyRwcm90b3R5cGUgPSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgICAnY29uc3RydWN0b3InOiAgICAgICAgICAgIE1heWJlLFxuICAgICdpc05vdGhpbmcnOiAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnaXNKdXN0JzogICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdAQHNob3cnOiAgICAgICAgICAgICAgICAgTm90aGluZyRwcm90b3R5cGUkc2hvdyxcbiAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgIE5vdGhpbmckcHJvdG90eXBlJGVxdWFscyxcbiAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgIE5vdGhpbmckcHJvdG90eXBlJGx0ZSxcbiAgICAnZmFudGFzeS1sYW5kL2NvbmNhdCc6ICAgIE5vdGhpbmckcHJvdG90eXBlJGNvbmNhdCxcbiAgICAnZmFudGFzeS1sYW5kL2ZpbHRlcic6ICAgIE5vdGhpbmckcHJvdG90eXBlJGZpbHRlcixcbiAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgIE5vdGhpbmckcHJvdG90eXBlJG1hcCxcbiAgICAnZmFudGFzeS1sYW5kL2FwJzogICAgICAgIE5vdGhpbmckcHJvdG90eXBlJGFwLFxuICAgICdmYW50YXN5LWxhbmQvY2hhaW4nOiAgICAgTm90aGluZyRwcm90b3R5cGUkY2hhaW4sXG4gICAgJ2ZhbnRhc3ktbGFuZC9hbHQnOiAgICAgICBOb3RoaW5nJHByb3RvdHlwZSRhbHQsXG4gICAgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnOiAgICBOb3RoaW5nJHByb3RvdHlwZSRyZWR1Y2UsXG4gICAgJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSc6ICBOb3RoaW5nJHByb3RvdHlwZSR0cmF2ZXJzZSxcbiAgICAnZmFudGFzeS1sYW5kL2V4dGVuZCc6ICAgIE5vdGhpbmckcHJvdG90eXBlJGV4dGVuZFxuICAgIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgfTtcblxuICB2YXIgSnVzdCRwcm90b3R5cGUgPSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cbiAgICAnY29uc3RydWN0b3InOiAgICAgICAgICAgIE1heWJlLFxuICAgICdpc05vdGhpbmcnOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2lzSnVzdCc6ICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdAQHNob3cnOiAgICAgICAgICAgICAgICAgSnVzdCRwcm90b3R5cGUkc2hvdyxcbiAgICAnZmFudGFzeS1sYW5kL2ZpbHRlcic6ICAgIEp1c3QkcHJvdG90eXBlJGZpbHRlcixcbiAgICAnZmFudGFzeS1sYW5kL21hcCc6ICAgICAgIEp1c3QkcHJvdG90eXBlJG1hcCxcbiAgICAnZmFudGFzeS1sYW5kL2FwJzogICAgICAgIEp1c3QkcHJvdG90eXBlJGFwLFxuICAgICdmYW50YXN5LWxhbmQvY2hhaW4nOiAgICAgSnVzdCRwcm90b3R5cGUkY2hhaW4sXG4gICAgJ2ZhbnRhc3ktbGFuZC9hbHQnOiAgICAgICBKdXN0JHByb3RvdHlwZSRhbHQsXG4gICAgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnOiAgICBKdXN0JHByb3RvdHlwZSRyZWR1Y2UsXG4gICAgJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSc6ICBKdXN0JHByb3RvdHlwZSR0cmF2ZXJzZSxcbiAgICAnZmFudGFzeS1sYW5kL2V4dGVuZCc6ICAgIEp1c3QkcHJvdG90eXBlJGV4dGVuZFxuICAgIC8qIGVzbGludC1lbmFibGUga2V5LXNwYWNpbmcgKi9cbiAgfTtcblxuICB2YXIgdXRpbCA9XG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0JyA/XG4gICAgcmVxdWlyZSAoJ3V0aWwnKSA6XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307XG4gIHZhciBpbnNwZWN0ID1cbiAgICB1dGlsLmluc3BlY3QgIT0gbnVsbCAmJiB0eXBlb2YgdXRpbC5pbnNwZWN0LmN1c3RvbSA9PT0gJ3N5bWJvbCcgP1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuaW5zcGVjdC5jdXN0b20gOlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovICdpbnNwZWN0JztcbiAgTm90aGluZyRwcm90b3R5cGVbaW5zcGVjdF0gPSBOb3RoaW5nJHByb3RvdHlwZSRzaG93O1xuICBKdXN0JHByb3RvdHlwZVtpbnNwZWN0XSA9IEp1c3QkcHJvdG90eXBlJHNob3c7XG5cbiAgLy8uIGBNYXliZSBhYCBzYXRpc2ZpZXMgdGhlIGZvbGxvd2luZyBbRmFudGFzeSBMYW5kXVtdIHNwZWNpZmljYXRpb25zOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29uc3QgVXNlbGVzcyA9IHJlcXVpcmUgKCdzYW5jdHVhcnktdXNlbGVzcycpXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoayA9PiBrICsgJyAnLnJlcGVhdCAoMTYgLSBrLmxlbmd0aCkgK1xuICAvLy4gLiAgICAgICAgICAgICAoWltrXS50ZXN0IChKdXN0IChVc2VsZXNzKSkgPyAnXFx1MjcwNSAgICcgOlxuICAvLy4gLiAgICAgICAgICAgICAgWltrXS50ZXN0IChOb3RoaW5nKSAgICAgICAgPyAnXFx1MjcwNSAqICcgOlxuICAvLy4gLiAgICAgICAgICAgICAgLyogb3RoZXJ3aXNlICovICAgICAgICAgICAgICAnXFx1Mjc0QyAgICcpKVxuICAvLy4gLiAgICAgICAoUy5rZXlzIChaLmZpbHRlciAoJC50ZXN0IChbXSkgKCQuVHlwZUNsYXNzKSwgWikpKVxuICAvLy4gWyAnU2V0b2lkICAgICAgICAgIOKchSAqICcsICAvLyBpZiDigJhh4oCZIHNhdGlzZmllcyBTZXRvaWRcbiAgLy8uIC4gJ09yZCAgICAgICAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBzYXRpc2ZpZXMgT3JkXG4gIC8vLiAuICdTZW1pZ3JvdXBvaWQgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0NhdGVnb3J5ICAgICAgICDinYwgICAnLFxuICAvLy4gLiAnU2VtaWdyb3VwICAgICAgIOKchSAqICcsICAvLyBpZiDigJhh4oCZIHNhdGlzZmllcyBTZW1pZ3JvdXBcbiAgLy8uIC4gJ01vbm9pZCAgICAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBzYXRpc2ZpZXMgU2VtaWdyb3VwXG4gIC8vLiAuICdHcm91cCAgICAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0ZpbHRlcmFibGUgICAgICDinIUgICAnLFxuICAvLy4gLiAnRnVuY3RvciAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdCaWZ1bmN0b3IgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ1Byb2Z1bmN0b3IgICAgICDinYwgICAnLFxuICAvLy4gLiAnQXBwbHkgICAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdBcHBsaWNhdGl2ZSAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0NoYWluICAgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnQ2hhaW5SZWMgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdNb25hZCAgICAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0FsdCAgICAgICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnUGx1cyAgICAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdBbHRlcm5hdGl2ZSAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0ZvbGRhYmxlICAgICAgICDinIUgICAnLFxuICAvLy4gLiAnVHJhdmVyc2FibGUgICAgIOKchSAgICcsXG4gIC8vLiAuICdFeHRlbmQgICAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0NvbW9uYWQgICAgICAgICDinYwgICAnLFxuICAvLy4gLiAnQ29udHJhdmFyaWFudCAgIOKdjCAgICcgXVxuICAvLy4gYGBgXG5cbiAgLy8jIE1heWJlIDo6IFR5cGVSZXAgTWF5YmVcbiAgLy8uXG4gIC8vLiBNYXliZSBbdHlwZSByZXByZXNlbnRhdGl2ZV1bXS5cblxuICAvLyMgTWF5YmUuTm90aGluZyA6OiBNYXliZSBhXG4gIC8vLlxuICAvLy4gVGhlIGVtcHR5IHZhbHVlIG9mIHR5cGUgYE1heWJlIGFgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gTm90aGluZ1xuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIHZhciBOb3RoaW5nID0gTWF5YmUuTm90aGluZyA9IE9iamVjdC5jcmVhdGUgKE5vdGhpbmckcHJvdG90eXBlKTtcblxuICAvLyMgTWF5YmUuSnVzdCA6OiBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RzIGEgdmFsdWUgb2YgdHlwZSBgTWF5YmUgYWAgZnJvbSBhIHZhbHVlIG9mIHR5cGUgYGFgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gSnVzdCAoNDIpXG4gIC8vLiBKdXN0ICg0MilcbiAgLy8uIGBgYFxuICB2YXIgSnVzdCA9IE1heWJlLkp1c3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBqdXN0ID0gT2JqZWN0LmNyZWF0ZSAoSnVzdCRwcm90b3R5cGUpO1xuICAgIGlmIChaLlNldG9pZC50ZXN0ICh2YWx1ZSkpIHtcbiAgICAgIGp1c3RbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9IEp1c3QkcHJvdG90eXBlJGVxdWFscztcbiAgICAgIGlmIChaLk9yZC50ZXN0ICh2YWx1ZSkpIHtcbiAgICAgICAganVzdFsnZmFudGFzeS1sYW5kL2x0ZSddID0gSnVzdCRwcm90b3R5cGUkbHRlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoWi5TZW1pZ3JvdXAudGVzdCAodmFsdWUpKSB7XG4gICAgICBqdXN0WydmYW50YXN5LWxhbmQvY29uY2F0J10gPSBKdXN0JHByb3RvdHlwZSRjb25jYXQ7XG4gICAgfVxuICAgIGp1c3QudmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4ganVzdDtcbiAgfTtcblxuICAvLyMgTWF5YmUuQEB0eXBlIDo6IFN0cmluZ1xuICAvLy5cbiAgLy8uIE1heWJlIFt0eXBlIGlkZW50aWZpZXJdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0eXBlIChKdXN0ICg0MikpXG4gIC8vLiAnc2FuY3R1YXJ5LW1heWJlL01heWJlQDEnXG4gIC8vLlxuICAvLy4gPiB0eXBlLnBhcnNlICh0eXBlIChKdXN0ICg0MikpKVxuICAvLy4ge25hbWVzcGFjZTogJ3NhbmN0dWFyeS1tYXliZScsIG5hbWU6ICdNYXliZScsIHZlcnNpb246IDF9XG4gIC8vLiBgYGBcbiAgTWF5YmVbJ0BAdHlwZSddID0gJ3NhbmN0dWFyeS1tYXliZS9NYXliZUAxJztcblxuICAvLyMgTWF5YmUuZmFudGFzeS1sYW5kL2VtcHR5IDo6ICgpIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiAgIC0gYGVtcHR5IChNYXliZSlgIGlzIGVxdWl2YWxlbnQgdG8gYE5vdGhpbmdgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVtcHR5IChNYXliZSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBNYXliZVsnZmFudGFzeS1sYW5kL2VtcHR5J10gPSBmdW5jdGlvbigpIHsgcmV0dXJuIE5vdGhpbmc7IH07XG5cbiAgLy8jIE1heWJlLmZhbnRhc3ktbGFuZC9vZiA6OiBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiAgIC0gYG9mIChNYXliZSkgKHgpYCBpcyBlcXVpdmFsZW50IHRvIGBKdXN0ICh4KWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMub2YgKE1heWJlKSAoNDIpXG4gIC8vLiBKdXN0ICg0MilcbiAgLy8uIGBgYFxuICBNYXliZVsnZmFudGFzeS1sYW5kL29mJ10gPSBKdXN0O1xuXG4gIGZ1bmN0aW9uIG5leHQoeCkgeyByZXR1cm4ge3RhZzogbmV4dCwgdmFsdWU6IHh9OyB9XG4gIGZ1bmN0aW9uIGRvbmUoeCkgeyByZXR1cm4ge3RhZzogZG9uZSwgdmFsdWU6IHh9OyB9XG5cbiAgLy8jIE1heWJlLmZhbnRhc3ktbGFuZC9jaGFpblJlYyA6OiAoKGEgLT4gYywgYiAtPiBjLCBhKSAtPiBNYXliZSBjLCBhKSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBaLmNoYWluUmVjIChcbiAgLy8uIC4gICBNYXliZSxcbiAgLy8uIC4gICAobmV4dCwgZG9uZSwgeCkgPT5cbiAgLy8uIC4gICAgIHggPD0gMSA/IE5vdGhpbmcgOiBKdXN0ICh4ID49IDEwMDAgPyBkb25lICh4KSA6IG5leHQgKHggKiB4KSksXG4gIC8vLiAuICAgMVxuICAvLy4gLiApXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBaLmNoYWluUmVjIChcbiAgLy8uIC4gICBNYXliZSxcbiAgLy8uIC4gICAobmV4dCwgZG9uZSwgeCkgPT5cbiAgLy8uIC4gICAgIHggPD0gMSA/IE5vdGhpbmcgOiBKdXN0ICh4ID49IDEwMDAgPyBkb25lICh4KSA6IG5leHQgKHggKiB4KSksXG4gIC8vLiAuICAgMlxuICAvLy4gLiApXG4gIC8vLiBKdXN0ICg2NTUzNilcbiAgLy8uIGBgYFxuICBNYXliZVsnZmFudGFzeS1sYW5kL2NoYWluUmVjJ10gPSBmdW5jdGlvbihmLCB4KSB7XG4gICAgdmFyIHIgPSBuZXh0ICh4KTtcbiAgICB3aGlsZSAoci50YWcgPT09IG5leHQpIHtcbiAgICAgIHZhciBtYXliZSA9IGYgKG5leHQsIGRvbmUsIHIudmFsdWUpO1xuICAgICAgaWYgKG1heWJlLmlzTm90aGluZykgcmV0dXJuIG1heWJlO1xuICAgICAgciA9IG1heWJlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gSnVzdCAoci52YWx1ZSk7XG4gIH07XG5cbiAgLy8jIE1heWJlLmZhbnRhc3ktbGFuZC96ZXJvIDo6ICgpIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiAgIC0gYHplcm8gKE1heWJlKWAgaXMgZXF1aXZhbGVudCB0byBgTm90aGluZ2BcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuemVybyAoTWF5YmUpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgTWF5YmVbJ2ZhbnRhc3ktbGFuZC96ZXJvJ10gPSBmdW5jdGlvbigpIHsgcmV0dXJuIE5vdGhpbmc7IH07XG5cbiAgLy8jIE1heWJlI0BAc2hvdyA6OiBTaG93YWJsZSBhID0+IE1heWJlIGEgfj4gKCkgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gICAtIGBzaG93IChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgJ05vdGhpbmcnYFxuICAvLy4gICAtIGBzaG93IChKdXN0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYCdKdXN0ICgnICsgc2hvdyAoeCkgKyAnKSdgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBzaG93IChOb3RoaW5nKVxuICAvLy4gJ05vdGhpbmcnXG4gIC8vLlxuICAvLy4gPiBzaG93IChKdXN0IChbJ2ZvbycsICdiYXInLCAnYmF6J10pKVxuICAvLy4gJ0p1c3QgKFtcImZvb1wiLCBcImJhclwiLCBcImJhelwiXSknXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTm90aGluZyRwcm90b3R5cGUkc2hvdygpIHtcbiAgICByZXR1cm4gJ05vdGhpbmcnO1xuICB9XG4gIGZ1bmN0aW9uIEp1c3QkcHJvdG90eXBlJHNob3coKSB7XG4gICAgcmV0dXJuICdKdXN0ICgnICsgc2hvdyAodGhpcy52YWx1ZSkgKyAnKSc7XG4gIH1cblxuICAvLyMgTWF5YmUjZmFudGFzeS1sYW5kL2VxdWFscyA6OiBTZXRvaWQgYSA9PiBNYXliZSBhIH4+IE1heWJlIGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uICAgLSBgTm90aGluZ2AgaXMgZXF1YWwgdG8gYE5vdGhpbmdgXG4gIC8vLiAgIC0gYEp1c3QgKHgpYCBpcyBlcXVhbCB0byBgSnVzdCAoeSlgIFtpZmZdW10gYHhgIGlzIGVxdWFsIHRvIGB5YFxuICAvLy4gICAgIGFjY29yZGluZyB0byBbYFouZXF1YWxzYF1bXVxuICAvLy4gICAtIGBOb3RoaW5nYCBpcyBuZXZlciBlcXVhbCB0byBgSnVzdCAoeClgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVxdWFscyAoTm90aGluZykgKE5vdGhpbmcpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmVxdWFscyAoSnVzdCAoWzEsIDIsIDNdKSkgKEp1c3QgKFsxLCAyLCAzXSkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmVxdWFscyAoSnVzdCAoWzEsIDIsIDNdKSkgKEp1c3QgKFszLCAyLCAxXSkpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMgKEp1c3QgKFsxLCAyLCAzXSkpIChOb3RoaW5nKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBOb3RoaW5nJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNOb3RoaW5nO1xuICB9XG4gIGZ1bmN0aW9uIEp1c3QkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBvdGhlci5pc0p1c3QgJiYgWi5lcXVhbHMgKHRoaXMudmFsdWUsIG90aGVyLnZhbHVlKTtcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvbHRlIDo6IE9yZCBhID0+IE1heWJlIGEgfj4gTWF5YmUgYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gICAtIGBOb3RoaW5nYCBpcyAobGVzcyB0aGFuIG9yKSBlcXVhbCB0byBgTm90aGluZ2BcbiAgLy8uICAgLSBgSnVzdCAoeClgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgSnVzdCAoeSlgIFtpZmZdW10gYHhgIGlzIGxlc3NcbiAgLy8uICAgICB0aGFuIG9yIGVxdWFsIHRvIGB5YCBhY2NvcmRpbmcgdG8gW2BaLmx0ZWBdW11cbiAgLy8uICAgLSBgTm90aGluZ2AgaXMgYWx3YXlzIGxlc3MgdGhhbiBgSnVzdCAoeClgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbHRlciAoUy5sdGUgKE5vdGhpbmcpKSAoW05vdGhpbmcsIEp1c3QgKDApLCBKdXN0ICgxKSwgSnVzdCAoMildKVxuICAvLy4gW05vdGhpbmddXG4gIC8vLlxuICAvLy4gPiBTLmZpbHRlciAoUy5sdGUgKEp1c3QgKDEpKSkgKFtOb3RoaW5nLCBKdXN0ICgwKSwgSnVzdCAoMSksIEp1c3QgKDIpXSlcbiAgLy8uIFtOb3RoaW5nLCBKdXN0ICgwKSwgSnVzdCAoMSldXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTm90aGluZyRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gSnVzdCRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzSnVzdCAmJiBaLmx0ZSAodGhpcy52YWx1ZSwgb3RoZXIudmFsdWUpO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9jb25jYXQgOjogU2VtaWdyb3VwIGEgPT4gTWF5YmUgYSB+PiBNYXliZSBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiAgIC0gYGNvbmNhdCAoTm90aGluZykgKE5vdGhpbmcpYCBpcyBlcXVpdmFsZW50IHRvIGBOb3RoaW5nYFxuICAvLy4gICAtIGBjb25jYXQgKEp1c3QgKHgpKSAoSnVzdCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvXG4gIC8vLiAgICAgYEp1c3QgKGNvbmNhdCAoeCkgKHkpKWBcbiAgLy8uICAgLSBgY29uY2F0IChOb3RoaW5nKSAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBKdXN0ICh4KWBcbiAgLy8uICAgLSBgY29uY2F0IChKdXN0ICh4KSkgKE5vdGhpbmcpYCBpcyBlcXVpdmFsZW50IHRvIGBKdXN0ICh4KWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuY29uY2F0IChOb3RoaW5nKSAoTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0IChKdXN0IChbMSwgMiwgM10pKSAoSnVzdCAoWzQsIDUsIDZdKSlcbiAgLy8uIEp1c3QgKFsxLCAyLCAzLCA0LCA1LCA2XSlcbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0IChOb3RoaW5nKSAoSnVzdCAoWzEsIDIsIDNdKSlcbiAgLy8uIEp1c3QgKFsxLCAyLCAzXSlcbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0IChKdXN0IChbMSwgMiwgM10pKSAoTm90aGluZylcbiAgLy8uIEp1c3QgKFsxLCAyLCAzXSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBOb3RoaW5nJHByb3RvdHlwZSRjb25jYXQob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXI7XG4gIH1cbiAgZnVuY3Rpb24gSnVzdCRwcm90b3R5cGUkY29uY2F0KG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLmlzSnVzdCA/IEp1c3QgKFouY29uY2F0ICh0aGlzLnZhbHVlLCBvdGhlci52YWx1ZSkpIDogdGhpcztcbiAgfVxuXG4gIC8vIyBNYXliZSNmYW50YXN5LWxhbmQvZmlsdGVyIDo6IE1heWJlIGEgfj4gKGEgLT4gQm9vbGVhbikgLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uICAgLSBgZmlsdGVyTSAocCkgKE5vdGhpbmcpYCBpcyBlcXVpdmFsZW50IHRvIGBOb3RoaW5nYFxuICAvLy4gICAtIGBmaWx0ZXJNIChwKSAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvXG4gIC8vLiAgICAgYHAgKHgpID8gSnVzdCAoeCkgOiBOb3RoaW5nYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maWx0ZXJNIChpc0Zpbml0ZSkgKE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmZpbHRlck0gKGlzRmluaXRlKSAoSnVzdCAoSW5maW5pdHkpKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5maWx0ZXJNIChpc0Zpbml0ZSkgKEp1c3QgKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSlcbiAgLy8uIEp1c3QgKDkwMDcxOTkyNTQ3NDA5OTEpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTm90aGluZyRwcm90b3R5cGUkZmlsdGVyKHByZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBKdXN0JHByb3RvdHlwZSRmaWx0ZXIocHJlZCkge1xuICAgIHJldHVybiBwcmVkICh0aGlzLnZhbHVlKSA/IHRoaXMgOiBOb3RoaW5nO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9tYXAgOjogTWF5YmUgYSB+PiAoYSAtPiBiKSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gICAtIGBtYXAgKGYpIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgTm90aGluZ2BcbiAgLy8uICAgLSBgbWFwIChmKSAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBKdXN0IChmICh4KSlgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcCAoTWF0aC5zcXJ0KSAoTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMubWFwIChNYXRoLnNxcnQpIChKdXN0ICg5KSlcbiAgLy8uIEp1c3QgKDMpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTm90aGluZyRwcm90b3R5cGUkbWFwKGYpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBKdXN0JHByb3RvdHlwZSRtYXAoZikge1xuICAgIHJldHVybiBKdXN0IChmICh0aGlzLnZhbHVlKSk7XG4gIH1cblxuICAvLyMgTWF5YmUjZmFudGFzeS1sYW5kL2FwIDo6IE1heWJlIGEgfj4gTWF5YmUgKGEgLT4gYikgLT4gTWF5YmUgYlxuICAvLy5cbiAgLy8uICAgLSBgYXAgKE5vdGhpbmcpIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgTm90aGluZ2BcbiAgLy8uICAgLSBgYXAgKE5vdGhpbmcpIChKdXN0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYE5vdGhpbmdgXG4gIC8vLiAgIC0gYGFwIChKdXN0IChmKSkgKE5vdGhpbmcpYCBpcyBlcXVpdmFsZW50IHRvIGBOb3RoaW5nYFxuICAvLy4gICAtIGBhcCAoSnVzdCAoZikpIChKdXN0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYEp1c3QgKGYgKHgpKWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXAgKE5vdGhpbmcpIChOb3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5hcCAoTm90aGluZykgKEp1c3QgKDkpKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5hcCAoSnVzdCAoTWF0aC5zcXJ0KSkgKE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmFwIChKdXN0IChNYXRoLnNxcnQpKSAoSnVzdCAoOSkpXG4gIC8vLiBKdXN0ICgzKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE5vdGhpbmckcHJvdG90eXBlJGFwKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZnVuY3Rpb24gSnVzdCRwcm90b3R5cGUkYXAob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIuaXNKdXN0ID8gSnVzdCAob3RoZXIudmFsdWUgKHRoaXMudmFsdWUpKSA6IG90aGVyO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9jaGFpbiA6OiBNYXliZSBhIH4+IChhIC0+IE1heWJlIGIpIC0+IE1heWJlIGJcbiAgLy8uXG4gIC8vLiAgIC0gYGNoYWluIChmKSAoTm90aGluZylgIGlzIGVxdWl2YWxlbnQgdG8gYE5vdGhpbmdgXG4gIC8vLiAgIC0gYGNoYWluIChmKSAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBmICh4KWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNvbnN0IGhlYWQgPSB4cyA9PiB4cy5sZW5ndGggPT09IDAgPyBOb3RoaW5nIDogSnVzdCAoeHNbMF0pXG4gIC8vLlxuICAvLy4gPiBTLmNoYWluIChoZWFkKSAoTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuY2hhaW4gKGhlYWQpIChKdXN0IChbXSkpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLmNoYWluIChoZWFkKSAoSnVzdCAoWydmb28nLCAnYmFyJywgJ2JheiddKSlcbiAgLy8uIEp1c3QgKCdmb28nKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE5vdGhpbmckcHJvdG90eXBlJGNoYWluKGYpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmdW5jdGlvbiBKdXN0JHByb3RvdHlwZSRjaGFpbihmKSB7XG4gICAgcmV0dXJuIGYgKHRoaXMudmFsdWUpO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9hbHQgOjogTWF5YmUgYSB+PiBNYXliZSBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiAgIC0gYGFsdCAoTm90aGluZykgKE5vdGhpbmcpYCBpcyBlcXVpdmFsZW50IHRvIGBOb3RoaW5nYFxuICAvLy4gICAtIGBhbHQgKE5vdGhpbmcpIChKdXN0ICh4KSlgIGlzIGVxdWl2YWxlbnQgdG8gYEp1c3QgKHgpYFxuICAvLy4gICAtIGBhbHQgKEp1c3QgKHgpKSAoTm90aGluZylgIGlzIGVxdWl2YWxlbnQgdG8gYEp1c3QgKHgpYFxuICAvLy4gICAtIGBhbHQgKEp1c3QgKHgpKSAoSnVzdCAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBKdXN0ICh4KWBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYWx0IChOb3RoaW5nKSAoTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuYWx0IChOb3RoaW5nKSAoSnVzdCAoMSkpXG4gIC8vLiBKdXN0ICgxKVxuICAvLy5cbiAgLy8uID4gUy5hbHQgKEp1c3QgKDIpKSAoTm90aGluZylcbiAgLy8uIEp1c3QgKDIpXG4gIC8vLlxuICAvLy4gPiBTLmFsdCAoSnVzdCAoMykpIChKdXN0ICg0KSlcbiAgLy8uIEp1c3QgKDMpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gTm90aGluZyRwcm90b3R5cGUkYWx0KG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyO1xuICB9XG4gIGZ1bmN0aW9uIEp1c3QkcHJvdG90eXBlJGFsdChvdGhlcikge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9yZWR1Y2UgOjogTWF5YmUgYSB+PiAoKGIsIGEpIC0+IGIsIGIpIC0+IGJcbiAgLy8uXG4gIC8vLiAgIC0gYHJlZHVjZSAoZikgKHgpIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgeGBcbiAgLy8uICAgLSBgcmVkdWNlIChmKSAoeCkgKEp1c3QgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgZiAoeCkgKHkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yZWR1Y2UgKFMuY29uY2F0KSAoJ2FiYycpIChOb3RoaW5nKVxuICAvLy4gJ2FiYydcbiAgLy8uXG4gIC8vLiA+IFMucmVkdWNlIChTLmNvbmNhdCkgKCdhYmMnKSAoSnVzdCAoJ3h5eicpKVxuICAvLy4gJ2FiY3h5eidcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBOb3RoaW5nJHByb3RvdHlwZSRyZWR1Y2UoZiwgeCkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIGZ1bmN0aW9uIEp1c3QkcHJvdG90eXBlJHJlZHVjZShmLCB4KSB7XG4gICAgcmV0dXJuIGYgKHgsIHRoaXMudmFsdWUpO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSA6OiBBcHBsaWNhdGl2ZSBmID0+IE1heWJlIGEgfj4gKFR5cGVSZXAgZiwgYSAtPiBmIGIpIC0+IGYgKE1heWJlIGIpXG4gIC8vLlxuICAvLy4gICAtIGB0cmF2ZXJzZSAoQSkgKGYpIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgb2YgKEEpIChOb3RoaW5nKWBcbiAgLy8uICAgLSBgdHJhdmVyc2UgKEEpIChmKSAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBtYXAgKEp1c3QpIChmICh4KSlgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRyYXZlcnNlIChBcnJheSkgKFMud29yZHMpIChOb3RoaW5nKVxuICAvLy4gW05vdGhpbmddXG4gIC8vLlxuICAvLy4gPiBTLnRyYXZlcnNlIChBcnJheSkgKFMud29yZHMpIChKdXN0ICgnZm9vIGJhciBiYXonKSlcbiAgLy8uIFtKdXN0ICgnZm9vJyksIEp1c3QgKCdiYXInKSwgSnVzdCAoJ2JheicpXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIE5vdGhpbmckcHJvdG90eXBlJHRyYXZlcnNlKHR5cGVSZXAsIGYpIHtcbiAgICByZXR1cm4gWi5vZiAodHlwZVJlcCwgdGhpcyk7XG4gIH1cbiAgZnVuY3Rpb24gSnVzdCRwcm90b3R5cGUkdHJhdmVyc2UodHlwZVJlcCwgZikge1xuICAgIHJldHVybiBaLm1hcCAoSnVzdCwgZiAodGhpcy52YWx1ZSkpO1xuICB9XG5cbiAgLy8jIE1heWJlI2ZhbnRhc3ktbGFuZC9leHRlbmQgOjogTWF5YmUgYSB+PiAoTWF5YmUgYSAtPiBiKSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gICAtIGBleHRlbmQgKGYpIChOb3RoaW5nKWAgaXMgZXF1aXZhbGVudCB0byBgTm90aGluZ2BcbiAgLy8uICAgLSBgZXh0ZW5kIChmKSAoSnVzdCAoeCkpYCBpcyBlcXVpdmFsZW50IHRvIGBKdXN0IChmIChKdXN0ICh4KSkpYFxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5leHRlbmQgKFMucmVkdWNlIChTLmFkZCkgKDEpKSAoTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZXh0ZW5kIChTLnJlZHVjZSAoUy5hZGQpICgxKSkgKEp1c3QgKDk5KSlcbiAgLy8uIEp1c3QgKDEwMClcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBOb3RoaW5nJHByb3RvdHlwZSRleHRlbmQoZikge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGZ1bmN0aW9uIEp1c3QkcHJvdG90eXBlJGV4dGVuZChmKSB7XG4gICAgcmV0dXJuIEp1c3QgKGYgKHRoaXMpKTtcbiAgfVxuXG4gIHJldHVybiBNYXliZTtcblxufSkpO1xuXG4vLy4gW0ZhbnRhc3kgTGFuZF06ICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kXG4vLy4gW2BaLmVxdWFsc2BdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZXF1YWxzXG4vLy4gW2BaLmx0ZWBdOiAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjbHRlXG4vLy4gW2lmZl06ICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lmX2FuZF9vbmx5X2lmXG4vLy4gW3R5cGUgaWRlbnRpZmllcl06ICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzXG4vLy4gW3R5cGUgcmVwcmVzZW50YXRpdmVdOiAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3R5cGUtcmVwcmVzZW50YXRpdmVzXG4iLCIgICAgICAgLyogICAgICAgICAgICAgICAgICAgKlxcXG4gICAgICAvLyAgICAgICAgICAgICAgICAgICAgIFxcXFxcbiAgICAgLy8gICBAQCAgQEAgICAgIEBAICBAQCAgIFxcXFxcbiAgICAvLyAgICAgIEBAICAgICAgIEBAICBAQCAgICBcXFxcXG4gICAgXFxcXCAgICAgIEBAICAgICAgIEBAICBAQCAgICAvL1xuICAgICBcXFxcICAgQEAgIEBAICBAICAgIEBAIEAgICAvL1xuICAgICAgXFxcXCAgICAgICAgICAvICAgICAgIEAgIC8vXG4gICAgICAgXFwqICAgICAgICAgICAgIEBAQEAgICovXG5cbi8vLiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZFwiPjxpbWcgYWx0PVwiRmFudGFzeSBMYW5kXCIgc3JjPVwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZC9tYXN0ZXIvbG9nby5wbmdcIiB3aWR0aD1cIjc1XCIgaGVpZ2h0PVwiNzVcIiBhbGlnbj1cImxlZnRcIj48L2E+XG4vLy5cbi8vLiAjIHNhbmN0dWFyeS1wYWlyXG4vLy5cbi8vLiBQYWlyIGlzIHRoZSBjYW5vbmljYWwgcHJvZHVjdCB0eXBlOiBhIHZhbHVlIG9mIHR5cGUgYFBhaXIgYSBiYCBhbHdheXNcbi8vLiBjb250YWlucyBleGFjdGx5IHR3byB2YWx1ZXM6IG9uZSBvZiB0eXBlIGBhYDsgb25lIG9mIHR5cGUgYGJgLlxuXG4oZnVuY3Rpb24oZikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZiAocmVxdWlyZSAoJ3NhbmN0dWFyeS1zaG93JyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcycpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgIT0gbnVsbCkge1xuICAgIGRlZmluZSAoWydzYW5jdHVhcnktc2hvdycsICdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJ10sIGYpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc2FuY3R1YXJ5UGFpciA9IGYgKHNlbGYuc2FuY3R1YXJ5U2hvdywgc2VsZi5zYW5jdHVhcnlUeXBlQ2xhc3Nlcyk7XG4gIH1cblxufSAoZnVuY3Rpb24oc2hvdywgWikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBfX2RvY3Rlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyICQgPSBfX2RvY3Rlc3QucmVxdWlyZSAoJ3NhbmN0dWFyeS1kZWYnKTtcbiAgICB2YXIgdHlwZSA9IF9fZG9jdGVzdC5yZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKTtcbiAgICB2YXIgUyA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBTID0gX19kb2N0ZXN0LnJlcXVpcmUgKCdzYW5jdHVhcnknKTtcbiAgICAgIHZhciBQYWlyVHlwZSA9ICQuQmluYXJ5VHlwZVxuICAgICAgICAoJ3NhbmN0dWFyeS1wYWlyL1BhaXInKVxuICAgICAgICAoJycpXG4gICAgICAgIChmdW5jdGlvbih4KSB7IHJldHVybiB0eXBlICh4KSA9PT0gUGFpclsnQEB0eXBlJ107IH0pXG4gICAgICAgIChmdW5jdGlvbihwKSB7IHJldHVybiBbcC5mc3RdOyB9KVxuICAgICAgICAoZnVuY3Rpb24ocCkgeyByZXR1cm4gW3Auc25kXTsgfSk7XG4gICAgICB2YXIgZW52ID0gWi5jb25jYXQgKFMuZW52LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbJC5UeXBlQ2xhc3MsIFBhaXJUeXBlICgkLlVua25vd24pICgkLlVua25vd24pXSk7XG4gICAgICByZXR1cm4gUy5jcmVhdGUgKHtjaGVja1R5cGVzOiB0cnVlLCBlbnY6IGVudn0pO1xuICAgIH0gKCkpO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZSA9IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICAgICdjb25zdHJ1Y3Rvcic6ICAgICAgICAgICAgUGFpcixcbiAgICAnQEBzaG93JzogICAgICAgICAgICAgICAgIFBhaXIkcHJvdG90eXBlJHNob3csXG4gICAgJ2ZhbnRhc3ktbGFuZC9jb21wb3NlJzogICBQYWlyJHByb3RvdHlwZSRjb21wb3NlLFxuICAgICdmYW50YXN5LWxhbmQvbWFwJzogICAgICAgUGFpciRwcm90b3R5cGUkbWFwLFxuICAgICdmYW50YXN5LWxhbmQvYmltYXAnOiAgICAgUGFpciRwcm90b3R5cGUkYmltYXAsXG4gICAgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnOiAgICBQYWlyJHByb3RvdHlwZSRyZWR1Y2UsXG4gICAgJ2ZhbnRhc3ktbGFuZC90cmF2ZXJzZSc6ICBQYWlyJHByb3RvdHlwZSR0cmF2ZXJzZSxcbiAgICAnZmFudGFzeS1sYW5kL2V4dGVuZCc6ICAgIFBhaXIkcHJvdG90eXBlJGV4dGVuZCxcbiAgICAnZmFudGFzeS1sYW5kL2V4dHJhY3QnOiAgIFBhaXIkcHJvdG90eXBlJGV4dHJhY3RcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG4gIH07XG5cbiAgdmFyIHV0aWwgPVxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcgP1xuICAgIHJlcXVpcmUgKCd1dGlsJykgOlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9O1xuICBwcm90b3R5cGVbXG4gICAgdXRpbC5pbnNwZWN0ICE9IG51bGwgJiYgdHlwZW9mIHV0aWwuaW5zcGVjdC5jdXN0b20gPT09ICdzeW1ib2wnID9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmluc3BlY3QuY3VzdG9tIDpcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyAnaW5zcGVjdCdcbiAgXSA9IFBhaXIkcHJvdG90eXBlJHNob3c7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgICBwcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLmZzdCwgdGhpcy5zbmRdW1N5bWJvbC5pdGVyYXRvcl0gKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vLiBgUGFpciBhIGJgIHNhdGlzZmllcyB0aGUgZm9sbG93aW5nIFtGYW50YXN5IExhbmRdW10gc3BlY2lmaWNhdGlvbnM6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb25zdCBVc2VsZXNzID0gcmVxdWlyZSAoJ3NhbmN0dWFyeS11c2VsZXNzJylcbiAgLy8uXG4gIC8vLiA+IFMubWFwIChrID0+IGsgKyAnICcucmVwZWF0ICgxNiAtIGsubGVuZ3RoKSArXG4gIC8vLiAuICAgICAgICAgICAgIChaW2tdLnRlc3QgKFBhaXIgKFVzZWxlc3MpIChVc2VsZXNzKSkgPyAnXFx1MjcwNSAgICcgOlxuICAvLy4gLiAgICAgICAgICAgICAgWltrXS50ZXN0IChQYWlyIChbJ2ZvbyddKSAoWydiYXInXSkpID8gJ1xcdTI3MDUgKiAnIDpcbiAgLy8uIC4gICAgICAgICAgICAgIC8qIG90aGVyd2lzZSAqLyAgICAgICAgICAgICAgICAgICAgICAgICdcXHUyNzRDICAgJykpXG4gIC8vLiAuICAgICAgIChTLmtleXMgKFouZmlsdGVyICgkLnRlc3QgKFtdKSAoJC5UeXBlQ2xhc3MpLCBaKSkpXG4gIC8vLiBbICdTZXRvaWQgICAgICAgICAg4pyFICogJywgIC8vIGlmIOKAmGHigJkgYW5kIOKAmGLigJkgc2F0aXNmeSBTZXRvaWRcbiAgLy8uIC4gJ09yZCAgICAgICAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBhbmQg4oCYYuKAmSBzYXRpc2Z5IE9yZFxuICAvLy4gLiAnU2VtaWdyb3Vwb2lkICAgIOKchSAgICcsXG4gIC8vLiAuICdDYXRlZ29yeSAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ1NlbWlncm91cCAgICAgICDinIUgKiAnLCAgLy8gaWYg4oCYYeKAmSBhbmQg4oCYYuKAmSBzYXRpc2Z5IFNlbWlncm91cFxuICAvLy4gLiAnTW9ub2lkICAgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdHcm91cCAgICAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ0ZpbHRlcmFibGUgICAgICDinYwgICAnLFxuICAvLy4gLiAnRnVuY3RvciAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdCaWZ1bmN0b3IgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ1Byb2Z1bmN0b3IgICAgICDinYwgICAnLFxuICAvLy4gLiAnQXBwbHkgICAgICAgICAgIOKchSAqICcsICAvLyBpZiDigJhh4oCZIHNhdGlzZmllcyBTZW1pZ3JvdXBcbiAgLy8uIC4gJ0FwcGxpY2F0aXZlICAgICDinYwgICAnLFxuICAvLy4gLiAnQ2hhaW4gICAgICAgICAgIOKchSAqICcsICAvLyBpZiDigJhh4oCZIHNhdGlzZmllcyBTZW1pZ3JvdXBcbiAgLy8uIC4gJ0NoYWluUmVjICAgICAgICDinYwgICAnLFxuICAvLy4gLiAnTW9uYWQgICAgICAgICAgIOKdjCAgICcsXG4gIC8vLiAuICdBbHQgICAgICAgICAgICAg4p2MICAgJyxcbiAgLy8uIC4gJ1BsdXMgICAgICAgICAgICDinYwgICAnLFxuICAvLy4gLiAnQWx0ZXJuYXRpdmUgICAgIOKdjCAgICcsXG4gIC8vLiAuICdGb2xkYWJsZSAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ1RyYXZlcnNhYmxlICAgICDinIUgICAnLFxuICAvLy4gLiAnRXh0ZW5kICAgICAgICAgIOKchSAgICcsXG4gIC8vLiAuICdDb21vbmFkICAgICAgICAg4pyFICAgJyxcbiAgLy8uIC4gJ0NvbnRyYXZhcmlhbnQgICDinYwgICAnIF1cbiAgLy8uIGBgYFxuXG4gIC8vIyBQYWlyIDo6IGEgLT4gYiAtPiBQYWlyIGEgYlxuICAvLy5cbiAgLy8uIFBhaXIncyBzb2xlIGRhdGEgY29uc3RydWN0b3IuIEFkZGl0aW9uYWxseSwgaXQgc2VydmVzIGFzIHRoZVxuICAvLy4gUGFpciBbdHlwZSByZXByZXNlbnRhdGl2ZV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFBhaXIgKDEpICgyKVxuICAvLy4gUGFpciAoMSkgKDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpcihmc3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc25kKSB7XG4gICAgICB2YXIgcGFpciA9IE9iamVjdC5jcmVhdGUgKHByb3RvdHlwZSk7XG4gICAgICBpZiAoWi5TZXRvaWQudGVzdCAoZnN0KSAmJiBaLlNldG9pZC50ZXN0IChzbmQpKSB7XG4gICAgICAgIHBhaXJbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9IFBhaXIkcHJvdG90eXBlJGVxdWFscztcbiAgICAgICAgaWYgKFouT3JkLnRlc3QgKGZzdCkgJiYgWi5PcmQudGVzdCAoc25kKSkge1xuICAgICAgICAgIHBhaXJbJ2ZhbnRhc3ktbGFuZC9sdGUnXSA9IFBhaXIkcHJvdG90eXBlJGx0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFouU2VtaWdyb3VwLnRlc3QgKGZzdCkpIHtcbiAgICAgICAgaWYgKFouU2VtaWdyb3VwLnRlc3QgKHNuZCkpIHtcbiAgICAgICAgICBwYWlyWydmYW50YXN5LWxhbmQvY29uY2F0J10gPSBQYWlyJHByb3RvdHlwZSRjb25jYXQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFpclsnZmFudGFzeS1sYW5kL2FwJ10gPSBQYWlyJHByb3RvdHlwZSRhcDtcbiAgICAgICAgcGFpclsnZmFudGFzeS1sYW5kL2NoYWluJ10gPSBQYWlyJHByb3RvdHlwZSRjaGFpbjtcbiAgICAgIH1cbiAgICAgIHBhaXIuZnN0ID0gZnN0O1xuICAgICAgcGFpci5zbmQgPSBzbmQ7XG4gICAgICByZXR1cm4gcGFpcjtcbiAgICB9O1xuICB9XG5cbiAgLy8jIFBhaXIuZnN0IDo6IFBhaXIgYSBiIC0+IGFcbiAgLy8uXG4gIC8vLiBgZnN0IChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGB4YC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFBhaXIuZnN0IChQYWlyICgnYWJjJykgKFsxLCAyLCAzXSkpXG4gIC8vLiAnYWJjJ1xuICAvLy4gYGBgXG4gIFBhaXIuZnN0ID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gcC5mc3Q7IH07XG5cbiAgLy8jIFBhaXIuc25kIDo6IFBhaXIgYSBiIC0+IGJcbiAgLy8uXG4gIC8vLiBgc25kIChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGB5YC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFBhaXIuc25kIChQYWlyICgnYWJjJykgKFsxLCAyLCAzXSkpXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uIGBgYFxuICBQYWlyLnNuZCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIHAuc25kOyB9O1xuXG4gIC8vIyBQYWlyLnN3YXAgOjogUGFpciBhIGIgLT4gUGFpciBiIGFcbiAgLy8uXG4gIC8vLiBgc3dhcCAoUGFpciAoeCkgKHkpKWAgaXMgZXF1aXZhbGVudCB0byBgUGFpciAoeSkgKHgpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFBhaXIuc3dhcCAoUGFpciAoJ2FiYycpIChbMSwgMiwgM10pKVxuICAvLy4gUGFpciAoWzEsIDIsIDNdKSAoJ2FiYycpXG4gIC8vLiBgYGBcbiAgUGFpci5zd2FwID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gUGFpciAocC5zbmQpIChwLmZzdCk7IH07XG5cbiAgLy8jIFBhaXIuQEB0eXBlIDo6IFN0cmluZ1xuICAvLy5cbiAgLy8uIFBhaXIgW3R5cGUgaWRlbnRpZmllcl1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHR5cGUgKFBhaXIgKCdhYmMnKSAoWzEsIDIsIDNdKSlcbiAgLy8uICdzYW5jdHVhcnktcGFpci9QYWlyQDEnXG4gIC8vLlxuICAvLy4gPiB0eXBlLnBhcnNlICh0eXBlIChQYWlyICgnYWJjJykgKFsxLCAyLCAzXSkpKVxuICAvLy4ge25hbWVzcGFjZTogJ3NhbmN0dWFyeS1wYWlyJywgbmFtZTogJ1BhaXInLCB2ZXJzaW9uOiAxfVxuICAvLy4gYGBgXG4gIFBhaXJbJ0BAdHlwZSddID0gJ3NhbmN0dWFyeS1wYWlyL1BhaXJAMSc7XG5cbiAgLy8jIFBhaXIjQEBzaG93IDo6IChTaG93YWJsZSBhLCBTaG93YWJsZSBiKSA9PiBQYWlyIGEgYiB+PiAoKSAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBgc2hvdyAoUGFpciAoeCkgKHkpKWAgaXMgZXF1aXZhbGVudCB0b1xuICAvLy4gYCdQYWlyICgnICsgc2hvdyAoeCkgKyAnKSAoJyArIHNob3cgKHkpICsgJyknYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNob3cgKFBhaXIgKCdhYmMnKSAoWzEsIDIsIDNdKSlcbiAgLy8uICdQYWlyIChcImFiY1wiKSAoWzEsIDIsIDNdKSdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBQYWlyJHByb3RvdHlwZSRzaG93KCkge1xuICAgIHJldHVybiAnUGFpciAoJyArIHNob3cgKHRoaXMuZnN0KSArICcpICgnICsgc2hvdyAodGhpcy5zbmQpICsgJyknO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL2VxdWFscyA6OiAoU2V0b2lkIGEsIFNldG9pZCBiKSA9PiBQYWlyIGEgYiB+PiBQYWlyIGEgYiAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gYFBhaXIgKHgpICh5KWAgaXMgZXF1YWwgdG8gYFBhaXIgKHYpICh3KWAgW2lmZl1bXSBgeGAgaXMgZXF1YWwgdG8gYHZgXG4gIC8vLiBhbmQgYHlgIGlzIGVxdWFsIHRvIGB3YCBhY2NvcmRpbmcgdG8gW2BaLmVxdWFsc2BdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVxdWFscyAoUGFpciAoJ2FiYycpIChbMSwgMiwgM10pKSAoUGFpciAoJ2FiYycpIChbMSwgMiwgM10pKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMgKFBhaXIgKCdhYmMnKSAoWzEsIDIsIDNdKSkgKFBhaXIgKCdhYmMnKSAoWzMsIDIsIDFdKSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIFouZXF1YWxzICh0aGlzLmZzdCwgb3RoZXIuZnN0KSAmJiBaLmVxdWFscyAodGhpcy5zbmQsIG90aGVyLnNuZCk7XG4gIH1cblxuICAvLyMgUGFpciNmYW50YXN5LWxhbmQvbHRlIDo6IChPcmQgYSwgT3JkIGIpID0+IFBhaXIgYSBiIH4+IFBhaXIgYSBiIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBgUGFpciAoeCkgKHkpYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYFBhaXIgKHYpICh3KWAgW2lmZl1bXSBgeGAgaXNcbiAgLy8uIGxlc3MgdGhhbiBgdmAgb3IgYHhgIGlzIGVxdWFsIHRvIGB2YCBhbmQgYHlgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAvLy4gYHdgIGFjY29yZGluZyB0byBbYFoubHRlYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZmlsdGVyIChTLmx0ZSAoUGFpciAoJ2InKSAoMikpKVxuICAvLy4gLiAgICAgICAgICAoW1BhaXIgKCdhJykgKDEpLCBQYWlyICgnYScpICgyKSwgUGFpciAoJ2EnKSAoMyksXG4gIC8vLiAuICAgICAgICAgICAgUGFpciAoJ2InKSAoMSksIFBhaXIgKCdiJykgKDIpLCBQYWlyICgnYicpICgzKSxcbiAgLy8uIC4gICAgICAgICAgICBQYWlyICgnYycpICgxKSwgUGFpciAoJ2MnKSAoMiksIFBhaXIgKCdjJykgKDMpXSlcbiAgLy8uIFsgUGFpciAoJ2EnKSAoMSksXG4gIC8vLiAuIFBhaXIgKCdhJykgKDIpLFxuICAvLy4gLiBQYWlyICgnYScpICgzKSxcbiAgLy8uIC4gUGFpciAoJ2InKSAoMSksXG4gIC8vLiAuIFBhaXIgKCdiJykgKDIpIF1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBQYWlyJHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICByZXR1cm4gWi5lcXVhbHMgKHRoaXMuZnN0LCBvdGhlci5mc3QpID8gWi5sdGUgKHRoaXMuc25kLCBvdGhlci5zbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFoubHRlICh0aGlzLmZzdCwgb3RoZXIuZnN0KTtcbiAgfVxuXG4gIC8vIyBQYWlyI2ZhbnRhc3ktbGFuZC9jb21wb3NlIDo6IFBhaXIgYSBiIH4+IFBhaXIgYiBjIC0+IFBhaXIgYSBjXG4gIC8vLlxuICAvLy4gYGNvbXBvc2UgKFBhaXIgKHgpICh5KSkgKFBhaXIgKHYpICh3KSlgIGlzIGVxdWl2YWxlbnQgdG8gYFBhaXIgKHYpICh5KWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmNvbXBvc2UgKFBhaXIgKCdhJykgKDApKSAoUGFpciAoWzEsIDIsIDNdKSAoJ2InKSlcbiAgLy8uIFBhaXIgKFsxLCAyLCAzXSkgKDApXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkY29tcG9zZShvdGhlcikge1xuICAgIHJldHVybiBQYWlyICh0aGlzLmZzdCkgKG90aGVyLnNuZCk7XG4gIH1cblxuICAvLyMgUGFpciNmYW50YXN5LWxhbmQvY29uY2F0IDo6IChTZW1pZ3JvdXAgYSwgU2VtaWdyb3VwIGIpID0+IFBhaXIgYSBiIH4+IFBhaXIgYSBiIC0+IFBhaXIgYSBiXG4gIC8vLlxuICAvLy4gYGNvbmNhdCAoUGFpciAoeCkgKHkpKSAoUGFpciAodikgKHcpKWAgaXMgZXF1aXZhbGVudCB0b1xuICAvLy4gYFBhaXIgKGNvbmNhdCAoeCkgKHYpKSAoY29uY2F0ICh5KSAodykpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuY29uY2F0IChQYWlyICgnYWJjJykgKFsxLCAyLCAzXSkpIChQYWlyICgneHl6JykgKFs0LCA1LCA2XSkpXG4gIC8vLiBQYWlyICgnYWJjeHl6JykgKFsxLCAyLCAzLCA0LCA1LCA2XSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBQYWlyJHByb3RvdHlwZSRjb25jYXQob3RoZXIpIHtcbiAgICByZXR1cm4gUGFpciAoWi5jb25jYXQgKHRoaXMuZnN0LCBvdGhlci5mc3QpKVxuICAgICAgICAgICAgICAgIChaLmNvbmNhdCAodGhpcy5zbmQsIG90aGVyLnNuZCkpO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL21hcCA6OiBQYWlyIGEgYiB+PiAoYiAtPiBjKSAtPiBQYWlyIGEgY1xuICAvLy5cbiAgLy8uIGBtYXAgKGYpIChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGBQYWlyICh4KSAoZiAoeSkpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwIChNYXRoLnNxcnQpIChQYWlyICgnYWJjJykgKDI1NikpXG4gIC8vLiBQYWlyICgnYWJjJykgKDE2KVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFBhaXIkcHJvdG90eXBlJG1hcChmKSB7XG4gICAgcmV0dXJuIFBhaXIgKHRoaXMuZnN0KSAoZiAodGhpcy5zbmQpKTtcbiAgfVxuXG4gIC8vIyBQYWlyI2ZhbnRhc3ktbGFuZC9iaW1hcCA6OiBQYWlyIGEgYyB+PiAoYSAtPiBiLCBjIC0+IGQpIC0+IFBhaXIgYiBkXG4gIC8vLlxuICAvLy4gYGJpbWFwIChmKSAoZykgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYFBhaXIgKGYgKHgpKSAoZyAoeSkpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYmltYXAgKFMudG9VcHBlcikgKE1hdGguc3FydCkgKFBhaXIgKCdhYmMnKSAoMjU2KSlcbiAgLy8uIFBhaXIgKCdBQkMnKSAoMTYpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkYmltYXAoZiwgZykge1xuICAgIHJldHVybiBQYWlyIChmICh0aGlzLmZzdCkpIChnICh0aGlzLnNuZCkpO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL2FwIDo6IFNlbWlncm91cCBhID0+IFBhaXIgYSBiIH4+IFBhaXIgYSAoYiAtPiBjKSAtPiBQYWlyIGEgY1xuICAvLy5cbiAgLy8uIGBhcCAoUGFpciAodikgKGYpKSAoUGFpciAoeCkgKHkpKWAgaXMgZXF1aXZhbGVudCB0b1xuICAvLy4gYFBhaXIgKGNvbmNhdCAodikgKHgpKSAoZiAoeSkpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXAgKFBhaXIgKCdhYmMnKSAoTWF0aC5zcXJ0KSkgKFBhaXIgKCd4eXonKSAoMjU2KSlcbiAgLy8uIFBhaXIgKCdhYmN4eXonKSAoMTYpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkYXAob3RoZXIpIHtcbiAgICByZXR1cm4gUGFpciAoWi5jb25jYXQgKG90aGVyLmZzdCwgdGhpcy5mc3QpKSAob3RoZXIuc25kICh0aGlzLnNuZCkpO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL2NoYWluIDo6IFNlbWlncm91cCBhID0+IFBhaXIgYSBiIH4+IChiIC0+IFBhaXIgYSBjKSAtPiBQYWlyIGEgY1xuICAvLy5cbiAgLy8uIGBjaGFpbiAoZikgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG9cbiAgLy8uIGBQYWlyIChjb25jYXQgKHgpIChmc3QgKGYgKHkpKSkpIChzbmQgKGYgKHkpKSlgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jaGFpbiAobiA9PiBQYWlyIChzaG93IChuKSkgKE1hdGguc3FydCAobikpKSAoUGFpciAoJ2FiYycpICgyNTYpKVxuICAvLy4gUGFpciAoJ2FiYzI1NicpICgxNilcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBQYWlyJHByb3RvdHlwZSRjaGFpbihmKSB7XG4gICAgdmFyIG90aGVyID0gZiAodGhpcy5zbmQpO1xuICAgIHJldHVybiBQYWlyIChaLmNvbmNhdCAodGhpcy5mc3QsIG90aGVyLmZzdCkpIChvdGhlci5zbmQpO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL3JlZHVjZSA6OiBQYWlyIGEgYiB+PiAoKGMsIGIpIC0+IGMsIGMpIC0+IGNcbiAgLy8uXG4gIC8vLiBgcmVkdWNlIChmKSAoeCkgKFBhaXIgKHYpICh3KSlgIGlzIGVxdWl2YWxlbnQgdG8gYGYgKHgpICh3KWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlZHVjZSAoUy5jb25jYXQpIChbMSwgMiwgM10pIChQYWlyICgnYWJjJykgKFs0LCA1LCA2XSkpXG4gIC8vLiBbMSwgMiwgMywgNCwgNSwgNl1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBQYWlyJHByb3RvdHlwZSRyZWR1Y2UoZiwgeCkge1xuICAgIHJldHVybiBmICh4LCB0aGlzLnNuZCk7XG4gIH1cblxuICAvLyMgUGFpciNmYW50YXN5LWxhbmQvdHJhdmVyc2UgOjogQXBwbGljYXRpdmUgZiA9PiBQYWlyIGEgYiB+PiAoVHlwZVJlcCBmLCBiIC0+IGYgYykgLT4gZiAoUGFpciBhIGMpXG4gIC8vLlxuICAvLy4gYHRyYXZlcnNlIChfKSAoZikgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG9cbiAgLy8uIGBtYXAgKFBhaXIgKHgpKSAoZiAoeSkpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudHJhdmVyc2UgKEFycmF5KSAoUy53b3JkcykgKFBhaXIgKDEyMykgKCdmb28gYmFyIGJheicpKVxuICAvLy4gW1BhaXIgKDEyMykgKCdmb28nKSwgUGFpciAoMTIzKSAoJ2JhcicpLCBQYWlyICgxMjMpICgnYmF6JyldXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkdHJhdmVyc2UodHlwZVJlcCwgZikge1xuICAgIHJldHVybiBaLm1hcCAoUGFpciAodGhpcy5mc3QpLCBmICh0aGlzLnNuZCkpO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL2V4dGVuZCA6OiBQYWlyIGEgYiB+PiAoUGFpciBhIGIgLT4gYykgLT4gUGFpciBhIGNcbiAgLy8uXG4gIC8vLiBgZXh0ZW5kIChmKSAoUGFpciAoeCkgKHkpKWAgaXMgZXF1aXZhbGVudCB0b1xuICAvLy4gYFBhaXIgKHgpIChmIChQYWlyICh4KSAoeSkpKWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmV4dGVuZCAoUy5yZWR1Y2UgKFMuYWRkKSAoMSkpIChQYWlyICgnYWJjJykgKDk5KSlcbiAgLy8uIFBhaXIgKCdhYmMnKSAoMTAwKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFBhaXIkcHJvdG90eXBlJGV4dGVuZChmKSB7XG4gICAgcmV0dXJuIFBhaXIgKHRoaXMuZnN0KSAoZiAodGhpcykpO1xuICB9XG5cbiAgLy8jIFBhaXIjZmFudGFzeS1sYW5kL2V4dHJhY3QgOjogUGFpciBhIGIgfj4gKCkgLT4gYlxuICAvLy5cbiAgLy8uIGBleHRyYWN0IChQYWlyICh4KSAoeSkpYCBpcyBlcXVpdmFsZW50IHRvIGB5YC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZXh0cmFjdCAoUGFpciAoJ2FiYycpIChbMSwgMiwgM10pKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gUGFpciRwcm90b3R5cGUkZXh0cmFjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zbmQ7XG4gIH1cblxuICByZXR1cm4gUGFpcjtcblxufSkpO1xuXG4vLy4gW0ZhbnRhc3kgTGFuZF06ICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kXG4vLy4gW2BaLmVxdWFsc2BdOiAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZXF1YWxzXG4vLy4gW2BaLmx0ZWBdOiAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjbHRlXG4vLy4gW2lmZl06ICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lmX2FuZF9vbmx5X2lmXG4vLy4gW3R5cGUgaWRlbnRpZmllcl06ICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzXG4vLy4gW3R5cGUgcmVwcmVzZW50YXRpdmVdOiAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3R5cGUtcmVwcmVzZW50YXRpdmVzXG4iLCIvLy4gIyBzYW5jdHVhcnktc2hvd1xuLy8uXG4vLy4gSGFza2VsbCBoYXMgYSBgc2hvd2AgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIGFwcGxpZWQgdG8gYSBjb21wYXRpYmxlIHZhbHVlIHRvXG4vLy4gcHJvZHVjZSBhIGRlc2NyaXB0aXZlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGF0IHZhbHVlLiBUaGUgaWRlYSBpcyB0aGF0XG4vLy4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBzaG91bGQsIGlmIHBvc3NpYmxlLCBiZSBhbiBleHByZXNzaW9uIHdoaWNoIHdvdWxkXG4vLy4gcHJvZHVjZSB0aGUgb3JpZ2luYWwgdmFsdWUgaWYgZXZhbHVhdGVkLlxuLy8uXG4vLy4gVGhpcyBsaWJyYXJ5IHByb3ZpZGVzIGEgc2ltaWxhciBbYHNob3dgXSgjc2hvdykgZnVuY3Rpb24uXG4vLy5cbi8vLiBJbiBnZW5lcmFsLCB0aGlzIHByb3BlcnR5IHNob3VsZCBob2xkOiBgZXZhbCAoc2hvdyAoeCkpID0geGAuIEluIHNvbWUgY2FzZXNcbi8vLiBwYXJlbnMgYXJlIG5lY2Vzc2FyeSB0byBlbnN1cmUgY29ycmVjdCBpbnRlcnByZXRhdGlvbiAoYHt9YCwgZm9yIGV4YW1wbGUsXG4vLy4gaXMgYW4gZW1wdHkgYmxvY2sgcmF0aGVyIHRoYW4gYW4gZW1wdHkgb2JqZWN0IGluIHNvbWUgY29udGV4dHMpLiBUaHVzIHRoZVxuLy8uIHByb3BlcnR5IGlzIG1vcmUgYWNjdXJhdGVseSBzdGF0ZWQgYGV2YWwgKCcoJyArIHNob3cgKHgpICsgJyknKSA9IHhgLlxuLy8uXG4vLy4gT25lIGNhbiBtYWtlIHZhbHVlcyBvZiBhIGN1c3RvbSB0eXBlIGNvbXBhdGlibGUgd2l0aCBbYHNob3dgXSgjc2hvdykgYnlcbi8vLiBkZWZpbmluZyBhIGBAQHNob3dgIG1ldGhvZC4gRm9yIGV4YW1wbGU6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8jIE1heWJlI0BAc2hvdyA6OiBNYXliZSBhIH4+ICgpIC0+IFN0cmluZ1xuLy8uIC8vLlxuLy8uIC8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8uID4gc2hvdyAoTm90aGluZylcbi8vLiAvLy4gJ05vdGhpbmcnXG4vLy4gLy8uXG4vLy4gLy8uID4gc2hvdyAoSnVzdCAoWydmb28nLCAnYmFyJywgJ2JheiddKSlcbi8vLiAvLy4gJ0p1c3QgKFtcImZvb1wiLCBcImJhclwiLCBcImJhelwiXSknXG4vLy4gLy8uIGBgYFxuLy8uIE1heWJlLnByb3RvdHlwZVsnQEBzaG93J10gPSBmdW5jdGlvbigpIHtcbi8vLiAgIHJldHVybiB0aGlzLmlzTm90aGluZyA/ICdOb3RoaW5nJyA6ICdKdXN0ICgnICsgc2hvdyAodGhpcy52YWx1ZSkgKyAnKSc7XG4vLy4gfTtcbi8vLiBgYGBcblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgIT0gbnVsbCkge1xuICAgIGRlZmluZShbXSwgZik7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zYW5jdHVhcnlTaG93ID0gZigpO1xuICB9XG5cbn0oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vICAkJHNob3cgOjogU3RyaW5nXG4gIHZhciAkJHNob3cgPSAnQEBzaG93JztcblxuICAvLyAgc2VlbiA6OiBBcnJheSBBbnlcbiAgdmFyIHNlZW4gPSBbXTtcblxuICAvLyAgZW50cnkgOjogT2JqZWN0IC0+IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gZW50cnkobykge1xuICAgIHJldHVybiBmdW5jdGlvbihrKSB7XG4gICAgICByZXR1cm4gc2hvdyhrKSArICc6ICcgKyBzaG93KG9ba10pO1xuICAgIH07XG4gIH1cblxuICAvLyMgc2hvdyA6OiBTaG93YWJsZSBhID0+IGEgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyBhIHVzZWZ1bCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHZhbHVlLlxuICAvLy5cbiAgLy8uIERpc3BhdGNoZXMgdG8gdGhlIHZhbHVlJ3MgYEBAc2hvd2AgbWV0aG9kIGlmIHByZXNlbnQuXG4gIC8vLlxuICAvLy4gV2hlcmUgcHJhY3RpY2FsLCBgc2hvdyAoZXZhbCAoJygnICsgc2hvdyAoeCkgKyAnKScpKSA9IHNob3cgKHgpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNob3cgKG51bGwpXG4gIC8vLiAnbnVsbCdcbiAgLy8uXG4gIC8vLiA+IHNob3cgKHVuZGVmaW5lZClcbiAgLy8uICd1bmRlZmluZWQnXG4gIC8vLlxuICAvLy4gPiBzaG93ICh0cnVlKVxuICAvLy4gJ3RydWUnXG4gIC8vLlxuICAvLy4gPiBzaG93IChuZXcgQm9vbGVhbiAoZmFsc2UpKVxuICAvLy4gJ25ldyBCb29sZWFuIChmYWxzZSknXG4gIC8vLlxuICAvLy4gPiBzaG93ICgtMClcbiAgLy8uICctMCdcbiAgLy8uXG4gIC8vLiA+IHNob3cgKE5hTilcbiAgLy8uICdOYU4nXG4gIC8vLlxuICAvLy4gPiBzaG93IChuZXcgTnVtYmVyIChJbmZpbml0eSkpXG4gIC8vLiAnbmV3IE51bWJlciAoSW5maW5pdHkpJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAoJ2Zvb1xcblwiYmFyXCJcXG5iYXpcXG4nKVxuICAvLy4gJ1wiZm9vXFxcXG5cXFxcXCJiYXJcXFxcXCJcXFxcbmJhelxcXFxuXCInXG4gIC8vLlxuICAvLy4gPiBzaG93IChuZXcgU3RyaW5nICgnJykpXG4gIC8vLiAnbmV3IFN0cmluZyAoXCJcIiknXG4gIC8vLlxuICAvLy4gPiBzaG93IChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAnW1wiZm9vXCIsIFwiYmFyXCIsIFwiYmF6XCJdJ1xuICAvLy5cbiAgLy8uID4gc2hvdyAoW1tbW1swXV1dXV0pXG4gIC8vLiAnW1tbW1swXV1dXV0nXG4gIC8vLlxuICAvLy4gPiBzaG93ICh7eDogWzEsIDJdLCB5OiBbMywgNF0sIHo6IFs1LCA2XX0pXG4gIC8vLiAne1wieFwiOiBbMSwgMl0sIFwieVwiOiBbMywgNF0sIFwielwiOiBbNSwgNl19J1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNob3coeCkge1xuICAgIGlmIChzZWVuLmluZGV4T2YoeCkgPj0gMCkgcmV0dXJuICc8Q2lyY3VsYXI+JztcblxuICAgIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpKSB7XG5cbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID9cbiAgICAgICAgICAnbmV3IEJvb2xlYW4gKCcgKyBzaG93KHgudmFsdWVPZigpKSArICcpJyA6XG4gICAgICAgICAgeC50b1N0cmluZygpO1xuXG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID9cbiAgICAgICAgICAnbmV3IE51bWJlciAoJyArIHNob3coeC52YWx1ZU9mKCkpICsgJyknIDpcbiAgICAgICAgICAxIC8geCA9PT0gLUluZmluaXR5ID8gJy0wJyA6IHgudG9TdHJpbmcoMTApO1xuXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID9cbiAgICAgICAgICAnbmV3IFN0cmluZyAoJyArIHNob3coeC52YWx1ZU9mKCkpICsgJyknIDpcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh4KTtcblxuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICAgIHJldHVybiAnbmV3IERhdGUgKCcgK1xuICAgICAgICAgICAgICAgc2hvdyhpc05hTih4LnZhbHVlT2YoKSkgPyBOYU4gOiB4LnRvSVNPU3RyaW5nKCkpICtcbiAgICAgICAgICAgICAgICcpJztcblxuICAgICAgY2FzZSAnW29iamVjdCBFcnJvcl0nOlxuICAgICAgICByZXR1cm4gJ25ldyAnICsgeC5uYW1lICsgJyAoJyArIHNob3coeC5tZXNzYWdlKSArICcpJztcblxuICAgICAgY2FzZSAnW29iamVjdCBBcmd1bWVudHNdJzpcbiAgICAgICAgcmV0dXJuICdmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0gKCcgK1xuICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKHgsIHNob3cpLmpvaW4oJywgJykgK1xuICAgICAgICAgICAgICAgJyknO1xuXG4gICAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICAgIHNlZW4ucHVzaCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gJ1snICsgeC5tYXAoc2hvdykuY29uY2F0KFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoeClcbiAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oaykgeyByZXR1cm4gIS9eXFxkKyQvLnRlc3Qoayk7IH0pXG4gICAgICAgICAgICAubWFwKGVudHJ5KHgpKVxuICAgICAgICAgICkuam9pbignLCAnKSArICddJztcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZWVuLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6XG4gICAgICAgIHNlZW4ucHVzaCh4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJCRzaG93IGluIHggJiZcbiAgICAgICAgICAgICh4LmNvbnN0cnVjdG9yID09IG51bGwgfHwgeC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgIT09IHgpID9cbiAgICAgICAgICAgICAgeFskJHNob3ddKCkgOlxuICAgICAgICAgICAgICAneycgKyBPYmplY3Qua2V5cyh4KS5zb3J0KCkubWFwKGVudHJ5KHgpKS5qb2luKCcsICcpICsgJ30nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZWVuLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBTdHJpbmcoeCk7XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2hvdztcblxufSkpO1xuIiwiLypcbiAgICAgICAgICAgICAjIyMjIyMjIyMjIyMgICAgICAgICAgICAgICAgICAjXG4gICAgICAgICAgICAjIyMjIyMjIyMjIyMgICAgICAgICAgICAgICAgICAjIyNcbiAgICAgICAgICAgICAgICAgICMjIyMjICAgICAgICAgICAgICAgICAgIyMjIyNcbiAgICAgICAgICAgICAgICAjIyMjIyAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjXG4gICAgICAgICAgICAgICMjIyMjICAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAgICAgICAgICMjIyMjICAgICAgICAgICAgICAgICAgICAgIyMjIyMjIyMjIyNcbiAgICAgICAgICAjIyMjIyAgICAgICAgICMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAgICAgIyMjIyMgICAgICAgICAgIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiAgICAgICMjIyMjICAgICAgICAgICAgICAgICAgICAgICAgIyMjIyNcbiAgICAgIyMjIyMjIyMjIyMjICAgICAgICAgICAgICAgICAjIyNcbiAgICAjIyMjIyMjIyMjIyMgICAgICAgICAgICAgICAgICovXG5cbi8vLiAjIHNhbmN0dWFyeS10eXBlLWNsYXNzZXNcbi8vLlxuLy8uIFRoZSBbRmFudGFzeSBMYW5kIFNwZWNpZmljYXRpb25dW0ZMXSBcInNwZWNpZmllcyBpbnRlcm9wZXJhYmlsaXR5IG9mIGNvbW1vblxuLy8uIGFsZ2VicmFpYyBzdHJ1Y3R1cmVzXCIgYnkgZGVmaW5pbmcgYSBudW1iZXIgb2YgdHlwZSBjbGFzc2VzLiBGb3IgZWFjaCB0eXBlXG4vLy4gY2xhc3MsIGl0IHN0YXRlcyBsYXdzIHdoaWNoIGV2ZXJ5IG1lbWJlciBvZiBhIHR5cGUgbXVzdCBvYmV5IGluIG9yZGVyIGZvclxuLy8uIHRoZSB0eXBlIHRvIGJlIGEgbWVtYmVyIG9mIHRoZSB0eXBlIGNsYXNzLiBJbiBvcmRlciBmb3IgdGhlIE1heWJlIHR5cGUgdG9cbi8vLiBiZSBjb25zaWRlcmVkIGEgW0Z1bmN0b3JdW10sIGZvciBleGFtcGxlLCBldmVyeSBgTWF5YmUgYWAgdmFsdWUgbXVzdCBoYXZlXG4vLy4gYSBgZmFudGFzeS1sYW5kL21hcGAgbWV0aG9kIHdoaWNoIG9iZXlzIHRoZSBpZGVudGl0eSBhbmQgY29tcG9zaXRpb24gbGF3cy5cbi8vLlxuLy8uIFRoaXMgcHJvamVjdCBwcm92aWRlczpcbi8vLlxuLy8uICAgLSBbYFR5cGVDbGFzc2BdKCNUeXBlQ2xhc3MpLCBhIGZ1bmN0aW9uIGZvciBkZWZpbmluZyB0eXBlIGNsYXNzZXM7XG4vLy4gICAtIG9uZSBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgZWFjaCBGYW50YXN5IExhbmQgdHlwZSBjbGFzcztcbi8vLiAgIC0gbGF3ZnVsIEZhbnRhc3kgTGFuZCBtZXRob2RzIGZvciBKYXZhU2NyaXB0J3MgYnVpbHQtaW4gdHlwZXM7XG4vLy4gICAtIG9uZSBmdW5jdGlvbiBmb3IgZWFjaCBGYW50YXN5IExhbmQgbWV0aG9kOyBhbmRcbi8vLiAgIC0gc2V2ZXJhbCBmdW5jdGlvbnMgZGVyaXZlZCBmcm9tIHRoZXNlIGZ1bmN0aW9ucy5cbi8vLlxuLy8uICMjIFR5cGUtY2xhc3MgaGllcmFyY2h5XG4vLy5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbi8vLiA8cHJlPlxuLy8uICBTZXRvaWQgICBTZW1pZ3JvdXBvaWQgIFNlbWlncm91cCAgIEZvbGRhYmxlICAgICAgICBGdW5jdG9yICAgICAgQ29udHJhdmFyaWFudCAgRmlsdGVyYWJsZVxuLy8uIChlcXVhbHMpICAgIChjb21wb3NlKSAgICAoY29uY2F0KSAgIChyZWR1Y2UpICAgICAgICAgKG1hcCkgICAgICAgIChjb250cmFtYXApICAgIChmaWx0ZXIpXG4vLy4gICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIFxcICAgICAgICAgLyB8IHwgfCB8IFxcXG4vLy4gICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICBcXCAgICAgICAvICB8IHwgfCB8ICBcXFxuLy8uICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgIFxcICAgICAvICAgfCB8IHwgfCAgIFxcXG4vLy4gICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgIFxcICAgLyAgICB8IHwgfCB8ICAgIFxcXG4vLy4gICAgIHwgICAgICAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICBcXCAvICAgICB8IHwgfCB8ICAgICBcXFxuLy8uICAgIE9yZCAgICAgIENhdGVnb3J5ICAgICBNb25vaWQgICAgICAgICBUcmF2ZXJzYWJsZSB8IHwgfCB8ICAgICAgXFxcbi8vLiAgIChsdGUpICAgICAgIChpZCkgICAgICAgKGVtcHR5KSAgICAgICAgKHRyYXZlcnNlKSAgLyB8IHwgXFwgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAvICB8IHwgIFxcICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAvICAgLyBcXCAgIFxcICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgUHJvZnVuY3RvciAvICAgXFwgQmlmdW5jdG9yIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIChwcm9tYXApIC8gICAgIFxcIChiaW1hcCkgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICBHcm91cCAgICAgICAgICAgICAgICAgICAvICAgICAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgIChpbnZlcnQpICAgICAgICAgICAgICAgQWx0ICAgICAgICBBcHBseSAgICAgIEV4dGVuZFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFsdCkgICAgICAgIChhcCkgICAgIChleHRlbmQpXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgLyBcXCAgICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICBcXCAgICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgLyAgICAgXFwgICAgICAgICAgIFxcXG4vLy4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgICAgICAgICAgLyAgICAgICBcXCAgICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gICAgICAgICAgIC8gICAgICAgICBcXCAgICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQbHVzICAgIEFwcGxpY2F0aXZlICAgIENoYWluICAgICAgQ29tb25hZFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHplcm8pICAgICAgIChvZikgICAgICAoY2hhaW4pICAgIChleHRyYWN0KVxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwgICAgICAgICAvIFxcICAgICAgICAgLyBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcICAgICAgIC8gICBcXCAgICAgICAvICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwgICAgIC8gICAgIFxcICAgICAvICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwgICAvICAgICAgIFxcICAgLyAgICAgICBcXFxuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcIC8gICAgICAgICBcXCAvICAgICAgICAgXFxcbi8vLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFsdGVybmF0aXZlICAgIE1vbmFkICAgICBDaGFpblJlY1xuLy8uICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoYWluUmVjKVxuLy8uIDwvcHJlPlxuLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4vLy5cbi8vLiAjIyBBUElcblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYocmVxdWlyZSgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUoWydzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycyddLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBzZWxmLnNhbmN0dWFyeVR5cGVDbGFzc2VzID0gZihzZWxmLnNhbmN0dWFyeVR5cGVJZGVudGlmaWVycyk7XG4gIH1cblxufShmdW5jdGlvbih0eXBlKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIF9fZG9jdGVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvKiBnbG9iYWwgX19kb2N0ZXN0OmZhbHNlICovXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgICB2YXIgSWRlbnRpdHkgPSBfX2RvY3Rlc3QucmVxdWlyZSgnLi90ZXN0L0lkZW50aXR5Jyk7XG4gICAgdmFyIExpc3QgPSBfX2RvY3Rlc3QucmVxdWlyZSgnLi90ZXN0L0xpc3QnKTtcbiAgICB2YXIgTWF5YmUgPSBfX2RvY3Rlc3QucmVxdWlyZSgnLi90ZXN0L01heWJlJyk7XG4gICAgdmFyIFN1bSA9IF9fZG9jdGVzdC5yZXF1aXJlKCcuL3Rlc3QvU3VtJyk7XG4gICAgdmFyIFR1cGxlID0gX19kb2N0ZXN0LnJlcXVpcmUoJy4vdGVzdC9UdXBsZScpO1xuXG4gICAgdmFyIE5pbCA9IExpc3QuTmlsLCBDb25zID0gTGlzdC5Db25zO1xuICAgIHZhciBOb3RoaW5nID0gTWF5YmUuTm90aGluZywgSnVzdCA9IE1heWJlLkp1c3Q7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICB9XG5cbiAgLy8gIGNvbmNhdF8gOjogQXJyYXkgYSAtPiBBcnJheSBhIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gY29uY2F0Xyh4cykge1xuICAgIHJldHVybiBmdW5jdGlvbih5cykge1xuICAgICAgcmV0dXJuIHhzLmNvbmNhdCh5cyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBjb25zdGFudCA6OiBhIC0+IGIgLT4gYVxuICBmdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gIH1cblxuICAvLyAgZm9yRWFjaEtleSA6OiAoU3RyTWFwIGEsIFN0ck1hcCBhIH4+IFN0cmluZyAtPiBVbmRlZmluZWQpIC0+IFVuZGVmaW5lZFxuICBmdW5jdGlvbiBmb3JFYWNoS2V5KHN0ck1hcCwgZikge1xuICAgIE9iamVjdC5rZXlzKHN0ck1hcCkuZm9yRWFjaChmLCBzdHJNYXApO1xuICB9XG5cbiAgLy8gIGhhcyA6OiAoU3RyaW5nLCBPYmplY3QpIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gaGFzKGssIG8pIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIGspO1xuICB9XG5cbiAgLy8gIGlkZW50aXR5IDo6IGEgLT4gYVxuICBmdW5jdGlvbiBpZGVudGl0eSh4KSB7IHJldHVybiB4OyB9XG5cbiAgLy8gIHBhaXIgOjogYSAtPiBiIC0+IEFycmF5MiBhIGJcbiAgZnVuY3Rpb24gcGFpcih4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfTtcbiAgfVxuXG4gIC8vICBzYW1lVHlwZSA6OiAoYSwgYikgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBzYW1lVHlwZSh4LCB5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSB0eXBlb2YgeSAmJiB0eXBlKHgpID09PSB0eXBlKHkpO1xuICB9XG5cbiAgLy8gIHRocnVzaCA6OiBhIC0+IChhIC0+IGIpIC0+IGJcbiAgZnVuY3Rpb24gdGhydXNoKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZikge1xuICAgICAgcmV0dXJuIGYoeCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICB0eXBlIEl0ZXJhdGlvbiBhID0geyB2YWx1ZSA6OiBhLCBkb25lIDo6IEJvb2xlYW4gfVxuXG4gIC8vICBpdGVyYXRpb25OZXh0IDo6IGEgLT4gSXRlcmF0aW9uIGFcbiAgZnVuY3Rpb24gaXRlcmF0aW9uTmV4dCh4KSB7IHJldHVybiB7dmFsdWU6IHgsIGRvbmU6IGZhbHNlfTsgfVxuXG4gIC8vICBpdGVyYXRpb25Eb25lIDo6IGEgLT4gSXRlcmF0aW9uIGFcbiAgZnVuY3Rpb24gaXRlcmF0aW9uRG9uZSh4KSB7IHJldHVybiB7dmFsdWU6IHgsIGRvbmU6IHRydWV9OyB9XG5cbiAgLy8jIFR5cGVDbGFzcyA6OiAoU3RyaW5nLCBTdHJpbmcsIEFycmF5IFR5cGVDbGFzcywgYSAtPiBCb29sZWFuKSAtPiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBUaGUgYXJndW1lbnRzIGFyZTpcbiAgLy8uXG4gIC8vLiAgIC0gdGhlIG5hbWUgb2YgdGhlIHR5cGUgY2xhc3MsIHByZWZpeGVkIGJ5IGl0cyBucG0gcGFja2FnZSBuYW1lO1xuICAvLy4gICAtIHRoZSBkb2N1bWVudGF0aW9uIFVSTCBvZiB0aGUgdHlwZSBjbGFzcztcbiAgLy8uICAgLSBhbiBhcnJheSBvZiBkZXBlbmRlbmNpZXM7IGFuZFxuICAvLy4gICAtIGEgcHJlZGljYXRlIHdoaWNoIGFjY2VwdHMgYW55IEphdmFTY3JpcHQgdmFsdWUgYW5kIHJldHVybnMgYHRydWVgXG4gIC8vLiAgICAgaWYgdGhlIHZhbHVlIHNhdGlzZmllcyB0aGUgcmVxdWlyZW1lbnRzIG9mIHRoZSB0eXBlIGNsYXNzOyBgZmFsc2VgXG4gIC8vLiAgICAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIEV4YW1wbGU6XG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gLy8gICAgaGFzTWV0aG9kIDo6IFN0cmluZyAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uIGNvbnN0IGhhc01ldGhvZCA9IG5hbWUgPT4geCA9PiB4ICE9IG51bGwgJiYgdHlwZW9mIHhbbmFtZV0gPT0gJ2Z1bmN0aW9uJztcbiAgLy8uXG4gIC8vLiAvLyAgICBGb28gOjogVHlwZUNsYXNzXG4gIC8vLiBjb25zdCBGb28gPSBaLlR5cGVDbGFzcyhcbiAgLy8uICAgJ215LXBhY2thZ2UvRm9vJyxcbiAgLy8uICAgJ2h0dHA6Ly9leGFtcGxlLmNvbS9teS1wYWNrYWdlI0ZvbycsXG4gIC8vLiAgIFtdLFxuICAvLy4gICBoYXNNZXRob2QoJ2ZvbycpXG4gIC8vLiApO1xuICAvLy5cbiAgLy8uIC8vICAgIEJhciA6OiBUeXBlQ2xhc3NcbiAgLy8uIGNvbnN0IEJhciA9IFouVHlwZUNsYXNzKFxuICAvLy4gICAnbXktcGFja2FnZS9CYXInLFxuICAvLy4gICAnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjQmFyJyxcbiAgLy8uICAgW0Zvb10sXG4gIC8vLiAgIGhhc01ldGhvZCgnYmFyJylcbiAgLy8uICk7XG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBUeXBlcyB3aG9zZSB2YWx1ZXMgaGF2ZSBhIGBmb29gIG1ldGhvZCBhcmUgbWVtYmVycyBvZiB0aGUgRm9vIHR5cGUgY2xhc3MuXG4gIC8vLiBNZW1iZXJzIG9mIHRoZSBGb28gdHlwZSBjbGFzcyB3aG9zZSB2YWx1ZXMgaGF2ZSBhIGBiYXJgIG1ldGhvZCBhcmUgYWxzb1xuICAvLy4gbWVtYmVycyBvZiB0aGUgQmFyIHR5cGUgY2xhc3MuXG4gIC8vLlxuICAvLy4gRWFjaCBgVHlwZUNsYXNzYCB2YWx1ZSBoYXMgYSBgdGVzdGAgZmllbGQ6IGEgZnVuY3Rpb24gd2hpY2ggYWNjZXB0c1xuICAvLy4gYW55IEphdmFTY3JpcHQgdmFsdWUgYW5kIHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBzYXRpc2ZpZXMgdGhlXG4gIC8vLiB0eXBlIGNsYXNzJ3MgcHJlZGljYXRlIGFuZCB0aGUgcHJlZGljYXRlcyBvZiBhbGwgdGhlIHR5cGUgY2xhc3Mnc1xuICAvLy4gZGVwZW5kZW5jaWVzOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZXMgbWF5IGJlIHVzZWQgd2l0aCBbc2FuY3R1YXJ5LWRlZl1bdHlwZS1jbGFzc2VzXVxuICAvLy4gdG8gZGVmaW5lIHBhcmFtZXRyaWNhbGx5IHBvbHltb3JwaGljIGZ1bmN0aW9ucyB3aGljaCB2ZXJpZnkgdGhlaXJcbiAgLy8uIHR5cGUtY2xhc3MgY29uc3RyYWludHMgYXQgcnVuIHRpbWUuXG4gIGZ1bmN0aW9uIFR5cGVDbGFzcyhuYW1lLCB1cmwsIGRlcGVuZGVuY2llcywgdGVzdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUeXBlQ2xhc3MpKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVDbGFzcyhuYW1lLCB1cmwsIGRlcGVuZGVuY2llcywgdGVzdCk7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy50ZXN0ID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGRlcGVuZGVuY2llcy5ldmVyeShmdW5jdGlvbihkKSB7IHJldHVybiBkLnRlc3QoeCk7IH0pICYmIHRlc3QoeCk7XG4gICAgfTtcbiAgfVxuXG4gIFR5cGVDbGFzc1snQEB0eXBlJ10gPSAnc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy9UeXBlQ2xhc3MnO1xuXG4gIC8vICBkYXRhIExvY2F0aW9uID0gQ29uc3RydWN0b3IgfCBWYWx1ZVxuXG4gIC8vICBDb25zdHJ1Y3RvciA6OiBMb2NhdGlvblxuICB2YXIgQ29uc3RydWN0b3IgPSAnQ29uc3RydWN0b3InO1xuXG4gIC8vICBWYWx1ZSA6OiBMb2NhdGlvblxuICB2YXIgVmFsdWUgPSAnVmFsdWUnO1xuXG4gIC8vICBfZnVuY1BhdGggOjogKEJvb2xlYW4sIEFycmF5IFN0cmluZywgYSkgLT4gTnVsbGFibGUgRnVuY3Rpb25cbiAgZnVuY3Rpb24gX2Z1bmNQYXRoKGFsbG93SW5oZXJpdGVkUHJvcHMsIHBhdGgsIF94KSB7XG4gICAgdmFyIHggPSBfeDtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBwYXRoLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIHZhciBrID0gcGF0aFtpZHhdO1xuICAgICAgaWYgKHggPT0gbnVsbCB8fCAhKGFsbG93SW5oZXJpdGVkUHJvcHMgfHwgaGFzKGssIHgpKSkgcmV0dXJuIG51bGw7XG4gICAgICB4ID0geFtrXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nID8geCA6IG51bGw7XG4gIH1cblxuICAvLyAgZnVuY1BhdGggOjogKEFycmF5IFN0cmluZywgYSkgLT4gTnVsbGFibGUgRnVuY3Rpb25cbiAgZnVuY3Rpb24gZnVuY1BhdGgocGF0aCwgeCkge1xuICAgIHJldHVybiBfZnVuY1BhdGgodHJ1ZSwgcGF0aCwgeCk7XG4gIH1cblxuICAvLyAgaW1wbFBhdGggOjogQXJyYXkgU3RyaW5nIC0+IE51bGxhYmxlIEZ1bmN0aW9uXG4gIGZ1bmN0aW9uIGltcGxQYXRoKHBhdGgpIHtcbiAgICByZXR1cm4gX2Z1bmNQYXRoKGZhbHNlLCBwYXRoLCBpbXBsZW1lbnRhdGlvbnMpO1xuICB9XG5cbiAgLy8gIGZ1bmN0aW9uTmFtZSA6OiBGdW5jdGlvbiAtPiBTdHJpbmdcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGhhcygnbmFtZScsIGZ1bmN0aW9uIGYoKSB7fSkgP1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uTmFtZShmKSB7IHJldHVybiBmLm5hbWU7IH0gOlxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25OYW1lKGYpIHtcbiAgICAgIHZhciBtYXRjaCA9IC9mdW5jdGlvbiAoXFx3KikvLmV4ZWMoZik7XG4gICAgICByZXR1cm4gbWF0Y2ggPT0gbnVsbCA/ICcnIDogbWF0Y2hbMV07XG4gICAgfTtcblxuICAvLyAgJCA6OiAoU3RyaW5nLCBBcnJheSBUeXBlQ2xhc3MsIFN0ck1hcCAoQXJyYXkgTG9jYXRpb24pKSAtPiBUeXBlQ2xhc3NcbiAgZnVuY3Rpb24gJChfbmFtZSwgZGVwZW5kZW5jaWVzLCByZXF1aXJlbWVudHMpIHtcbiAgICBmdW5jdGlvbiBnZXRCb3VuZE1ldGhvZChfbmFtZSkge1xuICAgICAgdmFyIG5hbWUgPSAnZmFudGFzeS1sYW5kLycgKyBfbmFtZTtcbiAgICAgIHJldHVybiByZXF1aXJlbWVudHNbX25hbWVdID09PSBDb25zdHJ1Y3RvciA/XG4gICAgICAgIGZ1bmN0aW9uKHR5cGVSZXApIHtcbiAgICAgICAgICB2YXIgZiA9IGZ1bmNQYXRoKFtuYW1lXSwgdHlwZVJlcCk7XG4gICAgICAgICAgcmV0dXJuIGYgPT0gbnVsbCAmJiB0eXBlb2YgdHlwZVJlcCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICBpbXBsUGF0aChbZnVuY3Rpb25OYW1lKHR5cGVSZXApLCBuYW1lXSkgOlxuICAgICAgICAgICAgZjtcbiAgICAgICAgfSA6XG4gICAgICAgIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2YXIgaXNQcm90b3R5cGUgPSB4ICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0geDtcbiAgICAgICAgICB2YXIgbSA9IG51bGw7XG4gICAgICAgICAgaWYgKCFpc1Byb3RvdHlwZSkgbSA9IGZ1bmNQYXRoKFtuYW1lXSwgeCk7XG4gICAgICAgICAgaWYgKG0gPT0gbnVsbCkgICAgbSA9IGltcGxQYXRoKFt0eXBlKHgpLCAncHJvdG90eXBlJywgbmFtZV0pO1xuICAgICAgICAgIHJldHVybiBtICYmIG0uYmluZCh4KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgdmVyc2lvbiA9ICc5LjAuMCc7ICAvLyB1cGRhdGVkIHByb2dyYW1tYXRpY2FsbHlcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlcXVpcmVtZW50cyk7XG5cbiAgICB2YXIgdHlwZUNsYXNzID0gVHlwZUNsYXNzKFxuICAgICAgJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMvJyArIF9uYW1lLFxuICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9zYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlcy90cmVlL3YnICsgdmVyc2lvblxuICAgICAgICArICcjJyArIF9uYW1lLFxuICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4ga2V5cy5ldmVyeShmdW5jdGlvbihfbmFtZSkge1xuICAgICAgICAgIHZhciBhcmcgPSByZXF1aXJlbWVudHNbX25hbWVdID09PSBDb25zdHJ1Y3RvciA/IHguY29uc3RydWN0b3IgOiB4O1xuICAgICAgICAgIHJldHVybiBnZXRCb3VuZE1ldGhvZChfbmFtZSkoYXJnKSAhPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgdHlwZUNsYXNzLm1ldGhvZHMgPSBrZXlzLnJlZHVjZShmdW5jdGlvbihtZXRob2RzLCBfbmFtZSkge1xuICAgICAgbWV0aG9kc1tfbmFtZV0gPSBnZXRCb3VuZE1ldGhvZChfbmFtZSk7XG4gICAgICByZXR1cm4gbWV0aG9kcztcbiAgICB9LCB7fSk7XG5cbiAgICByZXR1cm4gdHlwZUNsYXNzO1xuICB9XG5cbiAgLy8jIFNldG9pZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW1NldG9pZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFNldG9pZC50ZXN0KG51bGwpXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgdmFyIFNldG9pZCA9ICQoJ1NldG9pZCcsIFtdLCB7ZXF1YWxzOiBWYWx1ZX0pO1xuXG4gIC8vIyBPcmQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtPcmRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBPcmQudGVzdCgwKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gT3JkLnRlc3QoTWF0aC5zcXJ0KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgT3JkID0gJCgnT3JkJywgW1NldG9pZF0sIHtsdGU6IFZhbHVlfSk7XG5cbiAgLy8jIFNlbWlncm91cG9pZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW1NlbWlncm91cG9pZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFNlbWlncm91cG9pZC50ZXN0KE1hdGguc3FydClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFNlbWlncm91cG9pZC50ZXN0KDApXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBTZW1pZ3JvdXBvaWQgPSAkKCdTZW1pZ3JvdXBvaWQnLCBbXSwge2NvbXBvc2U6IFZhbHVlfSk7XG5cbiAgLy8jIENhdGVnb3J5IDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQ2F0ZWdvcnldW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBDYXRlZ29yeS50ZXN0KE1hdGguc3FydClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IENhdGVnb3J5LnRlc3QoMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIENhdGVnb3J5ID0gJCgnQ2F0ZWdvcnknLCBbU2VtaWdyb3Vwb2lkXSwge2lkOiBDb25zdHJ1Y3Rvcn0pO1xuXG4gIC8vIyBTZW1pZ3JvdXAgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtTZW1pZ3JvdXBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTZW1pZ3JvdXAudGVzdCgnJylcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFNlbWlncm91cC50ZXN0KDApXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBTZW1pZ3JvdXAgPSAkKCdTZW1pZ3JvdXAnLCBbXSwge2NvbmNhdDogVmFsdWV9KTtcblxuICAvLyMgTW9ub2lkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbTW9ub2lkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gTW9ub2lkLnRlc3QoJycpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBNb25vaWQudGVzdCgwKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgTW9ub2lkID0gJCgnTW9ub2lkJywgW1NlbWlncm91cF0sIHtlbXB0eTogQ29uc3RydWN0b3J9KTtcblxuICAvLyMgR3JvdXAgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtHcm91cF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEdyb3VwLnRlc3QoU3VtKDApKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gR3JvdXAudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEdyb3VwID0gJCgnR3JvdXAnLCBbTW9ub2lkXSwge2ludmVydDogVmFsdWV9KTtcblxuICAvLyMgRmlsdGVyYWJsZSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0ZpbHRlcmFibGVdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBGaWx0ZXJhYmxlLnRlc3Qoe30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBGaWx0ZXJhYmxlLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBGaWx0ZXJhYmxlID0gJCgnRmlsdGVyYWJsZScsIFtdLCB7ZmlsdGVyOiBWYWx1ZX0pO1xuXG4gIC8vIyBGdW5jdG9yIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbRnVuY3Rvcl1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEZ1bmN0b3IudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEZ1bmN0b3IudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEZ1bmN0b3IgPSAkKCdGdW5jdG9yJywgW10sIHttYXA6IFZhbHVlfSk7XG5cbiAgLy8jIEJpZnVuY3RvciA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0JpZnVuY3Rvcl1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEJpZnVuY3Rvci50ZXN0KFR1cGxlKCdmb28nLCA2NCkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBCaWZ1bmN0b3IudGVzdChbXSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEJpZnVuY3RvciA9ICQoJ0JpZnVuY3RvcicsIFtGdW5jdG9yXSwge2JpbWFwOiBWYWx1ZX0pO1xuXG4gIC8vIyBQcm9mdW5jdG9yIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbUHJvZnVuY3Rvcl1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFByb2Z1bmN0b3IudGVzdChNYXRoLnNxcnQpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBQcm9mdW5jdG9yLnRlc3QoW10pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBQcm9mdW5jdG9yID0gJCgnUHJvZnVuY3RvcicsIFtGdW5jdG9yXSwge3Byb21hcDogVmFsdWV9KTtcblxuICAvLyMgQXBwbHkgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtBcHBseV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEFwcGx5LnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBBcHBseS50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQXBwbHkgPSAkKCdBcHBseScsIFtGdW5jdG9yXSwge2FwOiBWYWx1ZX0pO1xuXG4gIC8vIyBBcHBsaWNhdGl2ZSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0FwcGxpY2F0aXZlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQXBwbGljYXRpdmUudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEFwcGxpY2F0aXZlLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBBcHBsaWNhdGl2ZSA9ICQoJ0FwcGxpY2F0aXZlJywgW0FwcGx5XSwge29mOiBDb25zdHJ1Y3Rvcn0pO1xuXG4gIC8vIyBDaGFpbiA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0NoYWluXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ2hhaW4udGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IENoYWluLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBDaGFpbiA9ICQoJ0NoYWluJywgW0FwcGx5XSwge2NoYWluOiBWYWx1ZX0pO1xuXG4gIC8vIyBDaGFpblJlYyA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW0NoYWluUmVjXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQ2hhaW5SZWMudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IENoYWluUmVjLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBDaGFpblJlYyA9ICQoJ0NoYWluUmVjJywgW0NoYWluXSwge2NoYWluUmVjOiBDb25zdHJ1Y3Rvcn0pO1xuXG4gIC8vIyBNb25hZCA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW01vbmFkXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gTW9uYWQudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IE1vbmFkLnRlc3Qoe30pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBNb25hZCA9ICQoJ01vbmFkJywgW0FwcGxpY2F0aXZlLCBDaGFpbl0sIHt9KTtcblxuICAvLyMgQWx0IDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQWx0XVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gQWx0LnRlc3Qoe30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBBbHQudGVzdCgnJylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIEFsdCA9ICQoJ0FsdCcsIFtGdW5jdG9yXSwge2FsdDogVmFsdWV9KTtcblxuICAvLyMgUGx1cyA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW1BsdXNdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBQbHVzLnRlc3Qoe30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBQbHVzLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBQbHVzID0gJCgnUGx1cycsIFtBbHRdLCB7emVybzogQ29uc3RydWN0b3J9KTtcblxuICAvLyMgQWx0ZXJuYXRpdmUgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtBbHRlcm5hdGl2ZV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEFsdGVybmF0aXZlLnRlc3QoW10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBBbHRlcm5hdGl2ZS50ZXN0KHt9KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgQWx0ZXJuYXRpdmUgPSAkKCdBbHRlcm5hdGl2ZScsIFtBcHBsaWNhdGl2ZSwgUGx1c10sIHt9KTtcblxuICAvLyMgRm9sZGFibGUgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtGb2xkYWJsZV1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IEZvbGRhYmxlLnRlc3Qoe30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBGb2xkYWJsZS50ZXN0KCcnKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgRm9sZGFibGUgPSAkKCdGb2xkYWJsZScsIFtdLCB7cmVkdWNlOiBWYWx1ZX0pO1xuXG4gIC8vIyBUcmF2ZXJzYWJsZSA6OiBUeXBlQ2xhc3NcbiAgLy8uXG4gIC8vLiBgVHlwZUNsYXNzYCB2YWx1ZSBmb3IgW1RyYXZlcnNhYmxlXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gVHJhdmVyc2FibGUudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFRyYXZlcnNhYmxlLnRlc3QoJycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBUcmF2ZXJzYWJsZSA9ICQoJ1RyYXZlcnNhYmxlJywgW0Z1bmN0b3IsIEZvbGRhYmxlXSwge3RyYXZlcnNlOiBWYWx1ZX0pO1xuXG4gIC8vIyBFeHRlbmQgOjogVHlwZUNsYXNzXG4gIC8vLlxuICAvLy4gYFR5cGVDbGFzc2AgdmFsdWUgZm9yIFtFeHRlbmRdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBFeHRlbmQudGVzdChbXSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IEV4dGVuZC50ZXN0KHt9KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICB2YXIgRXh0ZW5kID0gJCgnRXh0ZW5kJywgW0Z1bmN0b3JdLCB7ZXh0ZW5kOiBWYWx1ZX0pO1xuXG4gIC8vIyBDb21vbmFkIDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQ29tb25hZF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IENvbW9uYWQudGVzdChJZGVudGl0eSgwKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IENvbW9uYWQudGVzdChbXSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIENvbW9uYWQgPSAkKCdDb21vbmFkJywgW0V4dGVuZF0sIHtleHRyYWN0OiBWYWx1ZX0pO1xuXG4gIC8vIyBDb250cmF2YXJpYW50IDo6IFR5cGVDbGFzc1xuICAvLy5cbiAgLy8uIGBUeXBlQ2xhc3NgIHZhbHVlIGZvciBbQ29udHJhdmFyaWFudF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IENvbnRyYXZhcmlhbnQudGVzdChNYXRoLnNxcnQpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBDb250cmF2YXJpYW50LnRlc3QoW10pXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBDb250cmF2YXJpYW50ID0gJCgnQ29udHJhdmFyaWFudCcsIFtdLCB7Y29udHJhbWFwOiBWYWx1ZX0pO1xuXG4gIC8vICBOdWxsJHByb3RvdHlwZSRlcXVhbHMgOjogTnVsbCB+PiBOdWxsIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gTnVsbCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAgTnVsbCRwcm90b3R5cGUkbHRlIDo6IE51bGwgfj4gTnVsbCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE51bGwkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIFVuZGVmaW5lZCRwcm90b3R5cGUkZXF1YWxzIDo6IFVuZGVmaW5lZCB+PiBVbmRlZmluZWQgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBVbmRlZmluZWQkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIFVuZGVmaW5lZCRwcm90b3R5cGUkbHRlIDo6IFVuZGVmaW5lZCB+PiBVbmRlZmluZWQgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBVbmRlZmluZWQkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gIEJvb2xlYW4kcHJvdG90eXBlJGVxdWFscyA6OiBCb29sZWFuIH4+IEJvb2xlYW4gLT4gQm9vbGVhblxuICBmdW5jdGlvbiBCb29sZWFuJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnID9cbiAgICAgIGVxdWFscyh0aGlzLnZhbHVlT2YoKSwgb3RoZXIudmFsdWVPZigpKSA6XG4gICAgICB0aGlzID09PSBvdGhlcjtcbiAgfVxuXG4gIC8vICBCb29sZWFuJHByb3RvdHlwZSRsdGUgOjogQm9vbGVhbiB+PiBCb29sZWFuIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gQm9vbGVhbiRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICBsdGUodGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSkgOlxuICAgICAgdGhpcyA9PT0gZmFsc2UgfHwgb3RoZXIgPT09IHRydWU7XG4gIH1cblxuICAvLyAgTnVtYmVyJHByb3RvdHlwZSRlcXVhbHMgOjogTnVtYmVyIH4+IE51bWJlciAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIE51bWJlciRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICBlcXVhbHModGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSkgOlxuICAgICAgaXNOYU4odGhpcykgJiYgaXNOYU4ob3RoZXIpIHx8IHRoaXMgPT09IG90aGVyO1xuICB9XG5cbiAgLy8gIE51bWJlciRwcm90b3R5cGUkbHRlIDo6IE51bWJlciB+PiBOdW1iZXIgLT4gQm9vbGVhblxuICBmdW5jdGlvbiBOdW1iZXIkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcgP1xuICAgICAgbHRlKHRoaXMudmFsdWVPZigpLCBvdGhlci52YWx1ZU9mKCkpIDpcbiAgICAgIGlzTmFOKHRoaXMpIHx8IHRoaXMgPD0gb3RoZXI7XG4gIH1cblxuICAvLyAgRGF0ZSRwcm90b3R5cGUkZXF1YWxzIDo6IERhdGUgfj4gRGF0ZSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIERhdGUkcHJvdG90eXBlJGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiBlcXVhbHModGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSk7XG4gIH1cblxuICAvLyAgRGF0ZSRwcm90b3R5cGUkbHRlIDo6IERhdGUgfj4gRGF0ZSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIERhdGUkcHJvdG90eXBlJGx0ZShvdGhlcikge1xuICAgIHJldHVybiBsdGUodGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSk7XG4gIH1cblxuICAvLyAgUmVnRXhwJHByb3RvdHlwZSRlcXVhbHMgOjogUmVnRXhwIH4+IFJlZ0V4cCAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIFJlZ0V4cCRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyLnNvdXJjZSA9PT0gdGhpcy5zb3VyY2UgJiZcbiAgICAgICAgICAgb3RoZXIuZ2xvYmFsID09PSB0aGlzLmdsb2JhbCAmJlxuICAgICAgICAgICBvdGhlci5pZ25vcmVDYXNlID09PSB0aGlzLmlnbm9yZUNhc2UgJiZcbiAgICAgICAgICAgb3RoZXIubXVsdGlsaW5lID09PSB0aGlzLm11bHRpbGluZSAmJlxuICAgICAgICAgICBvdGhlci5zdGlja3kgPT09IHRoaXMuc3RpY2t5ICYmXG4gICAgICAgICAgIG90aGVyLnVuaWNvZGUgPT09IHRoaXMudW5pY29kZTtcbiAgfVxuXG4gIC8vICBTdHJpbmckZW1wdHkgOjogKCkgLT4gU3RyaW5nXG4gIGZ1bmN0aW9uIFN0cmluZyRlbXB0eSgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvLyAgU3RyaW5nJHByb3RvdHlwZSRlcXVhbHMgOjogU3RyaW5nIH4+IFN0cmluZyAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIFN0cmluZyRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICBlcXVhbHModGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSkgOlxuICAgICAgdGhpcyA9PT0gb3RoZXI7XG4gIH1cblxuICAvLyAgU3RyaW5nJHByb3RvdHlwZSRsdGUgOjogU3RyaW5nIH4+IFN0cmluZyAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIFN0cmluZyRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzID09PSAnb2JqZWN0JyA/XG4gICAgICBsdGUodGhpcy52YWx1ZU9mKCksIG90aGVyLnZhbHVlT2YoKSkgOlxuICAgICAgdGhpcyA8PSBvdGhlcjtcbiAgfVxuXG4gIC8vICBTdHJpbmckcHJvdG90eXBlJGNvbmNhdCA6OiBTdHJpbmcgfj4gU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiBTdHJpbmckcHJvdG90eXBlJGNvbmNhdChvdGhlcikge1xuICAgIHJldHVybiB0aGlzICsgb3RoZXI7XG4gIH1cblxuICAvLyAgQXJyYXkkZW1wdHkgOjogKCkgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBBcnJheSRlbXB0eSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICAvLyAgQXJyYXkkb2YgOjogYSAtPiBBcnJheSBhXG4gIGZ1bmN0aW9uIEFycmF5JG9mKHgpIHtcbiAgICByZXR1cm4gW3hdO1xuICB9XG5cbiAgLy8gIEFycmF5JGNoYWluUmVjIDo6ICgoYSAtPiBjLCBiIC0+IGMsIGEpIC0+IEFycmF5IGMsIGEpIC0+IEFycmF5IGJcbiAgZnVuY3Rpb24gQXJyYXkkY2hhaW5SZWMoZiwgeCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgbmlsID0ge307XG4gICAgdmFyIHRvZG8gPSB7aGVhZDogeCwgdGFpbDogbmlsfTtcbiAgICB3aGlsZSAodG9kbyAhPT0gbmlsKSB7XG4gICAgICB2YXIgbW9yZSA9IG5pbDtcbiAgICAgIHZhciBzdGVwcyA9IGYoaXRlcmF0aW9uTmV4dCwgaXRlcmF0aW9uRG9uZSwgdG9kby5oZWFkKTtcbiAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHN0ZXBzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgICAgdmFyIHN0ZXAgPSBzdGVwc1tpZHhdO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goc3RlcC52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9yZSA9IHtoZWFkOiBzdGVwLnZhbHVlLCB0YWlsOiBtb3JlfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG9kbyA9IHRvZG8udGFpbDtcbiAgICAgIHdoaWxlIChtb3JlICE9PSBuaWwpIHtcbiAgICAgICAgdG9kbyA9IHtoZWFkOiBtb3JlLmhlYWQsIHRhaWw6IHRvZG99O1xuICAgICAgICBtb3JlID0gbW9yZS50YWlsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIEFycmF5JHplcm8gOjogKCkgLT4gQXJyYXkgYVxuICBmdW5jdGlvbiBBcnJheSR6ZXJvKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkZXF1YWxzIDo6IEFycmF5IGEgfj4gQXJyYXkgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICBpZiAob3RoZXIubGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IHRoaXMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgaWYgKCFlcXVhbHModGhpc1tpZHhdLCBvdGhlcltpZHhdKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkbHRlIDo6IEFycmF5IGEgfj4gQXJyYXkgYSAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICBmb3IgKHZhciBpZHggPSAwOyB0cnVlOyBpZHggKz0gMSkge1xuICAgICAgaWYgKGlkeCA9PT0gdGhpcy5sZW5ndGgpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGlkeCA9PT0gb3RoZXIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIWVxdWFscyh0aGlzW2lkeF0sIG90aGVyW2lkeF0pKSByZXR1cm4gbHRlKHRoaXNbaWR4XSwgb3RoZXJbaWR4XSk7XG4gICAgfVxuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRjb25jYXQgOjogQXJyYXkgYSB+PiBBcnJheSBhIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGNvbmNhdChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbmNhdChvdGhlcik7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGZpbHRlciA6OiBBcnJheSBhIH4+IChhIC0+IEJvb2xlYW4pIC0+IEFycmF5IGFcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJGZpbHRlcihwcmVkKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHByZWQoeCk7IH0pO1xuICB9XG5cbiAgLy8gIEFycmF5JHByb3RvdHlwZSRtYXAgOjogQXJyYXkgYSB+PiAoYSAtPiBiKSAtPiBBcnJheSBiXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRtYXAoZikge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiBmKHgpOyB9KTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkYXAgOjogQXJyYXkgYSB+PiBBcnJheSAoYSAtPiBiKSAtPiBBcnJheSBiXG4gIGZ1bmN0aW9uIEFycmF5JHByb3RvdHlwZSRhcChmcykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBmcy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICBmb3IgKHZhciBpZHgyID0gMDsgaWR4MiA8IHRoaXMubGVuZ3RoOyBpZHgyICs9IDEpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goZnNbaWR4XSh0aGlzW2lkeDJdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJGNoYWluIDo6IEFycmF5IGEgfj4gKGEgLT4gQXJyYXkgYikgLT4gQXJyYXkgYlxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkY2hhaW4oZikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLmxlbmd0aDsgaWR4ICs9IDEpIHtcbiAgICAgIGZvciAodmFyIGlkeDIgPSAwLCB4cyA9IGYodGhpc1tpZHhdKTsgaWR4MiA8IHhzLmxlbmd0aDsgaWR4MiArPSAxKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHhzW2lkeDJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkYWx0IDo6IEFycmF5IGEgfj4gQXJyYXkgYSAtPiBBcnJheSBhXG4gIHZhciBBcnJheSRwcm90b3R5cGUkYWx0ID0gQXJyYXkkcHJvdG90eXBlJGNvbmNhdDtcblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJHJlZHVjZSA6OiBBcnJheSBhIH4+ICgoYiwgYSkgLT4gYiwgYikgLT4gYlxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkcmVkdWNlKGYsIGluaXRpYWwpIHtcbiAgICB2YXIgYWNjID0gaW5pdGlhbDtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLmxlbmd0aDsgaWR4ICs9IDEpIGFjYyA9IGYoYWNjLCB0aGlzW2lkeF0pO1xuICAgIHJldHVybiBhY2M7XG4gIH1cblxuICAvLyAgQXJyYXkkcHJvdG90eXBlJHRyYXZlcnNlIDo6IEFwcGxpY2F0aXZlIGYgPT4gQXJyYXkgYSB+PiAoVHlwZVJlcCBmLCBhIC0+IGYgYikgLT4gZiAoQXJyYXkgYilcbiAgZnVuY3Rpb24gQXJyYXkkcHJvdG90eXBlJHRyYXZlcnNlKHR5cGVSZXAsIGYpIHtcbiAgICB2YXIgeHMgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGdvKGlkeCwgbikge1xuICAgICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG9mKHR5cGVSZXAsIFtdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbGlmdDIocGFpciwgZih4c1tpZHhdKSwgZih4c1tpZHggKyAxXSkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZhciBtID0gTWF0aC5mbG9vcihuIC8gNCkgKiAyO1xuICAgICAgICAgIHJldHVybiBsaWZ0Mihjb25jYXRfLCBnbyhpZHgsIG0pLCBnbyhpZHggKyBtLCBuIC0gbSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5sZW5ndGggJSAyID09PSAxID9cbiAgICAgIGxpZnQyKGNvbmNhdF8sIG1hcChBcnJheSRvZiwgZih0aGlzWzBdKSksIGdvKDEsIHRoaXMubGVuZ3RoIC0gMSkpIDpcbiAgICAgIGdvKDAsIHRoaXMubGVuZ3RoKTtcbiAgfVxuXG4gIC8vICBBcnJheSRwcm90b3R5cGUkZXh0ZW5kIDo6IEFycmF5IGEgfj4gKEFycmF5IGEgLT4gYikgLT4gQXJyYXkgYlxuICBmdW5jdGlvbiBBcnJheSRwcm90b3R5cGUkZXh0ZW5kKGYpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oXywgaWR4LCB4cykgeyByZXR1cm4gZih4cy5zbGljZShpZHgpKTsgfSk7XG4gIH1cblxuICAvLyAgQXJndW1lbnRzJHByb3RvdHlwZSRlcXVhbHMgOjogQXJndW1lbnRzIH4+IEFyZ3VtZW50cyAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEFyZ3VtZW50cyRwcm90b3R5cGUkZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIEFycmF5JHByb3RvdHlwZSRlcXVhbHMuY2FsbCh0aGlzLCBvdGhlcik7XG4gIH1cblxuICAvLyAgQXJndW1lbnRzJHByb3RvdHlwZSRsdGUgOjogQXJndW1lbnRzIH4+IEFyZ3VtZW50cyAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEFyZ3VtZW50cyRwcm90b3R5cGUkbHRlKG90aGVyKSB7XG4gICAgcmV0dXJuIEFycmF5JHByb3RvdHlwZSRsdGUuY2FsbCh0aGlzLCBvdGhlcik7XG4gIH1cblxuICAvLyAgRXJyb3IkcHJvdG90eXBlJGVxdWFscyA6OiBFcnJvciB+PiBFcnJvciAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEVycm9yJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gZXF1YWxzKHRoaXMubmFtZSwgb3RoZXIubmFtZSkgJiZcbiAgICAgICAgICAgZXF1YWxzKHRoaXMubWVzc2FnZSwgb3RoZXIubWVzc2FnZSk7XG4gIH1cblxuICAvLyAgT2JqZWN0JGVtcHR5IDo6ICgpIC0+IFN0ck1hcCBhXG4gIGZ1bmN0aW9uIE9iamVjdCRlbXB0eSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvLyAgT2JqZWN0JHplcm8gOjogKCkgLT4gU3RyTWFwIGFcbiAgZnVuY3Rpb24gT2JqZWN0JHplcm8oKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkZXF1YWxzIDo6IFN0ck1hcCBhIH4+IFN0ck1hcCBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKS5zb3J0KCk7XG4gICAgcmV0dXJuIGVxdWFscyhrZXlzLCBPYmplY3Qua2V5cyhvdGhlcikuc29ydCgpKSAmJlxuICAgICAgICAgICBrZXlzLmV2ZXJ5KGZ1bmN0aW9uKGspIHsgcmV0dXJuIGVxdWFscyhzZWxmW2tdLCBvdGhlcltrXSk7IH0pO1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkbHRlIDo6IFN0ck1hcCBhIH4+IFN0ck1hcCBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gT2JqZWN0JHByb3RvdHlwZSRsdGUob3RoZXIpIHtcbiAgICB2YXIgdGhlc2VLZXlzID0gT2JqZWN0LmtleXModGhpcykuc29ydCgpO1xuICAgIHZhciBvdGhlcktleXMgPSBPYmplY3Qua2V5cyhvdGhlcikuc29ydCgpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAodGhlc2VLZXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAob3RoZXJLZXlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGsgPSB0aGVzZUtleXMuc2hpZnQoKTtcbiAgICAgIHZhciB6ID0gb3RoZXJLZXlzLnNoaWZ0KCk7XG4gICAgICBpZiAoayA8IHopIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGsgPiB6KSByZXR1cm4gZmFsc2U7XG4gICAgICBpZiAoIWVxdWFscyh0aGlzW2tdLCBvdGhlcltrXSkpIHJldHVybiBsdGUodGhpc1trXSwgb3RoZXJba10pO1xuICAgIH1cbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJGNvbmNhdCA6OiBTdHJNYXAgYSB+PiBTdHJNYXAgYSAtPiBTdHJNYXAgYVxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJGNvbmNhdChvdGhlcikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmdW5jdGlvbiBhc3NpZ24oaykgeyByZXN1bHRba10gPSB0aGlzW2tdOyB9XG4gICAgZm9yRWFjaEtleSh0aGlzLCBhc3NpZ24pO1xuICAgIGZvckVhY2hLZXkob3RoZXIsIGFzc2lnbik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJGZpbHRlciA6OiBTdHJNYXAgYSB+PiAoYSAtPiBCb29sZWFuKSAtPiBTdHJNYXAgYVxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJGZpbHRlcihwcmVkKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvckVhY2hLZXkodGhpcywgZnVuY3Rpb24oaykgeyBpZiAocHJlZCh0aGlzW2tdKSkgcmVzdWx0W2tdID0gdGhpc1trXTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJG1hcCA6OiBTdHJNYXAgYSB+PiAoYSAtPiBiKSAtPiBTdHJNYXAgYlxuICBmdW5jdGlvbiBPYmplY3QkcHJvdG90eXBlJG1hcChmKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvckVhY2hLZXkodGhpcywgZnVuY3Rpb24oaykgeyByZXN1bHRba10gPSBmKHRoaXNba10pOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkYXAgOjogU3RyTWFwIGEgfj4gU3RyTWFwIChhIC0+IGIpIC0+IFN0ck1hcCBiXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkYXAob3RoZXIpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yRWFjaEtleSh0aGlzLCBmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoaGFzKGssIG90aGVyKSkgcmVzdWx0W2tdID0gb3RoZXJba10odGhpc1trXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vICBPYmplY3QkcHJvdG90eXBlJGFsdCA6OiBTdHJNYXAgYSB+PiBTdHJNYXAgYSAtPiBTdHJNYXAgYVxuICB2YXIgT2JqZWN0JHByb3RvdHlwZSRhbHQgPSBPYmplY3QkcHJvdG90eXBlJGNvbmNhdDtcblxuICAvLyAgT2JqZWN0JHByb3RvdHlwZSRyZWR1Y2UgOjogU3RyTWFwIGEgfj4gKChiLCBhKSAtPiBiLCBiKSAtPiBiXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkcmVkdWNlKGYsIGluaXRpYWwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZnVuY3Rpb24gcmVkdWNlcihhY2MsIGspIHsgcmV0dXJuIGYoYWNjLCBzZWxmW2tdKTsgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5zb3J0KCkucmVkdWNlKHJlZHVjZXIsIGluaXRpYWwpO1xuICB9XG5cbiAgLy8gIE9iamVjdCRwcm90b3R5cGUkdHJhdmVyc2UgOjogQXBwbGljYXRpdmUgZiA9PiBTdHJNYXAgYSB+PiAoVHlwZVJlcCBmLCBhIC0+IGYgYikgLT4gZiAoU3RyTWFwIGIpXG4gIGZ1bmN0aW9uIE9iamVjdCRwcm90b3R5cGUkdHJhdmVyc2UodHlwZVJlcCwgZikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcykucmVkdWNlKGZ1bmN0aW9uKGFwcGxpY2F0aXZlLCBrKSB7XG4gICAgICBmdW5jdGlvbiBzZXQobykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgIHZhciBzaW5nbGV0b24gPSB7fTsgc2luZ2xldG9uW2tdID0gdjtcbiAgICAgICAgICByZXR1cm4gT2JqZWN0JHByb3RvdHlwZSRjb25jYXQuY2FsbChvLCBzaW5nbGV0b24pO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpZnQyKHNldCwgYXBwbGljYXRpdmUsIGYoc2VsZltrXSkpO1xuICAgIH0sIG9mKHR5cGVSZXAsIHt9KSk7XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kaWQgOjogKCkgLT4gYSAtPiBhXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJGlkKCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRvZiA6OiBiIC0+IChhIC0+IGIpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJG9mKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oXykgeyByZXR1cm4geDsgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRjaGFpblJlYyA6OiAoKGEgLT4gYywgYiAtPiBjLCBhKSAtPiAoeiAtPiBjKSwgYSkgLT4gKHogLT4gYilcbiAgZnVuY3Rpb24gRnVuY3Rpb24kY2hhaW5SZWMoZiwgeCkge1xuICAgIHJldHVybiBmdW5jdGlvbihhKSB7XG4gICAgICB2YXIgc3RlcCA9IGl0ZXJhdGlvbk5leHQoeCk7XG4gICAgICB3aGlsZSAoIXN0ZXAuZG9uZSkge1xuICAgICAgICBzdGVwID0gZihpdGVyYXRpb25OZXh0LCBpdGVyYXRpb25Eb25lLCBzdGVwLnZhbHVlKShhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGVwLnZhbHVlO1xuICAgIH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJGVxdWFscyA6OiBGdW5jdGlvbiB+PiBGdW5jdGlvbiAtPiBCb29sZWFuXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gb3RoZXIgPT09IHRoaXM7XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJGNvbXBvc2UgOjogKGEgLT4gYikgfj4gKGIgLT4gYykgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJGNvbXBvc2Uob3RoZXIpIHtcbiAgICB2YXIgc2VtaWdyb3Vwb2lkID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gb3RoZXIoc2VtaWdyb3Vwb2lkKHgpKTsgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkbWFwIDo6IChhIC0+IGIpIH4+IChiIC0+IGMpIC0+IChhIC0+IGMpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRtYXAoZikge1xuICAgIHZhciBmdW5jdG9yID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gZihmdW5jdG9yKHgpKTsgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkcHJvbWFwIDo6IChiIC0+IGMpIH4+IChhIC0+IGIsIGMgLT4gZCkgLT4gKGEgLT4gZClcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJHByb21hcChmLCBnKSB7XG4gICAgdmFyIHByb2Z1bmN0b3IgPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBnKHByb2Z1bmN0b3IoZih4KSkpOyB9O1xuICB9XG5cbiAgLy8gIEZ1bmN0aW9uJHByb3RvdHlwZSRhcCA6OiAoYSAtPiBiKSB+PiAoYSAtPiBiIC0+IGMpIC0+IChhIC0+IGMpXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uJHByb3RvdHlwZSRhcChmKSB7XG4gICAgdmFyIGFwcGx5ID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4gZih4KShhcHBseSh4KSk7IH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJGNoYWluIDo6IChhIC0+IGIpIH4+IChiIC0+IGEgLT4gYykgLT4gKGEgLT4gYylcbiAgZnVuY3Rpb24gRnVuY3Rpb24kcHJvdG90eXBlJGNoYWluKGYpIHtcbiAgICB2YXIgY2hhaW4gPSB0aGlzO1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiBmKGNoYWluKHgpKSh4KTsgfTtcbiAgfVxuXG4gIC8vICBGdW5jdGlvbiRwcm90b3R5cGUkZXh0ZW5kIDo6IFNlbWlncm91cCBhID0+IChhIC0+IGIpIH4+ICgoYSAtPiBiKSAtPiBjKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkZXh0ZW5kKGYpIHtcbiAgICB2YXIgZXh0ZW5kID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGYoZnVuY3Rpb24oeSkgeyByZXR1cm4gZXh0ZW5kKGNvbmNhdCh4LCB5KSk7IH0pO1xuICAgIH07XG4gIH1cblxuICAvLyAgRnVuY3Rpb24kcHJvdG90eXBlJGNvbnRyYW1hcCA6OiAoYiAtPiBjKSB+PiAoYSAtPiBiKSAtPiAoYSAtPiBjKVxuICBmdW5jdGlvbiBGdW5jdGlvbiRwcm90b3R5cGUkY29udHJhbWFwKGYpIHtcbiAgICB2YXIgY29udHJhdmFyaWFudCA9IHRoaXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIGNvbnRyYXZhcmlhbnQoZih4KSk7IH07XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuICB2YXIgaW1wbGVtZW50YXRpb25zID0ge1xuICAgIE51bGw6IHtcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBOdWxsJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBOdWxsJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIFVuZGVmaW5lZDoge1xuICAgICAgJ3Byb3RvdHlwZSc6IHtcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIFVuZGVmaW5lZCRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgVW5kZWZpbmVkJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIEJvb2xlYW46IHtcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBCb29sZWFuJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBCb29sZWFuJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIE51bWJlcjoge1xuICAgICAgJ3Byb3RvdHlwZSc6IHtcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIE51bWJlciRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2x0ZSc6ICAgICAgICAgTnVtYmVyJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIERhdGU6IHtcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBEYXRlJHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBEYXRlJHByb3RvdHlwZSRsdGVcbiAgICAgIH1cbiAgICB9LFxuICAgIFJlZ0V4cDoge1xuICAgICAgJ3Byb3RvdHlwZSc6IHtcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIFJlZ0V4cCRwcm90b3R5cGUkZXF1YWxzXG4gICAgICB9XG4gICAgfSxcbiAgICBTdHJpbmc6IHtcbiAgICAgICdmYW50YXN5LWxhbmQvZW1wdHknOiAgICAgICAgIFN0cmluZyRlbXB0eSxcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBTdHJpbmckcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIFN0cmluZyRwcm90b3R5cGUkbHRlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NvbmNhdCc6ICAgICAgU3RyaW5nJHByb3RvdHlwZSRjb25jYXRcbiAgICAgIH1cbiAgICB9LFxuICAgIEFycmF5OiB7XG4gICAgICAnZmFudGFzeS1sYW5kL2VtcHR5JzogICAgICAgICBBcnJheSRlbXB0eSxcbiAgICAgICdmYW50YXN5LWxhbmQvb2YnOiAgICAgICAgICAgIEFycmF5JG9mLFxuICAgICAgJ2ZhbnRhc3ktbGFuZC9jaGFpblJlYyc6ICAgICAgQXJyYXkkY2hhaW5SZWMsXG4gICAgICAnZmFudGFzeS1sYW5kL3plcm8nOiAgICAgICAgICBBcnJheSR6ZXJvLFxuICAgICAgJ3Byb3RvdHlwZSc6IHtcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIEFycmF5JHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBBcnJheSRwcm90b3R5cGUkbHRlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NvbmNhdCc6ICAgICAgQXJyYXkkcHJvdG90eXBlJGNvbmNhdCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9maWx0ZXInOiAgICAgIEFycmF5JHByb3RvdHlwZSRmaWx0ZXIsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbWFwJzogICAgICAgICBBcnJheSRwcm90b3R5cGUkbWFwLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2FwJzogICAgICAgICAgQXJyYXkkcHJvdG90eXBlJGFwLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NoYWluJzogICAgICAgQXJyYXkkcHJvdG90eXBlJGNoYWluLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2FsdCc6ICAgICAgICAgQXJyYXkkcHJvdG90eXBlJGFsdCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnOiAgICAgIEFycmF5JHByb3RvdHlwZSRyZWR1Y2UsXG4gICAgICAgICdmYW50YXN5LWxhbmQvdHJhdmVyc2UnOiAgICBBcnJheSRwcm90b3R5cGUkdHJhdmVyc2UsXG4gICAgICAgICdmYW50YXN5LWxhbmQvZXh0ZW5kJzogICAgICBBcnJheSRwcm90b3R5cGUkZXh0ZW5kXG4gICAgICB9XG4gICAgfSxcbiAgICBBcmd1bWVudHM6IHtcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBBcmd1bWVudHMkcHJvdG90eXBlJGVxdWFscyxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9sdGUnOiAgICAgICAgIEFyZ3VtZW50cyRwcm90b3R5cGUkbHRlXG4gICAgICB9XG4gICAgfSxcbiAgICBFcnJvcjoge1xuICAgICAgJ3Byb3RvdHlwZSc6IHtcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnOiAgICAgIEVycm9yJHByb3RvdHlwZSRlcXVhbHNcbiAgICAgIH1cbiAgICB9LFxuICAgIE9iamVjdDoge1xuICAgICAgJ2ZhbnRhc3ktbGFuZC9lbXB0eSc6ICAgICAgICAgT2JqZWN0JGVtcHR5LFxuICAgICAgJ2ZhbnRhc3ktbGFuZC96ZXJvJzogICAgICAgICAgT2JqZWN0JHplcm8sXG4gICAgICAncHJvdG90eXBlJzoge1xuICAgICAgICAnZmFudGFzeS1sYW5kL2VxdWFscyc6ICAgICAgT2JqZWN0JHByb3RvdHlwZSRlcXVhbHMsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbHRlJzogICAgICAgICBPYmplY3QkcHJvdG90eXBlJGx0ZSxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jb25jYXQnOiAgICAgIE9iamVjdCRwcm90b3R5cGUkY29uY2F0LFxuICAgICAgICAnZmFudGFzeS1sYW5kL2ZpbHRlcic6ICAgICAgT2JqZWN0JHByb3RvdHlwZSRmaWx0ZXIsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbWFwJzogICAgICAgICBPYmplY3QkcHJvdG90eXBlJG1hcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICAgIE9iamVjdCRwcm90b3R5cGUkYXAsXG4gICAgICAgICdmYW50YXN5LWxhbmQvYWx0JzogICAgICAgICBPYmplY3QkcHJvdG90eXBlJGFsdCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnOiAgICAgIE9iamVjdCRwcm90b3R5cGUkcmVkdWNlLFxuICAgICAgICAnZmFudGFzeS1sYW5kL3RyYXZlcnNlJzogICAgT2JqZWN0JHByb3RvdHlwZSR0cmF2ZXJzZVxuICAgICAgfVxuICAgIH0sXG4gICAgRnVuY3Rpb246IHtcbiAgICAgICdmYW50YXN5LWxhbmQvaWQnOiAgICAgICAgICAgIEZ1bmN0aW9uJGlkLFxuICAgICAgJ2ZhbnRhc3ktbGFuZC9vZic6ICAgICAgICAgICAgRnVuY3Rpb24kb2YsXG4gICAgICAnZmFudGFzeS1sYW5kL2NoYWluUmVjJzogICAgICBGdW5jdGlvbiRjaGFpblJlYyxcbiAgICAgICdwcm90b3R5cGUnOiB7XG4gICAgICAgICdmYW50YXN5LWxhbmQvZXF1YWxzJzogICAgICBGdW5jdGlvbiRwcm90b3R5cGUkZXF1YWxzLFxuICAgICAgICAnZmFudGFzeS1sYW5kL2NvbXBvc2UnOiAgICAgRnVuY3Rpb24kcHJvdG90eXBlJGNvbXBvc2UsXG4gICAgICAgICdmYW50YXN5LWxhbmQvbWFwJzogICAgICAgICBGdW5jdGlvbiRwcm90b3R5cGUkbWFwLFxuICAgICAgICAnZmFudGFzeS1sYW5kL3Byb21hcCc6ICAgICAgRnVuY3Rpb24kcHJvdG90eXBlJHByb21hcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9hcCc6ICAgICAgICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRhcCxcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9jaGFpbic6ICAgICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRjaGFpbixcbiAgICAgICAgJ2ZhbnRhc3ktbGFuZC9leHRlbmQnOiAgICAgIEZ1bmN0aW9uJHByb3RvdHlwZSRleHRlbmQsXG4gICAgICAgICdmYW50YXN5LWxhbmQvY29udHJhbWFwJzogICBGdW5jdGlvbiRwcm90b3R5cGUkY29udHJhbWFwXG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiBlc2xpbnQtZW5hYmxlIGtleS1zcGFjaW5nICovXG5cbiAgLy8jIGVxdWFscyA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIGVxdWFsIGFjY29yZGluZ1xuICAvLy4gdG8gdGhlIHR5cGUncyBbYGZhbnRhc3ktbGFuZC9lcXVhbHNgXVtdIG1ldGhvZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9lcXVhbHNgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBOdWxsLCBVbmRlZmluZWQsIEJvb2xlYW4sIE51bWJlciwgRGF0ZSwgUmVnRXhwLCBTdHJpbmcsXG4gIC8vLiBBcnJheSwgQXJndW1lbnRzLCBFcnJvciwgT2JqZWN0LCBhbmQgRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gVGhlIGFsZ29yaXRobSBzdXBwb3J0cyBjaXJjdWxhciBkYXRhIHN0cnVjdHVyZXMuIFR3byBhcnJheXMgYXJlIGVxdWFsXG4gIC8vLiBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgaW5kZXggcGF0aHMgYW5kIGZvciBlYWNoIHBhdGggaGF2ZSBlcXVhbCB2YWx1ZXMuXG4gIC8vLiBUd28gYXJyYXlzIHdoaWNoIHJlcHJlc2VudCBgWzEsIFsxLCBbMSwgWzEsIFsxLCAuLi5dXV1dXWAsIGZvciBleGFtcGxlLFxuICAvLy4gYXJlIGVxdWFsIGV2ZW4gaWYgdGhlaXIgaW50ZXJuYWwgc3RydWN0dXJlcyBkaWZmZXIuIFR3byBvYmplY3RzIGFyZSBlcXVhbFxuICAvLy4gaWYgdGhleSBoYXZlIHRoZSBzYW1lIHByb3BlcnR5IHBhdGhzIGFuZCBmb3IgZWFjaCBwYXRoIGhhdmUgZXF1YWwgdmFsdWVzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZXF1YWxzKDAsIC0wKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZXF1YWxzKE5hTiwgTmFOKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZXF1YWxzKENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIE5pbCkpLCBDb25zKCdmb28nLCBDb25zKCdiYXInLCBOaWwpKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVxdWFscyhDb25zKCdmb28nLCBDb25zKCdiYXInLCBOaWwpKSwgQ29ucygnYmFyJywgQ29ucygnZm9vJywgTmlsKSkpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIHZhciBlcXVhbHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgLy8gICRwYWlycyA6OiBBcnJheSAoQXJyYXkyIEFueSBBbnkpXG4gICAgdmFyICRwYWlycyA9IFtdO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGVxdWFscyh4LCB5KSB7XG4gICAgICBpZiAoIXNhbWVUeXBlKHgsIHkpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vICBUaGlzIGFsZ29yaXRobSBmb3IgY29tcGFyaW5nIGNpcmN1bGFyIGRhdGEgc3RydWN0dXJlcyB3YXNcbiAgICAgIC8vICBzdWdnZXN0ZWQgaW4gPGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQwNjIyNzk0LzMxMjc4NT4uXG4gICAgICBpZiAoJHBhaXJzLnNvbWUoZnVuY3Rpb24ocCkgeyByZXR1cm4gcFswXSA9PT0geCAmJiBwWzFdID09PSB5OyB9KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgJHBhaXJzLnB1c2goW3gsIHldKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBTZXRvaWQudGVzdCh4KSAmJiBTZXRvaWQudGVzdCh5KSAmJiBTZXRvaWQubWV0aG9kcy5lcXVhbHMoeCkoeSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAkcGFpcnMucG9wKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSgpKTtcblxuICAvLyMgbHQgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCB0aGUgZmlyc3QgaXNcbiAgLy8uIGxlc3MgdGhhbiB0aGUgc2Vjb25kIGFjY29yZGluZyB0byB0aGUgdHlwZSdzIFtgZmFudGFzeS1sYW5kL2x0ZWBdW11cbiAgLy8uIG1ldGhvZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGd0YF0oI2d0KSBhbmQgW2BndGVgXSgjZ3RlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGx0KDAsIDApXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gbHQoMCwgMSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGx0KDEsIDApXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGx0KHgsIHkpIHtcbiAgICByZXR1cm4gc2FtZVR5cGUoeCwgeSkgJiYgIWx0ZSh5LCB4KTtcbiAgfVxuXG4gIC8vIyBsdGUgOjogKGEsIGIpIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZCB0aGUgZmlyc3RcbiAgLy8uIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kIGFjY29yZGluZyB0byB0aGUgdHlwZSdzXG4gIC8vLiBbYGZhbnRhc3ktbGFuZC9sdGVgXVtdIG1ldGhvZDsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9sdGVgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBOdWxsLCBVbmRlZmluZWQsIEJvb2xlYW4sIE51bWJlciwgRGF0ZSwgU3RyaW5nLCBBcnJheSxcbiAgLy8uIEFyZ3VtZW50cywgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBUaGUgYWxnb3JpdGhtIHN1cHBvcnRzIGNpcmN1bGFyIGRhdGEgc3RydWN0dXJlcyBpbiB0aGUgc2FtZSBtYW5uZXIgYXNcbiAgLy8uIFtgZXF1YWxzYF0oI2VxdWFscykuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsdGBdKCNsdCksIFtgZ3RgXSgjZ3QpLCBhbmQgW2BndGVgXSgjZ3RlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGx0ZSgwLCAwKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gbHRlKDAsIDEpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBsdGUoMSwgMClcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgdmFyIGx0ZSA9IChmdW5jdGlvbigpIHtcbiAgICAvLyAgJHBhaXJzIDo6IEFycmF5IChBcnJheTIgQW55IEFueSlcbiAgICB2YXIgJHBhaXJzID0gW107XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbHRlKHgsIHkpIHtcbiAgICAgIGlmICghc2FtZVR5cGUoeCwgeSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gIFRoaXMgYWxnb3JpdGhtIGZvciBjb21wYXJpbmcgY2lyY3VsYXIgZGF0YSBzdHJ1Y3R1cmVzIHdhc1xuICAgICAgLy8gIHN1Z2dlc3RlZCBpbiA8aHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDA2MjI3OTQvMzEyNzg1Pi5cbiAgICAgIGlmICgkcGFpcnMuc29tZShmdW5jdGlvbihwKSB7IHJldHVybiBwWzBdID09PSB4ICYmIHBbMV0gPT09IHk7IH0pKSB7XG4gICAgICAgIHJldHVybiBlcXVhbHMoeCwgeSk7XG4gICAgICB9XG5cbiAgICAgICRwYWlycy5wdXNoKFt4LCB5XSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gT3JkLnRlc3QoeCkgJiYgT3JkLnRlc3QoeSkgJiYgT3JkLm1ldGhvZHMubHRlKHgpKHkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgJHBhaXJzLnBvcCgpO1xuICAgICAgfVxuICAgIH07XG4gIH0oKSk7XG5cbiAgLy8jIGd0IDo6IChhLCBiKSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgaXRzIGFyZ3VtZW50cyBhcmUgb2YgdGhlIHNhbWUgdHlwZSBhbmQgdGhlIGZpcnN0IGlzXG4gIC8vLiBncmVhdGVyIHRoYW4gdGhlIHNlY29uZCBhY2NvcmRpbmcgdG8gdGhlIHR5cGUncyBbYGZhbnRhc3ktbGFuZC9sdGVgXVtdXG4gIC8vLiBtZXRob2Q7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsdGBdKCNsdCkgYW5kIFtgZ3RlYF0oI2d0ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBndCgwLCAwKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGd0KDAsIDEpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZ3QoMSwgMClcbiAgLy8uIHRydWVcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBndCh4LCB5KSB7XG4gICAgcmV0dXJuIGx0KHksIHgpO1xuICB9XG5cbiAgLy8jIGd0ZSA6OiAoYSwgYikgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIGlmIGl0cyBhcmd1bWVudHMgYXJlIG9mIHRoZSBzYW1lIHR5cGUgYW5kIHRoZSBmaXJzdFxuICAvLy4gaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQgYWNjb3JkaW5nIHRvIHRoZSB0eXBlJ3NcbiAgLy8uIFtgZmFudGFzeS1sYW5kL2x0ZWBdW10gbWV0aG9kOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbHRgXSgjbHQpIGFuZCBbYGd0YF0oI2d0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGd0ZSgwLCAwKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZ3RlKDAsIDEpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gZ3RlKDEsIDApXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZ3RlKHgsIHkpIHtcbiAgICByZXR1cm4gbHRlKHksIHgpO1xuICB9XG5cbiAgLy8jIG1pbiA6OiBPcmQgYSA9PiAoYSwgYSkgLT4gYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHNtYWxsZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsdGVgXSgjbHRlKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1heGBdKCNtYXgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbWluKDEwLCAyKVxuICAvLy4gMlxuICAvLy5cbiAgLy8uID4gbWluKG5ldyBEYXRlKCcxOTk5LTEyLTMxJyksIG5ldyBEYXRlKCcyMDAwLTAxLTAxJykpXG4gIC8vLiBuZXcgRGF0ZSgnMTk5OS0xMi0zMScpXG4gIC8vLlxuICAvLy4gPiBtaW4oJzEwJywgJzInKVxuICAvLy4gJzEwJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1pbih4LCB5KSB7XG4gICAgcmV0dXJuIGx0ZSh4LCB5KSA/IHggOiB5O1xuICB9XG5cbiAgLy8jIG1heCA6OiBPcmQgYSA9PiAoYSwgYSkgLT4gYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIGxhcmdlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGx0ZWBdKCNsdGUpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbWluYF0oI21pbikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBtYXgoMTAsIDIpXG4gIC8vLiAxMFxuICAvLy5cbiAgLy8uID4gbWF4KG5ldyBEYXRlKCcxOTk5LTEyLTMxJyksIG5ldyBEYXRlKCcyMDAwLTAxLTAxJykpXG4gIC8vLiBuZXcgRGF0ZSgnMjAwMC0wMS0wMScpXG4gIC8vLlxuICAvLy4gPiBtYXgoJzEwJywgJzInKVxuICAvLy4gJzInXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbWF4KHgsIHkpIHtcbiAgICByZXR1cm4gbHRlKHgsIHkpID8geSA6IHg7XG4gIH1cblxuICAvLyMgY29tcG9zZSA6OiBTZW1pZ3JvdXBvaWQgYyA9PiAoYyBqIGssIGMgaSBqKSAtPiBjIGkga1xuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NvbXBvc2VgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvY29tcG9zZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29tcG9zZShNYXRoLnNxcnQsIHggPT4geCArIDEpKDk5KVxuICAvLy4gMTBcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjb21wb3NlKHgsIHkpIHtcbiAgICByZXR1cm4gU2VtaWdyb3Vwb2lkLm1ldGhvZHMuY29tcG9zZSh5KSh4KTtcbiAgfVxuXG4gIC8vIyBpZCA6OiBDYXRlZ29yeSBjID0+IFR5cGVSZXAgYyAtPiBjXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvaWRgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvaWRgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGlkKEZ1bmN0aW9uKSgnZm9vJylcbiAgLy8uICdmb28nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaWQodHlwZVJlcCkge1xuICAgIHJldHVybiBDYXRlZ29yeS5tZXRob2RzLmlkKHR5cGVSZXApKCk7XG4gIH1cblxuICAvLyMgY29uY2F0IDo6IFNlbWlncm91cCBhID0+IChhLCBhKSAtPiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvY29uY2F0YF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NvbmNhdGAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IFN0cmluZywgQXJyYXksIGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb25jYXQoJ2FiYycsICdkZWYnKVxuICAvLy4gJ2FiY2RlZidcbiAgLy8uXG4gIC8vLiA+IGNvbmNhdChbMSwgMiwgM10sIFs0LCA1LCA2XSlcbiAgLy8uIFsxLCAyLCAzLCA0LCA1LCA2XVxuICAvLy5cbiAgLy8uID4gY29uY2F0KHt4OiAxLCB5OiAyfSwge3k6IDMsIHo6IDR9KVxuICAvLy4ge3g6IDEsIHk6IDMsIHo6IDR9XG4gIC8vLlxuICAvLy4gPiBjb25jYXQoQ29ucygnZm9vJywgQ29ucygnYmFyJywgQ29ucygnYmF6JywgTmlsKSkpLCBDb25zKCdxdXV4JywgTmlsKSlcbiAgLy8uIENvbnMoJ2ZvbycsIENvbnMoJ2JhcicsIENvbnMoJ2JheicsIENvbnMoJ3F1dXgnLCBOaWwpKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY29uY2F0KHgsIHkpIHtcbiAgICByZXR1cm4gU2VtaWdyb3VwLm1ldGhvZHMuY29uY2F0KHgpKHkpO1xuICB9XG5cbiAgLy8jIGVtcHR5IDo6IE1vbm9pZCBtID0+IFR5cGVSZXAgbSAtPiBtXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvZW1wdHlgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZW1wdHlgIGltcGxlbWVudGF0aW9ucyBhcmUgcHJvdmlkZWQgZm9yIHRoZSBmb2xsb3dpbmdcbiAgLy8uIGJ1aWx0LWluIHR5cGVzOiBTdHJpbmcsIEFycmF5LCBhbmQgT2JqZWN0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZW1wdHkoU3RyaW5nKVxuICAvLy4gJydcbiAgLy8uXG4gIC8vLiA+IGVtcHR5KEFycmF5KVxuICAvLy4gW11cbiAgLy8uXG4gIC8vLiA+IGVtcHR5KE9iamVjdClcbiAgLy8uIHt9XG4gIC8vLlxuICAvLy4gPiBlbXB0eShMaXN0KVxuICAvLy4gTmlsXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZW1wdHkodHlwZVJlcCkge1xuICAgIHJldHVybiBNb25vaWQubWV0aG9kcy5lbXB0eSh0eXBlUmVwKSgpO1xuICB9XG5cbiAgLy8jIGludmVydCA6OiBHcm91cCBnID0+IGcgLT4gZ1xuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2ludmVydGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBpbnZlcnQoU3VtKDUpKVxuICAvLy4gU3VtKC01KVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGludmVydChncm91cCkge1xuICAgIHJldHVybiBHcm91cC5tZXRob2RzLmludmVydChncm91cCkoKTtcbiAgfVxuXG4gIC8vIyBmaWx0ZXIgOjogRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4sIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvZmlsdGVyYF1bXS4gRGlzY2FyZHMgZXZlcnkgZWxlbWVudFxuICAvLy4gd2hpY2ggZG9lcyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZmlsdGVyYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHJlamVjdGBdKCNyZWplY3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZmlsdGVyKHggPT4geCAlIDIgPT0gMSwgWzEsIDIsIDNdKVxuICAvLy4gWzEsIDNdXG4gIC8vLlxuICAvLy4gPiBmaWx0ZXIoeCA9PiB4ICUgMiA9PSAxLCB7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiB7eDogMSwgejogM31cbiAgLy8uXG4gIC8vLiA+IGZpbHRlcih4ID0+IHggJSAyID09IDEsIENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSlcbiAgLy8uIENvbnMoMSwgQ29ucygzLCBOaWwpKVxuICAvLy5cbiAgLy8uID4gZmlsdGVyKHggPT4geCAlIDIgPT0gMSwgTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IGZpbHRlcih4ID0+IHggJSAyID09IDEsIEp1c3QoMCkpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBmaWx0ZXIoeCA9PiB4ICUgMiA9PSAxLCBKdXN0KDEpKVxuICAvLy4gSnVzdCgxKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZpbHRlcihwcmVkLCBmaWx0ZXJhYmxlKSB7XG4gICAgcmV0dXJuIEZpbHRlcmFibGUubWV0aG9kcy5maWx0ZXIoZmlsdGVyYWJsZSkocHJlZCk7XG4gIH1cblxuICAvLyMgcmVqZWN0IDo6IEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIERpc2NhcmRzIGV2ZXJ5IGVsZW1lbnQgd2hpY2ggc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGUuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BmaWx0ZXJgXSgjZmlsdGVyKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHJlamVjdCh4ID0+IHggJSAyID09IDEsIFsxLCAyLCAzXSlcbiAgLy8uIFsyXVxuICAvLy5cbiAgLy8uID4gcmVqZWN0KHggPT4geCAlIDIgPT0gMSwge3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4ge3k6IDJ9XG4gIC8vLlxuICAvLy4gPiByZWplY3QoeCA9PiB4ICUgMiA9PSAxLCBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSkpXG4gIC8vLiBDb25zKDIsIE5pbClcbiAgLy8uXG4gIC8vLiA+IHJlamVjdCh4ID0+IHggJSAyID09IDEsIE5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiByZWplY3QoeCA9PiB4ICUgMiA9PSAxLCBKdXN0KDApKVxuICAvLy4gSnVzdCgwKVxuICAvLy5cbiAgLy8uID4gcmVqZWN0KHggPT4geCAlIDIgPT0gMSwgSnVzdCgxKSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiByZWplY3QocHJlZCwgZmlsdGVyYWJsZSkge1xuICAgIHJldHVybiBmaWx0ZXIoZnVuY3Rpb24oeCkgeyByZXR1cm4gIXByZWQoeCk7IH0sIGZpbHRlcmFibGUpO1xuICB9XG5cbiAgLy8jIHRha2VXaGlsZSA6OiBGaWx0ZXJhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbiwgZiBhKSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBEaXNjYXJkcyB0aGUgZmlyc3QgZWxlbWVudCB3aGljaCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUsIGFuZCBhbGxcbiAgLy8uIHN1YnNlcXVlbnQgZWxlbWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BmaWx0ZXJgXSgjZmlsdGVyKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGRyb3BXaGlsZWBdKCNkcm9wV2hpbGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gdGFrZVdoaWxlKHMgPT4gL3gvLnRlc3QocyksIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXSlcbiAgLy8uIFsneHknLCAneHonLCAneXgnXVxuICAvLy5cbiAgLy8uID4gdGFrZVdoaWxlKHMgPT4gL3kvLnRlc3QocyksIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXSlcbiAgLy8uIFsneHknXVxuICAvLy5cbiAgLy8uID4gdGFrZVdoaWxlKHMgPT4gL3ovLnRlc3QocyksIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXSlcbiAgLy8uIFtdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdGFrZVdoaWxlKHByZWQsIGZpbHRlcmFibGUpIHtcbiAgICB2YXIgdGFrZSA9IHRydWU7XG4gICAgcmV0dXJuIGZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiB0YWtlID0gdGFrZSAmJiBwcmVkKHgpOyB9LCBmaWx0ZXJhYmxlKTtcbiAgfVxuXG4gIC8vIyBkcm9wV2hpbGUgOjogRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4sIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gUmV0YWlucyB0aGUgZmlyc3QgZWxlbWVudCB3aGljaCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUsIGFuZCBhbGxcbiAgLy8uIHN1YnNlcXVlbnQgZWxlbWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BmaWx0ZXJgXSgjZmlsdGVyKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHRha2VXaGlsZWBdKCN0YWtlV2hpbGUpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZHJvcFdoaWxlKHMgPT4gL3gvLnRlc3QocyksIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXSlcbiAgLy8uIFsneXonLCAnengnLCAnenknXVxuICAvLy5cbiAgLy8uID4gZHJvcFdoaWxlKHMgPT4gL3kvLnRlc3QocyksIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXSlcbiAgLy8uIFsneHonLCAneXgnLCAneXonLCAnengnLCAnenknXVxuICAvLy5cbiAgLy8uID4gZHJvcFdoaWxlKHMgPT4gL3ovLnRlc3QocyksIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXSlcbiAgLy8uIFsneHknLCAneHonLCAneXgnLCAneXonLCAnengnLCAnenknXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGRyb3BXaGlsZShwcmVkLCBmaWx0ZXJhYmxlKSB7XG4gICAgdmFyIHRha2UgPSBmYWxzZTtcbiAgICByZXR1cm4gZmlsdGVyKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHRha2UgPSB0YWtlIHx8ICFwcmVkKHgpOyB9LCBmaWx0ZXJhYmxlKTtcbiAgfVxuXG4gIC8vIyBtYXAgOjogRnVuY3RvciBmID0+IChhIC0+IGIsIGYgYSkgLT4gZiBiXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvbWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL21hcGAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5LCBPYmplY3QsIGFuZCBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIFsxLCA0LCA5XSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gbWFwKE1hdGguc3FydCwge3g6IDEsIHk6IDQsIHo6IDl9KVxuICAvLy4ge3g6IDEsIHk6IDIsIHo6IDN9XG4gIC8vLlxuICAvLy4gPiBtYXAoTWF0aC5zcXJ0LCBzID0+IHMubGVuZ3RoKSgnU2FuY3R1YXJ5JylcbiAgLy8uIDNcbiAgLy8uXG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIFR1cGxlKCdmb28nLCA2NCkpXG4gIC8vLiBUdXBsZSgnZm9vJywgOClcbiAgLy8uXG4gIC8vLiA+IG1hcChNYXRoLnNxcnQsIE5pbClcbiAgLy8uIE5pbFxuICAvLy5cbiAgLy8uID4gbWFwKE1hdGguc3FydCwgQ29ucygxLCBDb25zKDQsIENvbnMoOSwgTmlsKSkpKVxuICAvLy4gQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbWFwKGYsIGZ1bmN0b3IpIHtcbiAgICByZXR1cm4gRnVuY3Rvci5tZXRob2RzLm1hcChmdW5jdG9yKShmKTtcbiAgfVxuXG4gIC8vIyBmbGlwIDo6IEZ1bmN0b3IgZiA9PiAoZiAoYSAtPiBiKSwgYSkgLT4gZiBiXG4gIC8vLlxuICAvLy4gTWFwcyBvdmVyIHRoZSBnaXZlbiBmdW5jdGlvbnMsIGFwcGx5aW5nIGVhY2ggdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbWFwYF0oI21hcCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBmbGlwKHggPT4geSA9PiB4ICsgeSwgJyEnKSgnZm9vJylcbiAgLy8uICdmb28hJ1xuICAvLy5cbiAgLy8uID4gZmxpcChbTWF0aC5mbG9vciwgTWF0aC5jZWlsXSwgMS41KVxuICAvLy4gWzEsIDJdXG4gIC8vLlxuICAvLy4gPiBmbGlwKHtmbG9vcjogTWF0aC5mbG9vciwgY2VpbDogTWF0aC5jZWlsfSwgMS41KVxuICAvLy4ge2Zsb29yOiAxLCBjZWlsOiAyfVxuICAvLy5cbiAgLy8uID4gZmxpcChDb25zKE1hdGguZmxvb3IsIENvbnMoTWF0aC5jZWlsLCBOaWwpKSwgMS41KVxuICAvLy4gQ29ucygxLCBDb25zKDIsIE5pbCkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZmxpcChmdW5jdG9yLCB4KSB7XG4gICAgcmV0dXJuIEZ1bmN0b3IubWV0aG9kcy5tYXAoZnVuY3RvcikodGhydXNoKHgpKTtcbiAgfVxuXG4gIC8vIyBiaW1hcCA6OiBCaWZ1bmN0b3IgZiA9PiAoYSAtPiBiLCBjIC0+IGQsIGYgYSBjKSAtPiBmIGIgZFxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2JpbWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGJpbWFwKHMgPT4gcy50b1VwcGVyQ2FzZSgpLCBNYXRoLnNxcnQsIFR1cGxlKCdmb28nLCA2NCkpXG4gIC8vLiBUdXBsZSgnRk9PJywgOClcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBiaW1hcChmLCBnLCBiaWZ1bmN0b3IpIHtcbiAgICByZXR1cm4gQmlmdW5jdG9yLm1ldGhvZHMuYmltYXAoYmlmdW5jdG9yKShmLCBnKTtcbiAgfVxuXG4gIC8vIyBtYXBMZWZ0IDo6IEJpZnVuY3RvciBmID0+IChhIC0+IGIsIGYgYSBjKSAtPiBmIGIgY1xuICAvLy5cbiAgLy8uIE1hcHMgdGhlIGdpdmVuIGZ1bmN0aW9uIG92ZXIgdGhlIGxlZnQgc2lkZSBvZiBhIEJpZnVuY3Rvci5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IG1hcExlZnQoTWF0aC5zcXJ0LCBUdXBsZSg2NCwgOSkpXG4gIC8vLiBUdXBsZSg4LCA5KVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1hcExlZnQoZiwgYmlmdW5jdG9yKSB7XG4gICAgcmV0dXJuIGJpbWFwKGYsIGlkZW50aXR5LCBiaWZ1bmN0b3IpO1xuICB9XG5cbiAgLy8jIHByb21hcCA6OiBQcm9mdW5jdG9yIHAgPT4gKGEgLT4gYiwgYyAtPiBkLCBwIGIgYykgLT4gcCBhIGRcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9wcm9tYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvcHJvbWFwYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBwcm9tYXAoTWF0aC5hYnMsIHggPT4geCArIDEsIE1hdGguc3FydCkoLTEwMClcbiAgLy8uIDExXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcHJvbWFwKGYsIGcsIHByb2Z1bmN0b3IpIHtcbiAgICByZXR1cm4gUHJvZnVuY3Rvci5tZXRob2RzLnByb21hcChwcm9mdW5jdG9yKShmLCBnKTtcbiAgfVxuXG4gIC8vIyBhcCA6OiBBcHBseSBmID0+IChmIChhIC0+IGIpLCBmIGEpIC0+IGYgYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2FwYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2FwYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXksIE9iamVjdCwgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gYXAoW01hdGguc3FydCwgeCA9PiB4ICogeF0sIFsxLCA0LCA5LCAxNiwgMjVdKVxuICAvLy4gWzEsIDIsIDMsIDQsIDUsIDEsIDE2LCA4MSwgMjU2LCA2MjVdXG4gIC8vLlxuICAvLy4gPiBhcCh7YTogTWF0aC5zcXJ0LCBiOiB4ID0+IHggKiB4fSwge2E6IDE2LCBiOiAxMCwgYzogMX0pXG4gIC8vLiB7YTogNCwgYjogMTAwfVxuICAvLy5cbiAgLy8uID4gYXAocyA9PiBuID0+IHMuc2xpY2UoMCwgbiksIHMgPT4gTWF0aC5jZWlsKHMubGVuZ3RoIC8gMikpKCdIYXNrZWxsJylcbiAgLy8uICdIYXNrJ1xuICAvLy5cbiAgLy8uID4gYXAoSWRlbnRpdHkoTWF0aC5zcXJ0KSwgSWRlbnRpdHkoNjQpKVxuICAvLy4gSWRlbnRpdHkoOClcbiAgLy8uXG4gIC8vLiA+IGFwKENvbnMoTWF0aC5zcXJ0LCBDb25zKHggPT4geCAqIHgsIE5pbCkpLCBDb25zKDE2LCBDb25zKDEwMCwgTmlsKSkpXG4gIC8vLiBDb25zKDQsIENvbnMoMTAsIENvbnMoMjU2LCBDb25zKDEwMDAwLCBOaWwpKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYXAoYXBwbHlGLCBhcHBseVgpIHtcbiAgICByZXR1cm4gQXBwbHkubWV0aG9kcy5hcChhcHBseVgpKGFwcGx5Rik7XG4gIH1cblxuICAvLyMgbGlmdDIgOjogQXBwbHkgZiA9PiAoYSAtPiBiIC0+IGMsIGYgYSwgZiBiKSAtPiBmIGNcbiAgLy8uXG4gIC8vLiBMaWZ0cyBgYSAtPiBiIC0+IGNgIHRvIGBBcHBseSBmID0+IGYgYSAtPiBmIGIgLT4gZiBjYCBhbmQgcmV0dXJucyB0aGVcbiAgLy8uIHJlc3VsdCBvZiBhcHBseWluZyB0aGlzIHRvIHRoZSBnaXZlbiBhcmd1bWVudHMuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BtYXBgXSgjbWFwKSBhbmQgW2BhcGBdKCNhcCkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsaWZ0M2BdKCNsaWZ0MykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBsaWZ0Mih4ID0+IHkgPT4gTWF0aC5wb3coeCwgeSksIFsxMF0sIFsxLCAyLCAzXSlcbiAgLy8uIFsxMCwgMTAwLCAxMDAwXVxuICAvLy5cbiAgLy8uID4gbGlmdDIoeCA9PiB5ID0+IE1hdGgucG93KHgsIHkpLCBJZGVudGl0eSgxMCksIElkZW50aXR5KDMpKVxuICAvLy4gSWRlbnRpdHkoMTAwMClcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBsaWZ0MihmLCB4LCB5KSB7XG4gICAgcmV0dXJuIGFwKG1hcChmLCB4KSwgeSk7XG4gIH1cblxuICAvLyMgbGlmdDMgOjogQXBwbHkgZiA9PiAoYSAtPiBiIC0+IGMgLT4gZCwgZiBhLCBmIGIsIGYgYykgLT4gZiBkXG4gIC8vLlxuICAvLy4gTGlmdHMgYGEgLT4gYiAtPiBjIC0+IGRgIHRvIGBBcHBseSBmID0+IGYgYSAtPiBmIGIgLT4gZiBjIC0+IGYgZGAgYW5kXG4gIC8vLiByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhpcyB0byB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbWFwYF0oI21hcCkgYW5kIFtgYXBgXSgjYXApLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbGlmdDJgXSgjbGlmdDIpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gbGlmdDMoeCA9PiB5ID0+IHogPT4geCArIHogKyB5LCBbJzwnXSwgWyc+J10sIFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uIFsnPGZvbz4nLCAnPGJhcj4nLCAnPGJhej4nXVxuICAvLy5cbiAgLy8uID4gbGlmdDMoeCA9PiB5ID0+IHogPT4geCArIHogKyB5LCBJZGVudGl0eSgnPCcpLCBJZGVudGl0eSgnPicpLCBJZGVudGl0eSgnYmF6JykpXG4gIC8vLiBJZGVudGl0eSgnPGJhej4nKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGxpZnQzKGYsIHgsIHksIHopIHtcbiAgICByZXR1cm4gYXAoYXAobWFwKGYsIHgpLCB5KSwgeik7XG4gIH1cblxuICAvLyMgYXBGaXJzdCA6OiBBcHBseSBmID0+IChmIGEsIGYgYikgLT4gZiBhXG4gIC8vLlxuICAvLy4gQ29tYmluZXMgdHdvIGVmZmVjdGZ1bCBhY3Rpb25zLCBrZWVwaW5nIG9ubHkgdGhlIHJlc3VsdCBvZiB0aGUgZmlyc3QuXG4gIC8vLiBFcXVpdmFsZW50IHRvIEhhc2tlbGwncyBgKDwqKWAgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BsaWZ0MmBdKCNsaWZ0MikuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcFNlY29uZGBdKCNhcFNlY29uZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBhcEZpcnN0KFsxLCAyXSwgWzMsIDRdKVxuICAvLy4gWzEsIDEsIDIsIDJdXG4gIC8vLlxuICAvLy4gPiBhcEZpcnN0KElkZW50aXR5KDEpLCBJZGVudGl0eSgyKSlcbiAgLy8uIElkZW50aXR5KDEpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYXBGaXJzdCh4LCB5KSB7XG4gICAgcmV0dXJuIGxpZnQyKGNvbnN0YW50LCB4LCB5KTtcbiAgfVxuXG4gIC8vIyBhcFNlY29uZCA6OiBBcHBseSBmID0+IChmIGEsIGYgYikgLT4gZiBiXG4gIC8vLlxuICAvLy4gQ29tYmluZXMgdHdvIGVmZmVjdGZ1bCBhY3Rpb25zLCBrZWVwaW5nIG9ubHkgdGhlIHJlc3VsdCBvZiB0aGUgc2Vjb25kLlxuICAvLy4gRXF1aXZhbGVudCB0byBIYXNrZWxsJ3MgYCgqPilgIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbGlmdDJgXSgjbGlmdDIpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgYXBGaXJzdGBdKCNhcEZpcnN0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGFwU2Vjb25kKFsxLCAyXSwgWzMsIDRdKVxuICAvLy4gWzMsIDQsIDMsIDRdXG4gIC8vLlxuICAvLy4gPiBhcFNlY29uZChJZGVudGl0eSgxKSwgSWRlbnRpdHkoMikpXG4gIC8vLiBJZGVudGl0eSgyKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFwU2Vjb25kKHgsIHkpIHtcbiAgICByZXR1cm4gbGlmdDIoY29uc3RhbnQoaWRlbnRpdHkpLCB4LCB5KTtcbiAgfVxuXG4gIC8vIyBvZiA6OiBBcHBsaWNhdGl2ZSBmID0+IChUeXBlUmVwIGYsIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL29mYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL29mYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gb2YoQXJyYXksIDQyKVxuICAvLy4gWzQyXVxuICAvLy5cbiAgLy8uID4gb2YoRnVuY3Rpb24sIDQyKShudWxsKVxuICAvLy4gNDJcbiAgLy8uXG4gIC8vLiA+IG9mKExpc3QsIDQyKVxuICAvLy4gQ29ucyg0MiwgTmlsKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG9mKHR5cGVSZXAsIHgpIHtcbiAgICByZXR1cm4gQXBwbGljYXRpdmUubWV0aG9kcy5vZih0eXBlUmVwKSh4KTtcbiAgfVxuXG4gIC8vIyBhcHBlbmQgOjogKEFwcGxpY2F0aXZlIGYsIFNlbWlncm91cCAoZiBhKSkgPT4gKGEsIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGVuZGluZyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHNlY29uZC5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNvbmNhdGBdKCNjb25jYXQpIGFuZCBbYG9mYF0oI29mKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHByZXBlbmRgXSgjcHJlcGVuZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBhcHBlbmQoMywgWzEsIDJdKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLlxuICAvLy4gPiBhcHBlbmQoMywgQ29ucygxLCBDb25zKDIsIE5pbCkpKVxuICAvLy4gQ29ucygxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYXBwZW5kKHgsIHhzKSB7XG4gICAgcmV0dXJuIGNvbmNhdCh4cywgb2YoeHMuY29uc3RydWN0b3IsIHgpKTtcbiAgfVxuXG4gIC8vIyBwcmVwZW5kIDo6IChBcHBsaWNhdGl2ZSBmLCBTZW1pZ3JvdXAgKGYgYSkpID0+IChhLCBmIGEpIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHJlc3VsdCBvZiBwcmVwZW5kaW5nIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgc2Vjb25kLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgY29uY2F0YF0oI2NvbmNhdCkgYW5kIFtgb2ZgXSgjb2YpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgYXBwZW5kYF0oI2FwcGVuZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBwcmVwZW5kKDEsIFsyLCAzXSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gcHJlcGVuZCgxLCBDb25zKDIsIENvbnMoMywgTmlsKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwcmVwZW5kKHgsIHhzKSB7XG4gICAgcmV0dXJuIGNvbmNhdChvZih4cy5jb25zdHJ1Y3RvciwgeCksIHhzKTtcbiAgfVxuXG4gIC8vIyBjaGFpbiA6OiBDaGFpbiBtID0+IChhIC0+IG0gYiwgbSBhKSAtPiBtIGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9jaGFpbmBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC9jaGFpbmAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBGdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGNoYWluKHggPT4gW3gsIHhdLCBbMSwgMiwgM10pXG4gIC8vLiBbMSwgMSwgMiwgMiwgMywgM11cbiAgLy8uXG4gIC8vLiA+IGNoYWluKHggPT4geCAlIDIgPT0gMSA/IG9mKExpc3QsIHgpIDogTmlsLCBDb25zKDEsIENvbnMoMiwgQ29ucygzLCBOaWwpKSkpXG4gIC8vLiBDb25zKDEsIENvbnMoMywgTmlsKSlcbiAgLy8uXG4gIC8vLiA+IGNoYWluKG4gPT4gcyA9PiBzLnNsaWNlKDAsIG4pLCBzID0+IE1hdGguY2VpbChzLmxlbmd0aCAvIDIpKSgnSGFza2VsbCcpXG4gIC8vLiAnSGFzaydcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjaGFpbihmLCBjaGFpbl8pIHtcbiAgICByZXR1cm4gQ2hhaW4ubWV0aG9kcy5jaGFpbihjaGFpbl8pKGYpO1xuICB9XG5cbiAgLy8jIGpvaW4gOjogQ2hhaW4gbSA9PiBtIChtIGEpIC0+IG0gYVxuICAvLy5cbiAgLy8uIFJlbW92ZXMgb25lIGxldmVsIG9mIG5lc3RpbmcgZnJvbSBhIG5lc3RlZCBtb25hZGljIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNoYWluYF0oI2NoYWluKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGpvaW4oW1sxXSwgWzJdLCBbM11dKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLlxuICAvLy4gPiBqb2luKFtbWzEsIDIsIDNdXV0pXG4gIC8vLiBbWzEsIDIsIDNdXVxuICAvLy5cbiAgLy8uID4gam9pbihJZGVudGl0eShJZGVudGl0eSgxKSkpXG4gIC8vLiBJZGVudGl0eSgxKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGpvaW4oY2hhaW5fKSB7XG4gICAgcmV0dXJuIGNoYWluKGlkZW50aXR5LCBjaGFpbl8pO1xuICB9XG5cbiAgLy8jIGNoYWluUmVjIDo6IENoYWluUmVjIG0gPT4gKFR5cGVSZXAgbSwgKGEgLT4gYywgYiAtPiBjLCBhKSAtPiBtIGMsIGEpIC0+IG0gYlxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2NoYWluUmVjYF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2NoYWluUmVjYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjaGFpblJlYyhcbiAgLy8uIC4gICBBcnJheSxcbiAgLy8uIC4gICAobmV4dCwgZG9uZSwgcykgPT4gcy5sZW5ndGggPT0gMiA/IFtzICsgJyEnLCBzICsgJz8nXS5tYXAoZG9uZSlcbiAgLy8uIC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtzICsgJ28nLCBzICsgJ24nXS5tYXAobmV4dCksXG4gIC8vLiAuICAgJydcbiAgLy8uIC4gKVxuICAvLy4gWydvbyEnLCAnb28/JywgJ29uIScsICdvbj8nLCAnbm8hJywgJ25vPycsICdubiEnLCAnbm4/J11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjaGFpblJlYyh0eXBlUmVwLCBmLCB4KSB7XG4gICAgcmV0dXJuIENoYWluUmVjLm1ldGhvZHMuY2hhaW5SZWModHlwZVJlcCkoZiwgeCk7XG4gIH1cblxuICAvLyMgYWx0IDo6IEFsdCBmID0+IChmIGEsIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRnVuY3Rpb24gd3JhcHBlciBmb3IgW2BmYW50YXN5LWxhbmQvYWx0YF1bXS5cbiAgLy8uXG4gIC8vLiBgZmFudGFzeS1sYW5kL2FsdGAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBhbHQoWzEsIDIsIDNdLCBbNCwgNSwgNl0pXG4gIC8vLiBbMSwgMiwgMywgNCwgNSwgNl1cbiAgLy8uXG4gIC8vLiA+IGFsdChOb3RoaW5nLCBOb3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gYWx0KE5vdGhpbmcsIEp1c3QoMSkpXG4gIC8vLiBKdXN0KDEpXG4gIC8vLlxuICAvLy4gPiBhbHQoSnVzdCgyKSwgSnVzdCgzKSlcbiAgLy8uIEp1c3QoMilcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhbHQoeCwgeSkge1xuICAgIHJldHVybiBBbHQubWV0aG9kcy5hbHQoeCkoeSk7XG4gIH1cblxuICAvLyMgemVybyA6OiBQbHVzIGYgPT4gVHlwZVJlcCBmIC0+IGYgYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL3plcm9gXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvemVyb2AgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB6ZXJvKEFycmF5KVxuICAvLy4gW11cbiAgLy8uXG4gIC8vLiA+IHplcm8oT2JqZWN0KVxuICAvLy4ge31cbiAgLy8uXG4gIC8vLiA+IHplcm8oTWF5YmUpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gemVybyh0eXBlUmVwKSB7XG4gICAgcmV0dXJuIFBsdXMubWV0aG9kcy56ZXJvKHR5cGVSZXApKCk7XG4gIH1cblxuICAvLyMgcmVkdWNlIDo6IEZvbGRhYmxlIGYgPT4gKChiLCBhKSAtPiBiLCBiLCBmIGEpIC0+IGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9yZWR1Y2VgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvcmVkdWNlYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIE9iamVjdC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHJlZHVjZSgoeHMsIHgpID0+IFt4XS5jb25jYXQoeHMpLCBbXSwgWzEsIDIsIDNdKVxuICAvLy4gWzMsIDIsIDFdXG4gIC8vLlxuICAvLy4gPiByZWR1Y2UoY29uY2F0LCAnJywgQ29ucygnZm9vJywgQ29ucygnYmFyJywgQ29ucygnYmF6JywgTmlsKSkpKVxuICAvLy4gJ2Zvb2JhcmJheidcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiByZWR1Y2UoZiwgeCwgZm9sZGFibGUpIHtcbiAgICByZXR1cm4gRm9sZGFibGUubWV0aG9kcy5yZWR1Y2UoZm9sZGFibGUpKGYsIHgpO1xuICB9XG5cbiAgLy8jIHNpemUgOjogRm9sZGFibGUgZiA9PiBmIGEgLT4gSW50ZWdlclxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgcmVkdWNlYF0oI3JlZHVjZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBzaXplKFtdKVxuICAvLy4gMFxuICAvLy5cbiAgLy8uID4gc2l6ZShbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAzXG4gIC8vLlxuICAvLy4gPiBzaXplKE5pbClcbiAgLy8uIDBcbiAgLy8uXG4gIC8vLiA+IHNpemUoQ29ucygnZm9vJywgQ29ucygnYmFyJywgQ29ucygnYmF6JywgTmlsKSkpKVxuICAvLy4gM1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNpemUoZm9sZGFibGUpIHtcbiAgICAvLyAgRmFzdCBwYXRoIGZvciBhcnJheXMuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm9sZGFibGUpKSByZXR1cm4gZm9sZGFibGUubGVuZ3RoO1xuICAgIHJldHVybiByZWR1Y2UoZnVuY3Rpb24obiwgXykgeyByZXR1cm4gbiArIDE7IH0sIDAsIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyBlbGVtIDo6IChTZXRvaWQgYSwgRm9sZGFibGUgZikgPT4gKGEsIGYgYSkgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFRha2VzIGEgdmFsdWUgYW5kIGEgc3RydWN0dXJlIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVcbiAgLy8uIHZhbHVlIGlzIGFuIGVsZW1lbnQgb2YgdGhlIHN0cnVjdHVyZTsgYGZhbHNlYCBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBkZXJpdmVkIGZyb20gW2BlcXVhbHNgXSgjZXF1YWxzKSBhbmRcbiAgLy8uIFtgcmVkdWNlYF0oI3JlZHVjZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBlbGVtKCdjJywgWydhJywgJ2InLCAnYyddKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gZWxlbSgneCcsIFsnYScsICdiJywgJ2MnXSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBlbGVtKDMsIHt4OiAxLCB5OiAyLCB6OiAzfSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVsZW0oOCwge3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IGVsZW0oMCwgSnVzdCgwKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IGVsZW0oMCwgSnVzdCgxKSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBlbGVtKDAsIE5vdGhpbmcpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGVsZW0oeCwgZm9sZGFibGUpIHtcbiAgICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uKGIsIHkpIHsgcmV0dXJuIGIgfHwgZXF1YWxzKHgsIHkpOyB9LFxuICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICAgICBmb2xkYWJsZSk7XG4gIH1cblxuICAvLyMgZm9sZE1hcCA6OiAoTW9ub2lkIG0sIEZvbGRhYmxlIGYpID0+IChUeXBlUmVwIG0sIGEgLT4gbSwgZiBhKSAtPiBtXG4gIC8vLlxuICAvLy4gRGVjb25zdHJ1Y3RzIGEgZm9sZGFibGUgYnkgbWFwcGluZyBldmVyeSBlbGVtZW50IHRvIGEgbW9ub2lkIGFuZFxuICAvLy4gY29uY2F0ZW5hdGluZyB0aGUgcmVzdWx0cy5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNvbmNhdGBdKCNjb25jYXQpLCBbYGVtcHR5YF0oI2VtcHR5KSxcbiAgLy8uIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZm9sZE1hcChTdHJpbmcsIGYgPT4gZi5uYW1lLCBbTWF0aC5zaW4sIE1hdGguY29zLCBNYXRoLnRhbl0pXG4gIC8vLiAnc2luY29zdGFuJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZvbGRNYXAodHlwZVJlcCwgZiwgZm9sZGFibGUpIHtcbiAgICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uKG1vbm9pZCwgeCkgeyByZXR1cm4gY29uY2F0KG1vbm9pZCwgZih4KSk7IH0sXG4gICAgICAgICAgICAgICAgICBlbXB0eSh0eXBlUmVwKSxcbiAgICAgICAgICAgICAgICAgIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyByZXZlcnNlIDo6IChBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBSZXZlcnNlcyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYGNvbmNhdGBdKCNjb25jYXQpLCBbYGVtcHR5YF0oI2VtcHR5KSxcbiAgLy8uIFtgb2ZgXSgjb2YpLCBhbmQgW2ByZWR1Y2VgXSgjcmVkdWNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHJldmVyc2UoWzEsIDIsIDNdKVxuICAvLy4gWzMsIDIsIDFdXG4gIC8vLlxuICAvLy4gPiByZXZlcnNlKENvbnMoMSwgQ29ucygyLCBDb25zKDMsIE5pbCkpKSlcbiAgLy8uIENvbnMoMywgQ29ucygyLCBDb25zKDEsIE5pbCkpKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJldmVyc2UoZm9sZGFibGUpIHtcbiAgICAvLyAgRmFzdCBwYXRoIGZvciBhcnJheXMuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm9sZGFibGUpKSByZXR1cm4gZm9sZGFibGUuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgdmFyIEYgPSBmb2xkYWJsZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gcmVkdWNlKGZ1bmN0aW9uKHhzLCB4KSB7IHJldHVybiBjb25jYXQob2YoRiwgeCksIHhzKTsgfSxcbiAgICAgICAgICAgICAgICAgIGVtcHR5KEYpLFxuICAgICAgICAgICAgICAgICAgZm9sZGFibGUpO1xuICB9XG5cbiAgLy8jIHNvcnQgOjogKE9yZCBhLCBBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBQZXJmb3JtcyBhIFtzdGFibGUgc29ydF1bXSBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZSxcbiAgLy8uIHVzaW5nIFtgbHRlYF0oI2x0ZSkgZm9yIGNvbXBhcmlzb25zLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSksIFtgY29uY2F0YF0oI2NvbmNhdCksXG4gIC8vLiBbYGVtcHR5YF0oI2VtcHR5KSwgW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc29ydEJ5YF0oI3NvcnRCeSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBzb3J0KFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uIFsnYmFyJywgJ2JheicsICdmb28nXVxuICAvLy5cbiAgLy8uID4gc29ydChbSnVzdCgyKSwgTm90aGluZywgSnVzdCgxKV0pXG4gIC8vLiBbTm90aGluZywgSnVzdCgxKSwgSnVzdCgyKV1cbiAgLy8uXG4gIC8vLiA+IHNvcnQoQ29ucygnZm9vJywgQ29ucygnYmFyJywgQ29ucygnYmF6JywgTmlsKSkpKVxuICAvLy4gQ29ucygnYmFyJywgQ29ucygnYmF6JywgQ29ucygnZm9vJywgTmlsKSkpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc29ydChmb2xkYWJsZSkge1xuICAgIHJldHVybiBzb3J0QnkoaWRlbnRpdHksIGZvbGRhYmxlKTtcbiAgfVxuXG4gIC8vIyBzb3J0QnkgOjogKE9yZCBiLCBBcHBsaWNhdGl2ZSBmLCBGb2xkYWJsZSBmLCBNb25vaWQgKGYgYSkpID0+IChhIC0+IGIsIGYgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gUGVyZm9ybXMgYSBbc3RhYmxlIHNvcnRdW10gb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUsXG4gIC8vLiB1c2luZyBbYGx0ZWBdKCNsdGUpIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBwcm9kdWNlZCBieSBhcHBseWluZyB0aGVcbiAgLy8uIGdpdmVuIGZ1bmN0aW9uIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgbHRlYF0oI2x0ZSksIFtgY29uY2F0YF0oI2NvbmNhdCksXG4gIC8vLiBbYGVtcHR5YF0oI2VtcHR5KSwgW2BvZmBdKCNvZiksIGFuZCBbYHJlZHVjZWBdKCNyZWR1Y2UpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc29ydGBdKCNzb3J0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBbJ3JlZCcsICdncmVlbicsICdibHVlJ10pXG4gIC8vLiBbJ3JlZCcsICdibHVlJywgJ2dyZWVuJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBbJ2JsYWNrJywgJ3doaXRlJ10pXG4gIC8vLiBbJ2JsYWNrJywgJ3doaXRlJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBbJ3doaXRlJywgJ2JsYWNrJ10pXG4gIC8vLiBbJ3doaXRlJywgJ2JsYWNrJ11cbiAgLy8uXG4gIC8vLiA+IHNvcnRCeShzID0+IHMubGVuZ3RoLCBDb25zKCdyZWQnLCBDb25zKCdncmVlbicsIENvbnMoJ2JsdWUnLCBOaWwpKSkpXG4gIC8vLiBDb25zKCdyZWQnLCBDb25zKCdibHVlJywgQ29ucygnZ3JlZW4nLCBOaWwpKSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzb3J0QnkoZiwgZm9sZGFibGUpIHtcbiAgICB2YXIgcnMgPSByZWR1Y2UoZnVuY3Rpb24ocnMsIHgpIHtcbiAgICAgIHJzLnB1c2goe2lkeDogcnMubGVuZ3RoLCB4OiB4LCBmeDogZih4KX0pO1xuICAgICAgcmV0dXJuIHJzO1xuICAgIH0sIFtdLCBmb2xkYWJsZSk7XG5cbiAgICB2YXIgbHRlXyA9IChmdW5jdGlvbihyKSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiAociAmJiByLmZ4KSkge1xuICAgICAgICBjYXNlICdudW1iZXInOiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHsgcmV0dXJuIHggPD0geSB8fCB4ICE9PSB4OyB9O1xuICAgICAgICBjYXNlICdzdHJpbmcnOiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHsgcmV0dXJuIHggPD0geTsgfTtcbiAgICAgICAgZGVmYXVsdDogICAgICAgIHJldHVybiBsdGU7XG4gICAgICB9XG4gICAgfShyc1swXSkpO1xuXG4gICAgcnMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gbHRlXyhhLmZ4LCBiLmZ4KSA/IGx0ZV8oYi5meCwgYS5meCkgPyBhLmlkeCAtIGIuaWR4IDogLTEgOiAxO1xuICAgIH0pO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm9sZGFibGUpKSB7XG4gICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBycy5sZW5ndGg7IGlkeCArPSAxKSByc1tpZHhdID0gcnNbaWR4XS54O1xuICAgICAgcmV0dXJuIHJzO1xuICAgIH1cblxuICAgIHZhciBGID0gZm9sZGFibGUuY29uc3RydWN0b3I7XG4gICAgdmFyIHJlc3VsdCA9IGVtcHR5KEYpO1xuICAgIGZvciAoaWR4ID0gMDsgaWR4IDwgcnMubGVuZ3RoOyBpZHggKz0gMSkge1xuICAgICAgcmVzdWx0ID0gY29uY2F0KHJlc3VsdCwgb2YoRiwgcnNbaWR4XS54KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyMgdHJhdmVyc2UgOjogKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChUeXBlUmVwIGYsIGEgLT4gZiBiLCB0IGEpIC0+IGYgKHQgYilcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC90cmF2ZXJzZWBdW10uXG4gIC8vLlxuICAvLy4gYGZhbnRhc3ktbGFuZC90cmF2ZXJzZWAgaW1wbGVtZW50YXRpb25zIGFyZSBwcm92aWRlZCBmb3IgdGhlIGZvbGxvd2luZ1xuICAvLy4gYnVpbHQtaW4gdHlwZXM6IEFycmF5IGFuZCBPYmplY3QuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BzZXF1ZW5jZWBdKCNzZXF1ZW5jZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0cmF2ZXJzZShBcnJheSwgeCA9PiB4LCBbWzEsIDIsIDNdLCBbNCwgNV1dKVxuICAvLy4gW1sxLCA0XSwgWzEsIDVdLCBbMiwgNF0sIFsyLCA1XSwgWzMsIDRdLCBbMywgNV1dXG4gIC8vLlxuICAvLy4gPiB0cmF2ZXJzZShJZGVudGl0eSwgeCA9PiBJZGVudGl0eSh4ICsgMSksIFsxLCAyLCAzXSlcbiAgLy8uIElkZW50aXR5KFsyLCAzLCA0XSlcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB0cmF2ZXJzZSh0eXBlUmVwLCBmLCB0cmF2ZXJzYWJsZSkge1xuICAgIHJldHVybiBUcmF2ZXJzYWJsZS5tZXRob2RzLnRyYXZlcnNlKHRyYXZlcnNhYmxlKSh0eXBlUmVwLCBmKTtcbiAgfVxuXG4gIC8vIyBzZXF1ZW5jZSA6OiAoQXBwbGljYXRpdmUgZiwgVHJhdmVyc2FibGUgdCkgPT4gKFR5cGVSZXAgZiwgdCAoZiBhKSkgLT4gZiAodCBhKVxuICAvLy5cbiAgLy8uIEludmVydHMgdGhlIGdpdmVuIGB0IChmIGEpYCB0byBwcm9kdWNlIGFuIGBmICh0IGEpYC5cbiAgLy8uXG4gIC8vLiBUaGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBbYHRyYXZlcnNlYF0oI3RyYXZlcnNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IHNlcXVlbmNlKEFycmF5LCBJZGVudGl0eShbMSwgMiwgM10pKVxuICAvLy4gW0lkZW50aXR5KDEpLCBJZGVudGl0eSgyKSwgSWRlbnRpdHkoMyldXG4gIC8vLlxuICAvLy4gPiBzZXF1ZW5jZShJZGVudGl0eSwgW0lkZW50aXR5KDEpLCBJZGVudGl0eSgyKSwgSWRlbnRpdHkoMyldKVxuICAvLy4gSWRlbnRpdHkoWzEsIDIsIDNdKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNlcXVlbmNlKHR5cGVSZXAsIHRyYXZlcnNhYmxlKSB7XG4gICAgcmV0dXJuIHRyYXZlcnNlKHR5cGVSZXAsIGlkZW50aXR5LCB0cmF2ZXJzYWJsZSk7XG4gIH1cblxuICAvLyMgZXh0ZW5kIDo6IEV4dGVuZCB3ID0+ICh3IGEgLT4gYiwgdyBhKSAtPiB3IGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9leHRlbmRgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvZXh0ZW5kYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogQXJyYXkgYW5kIEZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZXh0ZW5kKHNzID0+IHNzLmpvaW4oJycpLCBbJ3gnLCAneScsICd6J10pXG4gIC8vLiBbJ3h5eicsICd5eicsICd6J11cbiAgLy8uXG4gIC8vLiA+IGV4dGVuZChmID0+IGYoWzMsIDRdKSwgcmV2ZXJzZSkoWzEsIDJdKVxuICAvLy4gWzQsIDMsIDIsIDFdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZXh0ZW5kKGYsIGV4dGVuZF8pIHtcbiAgICByZXR1cm4gRXh0ZW5kLm1ldGhvZHMuZXh0ZW5kKGV4dGVuZF8pKGYpO1xuICB9XG5cbiAgLy8jIGR1cGxpY2F0ZSA6OiBFeHRlbmQgdyA9PiB3IGEgLT4gdyAodyBhKVxuICAvLy5cbiAgLy8uIEFkZHMgb25lIGxldmVsIG9mIG5lc3RpbmcgdG8gYSBjb21vbmFkaWMgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFRoaXMgZnVuY3Rpb24gaXMgZGVyaXZlZCBmcm9tIFtgZXh0ZW5kYF0oI2V4dGVuZCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBkdXBsaWNhdGUoSWRlbnRpdHkoMSkpXG4gIC8vLiBJZGVudGl0eShJZGVudGl0eSgxKSlcbiAgLy8uXG4gIC8vLiA+IGR1cGxpY2F0ZShbMV0pXG4gIC8vLiBbWzFdXVxuICAvLy5cbiAgLy8uID4gZHVwbGljYXRlKFsxLCAyLCAzXSlcbiAgLy8uIFtbMSwgMiwgM10sIFsyLCAzXSwgWzNdXVxuICAvLy5cbiAgLy8uID4gZHVwbGljYXRlKHJldmVyc2UpKFsxLCAyXSkoWzMsIDRdKVxuICAvLy4gWzQsIDMsIDIsIDFdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZHVwbGljYXRlKGV4dGVuZF8pIHtcbiAgICByZXR1cm4gZXh0ZW5kKGlkZW50aXR5LCBleHRlbmRfKTtcbiAgfVxuXG4gIC8vIyBleHRyYWN0IDo6IENvbW9uYWQgdyA9PiB3IGEgLT4gYVxuICAvLy5cbiAgLy8uIEZ1bmN0aW9uIHdyYXBwZXIgZm9yIFtgZmFudGFzeS1sYW5kL2V4dHJhY3RgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZXh0cmFjdChJZGVudGl0eSg0MikpXG4gIC8vLiA0MlxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGV4dHJhY3QoY29tb25hZCkge1xuICAgIHJldHVybiBDb21vbmFkLm1ldGhvZHMuZXh0cmFjdChjb21vbmFkKSgpO1xuICB9XG5cbiAgLy8jIGNvbnRyYW1hcCA6OiBDb250cmF2YXJpYW50IGYgPT4gKGIgLT4gYSwgZiBhKSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBGdW5jdGlvbiB3cmFwcGVyIGZvciBbYGZhbnRhc3ktbGFuZC9jb250cmFtYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBmYW50YXN5LWxhbmQvY29udHJhbWFwYCBpbXBsZW1lbnRhdGlvbnMgYXJlIHByb3ZpZGVkIGZvciB0aGUgZm9sbG93aW5nXG4gIC8vLiBidWlsdC1pbiB0eXBlczogRnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBjb250cmFtYXAocyA9PiBzLmxlbmd0aCwgTWF0aC5zcXJ0KSgnU2FuY3R1YXJ5JylcbiAgLy8uIDNcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBjb250cmFtYXAoZiwgY29udHJhdmFyaWFudCkge1xuICAgIHJldHVybiBDb250cmF2YXJpYW50Lm1ldGhvZHMuY29udHJhbWFwKGNvbnRyYXZhcmlhbnQpKGYpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBUeXBlQ2xhc3M6IFR5cGVDbGFzcyxcbiAgICBTZXRvaWQ6IFNldG9pZCxcbiAgICBPcmQ6IE9yZCxcbiAgICBTZW1pZ3JvdXBvaWQ6IFNlbWlncm91cG9pZCxcbiAgICBDYXRlZ29yeTogQ2F0ZWdvcnksXG4gICAgU2VtaWdyb3VwOiBTZW1pZ3JvdXAsXG4gICAgTW9ub2lkOiBNb25vaWQsXG4gICAgR3JvdXA6IEdyb3VwLFxuICAgIEZpbHRlcmFibGU6IEZpbHRlcmFibGUsXG4gICAgRnVuY3RvcjogRnVuY3RvcixcbiAgICBCaWZ1bmN0b3I6IEJpZnVuY3RvcixcbiAgICBQcm9mdW5jdG9yOiBQcm9mdW5jdG9yLFxuICAgIEFwcGx5OiBBcHBseSxcbiAgICBBcHBsaWNhdGl2ZTogQXBwbGljYXRpdmUsXG4gICAgQ2hhaW46IENoYWluLFxuICAgIENoYWluUmVjOiBDaGFpblJlYyxcbiAgICBNb25hZDogTW9uYWQsXG4gICAgQWx0OiBBbHQsXG4gICAgUGx1czogUGx1cyxcbiAgICBBbHRlcm5hdGl2ZTogQWx0ZXJuYXRpdmUsXG4gICAgRm9sZGFibGU6IEZvbGRhYmxlLFxuICAgIFRyYXZlcnNhYmxlOiBUcmF2ZXJzYWJsZSxcbiAgICBFeHRlbmQ6IEV4dGVuZCxcbiAgICBDb21vbmFkOiBDb21vbmFkLFxuICAgIENvbnRyYXZhcmlhbnQ6IENvbnRyYXZhcmlhbnQsXG4gICAgZXF1YWxzOiBlcXVhbHMsXG4gICAgbHQ6IGx0LFxuICAgIGx0ZTogbHRlLFxuICAgIGd0OiBndCxcbiAgICBndGU6IGd0ZSxcbiAgICBtaW46IG1pbixcbiAgICBtYXg6IG1heCxcbiAgICBjb21wb3NlOiBjb21wb3NlLFxuICAgIGlkOiBpZCxcbiAgICBjb25jYXQ6IGNvbmNhdCxcbiAgICBlbXB0eTogZW1wdHksXG4gICAgaW52ZXJ0OiBpbnZlcnQsXG4gICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgcmVqZWN0OiByZWplY3QsXG4gICAgbWFwOiBtYXAsXG4gICAgZmxpcDogZmxpcCxcbiAgICBiaW1hcDogYmltYXAsXG4gICAgbWFwTGVmdDogbWFwTGVmdCxcbiAgICBwcm9tYXA6IHByb21hcCxcbiAgICBhcDogYXAsXG4gICAgbGlmdDI6IGxpZnQyLFxuICAgIGxpZnQzOiBsaWZ0MyxcbiAgICBhcEZpcnN0OiBhcEZpcnN0LFxuICAgIGFwU2Vjb25kOiBhcFNlY29uZCxcbiAgICBvZjogb2YsXG4gICAgYXBwZW5kOiBhcHBlbmQsXG4gICAgcHJlcGVuZDogcHJlcGVuZCxcbiAgICBjaGFpbjogY2hhaW4sXG4gICAgam9pbjogam9pbixcbiAgICBjaGFpblJlYzogY2hhaW5SZWMsXG4gICAgYWx0OiBhbHQsXG4gICAgemVybzogemVybyxcbiAgICByZWR1Y2U6IHJlZHVjZSxcbiAgICBzaXplOiBzaXplLFxuICAgIGVsZW06IGVsZW0sXG4gICAgZm9sZE1hcDogZm9sZE1hcCxcbiAgICByZXZlcnNlOiByZXZlcnNlLFxuICAgIHNvcnQ6IHNvcnQsXG4gICAgc29ydEJ5OiBzb3J0QnksXG4gICAgdGFrZVdoaWxlOiB0YWtlV2hpbGUsXG4gICAgZHJvcFdoaWxlOiBkcm9wV2hpbGUsXG4gICAgdHJhdmVyc2U6IHRyYXZlcnNlLFxuICAgIHNlcXVlbmNlOiBzZXF1ZW5jZSxcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBkdXBsaWNhdGU6IGR1cGxpY2F0ZSxcbiAgICBleHRyYWN0OiBleHRyYWN0LFxuICAgIGNvbnRyYW1hcDogY29udHJhbWFwXG4gIH07XG5cbn0pKTtcblxuLy8uIFtBbHRdOiAgICAgICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhbHRcbi8vLiBbQWx0ZXJuYXRpdmVdOiAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYWx0ZXJuYXRpdmVcbi8vLiBbQXBwbGljYXRpdmVdOiAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbGljYXRpdmVcbi8vLiBbQXBwbHldOiAgICAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbHlcbi8vLiBbQmlmdW5jdG9yXTogICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYmlmdW5jdG9yXG4vLy4gW0NhdGVnb3J5XTogICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NhdGVnb3J5XG4vLy4gW0NoYWluXTogICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWluXG4vLy4gW0NoYWluUmVjXTogICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWlucmVjXG4vLy4gW0NvbW9uYWRdOiAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NvbW9uYWRcbi8vLiBbQ29udHJhdmFyaWFudF06ICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY29udHJhdmFyaWFudFxuLy8uIFtFeHRlbmRdOiAgICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNleHRlbmRcbi8vLiBbRkxdOiAgICAgICAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmRcbi8vLiBbRmlsdGVyYWJsZV06ICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZmlsdGVyYWJsZVxuLy8uIFtGb2xkYWJsZV06ICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNmb2xkYWJsZVxuLy8uIFtGdW5jdG9yXTogICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNmdW5jdG9yXG4vLy4gW0dyb3VwXTogICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2dyb3VwXG4vLy4gW01vbmFkXTogICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21vbmFkXG4vLy4gW01vbm9pZF06ICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21vbm9pZFxuLy8uIFtPcmRdOiAgICAgICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNvcmRcbi8vLiBbUGx1c106ICAgICAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjcGx1c1xuLy8uIFtQcm9mdW5jdG9yXTogICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNwcm9mdW5jdG9yXG4vLy4gW1NlbWlncm91cF06ICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3NlbWlncm91cFxuLy8uIFtTZW1pZ3JvdXBvaWRdOiAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZW1pZ3JvdXBvaWRcbi8vLiBbU2V0b2lkXTogICAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjc2V0b2lkXG4vLy4gW1RyYXZlcnNhYmxlXTogICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNhYmxlXG4vLy4gW2BmYW50YXN5LWxhbmQvYWx0YF06ICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FsdC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9hcGBdOiAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXAtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvYmltYXBgXTogICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2JpbWFwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2NoYWluYF06ICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbi1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9jaGFpblJlY2BdOiAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY2hhaW5yZWMtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvY29tcG9zZWBdOiAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NvbXBvc2UtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvY29uY2F0YF06ICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NvbmNhdC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9jb250cmFtYXBgXTogdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjY29udHJhbWFwLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2VtcHR5YF06ICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNlbXB0eS1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9lcXVhbHNgXTogICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjZXF1YWxzLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL2V4dGVuZGBdOiAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNleHRlbmQtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvZXh0cmFjdGBdOiAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2V4dHJhY3QtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvZmlsdGVyYF06ICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2ZpbHRlci1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9pZGBdOiAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjaWQtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvaW52ZXJ0YF06ICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2ludmVydC1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC9sdGVgXTogICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjbHRlLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL21hcGBdOiAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNtYXAtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvb2ZgXTogICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI29mLW1ldGhvZFxuLy8uIFtgZmFudGFzeS1sYW5kL3Byb21hcGBdOiAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNwcm9tYXAtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvcmVkdWNlYF06ICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3JlZHVjZS1tZXRob2Rcbi8vLiBbYGZhbnRhc3ktbGFuZC90cmF2ZXJzZWBdOiAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHJhdmVyc2UtbWV0aG9kXG4vLy4gW2BmYW50YXN5LWxhbmQvemVyb2BdOiAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3plcm8tbWV0aG9kXG4vLy4gW3N0YWJsZSBzb3J0XTogICAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NvcnRpbmdfYWxnb3JpdGhtI1N0YWJpbGl0eVxuLy8uIFt0eXBlLWNsYXNzZXNdOiAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1kZWYjdHlwZS1jbGFzc2VzXG4iLCIvKlxuICAgICAgICBAQEBAQEBAICAgICAgICAgICAgQEBAQEBAQCAgICAgICAgIEBAXG4gICAgICBAQCAgICAgICBAQCAgICAgICAgQEAgICAgICAgQEAgICAgICBAQEBcbiAgICBAQCAgIEBAQCBAQCAgQEAgICAgQEAgICBAQEAgQEAgIEBAICAgQEBAQEBAIEBAICAgQEBAICBAQCBAQEAgICAgICBAQEBAXG4gICBAQCAgQEAgICBAQEAgICBAQCAgQEAgIEBAICAgQEBAICAgQEAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQCAgIEBAXG4gICBAQCAgQEAgICBAQEAgICBAQCAgQEAgIEBAICAgQEBAICAgQEAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQEBAQEBAXG4gICBAQCAgQEAgICBAQEAgIEBAICAgQEAgIEBAICAgQEBAICBAQCAgICBAQEAgICBAQCAgIEBAQCAgQEBAICAgQEAgIEBAQFxuICAgIEBAICAgQEBAIEBAQEBAICAgICBAQCAgIEBAQCBAQEBAQCAgICAgIEBAQCAgICBAQEAgQEAgIEBAQEBAQCAgICAgIEBAQEBAXG4gICAgICBAQCAgICAgICAgICAgICAgICAgQEAgICAgICAgICAgICAgICAgICAgICAgICAgICBAQCAgQEBcbiAgICAgICAgQEBAQEBAQCAgICAgICAgICAgIEBAQEBAQEAgICAgICAgICAgICAgICBAQEBAQCAgICBAQFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4vLy4gIyBzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVyc1xuLy8uXG4vLy4gQSB0eXBlIGlzIGEgc2V0IG9mIHZhbHVlcy4gQm9vbGVhbiwgZm9yIGV4YW1wbGUsIGlzIHRoZSB0eXBlIGNvbXByaXNpbmdcbi8vLiBgdHJ1ZWAgYW5kIGBmYWxzZWAuIEEgdmFsdWUgbWF5IGJlIGEgbWVtYmVyIG9mIG11bHRpcGxlIHR5cGVzIChgNDJgIGlzIGFcbi8vLiBtZW1iZXIgb2YgTnVtYmVyLCBQb3NpdGl2ZU51bWJlciwgSW50ZWdlciwgYW5kIG1hbnkgb3RoZXIgdHlwZXMpLlxuLy8uXG4vLy4gSW4gY2VydGFpbiBzaXR1YXRpb25zIGl0IGlzIHVzZWZ1bCB0byBkaXZpZGUgSmF2YVNjcmlwdCB2YWx1ZXMgaW50b1xuLy8uIG5vbi1vdmVybGFwcGluZyB0eXBlcy4gVGhlIGxhbmd1YWdlIHByb3ZpZGVzIHR3byBjb25zdHJ1Y3RzIGZvciB0aGlzXG4vLy4gcHVycG9zZTogdGhlIFtgdHlwZW9mYF1bMV0gb3BlcmF0b3IgYW5kIFtgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2BdWzJdLlxuLy8uIEVhY2ggaGFzIHByb3MgYW5kIGNvbnMsIGJ1dCBuZWl0aGVyIHN1cHBvcnRzIHVzZXItZGVmaW5lZCB0eXBlcy5cbi8vLlxuLy8uIFRoaXMgcGFja2FnZSBzcGVjaWZpZXMgYW4gW2FsZ29yaXRobV1bM10gZm9yIGRlcml2aW5nIGEgX3R5cGUgaWRlbnRpZmllcl9cbi8vLiBmcm9tIGFueSBKYXZhU2NyaXB0IHZhbHVlLCBhbmQgZXhwb3J0cyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYWxnb3JpdGhtLlxuLy8uIEF1dGhvcnMgb2YgYWxnZWJyYWljIGRhdGEgdHlwZXMgbWF5IGZvbGxvdyB0aGlzIHNwZWNpZmljYXRpb24gaW4gb3JkZXIgdG9cbi8vLiBtYWtlIHRoZWlyIGRhdGEgdHlwZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBhbGdvcml0aG0uXG4vLy5cbi8vLiAjIyMgQWxnb3JpdGhtXG4vLy5cbi8vLiAxLiAgVGFrZSBhbnkgSmF2YVNjcmlwdCB2YWx1ZSBgeGAuXG4vLy5cbi8vLiAyLiAgSWYgYHhgIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgZ28gdG8gc3RlcCA2LlxuLy8uXG4vLy4gMy4gIElmIGB4LmNvbnN0cnVjdG9yYCBldmFsdWF0ZXMgdG8gYG51bGxgIG9yIGB1bmRlZmluZWRgLCBnbyB0byBzdGVwIDYuXG4vLy5cbi8vLiA0LiAgSWYgYHguY29uc3RydWN0b3IucHJvdG90eXBlID09PSB4YCwgZ28gdG8gc3RlcCA2LiBUaGlzIGNoZWNrIHByZXZlbnRzIGFcbi8vLiAgICAgcHJvdG90eXBlIG9iamVjdCBmcm9tIGJlaW5nIGNvbnNpZGVyZWQgYSBtZW1iZXIgb2YgaXRzIGFzc29jaWF0ZWQgdHlwZS5cbi8vLlxuLy8uIDUuICBJZiBgdHlwZW9mIHguY29uc3RydWN0b3JbJ0BAdHlwZSddYCBldmFsdWF0ZXMgdG8gYCdzdHJpbmcnYCwgcmV0dXJuXG4vLy4gICAgIHRoZSB2YWx1ZSBvZiBgeC5jb25zdHJ1Y3RvclsnQEB0eXBlJ11gLlxuLy8uXG4vLy4gNi4gIFJldHVybiB0aGUgW2BPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYF1bMl0gcmVwcmVzZW50YXRpb24gb2YgYHhgXG4vLy4gICAgIHdpdGhvdXQgdGhlIGxlYWRpbmcgYCdbb2JqZWN0ICdgIGFuZCB0cmFpbGluZyBgJ10nYC5cbi8vLlxuLy8uICMjIyBDb21wYXRpYmlsaXR5XG4vLy5cbi8vLiBGb3IgYW4gYWxnZWJyYWljIGRhdGEgdHlwZSB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIFthbGdvcml0aG1dWzNdOlxuLy8uXG4vLy4gICAtIGV2ZXJ5IG1lbWJlciBvZiB0aGUgdHlwZSBtdXN0IGhhdmUgYSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHBvaW50aW5nXG4vLy4gICAgIHRvIGFuIG9iamVjdCBrbm93biBhcyB0aGUgX3R5cGUgcmVwcmVzZW50YXRpdmVfO1xuLy8uXG4vLy4gICAtIHRoZSB0eXBlIHJlcHJlc2VudGF0aXZlIG11c3QgaGF2ZSBhIGBAQHR5cGVgIHByb3BlcnR5OyBhbmRcbi8vLlxuLy8uICAgLSB0aGUgdHlwZSByZXByZXNlbnRhdGl2ZSdzIGBAQHR5cGVgIHByb3BlcnR5ICh0aGUgX3R5cGUgaWRlbnRpZmllcl8pXG4vLy4gICAgIG11c3QgYmUgYSBzdHJpbmcgcHJpbWl0aXZlLCBpZGVhbGx5IGAnPG5wbS1wYWNrYWdlLW5hbWU+Lzx0eXBlLW5hbWU+J2AuXG4vLy5cbi8vLiBGb3IgZXhhbXBsZTpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiAvLyAgSWRlbnRpdHkgOjogYSAtPiBJZGVudGl0eSBhXG4vLy4gZnVuY3Rpb24gSWRlbnRpdHkoeCkge1xuLy8uICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIElkZW50aXR5KSkgcmV0dXJuIG5ldyBJZGVudGl0eSh4KTtcbi8vLiAgIHRoaXMudmFsdWUgPSB4O1xuLy8uIH1cbi8vLlxuLy8uIElkZW50aXR5WydAQHR5cGUnXSA9ICdteS1wYWNrYWdlL0lkZW50aXR5Jztcbi8vLiBgYGBcbi8vLlxuLy8uIE5vdGUgdGhhdCBieSB1c2luZyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGlzIHNldFxuLy8uIGltcGxpY2l0bHkgZm9yIGVhY2ggdmFsdWUgY3JlYXRlZC4gQ29uc3RydWN0b3IgZnVuY3Rpb25zIGFyZSBjb252ZW5pZW50IGZvclxuLy8uIHRoaXMgcmVhc29uLCBidXQgYXJlIG5vdCByZXF1aXJlZC4gVGhpcyBkZWZpbml0aW9uIGlzIGFsc28gdmFsaWQ6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gIElkZW50aXR5VHlwZVJlcCA6OiBUeXBlUmVwIElkZW50aXR5XG4vLy4gdmFyIElkZW50aXR5VHlwZVJlcCA9IHtcbi8vLiAgICdAQHR5cGUnOiAnbXktcGFja2FnZS9JZGVudGl0eSdcbi8vLiB9O1xuLy8uXG4vLy4gLy8gIElkZW50aXR5IDo6IGEgLT4gSWRlbnRpdHkgYVxuLy8uIGZ1bmN0aW9uIElkZW50aXR5KHgpIHtcbi8vLiAgIHJldHVybiB7Y29uc3RydWN0b3I6IElkZW50aXR5VHlwZVJlcCwgdmFsdWU6IHh9O1xuLy8uIH1cbi8vLiBgYGBcbi8vLlxuLy8uICMjIyBVc2FnZVxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIHZhciBJZGVudGl0eSA9IHJlcXVpcmUoJ215LXBhY2thZ2UnKS5JZGVudGl0eTtcbi8vLiB2YXIgdHlwZSA9IHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJyk7XG4vLy5cbi8vLiB0eXBlKG51bGwpOyAgICAgICAgIC8vID0+ICdOdWxsJ1xuLy8uIHR5cGUodHJ1ZSk7ICAgICAgICAgLy8gPT4gJ0Jvb2xlYW4nXG4vLy4gdHlwZShbMSwgMiwgM10pOyAgICAvLyA9PiAnQXJyYXknXG4vLy4gdHlwZShJZGVudGl0eSk7ICAgICAvLyA9PiAnRnVuY3Rpb24nXG4vLy4gdHlwZShJZGVudGl0eSgwKSk7ICAvLyA9PiAnbXktcGFja2FnZS9JZGVudGl0eSdcbi8vLiBgYGBcbi8vLlxuLy8uXG4vLy4gWzFdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvdHlwZW9mXG4vLy4gWzJdOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdG9TdHJpbmdcbi8vLiBbM106ICNhbGdvcml0aG1cblxuKGZ1bmN0aW9uKGYpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGYoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgIT0gbnVsbCkge1xuICAgIGRlZmluZShbXSwgZik7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zYW5jdHVhcnlUeXBlSWRlbnRpZmllcnMgPSBmKCk7XG4gIH1cblxufShmdW5jdGlvbigpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLy8gICQkdHlwZSA6OiBTdHJpbmdcbiAgdmFyICQkdHlwZSA9ICdAQHR5cGUnO1xuXG4gIC8vICB0eXBlIDo6IEFueSAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gdHlwZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJlxuICAgICAgICAgICB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiZcbiAgICAgICAgICAgeC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgIT09IHggJiZcbiAgICAgICAgICAgdHlwZW9mIHguY29uc3RydWN0b3JbJCR0eXBlXSA9PT0gJ3N0cmluZycgP1xuICAgICAgeC5jb25zdHJ1Y3RvclskJHR5cGVdIDpcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KS5zbGljZSgnW29iamVjdCAnLmxlbmd0aCwgLSddJy5sZW5ndGgpO1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG5cbn0pKTtcbiIsIi8qXG4gICAgICAgIEBAQEBAQEAgICAgICAgICAgICBAQEBAQEBAICAgICAgICAgQEBcbiAgICAgIEBAICAgICAgIEBAICAgICAgICBAQCAgICAgICBAQCAgICAgIEBAQFxuICAgIEBAICAgQEBAIEBAICBAQCAgICBAQCAgIEBAQCBAQCAgQEAgICBAQEBAQEAgQEAgICBAQEAgIEBAIEBAQCAgICAgIEBAQEBcbiAgIEBAICBAQCAgIEBAQCAgIEBAICBAQCAgQEAgICBAQEAgICBAQCAgIEBAQCAgIEBAICAgQEBAICBAQEAgICBAQCAgQEBAICAgQEBcbiAgIEBAICBAQCAgIEBAQCAgIEBAICBAQCAgQEAgICBAQEAgICBAQCAgIEBAQCAgIEBAICAgQEBAICBAQEAgICBAQCAgQEBAQEBAQEBcbiAgIEBAICBAQCAgIEBAQCAgQEAgICBAQCAgQEAgICBAQEAgIEBAICAgIEBAQCAgIEBAICAgQEBAICBAQEAgICBAQCAgQEBAXG4gICAgQEAgICBAQEAgQEBAQEAgICAgIEBAICAgQEBAIEBAQEBAICAgICAgQEBAICAgIEBAQCBAQCAgQEBAQEBAICAgICAgQEBAQEBcbiAgICAgIEBAICAgICAgICAgICAgICAgICBAQCAgICAgICAgICAgICAgICAgICAgICAgICAgIEBAICBAQFxuICAgICAgICBAQEBAQEBAICAgICAgICAgICAgQEBAQEBAQCAgICAgICAgICAgICAgIEBAQEBAICAgIEBAXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8vLiAjIHNhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzXG4vLy5cbi8vLiBBIHR5cGUgaXMgYSBzZXQgb2YgdmFsdWVzLiBCb29sZWFuLCBmb3IgZXhhbXBsZSwgaXMgdGhlIHR5cGUgY29tcHJpc2luZ1xuLy8uIGB0cnVlYCBhbmQgYGZhbHNlYC4gQSB2YWx1ZSBtYXkgYmUgYSBtZW1iZXIgb2YgbXVsdGlwbGUgdHlwZXMgKGA0MmAgaXMgYVxuLy8uIG1lbWJlciBvZiBOdW1iZXIsIFBvc2l0aXZlTnVtYmVyLCBJbnRlZ2VyLCBhbmQgbWFueSBvdGhlciB0eXBlcykuXG4vLy5cbi8vLiBJbiBjZXJ0YWluIHNpdHVhdGlvbnMgaXQgaXMgdXNlZnVsIHRvIGRpdmlkZSBKYXZhU2NyaXB0IHZhbHVlcyBpbnRvXG4vLy4gbm9uLW92ZXJsYXBwaW5nIHR5cGVzLiBUaGUgbGFuZ3VhZ2UgcHJvdmlkZXMgdHdvIGNvbnN0cnVjdHMgZm9yIHRoaXNcbi8vLiBwdXJwb3NlOiB0aGUgW2B0eXBlb2ZgXVsxXSBvcGVyYXRvciBhbmQgW2BPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYF1bMl0uXG4vLy4gRWFjaCBoYXMgcHJvcyBhbmQgY29ucywgYnV0IG5laXRoZXIgc3VwcG9ydHMgdXNlci1kZWZpbmVkIHR5cGVzLlxuLy8uXG4vLy4gc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMgY29tcHJpc2VzOlxuLy8uXG4vLy4gICAtIGFuIG5wbSBhbmQgYnJvd3NlciAtY29tcGF0aWJsZSBwYWNrYWdlIGZvciBkZXJpdmluZyB0aGVcbi8vLiAgICAgX3R5cGUgaWRlbnRpZmllcl8gb2YgYSBKYXZhU2NyaXB0IHZhbHVlOyBhbmRcbi8vLiAgIC0gYSBzcGVjaWZpY2F0aW9uIHdoaWNoIGF1dGhvcnMgbWF5IGZvbGxvdyB0byBzcGVjaWZ5IHR5cGVcbi8vLiAgICAgaWRlbnRpZmllcnMgZm9yIHRoZWlyIHR5cGVzLlxuLy8uXG4vLy4gIyMjIFNwZWNpZmljYXRpb25cbi8vLlxuLy8uIEZvciBhIHR5cGUgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoZSBhbGdvcml0aG06XG4vLy5cbi8vLiAgIC0gZXZlcnkgbWVtYmVyIG9mIHRoZSB0eXBlIE1VU1QgaGF2ZSBhIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHlcbi8vLiAgICAgcG9pbnRpbmcgdG8gYW4gb2JqZWN0IGtub3duIGFzIHRoZSBfdHlwZSByZXByZXNlbnRhdGl2ZV87XG4vLy5cbi8vLiAgIC0gdGhlIHR5cGUgcmVwcmVzZW50YXRpdmUgTVVTVCBoYXZlIGEgYEBAdHlwZWAgcHJvcGVydHlcbi8vLiAgICAgKHRoZSBfdHlwZSBpZGVudGlmaWVyXyk7IGFuZFxuLy8uXG4vLy4gICAtIHRoZSB0eXBlIGlkZW50aWZpZXIgTVVTVCBiZSBhIHN0cmluZyBwcmltaXRpdmUgYW5kIFNIT1VMRCBoYXZlXG4vLy4gICAgIGZvcm1hdCBgJzxuYW1lc3BhY2U+LzxuYW1lPltAPHZlcnNpb24+XSdgLCB3aGVyZTpcbi8vLlxuLy8uICAgICAgIC0gYDxuYW1lc3BhY2U+YCBNVVNUIGNvbnNpc3Qgb2Ygb25lIG9yIG1vcmUgY2hhcmFjdGVycywgYW5kXG4vLy4gICAgICAgICBTSE9VTEQgZXF1YWwgdGhlIG5hbWUgb2YgdGhlIG5wbSBwYWNrYWdlIHdoaWNoIGRlZmluZXMgdGhlXG4vLy4gICAgICAgICB0eXBlIChpbmNsdWRpbmcgW3Njb3BlXVszXSB3aGVyZSBhcHByb3ByaWF0ZSk7XG4vLy5cbi8vLiAgICAgICAtIGA8bmFtZT5gIE1VU1QgY29uc2lzdCBvZiBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzLCBhbmQgU0hPVUxEXG4vLy4gICAgICAgICBiZSB0aGUgdW5pcXVlIG5hbWUgb2YgdGhlIHR5cGU7IGFuZFxuLy8uXG4vLy4gICAgICAgLSBgPHZlcnNpb24+YCBNVVNUIGNvbnNpc3Qgb2Ygb25lIG9yIG1vcmUgZGlnaXRzLCBhbmQgU0hPVUxEXG4vLy4gICAgICAgICByZXByZXNlbnQgdGhlIHZlcnNpb24gb2YgdGhlIHR5cGUuXG4vLy5cbi8vLiBJZiB0aGUgdHlwZSBpZGVudGlmaWVyIGRvZXMgbm90IGNvbmZvcm0gdG8gdGhlIGZvcm1hdCBzcGVjaWZpZWQgYWJvdmUsXG4vLy4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBlbnRpcmUgc3RyaW5nIHJlcHJlc2VudHMgdGhlIF9uYW1lXyBvZiB0aGUgdHlwZTtcbi8vLiBfbmFtZXNwYWNlXyB3aWxsIGJlIGBudWxsYCBhbmQgX3ZlcnNpb25fIHdpbGwgYmUgYDBgLlxuLy8uXG4vLy4gSWYgdGhlIF92ZXJzaW9uXyBpcyBub3QgZ2l2ZW4sIGl0IGlzIGFzc3VtZWQgdG8gYmUgYDBgLlxuLy8uXG4vLy4gRm9yIGV4YW1wbGU6XG4vLy5cbi8vLiBgYGBqYXZhc2NyaXB0XG4vLy4gLy8gIElkZW50aXR5IDo6IGEgLT4gSWRlbnRpdHkgYVxuLy8uIGZ1bmN0aW9uIElkZW50aXR5KHgpIHtcbi8vLiAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJZGVudGl0eSkpIHJldHVybiBuZXcgSWRlbnRpdHkoeCk7XG4vLy4gICB0aGlzLnZhbHVlID0geDtcbi8vLiB9XG4vLy5cbi8vLiBJZGVudGl0eVsnQEB0eXBlJ10gPSAnbXktcGFja2FnZS9JZGVudGl0eSc7XG4vLy4gYGBgXG4vLy5cbi8vLiBOb3RlIHRoYXQgYnkgdXNpbmcgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBpcyBzZXRcbi8vLiBpbXBsaWNpdGx5IGZvciBlYWNoIHZhbHVlIGNyZWF0ZWQuIENvbnN0cnVjdG9yIGZ1bmN0aW9ucyBhcmUgY29udmVuaWVudCBmb3Jcbi8vLiB0aGlzIHJlYXNvbiwgYnV0IGFyZSBub3QgcmVxdWlyZWQuIFRoaXMgZGVmaW5pdGlvbiBpcyBhbHNvIHZhbGlkOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIC8vICBJZGVudGl0eVR5cGVSZXAgOjogVHlwZVJlcCBJZGVudGl0eVxuLy8uIHZhciBJZGVudGl0eVR5cGVSZXAgPSB7XG4vLy4gICAnQEB0eXBlJzogJ215LXBhY2thZ2UvSWRlbnRpdHknXG4vLy4gfTtcbi8vLlxuLy8uIC8vICBJZGVudGl0eSA6OiBhIC0+IElkZW50aXR5IGFcbi8vLiBmdW5jdGlvbiBJZGVudGl0eSh4KSB7XG4vLy4gICByZXR1cm4ge2NvbnN0cnVjdG9yOiBJZGVudGl0eVR5cGVSZXAsIHZhbHVlOiB4fTtcbi8vLiB9XG4vLy4gYGBgXG5cbihmdW5jdGlvbihmKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICE9IG51bGwpIHtcbiAgICBkZWZpbmUoW10sIGYpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc2FuY3R1YXJ5VHlwZUlkZW50aWZpZXJzID0gZigpO1xuICB9XG5cbn0oZnVuY3Rpb24oKSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vICAkJHR5cGUgOjogU3RyaW5nXG4gIHZhciAkJHR5cGUgPSAnQEB0eXBlJztcblxuICAvLyAgcGF0dGVybiA6OiBSZWdFeHBcbiAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKFxuICAgICdeJ1xuICArICcoW1xcXFxzXFxcXFNdKyknICAgLy8gIDxuYW1lc3BhY2U+XG4gICsgJy8nICAgICAgICAgICAgIC8vICBTT0xJRFVTIChVKzAwMkYpXG4gICsgJyhbXFxcXHNcXFxcU10rPyknICAvLyAgPG5hbWU+XG4gICsgJyg/OicgICAgICAgICAgIC8vICBvcHRpb25hbCBub24tY2FwdHVyaW5nIGdyb3VwIHtcbiAgKyAgICdAJyAgICAgICAgICAgLy8gICAgQ09NTUVSQ0lBTCBBVCAoVSswMDQwKVxuICArICAgJyhbMC05XSspJyAgICAvLyAgICA8dmVyc2lvbj5cbiAgKyAnKT8nICAgICAgICAgICAgLy8gIH1cbiAgKyAnJCdcbiAgKTtcblxuICAvLy4gIyMjIFVzYWdlXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gY29uc3QgdHlwZSA9IHJlcXVpcmUoJ3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzJyk7XG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGZ1bmN0aW9uIElkZW50aXR5KHgpIHtcbiAgLy8uIC4gICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSWRlbnRpdHkpKSByZXR1cm4gbmV3IElkZW50aXR5KHgpO1xuICAvLy4gLiAgIHRoaXMudmFsdWUgPSB4O1xuICAvLy4gLiB9XG4gIC8vLiAuIElkZW50aXR5WydAQHR5cGUnXSA9ICdteS1wYWNrYWdlL0lkZW50aXR5QDEnO1xuICAvLy5cbiAgLy8uID4gdHlwZS5wYXJzZSh0eXBlKElkZW50aXR5KDApKSlcbiAgLy8uIHtuYW1lc3BhY2U6ICdteS1wYWNrYWdlJywgbmFtZTogJ0lkZW50aXR5JywgdmVyc2lvbjogMX1cbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uICMjIyBBUElcbiAgLy8uXG4gIC8vIyB0eXBlIDo6IEFueSAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBUYWtlcyBhbnkgdmFsdWUgYW5kIHJldHVybnMgYSBzdHJpbmcgd2hpY2ggaWRlbnRpZmllcyBpdHMgdHlwZS4gSWYgdGhlXG4gIC8vLiB2YWx1ZSBjb25mb3JtcyB0byB0aGUgW3NwZWNpZmljYXRpb25dWzRdLCB0aGUgY3VzdG9tIHR5cGUgaWRlbnRpZmllciBpc1xuICAvLy4gcmV0dXJuZWQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0eXBlKG51bGwpXG4gIC8vLiAnTnVsbCdcbiAgLy8uXG4gIC8vLiA+IHR5cGUodHJ1ZSlcbiAgLy8uICdCb29sZWFuJ1xuICAvLy5cbiAgLy8uID4gdHlwZShJZGVudGl0eSgwKSlcbiAgLy8uICdteS1wYWNrYWdlL0lkZW50aXR5QDEnXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdHlwZSh4KSB7XG4gICAgcmV0dXJuIHggIT0gbnVsbCAmJlxuICAgICAgICAgICB4LmNvbnN0cnVjdG9yICE9IG51bGwgJiZcbiAgICAgICAgICAgeC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgIT09IHggJiZcbiAgICAgICAgICAgdHlwZW9mIHguY29uc3RydWN0b3JbJCR0eXBlXSA9PT0gJ3N0cmluZycgP1xuICAgICAgeC5jb25zdHJ1Y3RvclskJHR5cGVdIDpcbiAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KS5zbGljZSgnW29iamVjdCAnLmxlbmd0aCwgLSddJy5sZW5ndGgpO1xuICB9XG5cbiAgLy8jIHR5cGUucGFyc2UgOjogU3RyaW5nIC0+IHsgbmFtZXNwYWNlIDo6IE51bGxhYmxlIFN0cmluZywgbmFtZSA6OiBTdHJpbmcsIHZlcnNpb24gOjogTnVtYmVyIH1cbiAgLy8uXG4gIC8vLiBUYWtlcyBhbnkgc3RyaW5nIGFuZCBwYXJzZXMgaXQgYWNjb3JkaW5nIHRvIHRoZSBbc3BlY2lmaWNhdGlvbl1bNF0sXG4gIC8vLiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYG5hbWVzcGFjZWAsIGBuYW1lYCwgYW5kIGB2ZXJzaW9uYCBmaWVsZHMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiB0eXBlLnBhcnNlKCdteS1wYWNrYWdlL0xpc3RAMicpXG4gIC8vLiB7bmFtZXNwYWNlOiAnbXktcGFja2FnZScsIG5hbWU6ICdMaXN0JywgdmVyc2lvbjogMn1cbiAgLy8uXG4gIC8vLiA+IHR5cGUucGFyc2UoJ25vbnNlbnNlIScpXG4gIC8vLiB7bmFtZXNwYWNlOiBudWxsLCBuYW1lOiAnbm9uc2Vuc2UhJywgdmVyc2lvbjogMH1cbiAgLy8uXG4gIC8vLiA+IHR5cGUucGFyc2UoSWRlbnRpdHlbJ0BAdHlwZSddKVxuICAvLy4ge25hbWVzcGFjZTogJ215LXBhY2thZ2UnLCBuYW1lOiAnSWRlbnRpdHknLCB2ZXJzaW9uOiAxfVxuICAvLy4gYGBgXG4gIHR5cGUucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShzKSB7XG4gICAgdmFyIGdyb3VwcyA9IHBhdHRlcm4uZXhlYyhzKTtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZXNwYWNlOiBncm91cHMgPT0gbnVsbCB8fCBncm91cHNbMV0gPT0gbnVsbCA/IG51bGwgOiBncm91cHNbMV0sXG4gICAgICBuYW1lOiAgICAgIGdyb3VwcyA9PSBudWxsICAgICAgICAgICAgICAgICAgICAgID8gcyAgICA6IGdyb3Vwc1syXSxcbiAgICAgIHZlcnNpb246ICAgZ3JvdXBzID09IG51bGwgfHwgZ3JvdXBzWzNdID09IG51bGwgPyAwICAgIDogTnVtYmVyKGdyb3Vwc1szXSlcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiB0eXBlO1xuXG59KSk7XG5cbi8vLiBbMV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy90eXBlb2Zcbi8vLiBbMl06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC90b1N0cmluZ1xuLy8uIFszXTogaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9taXNjL3Njb3BlXG4vLy4gWzRdOiAjc3BlY2lmaWNhdGlvblxuIiwiLyogICAgIyMjIyMjI1xuICAgIyMjIyAgICAgIyMjI1xuICMjIyMgICAjIyMgICAjIyMjXG4jIyMjIyAgICMjIyMjIyMjIyMjICAgc2FuY3R1YXJ5XG4jIyMjIyMjIyAgICMjIyMjIyMjICAgbm91blxuIyMjIyMjIyMjIyMgICAjIyMjIyAgIDEgWyBtYXNzIG5vdW4gXSByZWZ1Z2UgZnJvbSB1bnNhZmUgSmF2YVNjcmlwdFxuICMjIyMgICAjIyMgICAjIyMjXG4gICAjIyMjICAgICAjIyMjXG4gICAgICAjIyMjIyMjICAgICovXG5cbi8vLiAjIFNhbmN0dWFyeVxuLy8uXG4vLy4gWyFbbnBtXShodHRwczovL2ltZy5zaGllbGRzLmlvL25wbS92L3NhbmN0dWFyeS5zdmcpXShodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9zYW5jdHVhcnkpXG4vLy4gWyFbQ2lyY2xlQ0ldKGh0dHBzOi8vaW1nLnNoaWVsZHMuaW8vY2lyY2xlY2kvcHJvamVjdC9naXRodWIvc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS9tYXN0ZXIuc3ZnKV0oaHR0cHM6Ly9jaXJjbGVjaS5jb20vZ2gvc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS90cmVlL21hc3Rlcilcbi8vLiBbIVtHaXR0ZXJdKGh0dHBzOi8vaW1nLnNoaWVsZHMuaW8vZ2l0dGVyL3Jvb20vYmFkZ2VzL3NoaWVsZHMuc3ZnKV0oaHR0cHM6Ly9naXR0ZXIuaW0vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeSlcbi8vLlxuLy8uIFNhbmN0dWFyeSBpcyBhIEphdmFTY3JpcHQgZnVuY3Rpb25hbCBwcm9ncmFtbWluZyBsaWJyYXJ5IGluc3BpcmVkIGJ5XG4vLy4gW0hhc2tlbGxdW10gYW5kIFtQdXJlU2NyaXB0XVtdLiBJdCdzIHN0cmljdGVyIHRoYW4gW1JhbWRhXVtdLCBhbmRcbi8vLiBwcm92aWRlcyBhIHNpbWlsYXIgc3VpdGUgb2YgZnVuY3Rpb25zLlxuLy8uXG4vLy4gU2FuY3R1YXJ5IHByb21vdGVzIHByb2dyYW1zIGNvbXBvc2VkIG9mIHNpbXBsZSwgcHVyZSBmdW5jdGlvbnMuIFN1Y2hcbi8vLiBwcm9ncmFtcyBhcmUgZWFzaWVyIHRvIGNvbXByZWhlbmQsIHRlc3QsIGFuZCBtYWludGFpbiAmbmRhc2g7IHRoZXkgYXJlXG4vLy4gYWxzbyBhIHBsZWFzdXJlIHRvIHdyaXRlLlxuLy8uXG4vLy4gU2FuY3R1YXJ5IHByb3ZpZGVzIHR3byBkYXRhIHR5cGVzLCBbTWF5YmVdW10gYW5kIFtFaXRoZXJdW10sIGJvdGggb2Zcbi8vLiB3aGljaCBhcmUgY29tcGF0aWJsZSB3aXRoIFtGYW50YXN5IExhbmRdW10uIFRoYW5rcyB0byB0aGVzZSBkYXRhIHR5cGVzXG4vLy4gZXZlbiBTYW5jdHVhcnkgZnVuY3Rpb25zIHdoaWNoIG1heSBmYWlsLCBzdWNoIGFzIFtgaGVhZGBdKCNoZWFkKSwgYXJlXG4vLy4gY29tcG9zYWJsZS5cbi8vLlxuLy8uIFNhbmN0dWFyeSBtYWtlcyBpdCBwb3NzaWJsZSB0byB3cml0ZSBzYWZlIGNvZGUgd2l0aG91dCBudWxsIGNoZWNrcy5cbi8vLiBJbiBKYXZhU2NyaXB0IGl0J3MgdHJpdmlhbCB0byBpbnRyb2R1Y2UgYSBwb3NzaWJsZSBydW4tdGltZSB0eXBlIGVycm9yOlxuLy8uXG4vLy4gICAgIHdvcmRzWzBdLnRvVXBwZXJDYXNlKClcbi8vLlxuLy8uIElmIGB3b3Jkc2AgaXMgYFtdYCB3ZSdsbCBnZXQgYSBmYW1pbGlhciBlcnJvciBhdCBydW4tdGltZTpcbi8vLlxuLy8uICAgICBUeXBlRXJyb3I6IENhbm5vdCByZWFkIHByb3BlcnR5ICd0b1VwcGVyQ2FzZScgb2YgdW5kZWZpbmVkXG4vLy5cbi8vLiBTYW5jdHVhcnkgZ2l2ZXMgdXMgYSBmaWdodGluZyBjaGFuY2Ugb2YgYXZvaWRpbmcgc3VjaCBlcnJvcnMuIFdlIG1pZ2h0XG4vLy4gd3JpdGU6XG4vLy5cbi8vLiAgICAgUy5tYXAgKFMudG9VcHBlcikgKFMuaGVhZCAod29yZHMpKVxuLy8uXG4vLy4gU2FuY3R1YXJ5IGlzIGRlc2lnbmVkIHRvIHdvcmsgaW4gTm9kZS5qcyBhbmQgaW4gRVM1LWNvbXBhdGlibGUgYnJvd3NlcnMuXG4vLy5cbi8vLiAjIyBSYW1kYVxuLy8uXG4vLy4gW1JhbWRhXVtdIHByb3ZpZGVzIHNldmVyYWwgZnVuY3Rpb25zIHdoaWNoIHJldHVybiBwcm9ibGVtYXRpYyB2YWx1ZXNcbi8vLiBzdWNoIGFzIGB1bmRlZmluZWRgLCBgSW5maW5pdHlgLCBvciBgTmFOYCB3aGVuIGFwcGxpZWQgdG8gdW5zdWl0YWJsZVxuLy8uIGlucHV0cy4gVGhlc2UgYXJlIGtub3duIGFzIFtwYXJ0aWFsIGZ1bmN0aW9uc11bXS4gUGFydGlhbCBmdW5jdGlvbnNcbi8vLiBuZWNlc3NpdGF0ZSB0aGUgdXNlIG9mIGd1YXJkcyBvciBudWxsIGNoZWNrcy4gSW4gb3JkZXIgdG8gc2FmZWx5IHVzZVxuLy8uIGBSLmhlYWRgLCBmb3IgZXhhbXBsZSwgb25lIG11c3QgZW5zdXJlIHRoYXQgdGhlIGFycmF5IGlzIG5vbi1lbXB0eTpcbi8vLlxuLy8uICAgICBpZiAoUi5pc0VtcHR5ICh4cykpIHtcbi8vLiAgICAgICAvLyAuLi5cbi8vLiAgICAgfSBlbHNlIHtcbi8vLiAgICAgICByZXR1cm4gZiAoUi5oZWFkICh4cykpO1xuLy8uICAgICB9XG4vLy5cbi8vLiBVc2luZyB0aGUgTWF5YmUgdHlwZSByZW5kZXJzIHN1Y2ggZ3VhcmRzIChhbmQgbnVsbCBjaGVja3MpIHVubmVjZXNzYXJ5LlxuLy8uIENoYW5naW5nIGZ1bmN0aW9ucyBzdWNoIGFzIGBSLmhlYWRgIHRvIHJldHVybiBNYXliZSB2YWx1ZXMgd2FzIHByb3Bvc2VkXG4vLy4gaW4gW3JhbWRhL3JhbWRhIzY4M11bXSwgYnV0IHdhcyBjb25zaWRlcmVkIHRvbyBtdWNoIG9mIGEgc3RyZXRjaCBmb3Jcbi8vLiBKYXZhU2NyaXB0IHByb2dyYW1tZXJzLiBTYW5jdHVhcnkgd2FzIHJlbGVhc2VkIHRoZSBmb2xsb3dpbmcgbW9udGgsXG4vLy4gaW4gSmFudWFyeSAyMDE1LCBhcyBhIGNvbXBhbmlvbiBsaWJyYXJ5IHRvIFJhbWRhLlxuLy8uXG4vLy4gSW4gYWRkaXRpb24gdG8gYnJvYWRlbmluZyBpbiBzY29wZSBpbiB0aGUgeWVhcnMgc2luY2UgaXRzIHJlbGVhc2UsXG4vLy4gU2FuY3R1YXJ5J3MgcGhpbG9zb3BoeSBoYXMgZGl2ZXJnZWQgZnJvbSBSYW1kYSdzIGluIHNldmVyYWwgcmVzcGVjdHMuXG4vLy5cbi8vLiAjIyMgVG90YWxpdHlcbi8vLlxuLy8uIEV2ZXJ5IFNhbmN0dWFyeSBmdW5jdGlvbiBpcyBkZWZpbmVkIGZvciBldmVyeSB2YWx1ZSB3aGljaCBpcyBhIG1lbWJlciBvZlxuLy8uIHRoZSBmdW5jdGlvbidzIGlucHV0IHR5cGUuIFN1Y2ggZnVuY3Rpb25zIGFyZSBrbm93biBhcyBbdG90YWwgZnVuY3Rpb25zXVtdLlxuLy8uIFJhbWRhLCBvbiB0aGUgb3RoZXIgaGFuZCwgY29udGFpbnMgYSBudW1iZXIgb2YgW3BhcnRpYWwgZnVuY3Rpb25zXVtdLlxuLy8uXG4vLy4gIyMjIEluZm9ybWF0aW9uIHByZXNlcnZhdGlvblxuLy8uXG4vLy4gQ2VydGFpbiBTYW5jdHVhcnkgZnVuY3Rpb25zIHByZXNlcnZlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciBSYW1kYVxuLy8uIGNvdW50ZXJwYXJ0cy4gRXhhbXBsZXM6XG4vLy5cbi8vLiAgICAgfD4gUi50YWlsIChbXSkgICAgICAgICAgICAgICAgICAgICAgfD4gUy50YWlsIChbXSlcbi8vLiAgICAgW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTm90aGluZ1xuLy8uXG4vLy4gICAgIHw+IFIudGFpbCAoWydmb28nXSkgICAgICAgICAgICAgICAgIHw+IFMudGFpbCAoWydmb28nXSlcbi8vLiAgICAgW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSnVzdCAoW10pXG4vLy5cbi8vLiAgICAgfD4gUi5yZXBsYWNlICgvXngvKSAoJycpICgnYWJjJykgICAgfD4gUy5zdHJpcFByZWZpeCAoJ3gnKSAoJ2FiYycpXG4vLy4gICAgICdhYmMnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5vdGhpbmdcbi8vLlxuLy8uICAgICB8PiBSLnJlcGxhY2UgKC9eeC8pICgnJykgKCd4YWJjJykgICB8PiBTLnN0cmlwUHJlZml4ICgneCcpICgneGFiYycpXG4vLy4gICAgICdhYmMnICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEp1c3QgKCdhYmMnKVxuLy8uXG4vLy4gIyMjIEludmFyaWFudHNcbi8vLlxuLy8uIFNhbmN0dWFyeSBwZXJmb3JtcyByaWdvcm91cyBbdHlwZSBjaGVja2luZ11bXSBvZiBpbnB1dHMgYW5kIG91dHB1dHMsIGFuZFxuLy8uIHRocm93cyBhIGRlc2NyaXB0aXZlIGVycm9yIGlmIGEgdHlwZSBlcnJvciBpcyBlbmNvdW50ZXJlZC4gVGhpcyBhbGxvd3MgYnVnc1xuLy8uIHRvIGJlIGNhdWdodCBhbmQgZml4ZWQgZWFybHkgaW4gdGhlIGRldmVsb3BtZW50IGN5Y2xlLlxuLy8uXG4vLy4gUmFtZGEgb3BlcmF0ZXMgb24gdGhlIFtnYXJiYWdlIGluLCBnYXJiYWdlIG91dF1bR0lHT10gcHJpbmNpcGFsLiBGdW5jdGlvbnNcbi8vLiBhcmUgZG9jdW1lbnRlZCB0byB0YWtlIGFyZ3VtZW50cyBvZiBwYXJ0aWN1bGFyIHR5cGVzLCBidXQgdGhlc2UgaW52YXJpYW50c1xuLy8uIGFyZSBub3QgZW5mb3JjZWQuIFRoZSBwcm9ibGVtIHdpdGggdGhpcyBhcHByb2FjaCBpbiBhIGxhbmd1YWdlIGFzXG4vLy4gcGVybWlzc2l2ZSBhcyBKYXZhU2NyaXB0IGlzIHRoYXQgdGhlcmUncyBubyBndWFyYW50ZWUgdGhhdCBnYXJiYWdlIGlucHV0XG4vLy4gd2lsbCBwcm9kdWNlIGdhcmJhZ2Ugb3V0cHV0IChbcmFtZGEvcmFtZGEjMTQxM11bXSkuIFJhbWRhIHBlcmZvcm1zIGFkIGhvY1xuLy8uIHR5cGUgY2hlY2tpbmcgaW4gc29tZSBzdWNoIGNhc2VzIChbcmFtZGEvcmFtZGEjMTQxOV1bXSkuXG4vLy5cbi8vLiBTYW5jdHVhcnkgY2FuIGJlIGNvbmZpZ3VyZWQgdG8gb3BlcmF0ZSBpbiBnYXJiYWdlIGluLCBnYXJiYWdlIG91dCBtb2RlLlxuLy8uIFJhbWRhIGNhbm5vdCBiZSBjb25maWd1cmVkIHRvIGVuZm9yY2UgaXRzIGludmFyaWFudHMuXG4vLy5cbi8vLiAjIyMgQ3Vycnlpbmdcbi8vLlxuLy8uIFNhbmN0dWFyeSBmdW5jdGlvbnMgYXJlIGN1cnJpZWQuIFRoZXJlIGlzLCBmb3IgZXhhbXBsZSwgZXhhY3RseSBvbmUgd2F5IHRvXG4vLy4gYXBwbHkgYFMucmVkdWNlYCB0byBgUy5hZGRgLCBgMGAsIGFuZCBgeHNgOlxuLy8uXG4vLy4gICAtIGBTLnJlZHVjZSAoUy5hZGQpICgwKSAoeHMpYFxuLy8uXG4vLy4gUmFtZGEgZnVuY3Rpb25zIGFyZSBhbHNvIGN1cnJpZWQsIGJ1dCBpbiBhIGNvbXBsZXggbWFubmVyLiBUaGVyZSBhcmUgZm91clxuLy8uIHdheXMgdG8gYXBwbHkgYFIucmVkdWNlYCB0byBgUi5hZGRgLCBgMGAsIGFuZCBgeHNgOlxuLy8uXG4vLy4gICAtIGBSLnJlZHVjZSAoUi5hZGQpICgwKSAoeHMpYFxuLy8uICAgLSBgUi5yZWR1Y2UgKFIuYWRkKSAoMCwgeHMpYFxuLy8uICAgLSBgUi5yZWR1Y2UgKFIuYWRkLCAwKSAoeHMpYFxuLy8uICAgLSBgUi5yZWR1Y2UgKFIuYWRkLCAwLCB4cylgXG4vLy5cbi8vLiBSYW1kYSBzdXBwb3J0cyBhbGwgdGhlc2UgZm9ybXMgYmVjYXVzZSBjdXJyaWVkIGZ1bmN0aW9ucyBlbmFibGUgcGFydGlhbFxuLy8uIGFwcGxpY2F0aW9uLCBvbmUgb2YgdGhlIGxpYnJhcnkncyB0ZW5ldHMsIGJ1dCBgZih4KSh5KSh6KWAgaXMgY29uc2lkZXJlZFxuLy8uIHRvbyB1bmZhbWlsaWFyIGFuZCB0b28gdW5hdHRyYWN0aXZlIHRvIGFwcGVhbCB0byBKYXZhU2NyaXB0IHByb2dyYW1tZXJzLlxuLy8uXG4vLy4gU2FuY3R1YXJ5J3MgZGV2ZWxvcGVycyBwcmVmZXIgYSBzaW1wbGUsIHVuZmFtaWxpYXIgY29uc3RydWN0IHRvIGEgY29tcGxleCxcbi8vLiBmYW1pbGlhciBvbmUuIEZhbWlsaWFyaXR5IGNhbiBiZSBhY3F1aXJlZDsgY29tcGxleGl0eSBpcyBpbnRyaW5zaWMuXG4vLy5cbi8vLiBUaGUgbGFjayBvZiBicmVhdGhpbmcgcm9vbSBpbiBgZih4KSh5KSh6KWAgaW1wYWlycyByZWFkYWJpbGl0eS4gVGhlIHNpbXBsZVxuLy8uIHNvbHV0aW9uIHRvIHRoaXMgcHJvYmxlbSwgcHJvcG9zZWQgaW4gWyM0MzhdW10sIGlzIHRvIGluY2x1ZGUgYSBzcGFjZSB3aGVuXG4vLy4gYXBwbHlpbmcgYSBmdW5jdGlvbjogYGYgKHgpICh5KSAoeilgLlxuLy8uXG4vLy4gUmFtZGEgYWxzbyBwcm92aWRlcyBhIHNwZWNpYWwgcGxhY2Vob2xkZXIgdmFsdWUsIFtgUi5fX2BdW10sIHdoaWNoIHJlbW92ZXNcbi8vLiB0aGUgcmVzdHJpY3Rpb24gdGhhdCBhIGZ1bmN0aW9uIG11c3QgYmUgYXBwbGllZCB0byBpdHMgYXJndW1lbnRzIGluIG9yZGVyLlxuLy8uIFRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbnMgYXJlIGVxdWl2YWxlbnQ6XG4vLy5cbi8vLiAgIC0gYFIucmVkdWNlIChSLl9fLCAwLCB4cykgKFIuYWRkKWBcbi8vLiAgIC0gYFIucmVkdWNlIChSLmFkZCwgUi5fXywgeHMpICgwKWBcbi8vLiAgIC0gYFIucmVkdWNlIChSLl9fLCAwKSAoUi5hZGQpICh4cylgXG4vLy4gICAtIGBSLnJlZHVjZSAoUi5fXywgMCkgKFIuYWRkLCB4cylgXG4vLy4gICAtIGBSLnJlZHVjZSAoUi5fXywgUi5fXywgeHMpIChSLmFkZCkgKDApYFxuLy8uICAgLSBgUi5yZWR1Y2UgKFIuX18sIFIuX18sIHhzKSAoUi5hZGQsIDApYFxuLy8uXG4vLy4gIyMjIFZhcmlhZGljIGZ1bmN0aW9uc1xuLy8uXG4vLy4gUmFtZGEgcHJvdmlkZXMgc2V2ZXJhbCBmdW5jdGlvbnMgd2hpY2ggdGFrZSBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cy4gVGhlc2Vcbi8vLiBhcmUga25vd24gYXMgW3ZhcmlhZGljIGZ1bmN0aW9uc11bXS4gQWRkaXRpb25hbGx5LCBSYW1kYSBwcm92aWRlcyBzZXZlcmFsXG4vLy4gZnVuY3Rpb25zIHdoaWNoIHRha2UgdmFyaWFkaWMgZnVuY3Rpb25zIGFzIGFyZ3VtZW50cy4gQWx0aG91Z2ggbmF0dXJhbCBpblxuLy8uIGEgZHluYW1pY2FsbHkgdHlwZWQgbGFuZ3VhZ2UsIHZhcmlhZGljIGZ1bmN0aW9ucyBhcmUgYXQgb2RkcyB3aXRoIHRoZSB0eXBlXG4vLy4gbm90YXRpb24gUmFtZGEgYW5kIFNhbmN0dWFyeSBib3RoIHVzZSwgbGVhZGluZyB0byBzb21lIGluZGVjaXBoZXJhYmxlIHR5cGVcbi8vLiBzaWduYXR1cmVzIHN1Y2ggYXMgdGhpcyBvbmU6XG4vLy5cbi8vLiAgICAgUi5saWZ0IDo6ICgqLi4uIC0+ICouLi4pIC0+IChbKl0uLi4gLT4gWypdKVxuLy8uXG4vLy4gU2FuY3R1YXJ5IGhhcyBubyB2YXJpYWRpYyBmdW5jdGlvbnMsIG5vciBhbnkgZnVuY3Rpb25zIHdoaWNoIHRha2UgdmFyaWFkaWNcbi8vLiBmdW5jdGlvbnMgYXMgYXJndW1lbnRzLiBTYW5jdHVhcnkgcHJvdmlkZXMgdHdvIFwibGlmdFwiIGZ1bmN0aW9ucywgZWFjaCB3aXRoXG4vLy4gYSBoZWxwZnVsIHR5cGUgc2lnbmF0dXJlOlxuLy8uXG4vLy4gICAgIFMubGlmdDIgOjogQXBwbHkgZiA9PiAoYSAtPiBiIC0+IGMpIC0+IGYgYSAtPiBmIGIgLT4gZiBjXG4vLy4gICAgIFMubGlmdDMgOjogQXBwbHkgZiA9PiAoYSAtPiBiIC0+IGMgLT4gZCkgLT4gZiBhIC0+IGYgYiAtPiBmIGMgLT4gZiBkXG4vLy5cbi8vLiAjIyMgSW1wbGljaXQgY29udGV4dFxuLy8uXG4vLy4gUmFtZGEgcHJvdmlkZXMgW2BSLmJpbmRgXVtdIGFuZCBbYFIuaW52b2tlcmBdW10gZm9yIHdvcmtpbmcgd2l0aCBtZXRob2RzLlxuLy8uIEFkZGl0aW9uYWxseSwgbWFueSBSYW1kYSBmdW5jdGlvbnMgdXNlIGBGdW5jdGlvbiNjYWxsYCBvciBgRnVuY3Rpb24jYXBwbHlgXG4vLy4gdG8gcHJlc2VydmUgY29udGV4dC4gU2FuY3R1YXJ5IG1ha2VzIG5vIGFsbG93YW5jZXMgZm9yIGB0aGlzYC5cbi8vLlxuLy8uICMjIyBUcmFuc2R1Y2Vyc1xuLy8uXG4vLy4gU2V2ZXJhbCBSYW1kYSBmdW5jdGlvbnMgYWN0IGFzIHRyYW5zZHVjZXJzLiBTYW5jdHVhcnkgcHJvdmlkZXMgbm8gc3VwcG9ydFxuLy8uIGZvciB0cmFuc2R1Y2Vycy5cbi8vLlxuLy8uICMjIyBNb2R1bGFyaXR5XG4vLy5cbi8vLiBXaGVyZWFzIFJhbWRhIGhhcyBubyBkZXBlbmRlbmNpZXMsIFNhbmN0dWFyeSBoYXMgYSBtb2R1bGFyIGRlc2lnbjpcbi8vLiBbc2FuY3R1YXJ5LWRlZl1bXSBwcm92aWRlcyB0eXBlIGNoZWNraW5nLCBbc2FuY3R1YXJ5LXR5cGUtY2xhc3Nlc11bXVxuLy8uIHByb3ZpZGVzIEZhbnRhc3kgTGFuZCBmdW5jdGlvbnMgYW5kIHR5cGUgY2xhc3NlcywgW3NhbmN0dWFyeS1zaG93XVtdXG4vLy4gcHJvdmlkZXMgc3RyaW5nIHJlcHJlc2VudGF0aW9ucywgYW5kIGFsZ2VicmFpYyBkYXRhIHR5cGVzIGFyZSBwcm92aWRlZFxuLy8uIGJ5IFtzYW5jdHVhcnktZWl0aGVyXVtdLCBbc2FuY3R1YXJ5LW1heWJlXVtdLCBhbmQgW3NhbmN0dWFyeS1wYWlyXVtdLlxuLy8uIE5vdCBvbmx5IGRvZXMgdGhpcyBhcHByb2FjaCByZWR1Y2UgdGhlIGNvbXBsZXhpdHkgb2YgU2FuY3R1YXJ5IGl0c2VsZixcbi8vLiBidXQgaXQgYWxsb3dzIHRoZXNlIGNvbXBvbmVudHMgdG8gYmUgcmV1c2VkIGluIG90aGVyIGNvbnRleHRzLlxuLy8uXG4vLy4gIyMgVHlwZXNcbi8vLlxuLy8uIFNhbmN0dWFyeSB1c2VzIEhhc2tlbGwtbGlrZSB0eXBlIHNpZ25hdHVyZXMgdG8gZGVzY3JpYmUgdGhlIHR5cGVzIG9mXG4vLy4gdmFsdWVzLCBpbmNsdWRpbmcgZnVuY3Rpb25zLiBgJ2ZvbydgLCBmb3IgZXhhbXBsZSwgaXMgYSBtZW1iZXIgb2YgYFN0cmluZ2A7XG4vLy4gYFsxLCAyLCAzXWAgaXMgYSBtZW1iZXIgb2YgYEFycmF5IE51bWJlcmAuIFRoZSBkb3VibGUgY29sb24gKGA6OmApIGlzIHVzZWRcbi8vLiB0byBtZWFuIFwiaXMgYSBtZW1iZXIgb2ZcIiwgc28gb25lIGNvdWxkIHdyaXRlOlxuLy8uXG4vLy4gICAgICdmb28nIDo6IFN0cmluZ1xuLy8uICAgICBbMSwgMiwgM10gOjogQXJyYXkgTnVtYmVyXG4vLy5cbi8vLiBBbiBpZGVudGlmaWVyIG1heSBhcHBlYXIgdG8gdGhlIGxlZnQgb2YgdGhlIGRvdWJsZSBjb2xvbjpcbi8vLlxuLy8uICAgICBNYXRoLlBJIDo6IE51bWJlclxuLy8uXG4vLy4gVGhlIGFycm93IChgLT5gKSBpcyB1c2VkIHRvIGV4cHJlc3MgYSBmdW5jdGlvbidzIHR5cGU6XG4vLy5cbi8vLiAgICAgTWF0aC5hYnMgOjogTnVtYmVyIC0+IE51bWJlclxuLy8uXG4vLy4gVGhhdCBzdGF0ZXMgdGhhdCBgTWF0aC5hYnNgIGlzIGEgdW5hcnkgZnVuY3Rpb24gd2hpY2ggdGFrZXMgYW4gYXJndW1lbnRcbi8vLiBvZiB0eXBlIGBOdW1iZXJgIGFuZCByZXR1cm5zIGEgdmFsdWUgb2YgdHlwZSBgTnVtYmVyYC5cbi8vLlxuLy8uIFNvbWUgZnVuY3Rpb25zIGFyZSBwYXJhbWV0cmljYWxseSBwb2x5bW9ycGhpYzogdGhlaXIgdHlwZXMgYXJlIG5vdCBmaXhlZC5cbi8vLiBUeXBlIHZhcmlhYmxlcyBhcmUgdXNlZCBpbiB0aGUgcmVwcmVzZW50YXRpb25zIG9mIHN1Y2ggZnVuY3Rpb25zOlxuLy8uXG4vLy4gICAgIFMuSSA6OiBhIC0+IGFcbi8vLlxuLy8uIGBhYCBpcyBhIHR5cGUgdmFyaWFibGUuIFR5cGUgdmFyaWFibGVzIGFyZSBub3QgY2FwaXRhbGl6ZWQsIHNvIHRoZXlcbi8vLiBhcmUgZGlmZmVyZW50aWFibGUgZnJvbSB0eXBlIGlkZW50aWZpZXJzICh3aGljaCBhcmUgYWx3YXlzIGNhcGl0YWxpemVkKS5cbi8vLiBCeSBjb252ZW50aW9uIHR5cGUgdmFyaWFibGVzIGhhdmUgc2luZ2xlLWNoYXJhY3RlciBuYW1lcy4gVGhlIHNpZ25hdHVyZVxuLy8uIGFib3ZlIHN0YXRlcyB0aGF0IGBTLklgIHRha2VzIGEgdmFsdWUgb2YgYW55IHR5cGUgYW5kIHJldHVybnMgYSB2YWx1ZSBvZlxuLy8uIHRoZSBzYW1lIHR5cGUuIFNvbWUgc2lnbmF0dXJlcyBmZWF0dXJlIG11bHRpcGxlIHR5cGUgdmFyaWFibGVzOlxuLy8uXG4vLy4gICAgIFMuSyA6OiBhIC0+IGIgLT4gYVxuLy8uXG4vLy4gSXQgbXVzdCBiZSBwb3NzaWJsZSB0byByZXBsYWNlIGFsbCBvY2N1cnJlbmNlcyBvZiBgYWAgd2l0aCBhIGNvbmNyZXRlIHR5cGUuXG4vLy4gVGhlIHNhbWUgYXBwbGllcyBmb3IgZWFjaCBvdGhlciB0eXBlIHZhcmlhYmxlLiBGb3IgdGhlIGZ1bmN0aW9uIGFib3ZlLCB0aGVcbi8vLiB0eXBlcyB3aXRoIHdoaWNoIGBhYCBhbmQgYGJgIGFyZSByZXBsYWNlZCBtYXkgYmUgZGlmZmVyZW50LCBidXQgbmVlZG4ndCBiZS5cbi8vLlxuLy8uIFNpbmNlIGFsbCBTYW5jdHVhcnkgZnVuY3Rpb25zIGFyZSBjdXJyaWVkICh0aGV5IGFjY2VwdCB0aGVpciBhcmd1bWVudHNcbi8vLiBvbmUgYXQgYSB0aW1lKSwgYSBiaW5hcnkgZnVuY3Rpb24gaXMgcmVwcmVzZW50ZWQgYXMgYSB1bmFyeSBmdW5jdGlvbiB3aGljaFxuLy8uIHJldHVybnMgYSB1bmFyeSBmdW5jdGlvbjogYCogLT4gKiAtPiAqYC4gVGhpcyBhbGlnbnMgbmVhdGx5IHdpdGggSGFza2VsbCxcbi8vLiB3aGljaCB1c2VzIGN1cnJpZWQgZnVuY3Rpb25zIGV4Y2x1c2l2ZWx5LiBJbiBKYXZhU2NyaXB0LCB0aG91Z2gsIHdlIG1heVxuLy8uIHdpc2ggdG8gcmVwcmVzZW50IHRoZSB0eXBlcyBvZiBmdW5jdGlvbnMgd2l0aCBhcml0aWVzIGxlc3MgdGhhbiBvciBncmVhdGVyXG4vLy4gdGhhbiBvbmUuIFRoZSBnZW5lcmFsIGZvcm0gaXMgYCg8aW5wdXQtdHlwZXM+KSAtPiA8b3V0cHV0LXR5cGU+YCwgd2hlcmVcbi8vLiBgPGlucHV0LXR5cGVzPmAgY29tcHJpc2VzIHplcm8gb3IgbW9yZSBjb21tYeKAk3NwYWNlICg8Y29kZT4sIDwvY29kZT4pXG4vLy4gLXNlcGFyYXRlZCB0eXBlIHJlcHJlc2VudGF0aW9uczpcbi8vLlxuLy8uICAgLSBgKCkgLT4gU3RyaW5nYFxuLy8uICAgLSBgKGEsIGIpIC0+IGFgXG4vLy4gICAtIGAoYSwgYiwgYykgLT4gZGBcbi8vLlxuLy8uIGBOdW1iZXIgLT4gTnVtYmVyYCBjYW4gdGh1cyBiZSBzZWVuIGFzIHNob3J0aGFuZCBmb3IgYChOdW1iZXIpIC0+IE51bWJlcmAuXG4vLy5cbi8vLiBUaGUgcXVlc3Rpb24gbWFyayAoYD9gKSBpcyB1c2VkIHRvIHJlcHJlc2VudCB0eXBlcyB3aGljaCBpbmNsdWRlIGBudWxsYFxuLy8uIGFuZCBgdW5kZWZpbmVkYCBhcyBtZW1iZXJzLiBgU3RyaW5nP2AsIGZvciBleGFtcGxlLCByZXByZXNlbnRzIHRoZSB0eXBlXG4vLy4gY29tcHJpc2luZyBgbnVsbGAsIGB1bmRlZmluZWRgLCBhbmQgYWxsIHN0cmluZ3MuXG4vLy5cbi8vLiBTYW5jdHVhcnkgZW1icmFjZXMgdHlwZXMuIEphdmFTY3JpcHQgZG9lc24ndCBzdXBwb3J0IGFsZ2VicmFpYyBkYXRhIHR5cGVzLFxuLy8uIGJ1dCB0aGVzZSBjYW4gYmUgc2ltdWxhdGVkIGJ5IHByb3ZpZGluZyBhIGdyb3VwIG9mIGRhdGEgY29uc3RydWN0b3JzIHdoaWNoXG4vLy4gcmV0dXJuIHZhbHVlcyB3aXRoIHRoZSBzYW1lIHNldCBvZiBtZXRob2RzLiBBIHZhbHVlIG9mIHRoZSBFaXRoZXIgdHlwZSwgZm9yXG4vLy4gZXhhbXBsZSwgaXMgY3JlYXRlZCB2aWEgdGhlIExlZnQgY29uc3RydWN0b3Igb3IgdGhlIFJpZ2h0IGNvbnN0cnVjdG9yLlxuLy8uXG4vLy4gSXQncyBuZWNlc3NhcnkgdG8gZXh0ZW5kIEhhc2tlbGwncyBub3RhdGlvbiB0byBkZXNjcmliZSBpbXBsaWNpdCBhcmd1bWVudHNcbi8vLiB0byB0aGUgKm1ldGhvZHMqIHByb3ZpZGVkIGJ5IFNhbmN0dWFyeSdzIHR5cGVzLiBJbiBgeC5tYXAoeSlgLCBmb3IgZXhhbXBsZSxcbi8vLiB0aGUgYG1hcGAgbWV0aG9kIHRha2VzIGFuIGltcGxpY2l0IGFyZ3VtZW50IGB4YCBpbiBhZGRpdGlvbiB0byB0aGUgZXhwbGljaXRcbi8vLiBhcmd1bWVudCBgeWAuIFRoZSB0eXBlIG9mIHRoZSB2YWx1ZSB1cG9uIHdoaWNoIGEgbWV0aG9kIGlzIGludm9rZWQgYXBwZWFyc1xuLy8uIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNpZ25hdHVyZSwgc2VwYXJhdGVkIGZyb20gdGhlIGFyZ3VtZW50cyBhbmQgcmV0dXJuXG4vLy4gdmFsdWUgYnkgYSBzcXVpZ2dseSBhcnJvdyAoYH4+YCkuIFRoZSB0eXBlIG9mIHRoZSBgZmFudGFzeS1sYW5kL21hcGAgbWV0aG9kXG4vLy4gb2YgdGhlIE1heWJlIHR5cGUgaXMgd3JpdHRlbiBgTWF5YmUgYSB+PiAoYSAtPiBiKSAtPiBNYXliZSBiYC4gT25lIGNvdWxkXG4vLy4gcmVhZCB0aGlzIGFzOlxuLy8uXG4vLy4gX1doZW4gdGhlIGBmYW50YXN5LWxhbmQvbWFwYCBtZXRob2QgaXMgaW52b2tlZCBvbiBhIHZhbHVlIG9mIHR5cGUgYE1heWJlIGFgXG4vLy4gKGZvciBhbnkgdHlwZSBgYWApIHdpdGggYW4gYXJndW1lbnQgb2YgdHlwZSBgYSAtPiBiYCAoZm9yIGFueSB0eXBlIGBiYCksXG4vLy4gaXQgcmV0dXJucyBhIHZhbHVlIG9mIHR5cGUgYE1heWJlIGJgLl9cbi8vLlxuLy8uIFRoZSBzcXVpZ2dseSBhcnJvdyBpcyBhbHNvIHVzZWQgd2hlbiByZXByZXNlbnRpbmcgbm9uLWZ1bmN0aW9uIHByb3BlcnRpZXMuXG4vLy4gYE1heWJlIGEgfj4gQm9vbGVhbmAsIGZvciBleGFtcGxlLCByZXByZXNlbnRzIGEgQm9vbGVhbiBwcm9wZXJ0eSBvZiBhIHZhbHVlXG4vLy4gb2YgdHlwZSBgTWF5YmUgYWAuXG4vLy5cbi8vLiBTYW5jdHVhcnkgc3VwcG9ydHMgdHlwZSBjbGFzc2VzOiBjb25zdHJhaW50cyBvbiB0eXBlIHZhcmlhYmxlcy4gV2hlcmVhc1xuLy8uIGBhIC0+IGFgIGltcGxpY2l0bHkgc3VwcG9ydHMgZXZlcnkgdHlwZSwgYEZ1bmN0b3IgZiA9PiAoYSAtPiBiKSAtPiBmIGEgLT5cbi8vLiBmIGJgIHJlcXVpcmVzIHRoYXQgYGZgIGJlIGEgdHlwZSB3aGljaCBzYXRpc2ZpZXMgdGhlIHJlcXVpcmVtZW50cyBvZiB0aGVcbi8vLiBGdW5jdG9yIHR5cGUgY2xhc3MuIFR5cGUtY2xhc3MgY29uc3RyYWludHMgYXBwZWFyIGF0IHRoZSBiZWdpbm5pbmcgb2YgYVxuLy8uIHR5cGUgc2lnbmF0dXJlLCBzZXBhcmF0ZWQgZnJvbSB0aGUgcmVzdCBvZiB0aGUgc2lnbmF0dXJlIGJ5IGEgZmF0IGFycm93XG4vLy4gKGA9PmApLlxuLy8uXG4vLy4gIyMgVHlwZSBjaGVja2luZ1xuLy8uXG4vLy4gU2FuY3R1YXJ5IGZ1bmN0aW9ucyBhcmUgZGVmaW5lZCB2aWEgW3NhbmN0dWFyeS1kZWZdW10gdG8gcHJvdmlkZSBydW4tdGltZVxuLy8uIHR5cGUgY2hlY2tpbmcuIFRoaXMgaXMgdHJlbWVuZG91c2x5IHVzZWZ1bCBkdXJpbmcgZGV2ZWxvcG1lbnQ6IHR5cGUgZXJyb3JzXG4vLy4gYXJlIHJlcG9ydGVkIGltbWVkaWF0ZWx5LCBhdm9pZGluZyBjaXJjdWl0b3VzIHN0YWNrIHRyYWNlcyAoYXQgYmVzdCkgYW5kXG4vLy4gc2lsZW50IGZhaWx1cmVzIGR1ZSB0byB0eXBlIGNvZXJjaW9uIChhdCB3b3JzdCkuIEZvciBleGFtcGxlOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIFMuYWRkICgyKSAodHJ1ZSk7XG4vLy4gLy8gISBUeXBlRXJyb3I6IEludmFsaWQgdmFsdWVcbi8vLiAvL1xuLy8uIC8vICAgYWRkIDo6IEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyXG4vLy4gLy8gICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXlxuLy8uIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDFcbi8vLiAvL1xuLy8uIC8vICAgMSkgIHRydWUgOjogQm9vbGVhblxuLy8uIC8vXG4vLy4gLy8gICBUaGUgdmFsdWUgYXQgcG9zaXRpb24gMSBpcyBub3QgYSBtZW1iZXIgb2Yg4oCYRmluaXRlTnVtYmVy4oCZLlxuLy8uIC8vXG4vLy4gLy8gICBTZWUgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiNGaW5pdGVOdW1iZXIgZm9yIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzYW5jdHVhcnktZGVmL0Zpbml0ZU51bWJlciB0eXBlLlxuLy8uIGBgYFxuLy8uXG4vLy4gQ29tcGFyZSB0aGlzIHRvIHRoZSBiZWhhdmlvdXIgb2YgUmFtZGEncyB1bmNoZWNrZWQgZXF1aXZhbGVudDpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBSLmFkZCAoMikgKHRydWUpO1xuLy8uIC8vID0+IDNcbi8vLiBgYGBcbi8vLlxuLy8uIFRoZXJlIGlzIGEgcGVyZm9ybWFuY2UgY29zdCB0byBydW4tdGltZSB0eXBlIGNoZWNraW5nLiBUeXBlIGNoZWNraW5nIGlzXG4vLy4gZGlzYWJsZWQgYnkgZGVmYXVsdCBpZiBgcHJvY2Vzcy5lbnYuTk9ERV9FTlZgIGlzIGAncHJvZHVjdGlvbidgLiBJZiB0aGlzXG4vLy4gcnVsZSBpcyB1bnN1aXRhYmxlIGZvciBhIGdpdmVuIHByb2dyYW0sIG9uZSBtYXkgdXNlIFtgY3JlYXRlYF0oI2NyZWF0ZSlcbi8vLiB0byBjcmVhdGUgYSBTYW5jdHVhcnkgbW9kdWxlIGJhc2VkIG9uIGEgZGlmZmVyZW50IHJ1bGUuIEZvciBleGFtcGxlOlxuLy8uXG4vLy4gYGBgamF2YXNjcmlwdFxuLy8uIGNvbnN0IFMgPSBzYW5jdHVhcnkuY3JlYXRlICh7XG4vLy4gICBjaGVja1R5cGVzOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSAoJ1NBTkNUVUFSWV9DSEVDS19UWVBFUycpID09PSAndHJ1ZScsXG4vLy4gICBlbnY6IHNhbmN0dWFyeS5lbnYsXG4vLy4gfSk7XG4vLy4gYGBgXG4vLy5cbi8vLiBPY2Nhc2lvbmFsbHkgb25lIG1heSB3aXNoIHRvIHBlcmZvcm0gYW4gb3BlcmF0aW9uIHdoaWNoIGlzIG5vdCB0eXBlIHNhZmUsXG4vLy4gc3VjaCBhcyBtYXBwaW5nIG92ZXIgYW4gb2JqZWN0IHdpdGggaGV0ZXJvZ2VuZW91cyB2YWx1ZXMuIFRoaXMgaXMgcG9zc2libGVcbi8vLiB2aWEgc2VsZWN0aXZlIHVzZSBvZiBbYHVuY2hlY2tlZGBdKCN1bmNoZWNrZWQpIGZ1bmN0aW9ucy5cbi8vLlxuLy8uICMjIEluc3RhbGxhdGlvblxuLy8uXG4vLy4gYG5wbSBpbnN0YWxsIHNhbmN0dWFyeWAgd2lsbCBpbnN0YWxsIFNhbmN0dWFyeSBmb3IgdXNlIGluIE5vZGUuanMuXG4vLy5cbi8vLiBSdW5uaW5nIFNhbmN0dWFyeSBpbiB0aGUgYnJvd3NlciBpcyBtb3JlIGludm9sdmVkLiBPbmUgbXVzdCBpbmNsdWRlIGFcbi8vLiBgPHNjcmlwdD5gIGZvciBlYWNoIGRlcGVuZGVuY3kgaW4gYWRkaXRpb24gdG8gb25lIGZvciBTYW5jdHVhcnkgaXRzZWxmOlxuLy8uXG4vLy4gYGBgaHRtbFxuLy8uIDxzY3JpcHQgc3JjPVwidmVuZG9yL3NhbmN0dWFyeS1zaG93LmpzXCI+PC9zY3JpcHQ+XG4vLy4gPHNjcmlwdCBzcmM9XCJ2ZW5kb3Ivc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMuanNcIj48L3NjcmlwdD5cbi8vLiA8c2NyaXB0IHNyYz1cInZlbmRvci9zYW5jdHVhcnktdHlwZS1jbGFzc2VzLmpzXCI+PC9zY3JpcHQ+XG4vLy4gPHNjcmlwdCBzcmM9XCJ2ZW5kb3Ivc2FuY3R1YXJ5LWVpdGhlci5qc1wiPjwvc2NyaXB0PlxuLy8uIDxzY3JpcHQgc3JjPVwidmVuZG9yL3NhbmN0dWFyeS1tYXliZS5qc1wiPjwvc2NyaXB0PlxuLy8uIDxzY3JpcHQgc3JjPVwidmVuZG9yL3NhbmN0dWFyeS1wYWlyLmpzXCI+PC9zY3JpcHQ+XG4vLy4gPHNjcmlwdCBzcmM9XCJ2ZW5kb3Ivc2FuY3R1YXJ5LWRlZi5qc1wiPjwvc2NyaXB0PlxuLy8uIDxzY3JpcHQgc3JjPVwidmVuZG9yL3NhbmN0dWFyeS5qc1wiPjwvc2NyaXB0PlxuLy8uIGBgYFxuLy8uXG4vLy4gVG8gZW5zdXJlIGNvbXBhdGliaWxpdHkgb25lIHNob3VsZCB1c2UgdGhlIGRlcGVuZGVuY3kgdmVyc2lvbnMgc3BlY2lmaWVkXG4vLy4gaW4gX19wYWNrYWdlLmpzb25fXy5cbi8vLlxuLy8uIEZvciBjb252ZW5pZW5jZSBvbmUgY291bGQgZGVmaW5lIGFsaWFzZXMgZm9yIHZhcmlvdXMgbW9kdWxlczpcbi8vLlxuLy8uIGBgYGphdmFzY3JpcHRcbi8vLiBjb25zdCBTID0gd2luZG93LnNhbmN0dWFyeTtcbi8vLiBjb25zdCAkID0gd2luZG93LnNhbmN0dWFyeURlZjtcbi8vLiAvLyAuLi5cbi8vLiBgYGBcbi8vLlxuLy8uICMjIEFQSVxuXG4oZnVuY3Rpb24oZikge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZiAocmVxdWlyZSAoJ3NhbmN0dWFyeS1kZWYnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCdzYW5jdHVhcnktZWl0aGVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LW1heWJlJyksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlICgnc2FuY3R1YXJ5LXBhaXInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCdzYW5jdHVhcnktc2hvdycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSAoJ3NhbmN0dWFyeS10eXBlLWNsYXNzZXMnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUgKCdzYW5jdHVhcnktdHlwZS1pZGVudGlmaWVycycpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgIT0gbnVsbCkge1xuICAgIGRlZmluZSAoWydzYW5jdHVhcnktZGVmJyxcbiAgICAgICAgICAgICAnc2FuY3R1YXJ5LWVpdGhlcicsXG4gICAgICAgICAgICAgJ3NhbmN0dWFyeS1tYXliZScsXG4gICAgICAgICAgICAgJ3NhbmN0dWFyeS1wYWlyJyxcbiAgICAgICAgICAgICAnc2FuY3R1YXJ5LXNob3cnLFxuICAgICAgICAgICAgICdzYW5jdHVhcnktdHlwZS1jbGFzc2VzJyxcbiAgICAgICAgICAgICAnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnXSxcbiAgICAgICAgICAgIGYpO1xuICB9IGVsc2Uge1xuICAgIHNlbGYuc2FuY3R1YXJ5ID0gZiAoc2VsZi5zYW5jdHVhcnlEZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNhbmN0dWFyeUVpdGhlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2FuY3R1YXJ5TWF5YmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNhbmN0dWFyeVBhaXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNhbmN0dWFyeVNob3csXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNhbmN0dWFyeVR5cGVDbGFzc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zYW5jdHVhcnlUeXBlSWRlbnRpZmllcnMpO1xuICB9XG5cbn0gKGZ1bmN0aW9uKCQsIEVpdGhlciwgTWF5YmUsIFBhaXIsIHNob3csIFosIHR5cGUpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh0eXBlb2YgX19kb2N0ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gICAgdmFyIERlc2NlbmRpbmcgPSBfX2RvY3Rlc3QucmVxdWlyZSAoJ3NhbmN0dWFyeS1kZXNjZW5kaW5nJyk7XG4gICAgdmFyIE5pbCA9IChfX2RvY3Rlc3QucmVxdWlyZSAoJy4vdGVzdC9pbnRlcm5hbC9MaXN0JykpLk5pbDtcbiAgICB2YXIgQ29ucyA9IChfX2RvY3Rlc3QucmVxdWlyZSAoJy4vdGVzdC9pbnRlcm5hbC9MaXN0JykpLkNvbnM7XG4gICAgdmFyIFN1bSA9IF9fZG9jdGVzdC5yZXF1aXJlICgnLi90ZXN0L2ludGVybmFsL1N1bScpO1xuICAgIHZhciBTID0gKGZ1bmN0aW9uKFMpIHtcbiAgICAgIC8vICBEZXNjZW5kaW5nVHlwZSA6OiBUeXBlIC0+IFR5cGVcbiAgICAgIHZhciBEZXNjZW5kaW5nVHlwZSA9ICQuVW5hcnlUeXBlXG4gICAgICAgICgnc2FuY3R1YXJ5L0Rlc2NlbmRpbmcnKVxuICAgICAgICAoJycpXG4gICAgICAgICh0eXBlRXEgKERlc2NlbmRpbmdbJ0BAdHlwZSddKSlcbiAgICAgICAgKEIgKG9mIChBcnJheSkpIChaLmV4dHJhY3QpKTtcblxuICAgICAgdmFyIFNfID0gUy5jcmVhdGUgKHtcbiAgICAgICAgY2hlY2tUeXBlczogdHJ1ZSxcbiAgICAgICAgZW52OiBTLmVudi5jb25jYXQgKFtcbiAgICAgICAgICBEZXNjZW5kaW5nVHlwZSAoJC5Vbmtub3duKSxcbiAgICAgICAgICAoX19kb2N0ZXN0LnJlcXVpcmUgKCcuL3Rlc3QvaW50ZXJuYWwvTGlzdCcpKS5UeXBlICgkLlVua25vd24pLFxuICAgICAgICAgIFN1bS5UeXBlXG4gICAgICAgIF0pXG4gICAgICB9KTtcbiAgICAgIFNfLmVudiA9IFMuZW52OyAgLy8gc2VlIFMuZW52IGRvY3Rlc3RcbiAgICAgIHJldHVybiBTXztcbiAgICB9IChyZXF1aXJlICgnLicpKSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuICB9XG5cbiAgLy8gIExlZnQgOjogYSAtPiBFaXRoZXIgYSBiXG4gIHZhciBMZWZ0ID0gRWl0aGVyLkxlZnQ7XG5cbiAgLy8gIFJpZ2h0IDo6IGIgLT4gRWl0aGVyIGEgYlxuICB2YXIgUmlnaHQgPSBFaXRoZXIuUmlnaHQ7XG5cbiAgLy8gIE5vdGhpbmcgOjogTWF5YmUgYVxuICB2YXIgTm90aGluZyA9IE1heWJlLk5vdGhpbmc7XG5cbiAgLy8gIEp1c3QgOjogYSAtPiBNYXliZSBhXG4gIHZhciBKdXN0ID0gTWF5YmUuSnVzdDtcblxuICAvLyAgQiA6OiAoYiAtPiBjKSAtPiAoYSAtPiBiKSAtPiBhIC0+IGNcbiAgZnVuY3Rpb24gQihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBmIChnICh4KSk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICAvLyAgQyA6OiAoYSAtPiBiIC0+IGMpIC0+IGIgLT4gYSAtPiBjXG4gIGZ1bmN0aW9uIEMoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gZiAoeCkgKHkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG5cbiAgLy8gIEZuIDo6IFR5cGUgLT4gVHlwZSAtPiBUeXBlXG4gIGZ1bmN0aW9uIEZuKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuICQuRnVuY3Rpb24gKFt4LCB5XSk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICBnZXRfIDo6IFN0cmluZyAtPiBhIC0+IE1heWJlIGJcbiAgZnVuY3Rpb24gZ2V0XyhrZXkpIHtcbiAgICByZXR1cm4gQiAoZnVuY3Rpb24ob2JqKSB7IHJldHVybiBrZXkgaW4gb2JqID8gSnVzdCAob2JqW2tleV0pIDogTm90aGluZzsgfSlcbiAgICAgICAgICAgICAodG9PYmplY3QpO1xuICB9XG5cbiAgLy8gIGludm9rZTAgOjogU3RyaW5nIC0+IGEgLT4gYlxuICBmdW5jdGlvbiBpbnZva2UwKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGFyZ2V0W25hbWVdICgpO1xuICAgIH07XG4gIH1cblxuICAvLyAgaW52b2tlMSA6OiBTdHJpbmcgLT4gYSAtPiBiIC0+IGNcbiAgZnVuY3Rpb24gaW52b2tlMShuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtuYW1lXSAoeCk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cblxuICAvLyAgdG9PYmplY3QgOjogYSAtPiBPYmplY3RcbiAgZnVuY3Rpb24gdG9PYmplY3QoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgPyBPYmplY3QuY3JlYXRlIChudWxsKSA6IE9iamVjdCAoeCk7XG4gIH1cblxuICAvLyAgdHlwZUVxIDo6IFN0cmluZyAtPiBhIC0+IEJvb2xlYW5cbiAgZnVuY3Rpb24gdHlwZUVxKHR5cGVJZGVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZSAoeCkgPT09IHR5cGVJZGVudDtcbiAgICB9O1xuICB9XG5cbiAgLy8gIHZhbHVlIDo6IHsgdmFsdWUgOjogYSB9IC0+IGFcbiAgZnVuY3Rpb24gdmFsdWUocikge1xuICAgIHJldHVybiByLnZhbHVlO1xuICB9XG5cbiAgLy8gIDo6IFR5cGVcbiAgdmFyIGEgPSAkLlR5cGVWYXJpYWJsZSAoJ2EnKTtcbiAgdmFyIGIgPSAkLlR5cGVWYXJpYWJsZSAoJ2InKTtcbiAgdmFyIGMgPSAkLlR5cGVWYXJpYWJsZSAoJ2MnKTtcbiAgdmFyIGQgPSAkLlR5cGVWYXJpYWJsZSAoJ2QnKTtcbiAgdmFyIGUgPSAkLlR5cGVWYXJpYWJsZSAoJ2UnKTtcbiAgdmFyIGcgPSAkLlR5cGVWYXJpYWJsZSAoJ2cnKTtcbiAgdmFyIGwgPSAkLlR5cGVWYXJpYWJsZSAoJ2wnKTtcbiAgdmFyIHIgPSAkLlR5cGVWYXJpYWJsZSAoJ3InKTtcblxuICAvLyAgOjogVHlwZSAtPiBUeXBlXG4gIHZhciBmID0gJC5VbmFyeVR5cGVWYXJpYWJsZSAoJ2YnKTtcbiAgdmFyIG0gPSAkLlVuYXJ5VHlwZVZhcmlhYmxlICgnbScpO1xuICB2YXIgdCA9ICQuVW5hcnlUeXBlVmFyaWFibGUgKCd0Jyk7XG4gIHZhciB3ID0gJC5VbmFyeVR5cGVWYXJpYWJsZSAoJ3cnKTtcblxuICAvLyAgOjogVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgdmFyIHAgPSAkLkJpbmFyeVR5cGVWYXJpYWJsZSAoJ3AnKTtcbiAgdmFyIHMgPSAkLkJpbmFyeVR5cGVWYXJpYWJsZSAoJ3MnKTtcblxuICAvLyAgJEVpdGhlciA6OiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICB2YXIgJEVpdGhlciA9ICQuQmluYXJ5VHlwZVxuICAgICgnc2FuY3R1YXJ5L0VpdGhlcicpXG4gICAgKCdodHRwczovL2dpdGh1Yi5jb20vc2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1laXRoZXInKVxuICAgICh0eXBlRXEgKCdzYW5jdHVhcnktZWl0aGVyL0VpdGhlckAxJykpXG4gICAgKGVpdGhlciAob2YgKEFycmF5KSkgKEsgKFtdKSkpXG4gICAgKGVpdGhlciAoSyAoW10pKSAob2YgKEFycmF5KSkpO1xuXG4gIC8vICAkTWF5YmUgOjogVHlwZSAtPiBUeXBlXG4gIHZhciAkTWF5YmUgPSAkLlVuYXJ5VHlwZVxuICAgICgnc2FuY3R1YXJ5L01heWJlJylcbiAgICAoJ2h0dHBzOi8vZ2l0aHViLmNvbS9zYW5jdHVhcnktanMvc2FuY3R1YXJ5LW1heWJlJylcbiAgICAodHlwZUVxICgnc2FuY3R1YXJ5LW1heWJlL01heWJlQDEnKSlcbiAgICAobWF5YmUgKFtdKSAob2YgKEFycmF5KSkpO1xuXG4gIC8vICAkUGFpciA6OiBUeXBlIC0+IFR5cGUgLT4gVHlwZVxuICB2YXIgJFBhaXIgPSAkLkJpbmFyeVR5cGVcbiAgICAoJ3NhbmN0dWFyeS9QYWlyJylcbiAgICAoJ2h0dHBzOi8vZ2l0aHViLmNvbS9zYW5jdHVhcnktanMvc2FuY3R1YXJ5LXBhaXInKVxuICAgICh0eXBlRXEgKCdzYW5jdHVhcnktcGFpci9QYWlyQDEnKSlcbiAgICAoZnVuY3Rpb24ocGFpcikgeyByZXR1cm4gW3BhaXIuZnN0XTsgfSlcbiAgICAoZnVuY3Rpb24ocGFpcikgeyByZXR1cm4gW3BhaXIuc25kXTsgfSk7XG5cbiAgLy8gIFR5cGVSZXAgOjogVHlwZSAtPiBUeXBlXG4gIHZhciBUeXBlUmVwID0gJC5VbmFyeVR5cGVcbiAgICAoJ3NhbmN0dWFyeS9UeXBlUmVwJylcbiAgICAoJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjdHlwZS1yZXByZXNlbnRhdGl2ZXMnKVxuICAgIChmdW5jdGlvbih4KSB7XG4gICAgICAgcmV0dXJuICQuQW55RnVuY3Rpb24uX3Rlc3QgKHgpIHx8XG4gICAgICAgICAgICAgIHggIT0gbnVsbCAmJiAkLlN0cmluZy5fdGVzdCAoeFsnQEB0eXBlJ10pO1xuICAgICB9KVxuICAgIChLIChbXSkpO1xuXG4gIC8vICBPcHRpb25zIDo6IFR5cGVcbiAgdmFyIE9wdGlvbnMgPSAkLlJlY29yZFR5cGUgKHtjaGVja1R5cGVzOiAkLkJvb2xlYW4sIGVudjogJC5BcnJheSAoJC5BbnkpfSk7XG5cbiAgdmFyIF8gPSB7fTtcblxuICAvLy4gIyMjIENvbmZpZ3VyZVxuXG4gIC8vIyBjcmVhdGUgOjogeyBjaGVja1R5cGVzIDo6IEJvb2xlYW4sIGVudiA6OiBBcnJheSBUeXBlIH0gLT4gTW9kdWxlXG4gIC8vLlxuICAvLy4gVGFrZXMgYW4gb3B0aW9ucyByZWNvcmQgYW5kIHJldHVybnMgYSBTYW5jdHVhcnkgbW9kdWxlLiBgY2hlY2tUeXBlc2BcbiAgLy8uIHNwZWNpZmllcyB3aGV0aGVyIHRvIGVuYWJsZSB0eXBlIGNoZWNraW5nLiBUaGUgbW9kdWxlJ3MgcG9seW1vcnBoaWNcbiAgLy8uIGZ1bmN0aW9ucyAoc3VjaCBhcyBbYElgXSgjSSkpIHJlcXVpcmUgZWFjaCB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYVxuICAvLy4gdHlwZSB2YXJpYWJsZSB0byBiZSBhIG1lbWJlciBvZiBhdCBsZWFzdCBvbmUgdHlwZSBpbiB0aGUgZW52aXJvbm1lbnQuXG4gIC8vLlxuICAvLy4gQSB3ZWxsLXR5cGVkIGFwcGxpY2F0aW9uIG9mIGEgU2FuY3R1YXJ5IGZ1bmN0aW9uIHdpbGwgcHJvZHVjZSB0aGUgc2FtZVxuICAvLy4gcmVzdWx0IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0eXBlIGNoZWNraW5nIGlzIGVuYWJsZWQuIElmIHR5cGUgY2hlY2tpbmdcbiAgLy8uIGlzIGVuYWJsZWQsIGEgYmFkbHkgdHlwZWQgYXBwbGljYXRpb24gd2lsbCBwcm9kdWNlIGFuIGV4Y2VwdGlvbiB3aXRoIGFcbiAgLy8uIGRlc2NyaXB0aXZlIGVycm9yIG1lc3NhZ2UuXG4gIC8vLlxuICAvLy4gVGhlIGZvbGxvd2luZyBzbmlwcGV0IGRlbW9uc3RyYXRlcyBkZWZpbmluZyBhIGN1c3RvbSB0eXBlIGFuZCB1c2luZ1xuICAvLy4gYGNyZWF0ZWAgdG8gcHJvZHVjZSBhIFNhbmN0dWFyeSBtb2R1bGUgd2hpY2ggaXMgYXdhcmUgb2YgdGhhdCB0eXBlOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uIGNvbnN0IHtjcmVhdGUsIGVudn0gPSByZXF1aXJlICgnc2FuY3R1YXJ5Jyk7XG4gIC8vLiBjb25zdCAkID0gcmVxdWlyZSAoJ3NhbmN0dWFyeS1kZWYnKTtcbiAgLy8uIGNvbnN0IHR5cGUgPSByZXF1aXJlICgnc2FuY3R1YXJ5LXR5cGUtaWRlbnRpZmllcnMnKTtcbiAgLy8uXG4gIC8vLiAvLyAgICBJZGVudGl0eSA6OiBhIC0+IElkZW50aXR5IGFcbiAgLy8uIGNvbnN0IElkZW50aXR5ID0geCA9PiB7XG4gIC8vLiAgIGNvbnN0IGlkZW50aXR5ID0gT2JqZWN0LmNyZWF0ZSAoSWRlbnRpdHkkcHJvdG90eXBlKTtcbiAgLy8uICAgaWRlbnRpdHkudmFsdWUgPSB4O1xuICAvLy4gICByZXR1cm4gaWRlbnRpdHk7XG4gIC8vLiB9O1xuICAvLy5cbiAgLy8uIElkZW50aXR5WydAQHR5cGUnXSA9ICdteS1wYWNrYWdlL0lkZW50aXR5QDEnO1xuICAvLy5cbiAgLy8uIGNvbnN0IElkZW50aXR5JHByb3RvdHlwZSA9IHtcbiAgLy8uICAgJ2NvbnN0cnVjdG9yJzogSWRlbnRpdHksXG4gIC8vLiAgICdAQHNob3cnOiBmdW5jdGlvbigpIHsgcmV0dXJuIGBJZGVudGl0eSAoJHtTLnNob3cgKHRoaXMudmFsdWUpfSlgOyB9LFxuICAvLy4gICAnZmFudGFzeS1sYW5kL21hcCc6IGZ1bmN0aW9uKGYpIHsgcmV0dXJuIElkZW50aXR5IChmICh0aGlzLnZhbHVlKSk7IH0sXG4gIC8vLiB9O1xuICAvLy5cbiAgLy8uIC8vICAgIElkZW50aXR5VHlwZSA6OiBUeXBlIC0+IFR5cGVcbiAgLy8uIGNvbnN0IElkZW50aXR5VHlwZSA9ICQuVW5hcnlUeXBlXG4gIC8vLiAgIChJZGVudGl0eVsnQEB0eXBlJ10pXG4gIC8vLiAgICgnaHR0cDovL2V4YW1wbGUuY29tL215LXBhY2thZ2UjSWRlbnRpdHknKVxuICAvLy4gICAoeCA9PiB0eXBlICh4KSA9PT0gSWRlbnRpdHlbJ0BAdHlwZSddKVxuICAvLy4gICAoaWRlbnRpdHkgPT4gW2lkZW50aXR5LnZhbHVlXSk7XG4gIC8vLlxuICAvLy4gY29uc3QgUyA9IGNyZWF0ZSAoe1xuICAvLy4gICBjaGVja1R5cGVzOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAvLy4gICBlbnY6IGVudi5jb25jYXQgKFtJZGVudGl0eVR5cGUgKCQuVW5rbm93bildKSxcbiAgLy8uIH0pO1xuICAvLy5cbiAgLy8uIFMubWFwIChTLnN1YiAoMSkpIChJZGVudGl0eSAoNDMpKTtcbiAgLy8uIC8vID0+IElkZW50aXR5ICg0MilcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZW52YF0oI2VudikuXG4gIGZ1bmN0aW9uIGNyZWF0ZShvcHRzKSB7XG4gICAgdmFyIGRlZiA9ICQuY3JlYXRlIChvcHRzKTtcbiAgICB2YXIgUyA9IHtcbiAgICAgIGVudjogb3B0cy5lbnYsXG4gICAgICBpczogZGVmICgnaXMnKSAoe30pIChbJC5UeXBlLCAkLkFueSwgJC5Cb29sZWFuXSkgKCQudGVzdCAob3B0cy5lbnYpKSxcbiAgICAgIE1heWJlVHlwZTogJE1heWJlLFxuICAgICAgTWF5YmU6IE1heWJlLFxuICAgICAgTm90aGluZzogTm90aGluZyxcbiAgICAgIEVpdGhlclR5cGU6ICRFaXRoZXIsXG4gICAgICBFaXRoZXI6IEVpdGhlcixcbiAgICAgIFBhaXJUeXBlOiAkUGFpclxuICAgIH07XG4gICAgKE9iamVjdC5rZXlzIChfKSkuZm9yRWFjaCAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgU1tuYW1lXSA9IGRlZiAobmFtZSkgKF9bbmFtZV0uY29uc3RzKSAoX1tuYW1lXS50eXBlcykgKF9bbmFtZV0uaW1wbCk7XG4gICAgfSk7XG4gICAgUy51bmNoZWNrZWQgPSBvcHRzLmNoZWNrVHlwZXMgPyBjcmVhdGUgKHtjaGVja1R5cGVzOiBmYWxzZSwgZW52OiBvcHRzLmVudn0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBTO1xuICAgIHJldHVybiBTO1xuICB9XG4gIF8uY3JlYXRlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtPcHRpb25zLCAkLk9iamVjdF0sXG4gICAgaW1wbDogY3JlYXRlXG4gIH07XG5cbiAgLy8jIGVudiA6OiBBcnJheSBUeXBlXG4gIC8vLlxuICAvLy4gVGhlIFNhbmN0dWFyeSBtb2R1bGUncyBlbnZpcm9ubWVudCAoYChTLmNyZWF0ZSAoe2NoZWNrVHlwZXMsIGVudn0pKS5lbnZgXG4gIC8vLiBpcyBhIHJlZmVyZW5jZSB0byBgZW52YCkuIFVzZWZ1bCBpbiBjb25qdW5jdGlvbiB3aXRoIFtgY3JlYXRlYF0oI2NyZWF0ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVudlxuICAvLy4gWyAkLkFueUZ1bmN0aW9uLFxuICAvLy4gLiAkLkFyZ3VtZW50cyxcbiAgLy8uIC4gJC5BcnJheSAoJC5Vbmtub3duKSxcbiAgLy8uIC4gJC5Cb29sZWFuLFxuICAvLy4gLiAkLkRhdGUsXG4gIC8vLiAuICQuRXJyb3IsXG4gIC8vLiAuICQuSHRtbEVsZW1lbnQsXG4gIC8vLiAuICQuTnVsbCxcbiAgLy8uIC4gJC5OdW1iZXIsXG4gIC8vLiAuICQuT2JqZWN0LFxuICAvLy4gLiAkLlJlZ0V4cCxcbiAgLy8uIC4gJC5TdHJNYXAgKCQuVW5rbm93biksXG4gIC8vLiAuICQuU3RyaW5nLFxuICAvLy4gLiAkLlN5bWJvbCxcbiAgLy8uIC4gJC5VbmRlZmluZWQsXG4gIC8vLiAuICQuRmluaXRlTnVtYmVyLFxuICAvLy4gLiAkLk5vblplcm9GaW5pdGVOdW1iZXIsXG4gIC8vLiAuIFMuRWl0aGVyVHlwZSAoJC5Vbmtub3duKSAoJC5Vbmtub3duKSxcbiAgLy8uIC4gJC5GdW5jdGlvbiAoWyQuVW5rbm93biwgJC5Vbmtub3duXSksXG4gIC8vLiAuICQuR2xvYmFsUmVnRXhwLFxuICAvLy4gLiAkLk5vbkdsb2JhbFJlZ0V4cCxcbiAgLy8uIC4gJC5JbnRlZ2VyLFxuICAvLy4gLiAkLk5vbk5lZ2F0aXZlSW50ZWdlcixcbiAgLy8uIC4gUy5NYXliZVR5cGUgKCQuVW5rbm93biksXG4gIC8vLiAuICQuQXJyYXkyICgkLlVua25vd24pICgkLlVua25vd24pLFxuICAvLy4gLiBTLlBhaXJUeXBlICgkLlVua25vd24pICgkLlVua25vd24pLFxuICAvLy4gLiAkLlJlZ2V4RmxhZ3MsXG4gIC8vLiAuICQuVHlwZSxcbiAgLy8uIC4gJC5UeXBlQ2xhc3MsXG4gIC8vLiAuICQuVmFsaWREYXRlLFxuICAvLy4gLiAkLlZhbGlkTnVtYmVyIF1cbiAgLy8uIGBgYFxuXG4gIC8vIyB1bmNoZWNrZWQgOjogTW9kdWxlXG4gIC8vLlxuICAvLy4gQSBjb21wbGV0ZSBTYW5jdHVhcnkgbW9kdWxlIHdoaWNoIHBlcmZvcm1zIG5vIHR5cGUgY2hlY2tpbmcuIFRoaXMgaXNcbiAgLy8uIHVzZWZ1bCBhcyBpdCBwZXJtaXRzIG9wZXJhdGlvbnMgd2hpY2ggU2FuY3R1YXJ5J3MgdHlwZSBjaGVja2luZyB3b3VsZFxuICAvLy4gZGlzYWxsb3csIHN1Y2ggYXMgbWFwcGluZyBvdmVyIGFuIG9iamVjdCB3aXRoIGhldGVyb2dlbmVvdXMgdmFsdWVzLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgY3JlYXRlYF0oI2NyZWF0ZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnVuY2hlY2tlZC5tYXAgKFMuc2hvdykgKHt4OiAnZm9vJywgeTogdHJ1ZSwgejogNDJ9KVxuICAvLy4ge3g6ICdcImZvb1wiJywgeTogJ3RydWUnLCB6OiAnNDInfVxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gT3B0aW5nIG91dCBvZiB0eXBlIGNoZWNraW5nIG1heSBjYXVzZSB0eXBlIGVycm9ycyB0byBnbyB1bm5vdGljZWQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnVuY2hlY2tlZC5hZGQgKDIpICgnMicpXG4gIC8vLiAnMjInXG4gIC8vLiBgYGBcblxuICAvLy4gIyMjIENsYXNzaWZ5XG5cbiAgLy8jIHR5cGUgOjogQW55IC0+IHsgbmFtZXNwYWNlIDo6IE1heWJlIFN0cmluZywgbmFtZSA6OiBTdHJpbmcsIHZlcnNpb24gOjogTm9uTmVnYXRpdmVJbnRlZ2VyIH1cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgcGFyc2luZyB0aGUgW3R5cGUgaWRlbnRpZmllcl1bXSBvZiB0aGUgZ2l2ZW4gdmFsdWUuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnR5cGUgKFMuSnVzdCAoNDIpKVxuICAvLy4ge25hbWVzcGFjZTogSnVzdCAoJ3NhbmN0dWFyeS1tYXliZScpLCBuYW1lOiAnTWF5YmUnLCB2ZXJzaW9uOiAxfVxuICAvLy5cbiAgLy8uID4gUy50eXBlIChbMSwgMiwgM10pXG4gIC8vLiB7bmFtZXNwYWNlOiBOb3RoaW5nLCBuYW1lOiAnQXJyYXknLCB2ZXJzaW9uOiAwfVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHR5cGVfKHgpIHtcbiAgICB2YXIgciA9IHR5cGUucGFyc2UgKHR5cGUgKHgpKTtcbiAgICByLm5hbWVzcGFjZSA9IHRvTWF5YmUgKHIubmFtZXNwYWNlKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBfLnR5cGUgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuQW55LFxuICAgICAgICAgICAgJC5SZWNvcmRUeXBlICh7bmFtZXNwYWNlOiAkTWF5YmUgKCQuU3RyaW5nKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICQuU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJC5Ob25OZWdhdGl2ZUludGVnZXJ9KV0sXG4gICAgaW1wbDogdHlwZV9cbiAgfTtcblxuICAvLyMgaXMgOjogVHlwZSAtPiBBbnkgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIFtpZmZdW10gdGhlIGdpdmVuIHZhbHVlIGlzIGEgbWVtYmVyIG9mIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAgLy8uIFNlZSBbYCQudGVzdGBdW10gZm9yIGRldGFpbHMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmlzICgkLkFycmF5ICgkLkludGVnZXIpKSAoWzEsIDIsIDNdKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5pcyAoJC5BcnJheSAoJC5JbnRlZ2VyKSkgKFsxLCAyLCAzLjE0XSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcblxuICAvLy4gIyMjIFNob3dhYmxlXG5cbiAgLy8jIHNob3cgOjogQW55IC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIEFsaWFzIG9mIFtgc2hvd2BdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNob3cgKC0wKVxuICAvLy4gJy0wJ1xuICAvLy5cbiAgLy8uID4gUy5zaG93IChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAnW1wiZm9vXCIsIFwiYmFyXCIsIFwiYmF6XCJdJ1xuICAvLy5cbiAgLy8uID4gUy5zaG93ICh7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiAne1wieFwiOiAxLCBcInlcIjogMiwgXCJ6XCI6IDN9J1xuICAvLy5cbiAgLy8uID4gUy5zaG93IChTLkxlZnQgKFMuUmlnaHQgKFMuSnVzdCAoUy5Ob3RoaW5nKSkpKVxuICAvLy4gJ0xlZnQgKFJpZ2h0IChKdXN0IChOb3RoaW5nKSkpJ1xuICAvLy4gYGBgXG4gIF8uc2hvdyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5BbnksICQuU3RyaW5nXSxcbiAgICBpbXBsOiBzaG93XG4gIH07XG5cbiAgLy8uICMjIyBGYW50YXN5IExhbmRcbiAgLy8uXG4gIC8vLiBTYW5jdHVhcnkgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBbRmFudGFzeSBMYW5kXVtdIHNwZWNpZmljYXRpb24uXG5cbiAgLy8jIGVxdWFscyA6OiBTZXRvaWQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouZXF1YWxzYF1bXSB3aGljaCByZXF1aXJlcyB0d28gYXJndW1lbnRzIG9mIHRoZVxuICAvLy4gc2FtZSB0eXBlLlxuICAvLy5cbiAgLy8uIFRvIGNvbXBhcmUgdmFsdWVzIG9mIGRpZmZlcmVudCB0eXBlcyBmaXJzdCB1c2UgW2BjcmVhdGVgXSgjY3JlYXRlKSB0b1xuICAvLy4gY3JlYXRlIGEgU2FuY3R1YXJ5IG1vZHVsZSB3aXRoIHR5cGUgY2hlY2tpbmcgZGlzYWJsZWQsIHRoZW4gdXNlIHRoYXRcbiAgLy8uIG1vZHVsZSdzIGBlcXVhbHNgIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5lcXVhbHMgKDApICgtMClcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuZXF1YWxzIChOYU4pIChOYU4pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmVxdWFscyAoUy5KdXN0IChbMSwgMiwgM10pKSAoUy5KdXN0IChbMSwgMiwgM10pKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5lcXVhbHMgKFMuSnVzdCAoWzEsIDIsIDNdKSkgKFMuSnVzdCAoWzEsIDIsIDRdKSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgXy5lcXVhbHMgPSB7XG4gICAgY29uc3RzOiB7YTogW1ouU2V0b2lkXX0sXG4gICAgdHlwZXM6IFthLCBhLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5lcXVhbHMpXG4gIH07XG5cbiAgLy8jIGx0IDo6IE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgW2lmZl1bXSB0aGUgKnNlY29uZCogYXJndW1lbnQgaXMgbGVzcyB0aGFuIHRoZSBmaXJzdFxuICAvLy4gYWNjb3JkaW5nIHRvIFtgWi5sdGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbHRlciAoUy5sdCAoMykpIChbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiBbMSwgMl1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBsdCh5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBaLmx0ICh4LCB5KTtcbiAgICB9O1xuICB9XG4gIF8ubHQgPSB7XG4gICAgY29uc3RzOiB7YTogW1ouT3JkXX0sXG4gICAgdHlwZXM6IFthLCBhLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGx0XG4gIH07XG5cbiAgLy8jIGx0ZSA6OiBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIFtpZmZdW10gdGhlICpzZWNvbmQqIGFyZ3VtZW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAvLy4gdGhlIGZpcnN0IGFjY29yZGluZyB0byBbYFoubHRlYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZmlsdGVyIChTLmx0ZSAoMykpIChbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBsdGUoeSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gWi5sdGUgKHgsIHkpO1xuICAgIH07XG4gIH1cbiAgXy5sdGUgPSB7XG4gICAgY29uc3RzOiB7YTogW1ouT3JkXX0sXG4gICAgdHlwZXM6IFthLCBhLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGx0ZVxuICB9O1xuXG4gIC8vIyBndCA6OiBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIFJldHVybnMgYHRydWVgIFtpZmZdW10gdGhlICpzZWNvbmQqIGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgZmlyc3RcbiAgLy8uIGFjY29yZGluZyB0byBbYFouZ3RgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5maWx0ZXIgKFMuZ3QgKDMpKSAoWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gWzQsIDVdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZ3QoeSkge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gWi5ndCAoeCwgeSk7XG4gICAgfTtcbiAgfVxuICBfLmd0ID0ge1xuICAgIGNvbnN0czoge2E6IFtaLk9yZF19LFxuICAgIHR5cGVzOiBbYSwgYSwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBndFxuICB9O1xuXG4gIC8vIyBndGUgOjogT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSAqc2Vjb25kKiBhcmd1bWVudCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWxcbiAgLy8uIHRvIHRoZSBmaXJzdCBhY2NvcmRpbmcgdG8gW2BaLmd0ZWBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbHRlciAoUy5ndGUgKDMpKSAoWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gWzMsIDQsIDVdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZ3RlKHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFouZ3RlICh4LCB5KTtcbiAgICB9O1xuICB9XG4gIF8uZ3RlID0ge1xuICAgIGNvbnN0czoge2E6IFtaLk9yZF19LFxuICAgIHR5cGVzOiBbYSwgYSwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBndGVcbiAgfTtcblxuICAvLyMgbWluIDo6IE9yZCBhID0+IGEgLT4gYSAtPiBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgc21hbGxlciBvZiBpdHMgdHdvIGFyZ3VtZW50cyAoYWNjb3JkaW5nIHRvIFtgWi5sdGVgXVtdKS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1heGBdKCNtYXgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5taW4gKDEwKSAoMilcbiAgLy8uIDJcbiAgLy8uXG4gIC8vLiA+IFMubWluIChuZXcgRGF0ZSAoJzE5OTktMTItMzEnKSkgKG5ldyBEYXRlICgnMjAwMC0wMS0wMScpKVxuICAvLy4gbmV3IERhdGUgKCcxOTk5LTEyLTMxJylcbiAgLy8uXG4gIC8vLiA+IFMubWluICgnMTAnKSAoJzInKVxuICAvLy4gJzEwJ1xuICAvLy4gYGBgXG4gIF8ubWluID0ge1xuICAgIGNvbnN0czoge2E6IFtaLk9yZF19LFxuICAgIHR5cGVzOiBbYSwgYSwgYV0sXG4gICAgaW1wbDogY3VycnkyIChaLm1pbilcbiAgfTtcblxuICAvLyMgbWF4IDo6IE9yZCBhID0+IGEgLT4gYSAtPiBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgbGFyZ2VyIG9mIGl0cyB0d28gYXJndW1lbnRzIChhY2NvcmRpbmcgdG8gW2BaLmx0ZWBdW10pLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbWluYF0oI21pbikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1heCAoMTApICgyKVxuICAvLy4gMTBcbiAgLy8uXG4gIC8vLiA+IFMubWF4IChuZXcgRGF0ZSAoJzE5OTktMTItMzEnKSkgKG5ldyBEYXRlICgnMjAwMC0wMS0wMScpKVxuICAvLy4gbmV3IERhdGUgKCcyMDAwLTAxLTAxJylcbiAgLy8uXG4gIC8vLiA+IFMubWF4ICgnMTAnKSAoJzInKVxuICAvLy4gJzInXG4gIC8vLiBgYGBcbiAgXy5tYXggPSB7XG4gICAgY29uc3RzOiB7YTogW1ouT3JkXX0sXG4gICAgdHlwZXM6IFthLCBhLCBhXSxcbiAgICBpbXBsOiBjdXJyeTIgKFoubWF4KVxuICB9O1xuXG4gIC8vIyBpZCA6OiBDYXRlZ29yeSBjID0+IFR5cGVSZXAgYyAtPiBjXG4gIC8vLlxuICAvLy4gW1R5cGUtc2FmZV1bc2FuY3R1YXJ5LWRlZl0gdmVyc2lvbiBvZiBbYFouaWRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pZCAoRnVuY3Rpb24pICg0MilcbiAgLy8uIDQyXG4gIC8vLiBgYGBcbiAgXy5pZCA9IHtcbiAgICBjb25zdHM6IHtjOiBbWi5DYXRlZ29yeV19LFxuICAgIHR5cGVzOiBbVHlwZVJlcCAoYyksIGNdLFxuICAgIGltcGw6IFouaWRcbiAgfTtcblxuICAvLyMgY29uY2F0IDo6IFNlbWlncm91cCBhID0+IGEgLT4gYSAtPiBhXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5jb25jYXRgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jb25jYXQgKCdhYmMnKSAoJ2RlZicpXG4gIC8vLiAnYWJjZGVmJ1xuICAvLy5cbiAgLy8uID4gUy5jb25jYXQgKFsxLCAyLCAzXSkgKFs0LCA1LCA2XSlcbiAgLy8uIFsxLCAyLCAzLCA0LCA1LCA2XVxuICAvLy5cbiAgLy8uID4gUy5jb25jYXQgKHt4OiAxLCB5OiAyfSkgKHt5OiAzLCB6OiA0fSlcbiAgLy8uIHt4OiAxLCB5OiAzLCB6OiA0fVxuICAvLy5cbiAgLy8uID4gUy5jb25jYXQgKFMuSnVzdCAoWzEsIDIsIDNdKSkgKFMuSnVzdCAoWzQsIDUsIDZdKSlcbiAgLy8uIEp1c3QgKFsxLCAyLCAzLCA0LCA1LCA2XSlcbiAgLy8uXG4gIC8vLiA+IFMuY29uY2F0IChTdW0gKDE4KSkgKFN1bSAoMjQpKVxuICAvLy4gU3VtICg0MilcbiAgLy8uIGBgYFxuICBfLmNvbmNhdCA9IHtcbiAgICBjb25zdHM6IHthOiBbWi5TZW1pZ3JvdXBdfSxcbiAgICB0eXBlczogW2EsIGEsIGFdLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5jb25jYXQpXG4gIH07XG5cbiAgLy8jIGVtcHR5IDo6IE1vbm9pZCBhID0+IFR5cGVSZXAgYSAtPiBhXG4gIC8vLlxuICAvLy4gW1R5cGUtc2FmZV1bc2FuY3R1YXJ5LWRlZl0gdmVyc2lvbiBvZiBbYFouZW1wdHlgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5lbXB0eSAoU3RyaW5nKVxuICAvLy4gJydcbiAgLy8uXG4gIC8vLiA+IFMuZW1wdHkgKEFycmF5KVxuICAvLy4gW11cbiAgLy8uXG4gIC8vLiA+IFMuZW1wdHkgKE9iamVjdClcbiAgLy8uIHt9XG4gIC8vLlxuICAvLy4gPiBTLmVtcHR5IChTdW0pXG4gIC8vLiBTdW0gKDApXG4gIC8vLiBgYGBcbiAgXy5lbXB0eSA9IHtcbiAgICBjb25zdHM6IHthOiBbWi5Nb25vaWRdfSxcbiAgICB0eXBlczogW1R5cGVSZXAgKGEpLCBhXSxcbiAgICBpbXBsOiBaLmVtcHR5XG4gIH07XG5cbiAgLy8jIGludmVydCA6OiBHcm91cCBnID0+IGcgLT4gZ1xuICAvLy5cbiAgLy8uIFtUeXBlLXNhZmVdW3NhbmN0dWFyeS1kZWZdIHZlcnNpb24gb2YgW2BaLmludmVydGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmludmVydCAoU3VtICg1KSlcbiAgLy8uIFN1bSAoLTUpXG4gIC8vLiBgYGBcbiAgXy5pbnZlcnQgPSB7XG4gICAgY29uc3RzOiB7ZzogW1ouR3JvdXBdfSxcbiAgICB0eXBlczogW2csIGddLFxuICAgIGltcGw6IFouaW52ZXJ0XG4gIH07XG5cbiAgLy8jIGZpbHRlciA6OiBGaWx0ZXJhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbikgLT4gZiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouZmlsdGVyYF1bXS4gRGlzY2FyZHMgZXZlcnkgZWxlbWVudCB3aGljaCBkb2VzIG5vdFxuICAvLy4gc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgcmVqZWN0YF0oI3JlamVjdCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZpbHRlciAoUy5vZGQpIChbMSwgMiwgM10pXG4gIC8vLiBbMSwgM11cbiAgLy8uXG4gIC8vLiA+IFMuZmlsdGVyIChTLm9kZCkgKHt4OiAxLCB5OiAyLCB6OiAzfSlcbiAgLy8uIHt4OiAxLCB6OiAzfVxuICAvLy5cbiAgLy8uID4gUy5maWx0ZXIgKFMub2RkKSAoUy5Ob3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5maWx0ZXIgKFMub2RkKSAoUy5KdXN0ICgwKSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZmlsdGVyIChTLm9kZCkgKFMuSnVzdCAoMSkpXG4gIC8vLiBKdXN0ICgxKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGZpbHRlcihwcmVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGZpbHRlcmFibGUpIHtcbiAgICAgIHJldHVybiBaLmZpbHRlciAocHJlZCwgZmlsdGVyYWJsZSk7XG4gICAgfTtcbiAgfVxuICBfLmZpbHRlciA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5GaWx0ZXJhYmxlXX0sXG4gICAgdHlwZXM6IFskLlByZWRpY2F0ZSAoYSksIGYgKGEpLCBmIChhKV0sXG4gICAgaW1wbDogZmlsdGVyXG4gIH07XG5cbiAgLy8jIHJlamVjdCA6OiBGaWx0ZXJhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbikgLT4gZiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFoucmVqZWN0YF1bXS4gRGlzY2FyZHMgZXZlcnkgZWxlbWVudCB3aGljaCBzYXRpc2ZpZXNcbiAgLy8uIHRoZSBwcmVkaWNhdGUuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BmaWx0ZXJgXSgjZmlsdGVyKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmVqZWN0IChTLm9kZCkgKFsxLCAyLCAzXSlcbiAgLy8uIFsyXVxuICAvLy5cbiAgLy8uID4gUy5yZWplY3QgKFMub2RkKSAoe3g6IDEsIHk6IDIsIHo6IDN9KVxuICAvLy4ge3k6IDJ9XG4gIC8vLlxuICAvLy4gPiBTLnJlamVjdCAoUy5vZGQpIChTLk5vdGhpbmcpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLnJlamVjdCAoUy5vZGQpIChTLkp1c3QgKDApKVxuICAvLy4gSnVzdCAoMClcbiAgLy8uXG4gIC8vLiA+IFMucmVqZWN0IChTLm9kZCkgKFMuSnVzdCAoMSkpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgXy5yZWplY3QgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRmlsdGVyYWJsZV19LFxuICAgIHR5cGVzOiBbJC5QcmVkaWNhdGUgKGEpLCBmIChhKSwgZiAoYSldLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5yZWplY3QpXG4gIH07XG5cbiAgLy8jIHRha2VXaGlsZSA6OiBGaWx0ZXJhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbikgLT4gZiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFoudGFrZVdoaWxlYF1bXS4gRGlzY2FyZHMgdGhlIGZpcnN0IGVsZW1lbnQgd2hpY2hcbiAgLy8uIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSwgYW5kIGFsbCBzdWJzZXF1ZW50IGVsZW1lbnRzLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZHJvcFdoaWxlYF0oI2Ryb3BXaGlsZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRha2VXaGlsZSAoUy5vZGQpIChbMywgMywgMywgNywgNiwgMywgNSwgNF0pXG4gIC8vLiBbMywgMywgMywgN11cbiAgLy8uXG4gIC8vLiA+IFMudGFrZVdoaWxlIChTLmV2ZW4pIChbMywgMywgMywgNywgNiwgMywgNSwgNF0pXG4gIC8vLiBbXVxuICAvLy4gYGBgXG4gIF8udGFrZVdoaWxlID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZpbHRlcmFibGVdfSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlIChhKSwgZiAoYSksIGYgKGEpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFoudGFrZVdoaWxlKVxuICB9O1xuXG4gIC8vIyBkcm9wV2hpbGUgOjogRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmRyb3BXaGlsZWBdW10uIFJldGFpbnMgdGhlIGZpcnN0IGVsZW1lbnQgd2hpY2hcbiAgLy8uIGRvZXMgbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZSwgYW5kIGFsbCBzdWJzZXF1ZW50IGVsZW1lbnRzLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdGFrZVdoaWxlYF0oI3Rha2VXaGlsZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmRyb3BXaGlsZSAoUy5vZGQpIChbMywgMywgMywgNywgNiwgMywgNSwgNF0pXG4gIC8vLiBbNiwgMywgNSwgNF1cbiAgLy8uXG4gIC8vLiA+IFMuZHJvcFdoaWxlIChTLmV2ZW4pIChbMywgMywgMywgNywgNiwgMywgNSwgNF0pXG4gIC8vLiBbMywgMywgMywgNywgNiwgMywgNSwgNF1cbiAgLy8uIGBgYFxuICBfLmRyb3BXaGlsZSA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5GaWx0ZXJhYmxlXX0sXG4gICAgdHlwZXM6IFskLlByZWRpY2F0ZSAoYSksIGYgKGEpLCBmIChhKV0sXG4gICAgaW1wbDogY3VycnkyIChaLmRyb3BXaGlsZSlcbiAgfTtcblxuICAvLyMgbWFwIDo6IEZ1bmN0b3IgZiA9PiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5tYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXAgKE1hdGguc3FydCkgKFsxLCA0LCA5XSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gUy5tYXAgKE1hdGguc3FydCkgKHt4OiAxLCB5OiA0LCB6OiA5fSlcbiAgLy8uIHt4OiAxLCB5OiAyLCB6OiAzfVxuICAvLy5cbiAgLy8uID4gUy5tYXAgKE1hdGguc3FydCkgKFMuSnVzdCAoOSkpXG4gIC8vLiBKdXN0ICgzKVxuICAvLy5cbiAgLy8uID4gUy5tYXAgKE1hdGguc3FydCkgKFMuUmlnaHQgKDkpKVxuICAvLy4gUmlnaHQgKDMpXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoTWF0aC5zcXJ0KSAoUy5QYWlyICg5OTk4MDAwMSkgKDk5OTgwMDAxKSlcbiAgLy8uIFBhaXIgKDk5OTgwMDAxKSAoOTk5OSlcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFJlcGxhY2luZyBgRnVuY3RvciBmID0+IGZgIHdpdGggYEZ1bmN0aW9uIHhgIHByb2R1Y2VzIHRoZSBCIGNvbWJpbmF0b3JcbiAgLy8uIGZyb20gY29tYmluYXRvcnkgbG9naWMgKGkuZS4gW2Bjb21wb3NlYF0oI2NvbXBvc2UpKTpcbiAgLy8uXG4gIC8vLiAgICAgRnVuY3RvciBmID0+IChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgLy8uICAgICAoYSAtPiBiKSAtPiBGdW5jdGlvbiB4IGEgLT4gRnVuY3Rpb24geCBiXG4gIC8vLiAgICAgKGEgLT4gYykgLT4gRnVuY3Rpb24geCBhIC0+IEZ1bmN0aW9uIHggY1xuICAvLy4gICAgIChiIC0+IGMpIC0+IEZ1bmN0aW9uIHggYiAtPiBGdW5jdGlvbiB4IGNcbiAgLy8uICAgICAoYiAtPiBjKSAtPiBGdW5jdGlvbiBhIGIgLT4gRnVuY3Rpb24gYSBjXG4gIC8vLiAgICAgKGIgLT4gYykgLT4gKGEgLT4gYikgLT4gKGEgLT4gYylcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwIChNYXRoLnNxcnQpIChTLmFkZCAoMSkpICg5OSlcbiAgLy8uIDEwXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbWFwKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZnVuY3Rvcikge1xuICAgICAgcmV0dXJuIFoubWFwIChmLCBmdW5jdG9yKTtcbiAgICB9O1xuICB9XG4gIF8ubWFwID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZ1bmN0b3JdfSxcbiAgICB0eXBlczogW0ZuIChhKSAoYiksIGYgKGEpLCBmIChiKV0sXG4gICAgaW1wbDogbWFwXG4gIH07XG5cbiAgLy8jIGZsaXAgOjogRnVuY3RvciBmID0+IGYgKGEgLT4gYikgLT4gYSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmZsaXBgXVtdLiBNYXBzIG92ZXIgdGhlIGdpdmVuIGZ1bmN0aW9ucywgYXBwbHlpbmdcbiAgLy8uIGVhY2ggdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAvLy5cbiAgLy8uIFJlcGxhY2luZyBgRnVuY3RvciBmID0+IGZgIHdpdGggYEZ1bmN0aW9uIHhgIHByb2R1Y2VzIHRoZSBDIGNvbWJpbmF0b3JcbiAgLy8uIGZyb20gY29tYmluYXRvcnkgbG9naWM6XG4gIC8vLlxuICAvLy4gICAgIEZ1bmN0b3IgZiA9PiBmIChhIC0+IGIpIC0+IGEgLT4gZiBiXG4gIC8vLiAgICAgRnVuY3Rpb24geCAoYSAtPiBiKSAtPiBhIC0+IEZ1bmN0aW9uIHggYlxuICAvLy4gICAgIEZ1bmN0aW9uIHggKGEgLT4gYykgLT4gYSAtPiBGdW5jdGlvbiB4IGNcbiAgLy8uICAgICBGdW5jdGlvbiB4IChiIC0+IGMpIC0+IGIgLT4gRnVuY3Rpb24geCBjXG4gIC8vLiAgICAgRnVuY3Rpb24gYSAoYiAtPiBjKSAtPiBiIC0+IEZ1bmN0aW9uIGEgY1xuICAvLy4gICAgIChhIC0+IGIgLT4gYykgLT4gYiAtPiBhIC0+IGNcbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZmxpcCAoUy5jb25jYXQpICgnIScpICgnZm9vJylcbiAgLy8uICdmb28hJ1xuICAvLy5cbiAgLy8uID4gUy5mbGlwIChbTWF0aC5mbG9vciwgTWF0aC5jZWlsXSkgKDEuNSlcbiAgLy8uIFsxLCAyXVxuICAvLy5cbiAgLy8uID4gUy5mbGlwICh7Zmxvb3I6IE1hdGguZmxvb3IsIGNlaWw6IE1hdGguY2VpbH0pICgxLjUpXG4gIC8vLiB7Zmxvb3I6IDEsIGNlaWw6IDJ9XG4gIC8vLlxuICAvLy4gPiBTLmZsaXAgKENvbnMgKE1hdGguZmxvb3IpIChDb25zIChNYXRoLmNlaWwpIChOaWwpKSkgKDEuNSlcbiAgLy8uIENvbnMgKDEpIChDb25zICgyKSAoTmlsKSlcbiAgLy8uIGBgYFxuICBfLmZsaXAgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRnVuY3Rvcl19LFxuICAgIHR5cGVzOiBbZiAoRm4gKGEpIChiKSksIGEsIGYgKGIpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouZmxpcClcbiAgfTtcblxuICAvLyMgYmltYXAgOjogQmlmdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gKGMgLT4gZCkgLT4gZiBhIGMgLT4gZiBiIGRcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmJpbWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYmltYXAgKFMudG9VcHBlcikgKE1hdGguc3FydCkgKFMuUGFpciAoJ2ZvbycpICg2NCkpXG4gIC8vLiBQYWlyICgnRk9PJykgKDgpXG4gIC8vLlxuICAvLy4gPiBTLmJpbWFwIChTLnRvVXBwZXIpIChNYXRoLnNxcnQpIChTLkxlZnQgKCdmb28nKSlcbiAgLy8uIExlZnQgKCdGT08nKVxuICAvLy5cbiAgLy8uID4gUy5iaW1hcCAoUy50b1VwcGVyKSAoTWF0aC5zcXJ0KSAoUy5SaWdodCAoNjQpKVxuICAvLy4gUmlnaHQgKDgpXG4gIC8vLiBgYGBcbiAgXy5iaW1hcCA9IHtcbiAgICBjb25zdHM6IHtwOiBbWi5CaWZ1bmN0b3JdfSxcbiAgICB0eXBlczogW0ZuIChhKSAoYiksIEZuIChjKSAoZCksIHAgKGEpIChjKSwgcCAoYikgKGQpXSxcbiAgICBpbXBsOiBjdXJyeTMgKFouYmltYXApXG4gIH07XG5cbiAgLy8jIG1hcExlZnQgOjogQmlmdW5jdG9yIGYgPT4gKGEgLT4gYikgLT4gZiBhIGMgLT4gZiBiIGNcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLm1hcExlZnRgXVtdLiBNYXBzIHRoZSBnaXZlbiBmdW5jdGlvbiBvdmVyIHRoZSBsZWZ0XG4gIC8vLiBzaWRlIG9mIGEgQmlmdW5jdG9yLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXBMZWZ0IChTLnRvVXBwZXIpIChTLlBhaXIgKCdmb28nKSAoNjQpKVxuICAvLy4gUGFpciAoJ0ZPTycpICg2NClcbiAgLy8uXG4gIC8vLiA+IFMubWFwTGVmdCAoUy50b1VwcGVyKSAoUy5MZWZ0ICgnZm9vJykpXG4gIC8vLiBMZWZ0ICgnRk9PJylcbiAgLy8uXG4gIC8vLiA+IFMubWFwTGVmdCAoUy50b1VwcGVyKSAoUy5SaWdodCAoNjQpKVxuICAvLy4gUmlnaHQgKDY0KVxuICAvLy4gYGBgXG4gIF8ubWFwTGVmdCA9IHtcbiAgICBjb25zdHM6IHtwOiBbWi5CaWZ1bmN0b3JdfSxcbiAgICB0eXBlczogW0ZuIChhKSAoYiksIHAgKGEpIChjKSwgcCAoYikgKGMpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFoubWFwTGVmdClcbiAgfTtcblxuICAvLyMgcHJvbWFwIDo6IFByb2Z1bmN0b3IgcCA9PiAoYSAtPiBiKSAtPiAoYyAtPiBkKSAtPiBwIGIgYyAtPiBwIGEgZFxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFoucHJvbWFwYF1bXS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucHJvbWFwIChNYXRoLmFicykgKFMuYWRkICgxKSkgKE1hdGguc3FydCkgKC0xMDApXG4gIC8vLiAxMVxuICAvLy4gYGBgXG4gIF8ucHJvbWFwID0ge1xuICAgIGNvbnN0czoge3A6IFtaLlByb2Z1bmN0b3JdfSxcbiAgICB0eXBlczogW0ZuIChhKSAoYiksIEZuIChjKSAoZCksIHAgKGIpIChjKSwgcCAoYSkgKGQpXSxcbiAgICBpbXBsOiBjdXJyeTMgKFoucHJvbWFwKVxuICB9O1xuXG4gIC8vIyBhbHQgOjogQWx0IGYgPT4gZiBhIC0+IGYgYSAtPiBmIGFcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmFsdGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFsdCAoUy5Ob3RoaW5nKSAoUy5KdXN0ICgxKSlcbiAgLy8uIEp1c3QgKDEpXG4gIC8vLlxuICAvLy4gPiBTLmFsdCAoUy5KdXN0ICgyKSkgKFMuSnVzdCAoMykpXG4gIC8vLiBKdXN0ICgyKVxuICAvLy5cbiAgLy8uID4gUy5hbHQgKFMuTGVmdCAoJ1gnKSkgKFMuUmlnaHQgKDEpKVxuICAvLy4gUmlnaHQgKDEpXG4gIC8vLlxuICAvLy4gPiBTLmFsdCAoUy5SaWdodCAoMikpIChTLlJpZ2h0ICgzKSlcbiAgLy8uIFJpZ2h0ICgyKVxuICAvLy4gYGBgXG4gIF8uYWx0ID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkFsdF19LFxuICAgIHR5cGVzOiBbZiAoYSksIGYgKGEpLCBmIChhKV0sXG4gICAgaW1wbDogY3VycnkyIChaLmFsdClcbiAgfTtcblxuICAvLyMgemVybyA6OiBQbHVzIGYgPT4gVHlwZVJlcCBmIC0+IGYgYVxuICAvLy5cbiAgLy8uIFtUeXBlLXNhZmVdW3NhbmN0dWFyeS1kZWZdIHZlcnNpb24gb2YgW2BaLnplcm9gXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy56ZXJvIChBcnJheSlcbiAgLy8uIFtdXG4gIC8vLlxuICAvLy4gPiBTLnplcm8gKE9iamVjdClcbiAgLy8uIHt9XG4gIC8vLlxuICAvLy4gPiBTLnplcm8gKFMuTWF5YmUpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgXy56ZXJvID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLlBsdXNdfSxcbiAgICB0eXBlczogW1R5cGVSZXAgKCQuVHlwZVZhcmlhYmxlICgnZicpKSwgZiAoYSldLFxuICAgIGltcGw6IFouemVyb1xuICB9O1xuXG4gIC8vIyByZWR1Y2UgOjogRm9sZGFibGUgZiA9PiAoYiAtPiBhIC0+IGIpIC0+IGIgLT4gZiBhIC0+IGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGN1cnJpZWQgYmluYXJ5IGZ1bmN0aW9uLCBhbiBpbml0aWFsIHZhbHVlLCBhbmQgYSBbRm9sZGFibGVdW10sXG4gIC8vLiBhbmQgYXBwbGllcyB0aGUgZnVuY3Rpb24gdG8gdGhlIGluaXRpYWwgdmFsdWUgYW5kIHRoZSBGb2xkYWJsZSdzIGZpcnN0XG4gIC8vLiB2YWx1ZSwgdGhlbiBhcHBsaWVzIHRoZSBmdW5jdGlvbiB0byB0aGUgcmVzdWx0IG9mIHRoZSBwcmV2aW91c1xuICAvLy4gYXBwbGljYXRpb24gYW5kIHRoZSBGb2xkYWJsZSdzIHNlY29uZCB2YWx1ZS4gUmVwZWF0cyB0aGlzIHByb2Nlc3NcbiAgLy8uIHVudGlsIGVhY2ggb2YgdGhlIEZvbGRhYmxlJ3MgdmFsdWVzIGhhcyBiZWVuIHVzZWQuIFJldHVybnMgdGhlIGluaXRpYWxcbiAgLy8uIHZhbHVlIGlmIHRoZSBGb2xkYWJsZSBpcyBlbXB0eTsgdGhlIHJlc3VsdCBvZiB0aGUgZmluYWwgYXBwbGljYXRpb25cbiAgLy8uIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmVkdWNlIChTLmFkZCkgKDApIChbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiAxNVxuICAvLy5cbiAgLy8uID4gUy5yZWR1Y2UgKHhzID0+IHggPT4gUy5wcmVwZW5kICh4KSAoeHMpKSAoW10pIChbMSwgMiwgMywgNCwgNV0pXG4gIC8vLiBbNSwgNCwgMywgMiwgMV1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiByZWR1Y2UoZikge1xuICAgIHJldHVybiBmdW5jdGlvbihpbml0aWFsKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZm9sZGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFoucmVkdWNlIChmdW5jdGlvbih5LCB4KSB7IHJldHVybiBmICh5KSAoeCk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBmb2xkYWJsZSk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5yZWR1Y2UgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRm9sZGFibGVdfSxcbiAgICB0eXBlczogW0ZuIChhKSAoRm4gKGIpIChhKSksIGEsIGYgKGIpLCBhXSxcbiAgICBpbXBsOiByZWR1Y2VcbiAgfTtcblxuICAvLyMgdHJhdmVyc2UgOjogKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IFR5cGVSZXAgZiAtPiAoYSAtPiBmIGIpIC0+IHQgYSAtPiBmICh0IGIpXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi50cmF2ZXJzZWBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRyYXZlcnNlIChBcnJheSkgKFMud29yZHMpIChTLkp1c3QgKCdmb28gYmFyIGJheicpKVxuICAvLy4gW0p1c3QgKCdmb28nKSwgSnVzdCAoJ2JhcicpLCBKdXN0ICgnYmF6JyldXG4gIC8vLlxuICAvLy4gPiBTLnRyYXZlcnNlIChBcnJheSkgKFMud29yZHMpIChTLk5vdGhpbmcpXG4gIC8vLiBbTm90aGluZ11cbiAgLy8uXG4gIC8vLiA+IFMudHJhdmVyc2UgKFMuTWF5YmUpIChTLnBhcnNlSW50ICgxNikpIChbJ0EnLCAnQicsICdDJ10pXG4gIC8vLiBKdXN0IChbMTAsIDExLCAxMl0pXG4gIC8vLlxuICAvLy4gPiBTLnRyYXZlcnNlIChTLk1heWJlKSAoUy5wYXJzZUludCAoMTYpKSAoWydBJywgJ0InLCAnQycsICdYJ10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLnRyYXZlcnNlIChTLk1heWJlKSAoUy5wYXJzZUludCAoMTYpKSAoe2E6ICdBJywgYjogJ0InLCBjOiAnQyd9KVxuICAvLy4gSnVzdCAoe2E6IDEwLCBiOiAxMSwgYzogMTJ9KVxuICAvLy5cbiAgLy8uID4gUy50cmF2ZXJzZSAoUy5NYXliZSkgKFMucGFyc2VJbnQgKDE2KSkgKHthOiAnQScsIGI6ICdCJywgYzogJ0MnLCB4OiAnWCd9KVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIF8udHJhdmVyc2UgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbGljYXRpdmVdLCB0OiBbWi5UcmF2ZXJzYWJsZV19LFxuICAgIHR5cGVzOiBbVHlwZVJlcCAoJC5UeXBlVmFyaWFibGUgKCdmJykpLCBGbiAoYSkgKGYgKGIpKSwgdCAoYSksIGYgKHQgKGIpKV0sXG4gICAgaW1wbDogY3VycnkzIChaLnRyYXZlcnNlKVxuICB9O1xuXG4gIC8vIyBzZXF1ZW5jZSA6OiAoQXBwbGljYXRpdmUgZiwgVHJhdmVyc2FibGUgdCkgPT4gVHlwZVJlcCBmIC0+IHQgKGYgYSkgLT4gZiAodCBhKVxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouc2VxdWVuY2VgXVtdLiBJbnZlcnRzIHRoZSBnaXZlbiBgdCAoZiBhKWBcbiAgLy8uIHRvIHByb2R1Y2UgYW4gYGYgKHQgYSlgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zZXF1ZW5jZSAoQXJyYXkpIChTLkp1c3QgKFsxLCAyLCAzXSkpXG4gIC8vLiBbSnVzdCAoMSksIEp1c3QgKDIpLCBKdXN0ICgzKV1cbiAgLy8uXG4gIC8vLiA+IFMuc2VxdWVuY2UgKFMuTWF5YmUpIChbUy5KdXN0ICgxKSwgUy5KdXN0ICgyKSwgUy5KdXN0ICgzKV0pXG4gIC8vLiBKdXN0IChbMSwgMiwgM10pXG4gIC8vLlxuICAvLy4gPiBTLnNlcXVlbmNlIChTLk1heWJlKSAoW1MuSnVzdCAoMSksIFMuSnVzdCAoMiksIFMuTm90aGluZ10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLnNlcXVlbmNlIChTLk1heWJlKSAoe2E6IFMuSnVzdCAoMSksIGI6IFMuSnVzdCAoMiksIGM6IFMuSnVzdCAoMyl9KVxuICAvLy4gSnVzdCAoe2E6IDEsIGI6IDIsIGM6IDN9KVxuICAvLy5cbiAgLy8uID4gUy5zZXF1ZW5jZSAoUy5NYXliZSkgKHthOiBTLkp1c3QgKDEpLCBiOiBTLkp1c3QgKDIpLCBjOiBTLk5vdGhpbmd9KVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIF8uc2VxdWVuY2UgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbGljYXRpdmVdLCB0OiBbWi5UcmF2ZXJzYWJsZV19LFxuICAgIHR5cGVzOiBbVHlwZVJlcCAoJC5UeXBlVmFyaWFibGUgKCdmJykpLCB0IChmIChhKSksIGYgKHQgKGEpKV0sXG4gICAgaW1wbDogY3VycnkyIChaLnNlcXVlbmNlKVxuICB9O1xuXG4gIC8vIyBhcCA6OiBBcHBseSBmID0+IGYgKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hcCAoW01hdGguc3FydCwgeCA9PiB4ICogeF0pIChbMSwgNCwgOSwgMTYsIDI1XSlcbiAgLy8uIFsxLCAyLCAzLCA0LCA1LCAxLCAxNiwgODEsIDI1NiwgNjI1XVxuICAvLy5cbiAgLy8uID4gUy5hcCAoe3g6IE1hdGguc3FydCwgeTogUy5hZGQgKDEpLCB6OiBTLnN1YiAoMSl9KSAoe3c6IDQsIHg6IDQsIHk6IDR9KVxuICAvLy4ge3g6IDIsIHk6IDV9XG4gIC8vLlxuICAvLy4gPiBTLmFwIChTLkp1c3QgKE1hdGguc3FydCkpIChTLkp1c3QgKDY0KSlcbiAgLy8uIEp1c3QgKDgpXG4gIC8vLiBgYGBcbiAgLy8uXG4gIC8vLiBSZXBsYWNpbmcgYEFwcGx5IGYgPT4gZmAgd2l0aCBgRnVuY3Rpb24geGAgcHJvZHVjZXMgdGhlIFMgY29tYmluYXRvclxuICAvLy4gZnJvbSBjb21iaW5hdG9yeSBsb2dpYzpcbiAgLy8uXG4gIC8vLiAgICAgQXBwbHkgZiA9PiBmIChhIC0+IGIpIC0+IGYgYSAtPiBmIGJcbiAgLy8uICAgICBGdW5jdGlvbiB4IChhIC0+IGIpIC0+IEZ1bmN0aW9uIHggYSAtPiBGdW5jdGlvbiB4IGJcbiAgLy8uICAgICBGdW5jdGlvbiB4IChhIC0+IGMpIC0+IEZ1bmN0aW9uIHggYSAtPiBGdW5jdGlvbiB4IGNcbiAgLy8uICAgICBGdW5jdGlvbiB4IChiIC0+IGMpIC0+IEZ1bmN0aW9uIHggYiAtPiBGdW5jdGlvbiB4IGNcbiAgLy8uICAgICBGdW5jdGlvbiBhIChiIC0+IGMpIC0+IEZ1bmN0aW9uIGEgYiAtPiBGdW5jdGlvbiBhIGNcbiAgLy8uICAgICAoYSAtPiBiIC0+IGMpIC0+IChhIC0+IGIpIC0+IChhIC0+IGMpXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFwIChzID0+IG4gPT4gcy5zbGljZSAoMCwgbikpIChzID0+IE1hdGguY2VpbCAocy5sZW5ndGggLyAyKSkgKCdIYXNrZWxsJylcbiAgLy8uICdIYXNrJ1xuICAvLy4gYGBgXG4gIF8uYXAgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbHldfSxcbiAgICB0eXBlczogW2YgKEZuIChhKSAoYikpLCBmIChhKSwgZiAoYildLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5hcClcbiAgfTtcblxuICAvLyMgbGlmdDIgOjogQXBwbHkgZiA9PiAoYSAtPiBiIC0+IGMpIC0+IGYgYSAtPiBmIGIgLT4gZiBjXG4gIC8vLlxuICAvLy4gUHJvbW90ZXMgYSBjdXJyaWVkIGJpbmFyeSBmdW5jdGlvbiB0byBhIGZ1bmN0aW9uIHdoaWNoIG9wZXJhdGVzIG9uIHR3b1xuICAvLy4gW0FwcGx5XVtdcy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubGlmdDIgKFMuYWRkKSAoUy5KdXN0ICgyKSkgKFMuSnVzdCAoMykpXG4gIC8vLiBKdXN0ICg1KVxuICAvLy5cbiAgLy8uID4gUy5saWZ0MiAoUy5hZGQpIChTLkp1c3QgKDIpKSAoUy5Ob3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5saWZ0MiAoUy5hbmQpIChTLkp1c3QgKHRydWUpKSAoUy5KdXN0ICh0cnVlKSlcbiAgLy8uIEp1c3QgKHRydWUpXG4gIC8vLlxuICAvLy4gPiBTLmxpZnQyIChTLmFuZCkgKFMuSnVzdCAodHJ1ZSkpIChTLkp1c3QgKGZhbHNlKSlcbiAgLy8uIEp1c3QgKGZhbHNlKVxuICAvLy4gYGBgXG4gIF8ubGlmdDIgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbHldfSxcbiAgICB0eXBlczogW0ZuIChhKSAoRm4gKGIpIChjKSksIGYgKGEpLCBmIChiKSwgZiAoYyldLFxuICAgIGltcGw6IGN1cnJ5MyAoWi5saWZ0MilcbiAgfTtcblxuICAvLyMgbGlmdDMgOjogQXBwbHkgZiA9PiAoYSAtPiBiIC0+IGMgLT4gZCkgLT4gZiBhIC0+IGYgYiAtPiBmIGMgLT4gZiBkXG4gIC8vLlxuICAvLy4gUHJvbW90ZXMgYSBjdXJyaWVkIHRlcm5hcnkgZnVuY3Rpb24gdG8gYSBmdW5jdGlvbiB3aGljaCBvcGVyYXRlcyBvbiB0aHJlZVxuICAvLy4gW0FwcGx5XVtdcy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubGlmdDMgKFMucmVkdWNlKSAoUy5KdXN0IChTLmFkZCkpIChTLkp1c3QgKDApKSAoUy5KdXN0IChbMSwgMiwgM10pKVxuICAvLy4gSnVzdCAoNilcbiAgLy8uXG4gIC8vLiA+IFMubGlmdDMgKFMucmVkdWNlKSAoUy5KdXN0IChTLmFkZCkpIChTLkp1c3QgKDApKSAoUy5Ob3RoaW5nKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIF8ubGlmdDMgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbHldfSxcbiAgICB0eXBlczogW0ZuIChhKSAoRm4gKGIpIChGbiAoYykgKGQpKSksIGYgKGEpLCBmIChiKSwgZiAoYyksIGYgKGQpXSxcbiAgICBpbXBsOiBjdXJyeTQgKFoubGlmdDMpXG4gIH07XG5cbiAgLy8jIGFwRmlyc3QgOjogQXBwbHkgZiA9PiBmIGEgLT4gZiBiIC0+IGYgYVxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFouYXBGaXJzdGBdW10uIENvbWJpbmVzIHR3byBlZmZlY3RmdWwgYWN0aW9ucyxcbiAgLy8uIGtlZXBpbmcgb25seSB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdC4gRXF1aXZhbGVudCB0byBIYXNrZWxsJ3MgYCg8KilgXG4gIC8vLiBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGFwU2Vjb25kYF0oI2FwU2Vjb25kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYXBGaXJzdCAoWzEsIDJdKSAoWzMsIDRdKVxuICAvLy4gWzEsIDEsIDIsIDJdXG4gIC8vLlxuICAvLy4gPiBTLmFwRmlyc3QgKFMuSnVzdCAoMSkpIChTLkp1c3QgKDIpKVxuICAvLy4gSnVzdCAoMSlcbiAgLy8uIGBgYFxuICBfLmFwRmlyc3QgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbHldfSxcbiAgICB0eXBlczogW2YgKGEpLCBmIChiKSwgZiAoYSldLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5hcEZpcnN0KVxuICB9O1xuXG4gIC8vIyBhcFNlY29uZCA6OiBBcHBseSBmID0+IGYgYSAtPiBmIGIgLT4gZiBiXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5hcFNlY29uZGBdW10uIENvbWJpbmVzIHR3byBlZmZlY3RmdWwgYWN0aW9ucyxcbiAgLy8uIGtlZXBpbmcgb25seSB0aGUgcmVzdWx0IG9mIHRoZSBzZWNvbmQuIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGAoKj4pYFxuICAvLy4gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcEZpcnN0YF0oI2FwRmlyc3QpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hcFNlY29uZCAoWzEsIDJdKSAoWzMsIDRdKVxuICAvLy4gWzMsIDQsIDMsIDRdXG4gIC8vLlxuICAvLy4gPiBTLmFwU2Vjb25kIChTLkp1c3QgKDEpKSAoUy5KdXN0ICgyKSlcbiAgLy8uIEp1c3QgKDIpXG4gIC8vLiBgYGBcbiAgXy5hcFNlY29uZCA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5BcHBseV19LFxuICAgIHR5cGVzOiBbZiAoYSksIGYgKGIpLCBmIChiKV0sXG4gICAgaW1wbDogY3VycnkyIChaLmFwU2Vjb25kKVxuICB9O1xuXG4gIC8vIyBvZiA6OiBBcHBsaWNhdGl2ZSBmID0+IFR5cGVSZXAgZiAtPiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIEN1cnJpZWQgdmVyc2lvbiBvZiBbYFoub2ZgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5vZiAoQXJyYXkpICg0MilcbiAgLy8uIFs0Ml1cbiAgLy8uXG4gIC8vLiA+IFMub2YgKEZ1bmN0aW9uKSAoNDIpIChudWxsKVxuICAvLy4gNDJcbiAgLy8uXG4gIC8vLiA+IFMub2YgKFMuTWF5YmUpICg0MilcbiAgLy8uIEp1c3QgKDQyKVxuICAvLy5cbiAgLy8uID4gUy5vZiAoUy5FaXRoZXIpICg0MilcbiAgLy8uIFJpZ2h0ICg0MilcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBvZih0eXBlUmVwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBaLm9mICh0eXBlUmVwLCB4KTtcbiAgICB9O1xuICB9XG4gIF8ub2YgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbGljYXRpdmVdfSxcbiAgICB0eXBlczogW1R5cGVSZXAgKCQuVHlwZVZhcmlhYmxlICgnZicpKSwgYSwgZiAoYSldLFxuICAgIGltcGw6IG9mXG4gIH07XG5cbiAgLy8jIGNoYWluIDo6IENoYWluIG0gPT4gKGEgLT4gbSBiKSAtPiBtIGEgLT4gbSBiXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5jaGFpbmBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmNoYWluICh4ID0+IFt4LCB4XSkgKFsxLCAyLCAzXSlcbiAgLy8uIFsxLCAxLCAyLCAyLCAzLCAzXVxuICAvLy5cbiAgLy8uID4gUy5jaGFpbiAobiA9PiBzID0+IHMuc2xpY2UgKDAsIG4pKSAocyA9PiBNYXRoLmNlaWwgKHMubGVuZ3RoIC8gMikpICgnc2xpY2UnKVxuICAvLy4gJ3NsaSdcbiAgLy8uXG4gIC8vLiA+IFMuY2hhaW4gKFMucGFyc2VJbnQgKDEwKSkgKFMuSnVzdCAoJzEyMycpKVxuICAvLy4gSnVzdCAoMTIzKVxuICAvLy5cbiAgLy8uID4gUy5jaGFpbiAoUy5wYXJzZUludCAoMTApKSAoUy5KdXN0ICgnWFhYJykpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgXy5jaGFpbiA9IHtcbiAgICBjb25zdHM6IHttOiBbWi5DaGFpbl19LFxuICAgIHR5cGVzOiBbRm4gKGEpIChtIChiKSksIG0gKGEpLCBtIChiKV0sXG4gICAgaW1wbDogY3VycnkyIChaLmNoYWluKVxuICB9O1xuXG4gIC8vIyBqb2luIDo6IENoYWluIG0gPT4gbSAobSBhKSAtPiBtIGFcbiAgLy8uXG4gIC8vLiBbVHlwZS1zYWZlXVtzYW5jdHVhcnktZGVmXSB2ZXJzaW9uIG9mIFtgWi5qb2luYF1bXS5cbiAgLy8uIFJlbW92ZXMgb25lIGxldmVsIG9mIG5lc3RpbmcgZnJvbSBhIG5lc3RlZCBtb25hZGljIHN0cnVjdHVyZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuam9pbiAoW1sxXSwgWzJdLCBbM11dKVxuICAvLy4gWzEsIDIsIDNdXG4gIC8vLlxuICAvLy4gPiBTLmpvaW4gKFtbWzEsIDIsIDNdXV0pXG4gIC8vLiBbWzEsIDIsIDNdXVxuICAvLy5cbiAgLy8uID4gUy5qb2luIChTLkp1c3QgKFMuSnVzdCAoMSkpKVxuICAvLy4gSnVzdCAoMSlcbiAgLy8uXG4gIC8vLiA+IFMuam9pbiAoUy5QYWlyICgnZm9vJykgKFMuUGFpciAoJ2JhcicpICgnYmF6JykpKVxuICAvLy4gUGFpciAoJ2Zvb2JhcicpICgnYmF6JylcbiAgLy8uIGBgYFxuICAvLy5cbiAgLy8uIFJlcGxhY2luZyBgQ2hhaW4gbSA9PiBtYCB3aXRoIGBGdW5jdGlvbiB4YCBwcm9kdWNlcyB0aGUgVyBjb21iaW5hdG9yXG4gIC8vLiBmcm9tIGNvbWJpbmF0b3J5IGxvZ2ljOlxuICAvLy5cbiAgLy8uICAgICBDaGFpbiBtID0+IG0gKG0gYSkgLT4gbSBhXG4gIC8vLiAgICAgRnVuY3Rpb24geCAoRnVuY3Rpb24geCBhKSAtPiBGdW5jdGlvbiB4IGFcbiAgLy8uICAgICAoeCAtPiB4IC0+IGEpIC0+ICh4IC0+IGEpXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmpvaW4gKFMuY29uY2F0KSAoJ2FiYycpXG4gIC8vLiAnYWJjYWJjJ1xuICAvLy4gYGBgXG4gIF8uam9pbiA9IHtcbiAgICBjb25zdHM6IHttOiBbWi5DaGFpbl19LFxuICAgIHR5cGVzOiBbbSAobSAoYSkpLCBtIChhKV0sXG4gICAgaW1wbDogWi5qb2luXG4gIH07XG5cbiAgLy8jIGNoYWluUmVjIDo6IENoYWluUmVjIG0gPT4gVHlwZVJlcCBtIC0+IChhIC0+IG0gKEVpdGhlciBhIGIpKSAtPiBhIC0+IG0gYlxuICAvLy5cbiAgLy8uIFBlcmZvcm1zIGEgW2BjaGFpbmBdKCNjaGFpbiktbGlrZSBjb21wdXRhdGlvbiB3aXRoIGNvbnN0YW50IHN0YWNrIHVzYWdlLlxuICAvLy4gU2ltaWxhciB0byBbYFouY2hhaW5SZWNgXVtdLCBidXQgY3VycmllZCBhbmQgbW9yZSBjb252ZW5pZW50IGR1ZSB0byB0aGVcbiAgLy8uIHVzZSBvZiB0aGUgRWl0aGVyIHR5cGUgdG8gaW5kaWNhdGUgY29tcGxldGlvbiAodmlhIGEgUmlnaHQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jaGFpblJlYyAoQXJyYXkpXG4gIC8vLiAuICAgICAgICAgICAgKHMgPT4gcy5sZW5ndGggPT09IDIgPyBTLm1hcCAoUy5SaWdodCkgKFtzICsgJyEnLCBzICsgJz8nXSlcbiAgLy8uIC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFMubWFwIChTLkxlZnQpIChbcyArICdvJywgcyArICduJ10pKVxuICAvLy4gLiAgICAgICAgICAgICgnJylcbiAgLy8uIFsnb28hJywgJ29vPycsICdvbiEnLCAnb24/JywgJ25vIScsICdubz8nLCAnbm4hJywgJ25uPyddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY2hhaW5SZWModHlwZVJlcCkge1xuICAgIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gWi5jaGFpblJlYyAodHlwZVJlcCwgc3RlcCwgeCk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gc3RlcChuZXh0LCBkb25lLCB4KSB7XG4gICAgICAgIHJldHVybiBaLm1hcCAoZWl0aGVyIChuZXh0KSAoZG9uZSksIGYgKHgpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIF8uY2hhaW5SZWMgPSB7XG4gICAgY29uc3RzOiB7bTogW1ouQ2hhaW5SZWNdfSxcbiAgICB0eXBlczogW1R5cGVSZXAgKCQuVHlwZVZhcmlhYmxlICgnbScpKSxcbiAgICAgICAgICAgIEZuIChhKSAobSAoJEVpdGhlciAoYSkgKGIpKSksXG4gICAgICAgICAgICBhLFxuICAgICAgICAgICAgbSAoYildLFxuICAgIGltcGw6IGNoYWluUmVjXG4gIH07XG5cbiAgLy8jIGV4dGVuZCA6OiBFeHRlbmQgdyA9PiAodyBhIC0+IGIpIC0+IHcgYSAtPiB3IGJcbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmV4dGVuZGBdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmV4dGVuZCAoUy5qb2luV2l0aCAoJycpKSAoWyd4JywgJ3knLCAneiddKVxuICAvLy4gWyd4eXonLCAneXonLCAneiddXG4gIC8vLlxuICAvLy4gPiBTLmV4dGVuZCAoZiA9PiBmIChbMywgNF0pKSAoUy5yZXZlcnNlKSAoWzEsIDJdKVxuICAvLy4gWzQsIDMsIDIsIDFdXG4gIC8vLiBgYGBcbiAgXy5leHRlbmQgPSB7XG4gICAgY29uc3RzOiB7dzogW1ouRXh0ZW5kXX0sXG4gICAgdHlwZXM6IFtGbiAodyAoYSkpIChiKSwgdyAoYSksIHcgKGIpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouZXh0ZW5kKVxuICB9O1xuXG4gIC8vIyBkdXBsaWNhdGUgOjogRXh0ZW5kIHcgPT4gdyBhIC0+IHcgKHcgYSlcbiAgLy8uXG4gIC8vLiBbVHlwZS1zYWZlXVtzYW5jdHVhcnktZGVmXSB2ZXJzaW9uIG9mIFtgWi5kdXBsaWNhdGVgXVtdLlxuICAvLy4gQWRkcyBvbmUgbGV2ZWwgb2YgbmVzdGluZyB0byBhIGNvbW9uYWRpYyBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmR1cGxpY2F0ZSAoUy5KdXN0ICgxKSlcbiAgLy8uIEp1c3QgKEp1c3QgKDEpKVxuICAvLy5cbiAgLy8uID4gUy5kdXBsaWNhdGUgKFsxXSlcbiAgLy8uIFtbMV1dXG4gIC8vLlxuICAvLy4gPiBTLmR1cGxpY2F0ZSAoWzEsIDIsIDNdKVxuICAvLy4gW1sxLCAyLCAzXSwgWzIsIDNdLCBbM11dXG4gIC8vLlxuICAvLy4gPiBTLmR1cGxpY2F0ZSAoUy5yZXZlcnNlKSAoWzEsIDJdKSAoWzMsIDRdKVxuICAvLy4gWzQsIDMsIDIsIDFdXG4gIC8vLiBgYGBcbiAgXy5kdXBsaWNhdGUgPSB7XG4gICAgY29uc3RzOiB7dzogW1ouRXh0ZW5kXX0sXG4gICAgdHlwZXM6IFt3IChhKSwgdyAodyAoYSkpXSxcbiAgICBpbXBsOiBaLmR1cGxpY2F0ZVxuICB9O1xuXG4gIC8vIyBleHRyYWN0IDo6IENvbW9uYWQgdyA9PiB3IGEgLT4gYVxuICAvLy5cbiAgLy8uIFtUeXBlLXNhZmVdW3NhbmN0dWFyeS1kZWZdIHZlcnNpb24gb2YgW2BaLmV4dHJhY3RgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5leHRyYWN0IChTLlBhaXIgKCdmb28nKSAoJ2JhcicpKVxuICAvLy4gJ2JhcidcbiAgLy8uIGBgYFxuICBfLmV4dHJhY3QgPSB7XG4gICAgY29uc3RzOiB7dzogW1ouQ29tb25hZF19LFxuICAgIHR5cGVzOiBbdyAoYSksIGFdLFxuICAgIGltcGw6IFouZXh0cmFjdFxuICB9O1xuXG4gIC8vIyBjb250cmFtYXAgOjogQ29udHJhdmFyaWFudCBmID0+IChiIC0+IGEpIC0+IGYgYSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBbVHlwZS1zYWZlXVtzYW5jdHVhcnktZGVmXSB2ZXJzaW9uIG9mIFtgWi5jb250cmFtYXBgXVtdLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5jb250cmFtYXAgKHMgPT4gcy5sZW5ndGgpIChNYXRoLnNxcnQpICgnU2FuY3R1YXJ5JylcbiAgLy8uIDNcbiAgLy8uIGBgYFxuICBfLmNvbnRyYW1hcCA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5Db250cmF2YXJpYW50XX0sXG4gICAgdHlwZXM6IFtGbiAoYikgKGEpLCBmIChhKSwgZiAoYildLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5jb250cmFtYXApXG4gIH07XG5cbiAgLy8uICMjIyBDb21iaW5hdG9yXG5cbiAgLy8jIEkgOjogYSAtPiBhXG4gIC8vLlxuICAvLy4gVGhlIEkgY29tYmluYXRvci4gUmV0dXJucyBpdHMgYXJndW1lbnQuIEVxdWl2YWxlbnQgdG8gSGFza2VsbCdzIGBpZGBcbiAgLy8uIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5JICgnZm9vJylcbiAgLy8uICdmb28nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gSSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgXy5JID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFthLCBhXSxcbiAgICBpbXBsOiBJXG4gIH07XG5cbiAgLy8jIEsgOjogYSAtPiBiIC0+IGFcbiAgLy8uXG4gIC8vLiBUaGUgSyBjb21iaW5hdG9yLiBUYWtlcyB0d28gdmFsdWVzIGFuZCByZXR1cm5zIHRoZSBmaXJzdC4gRXF1aXZhbGVudCB0b1xuICAvLy4gSGFza2VsbCdzIGBjb25zdGAgZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLksgKCdmb28nKSAoJ2JhcicpXG4gIC8vLiAnZm9vJ1xuICAvLy5cbiAgLy8uID4gUy5tYXAgKFMuSyAoNDIpKSAoUy5yYW5nZSAoMCkgKDUpKVxuICAvLy4gWzQyLCA0MiwgNDIsIDQyLCA0Ml1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBLKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuICBfLksgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW2EsIGIsIGFdLFxuICAgIGltcGw6IEtcbiAgfTtcblxuICAvLyMgVCA6OiBhIC0+IChhIC0+IGIpIC0+IGJcbiAgLy8uXG4gIC8vLiBUaGUgVCAoW3RocnVzaF1bXSkgY29tYmluYXRvci4gVGFrZXMgYSB2YWx1ZSBhbmQgYSBmdW5jdGlvbiwgYW5kIHJldHVybnNcbiAgLy8uIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvIHRoZSB2YWx1ZS4gRXF1aXZhbGVudCB0byBIYXNrZWxsJ3NcbiAgLy8uIGAoJilgIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5UICg0MikgKFMuYWRkICgxKSlcbiAgLy8uIDQzXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoUy5UICgxMDApKSAoW1MuYWRkICgxKSwgTWF0aC5zcXJ0XSlcbiAgLy8uIFsxMDEsIDEwXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIFQoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZiAoeCk7XG4gICAgfTtcbiAgfVxuICBfLlQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW2EsIEZuIChhKSAoYiksIGJdLFxuICAgIGltcGw6IFRcbiAgfTtcblxuICAvLy4gIyMjIEZ1bmN0aW9uXG5cbiAgLy8jIGN1cnJ5MiA6OiAoKGEsIGIpIC0+IGMpIC0+IGEgLT4gYiAtPiBjXG4gIC8vLlxuICAvLy4gQ3VycmllcyB0aGUgZ2l2ZW4gYmluYXJ5IGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXAgKFMuY3VycnkyIChNYXRoLnBvdykgKDEwKSkgKFsxLCAyLCAzXSlcbiAgLy8uIFsxMCwgMTAwLCAxMDAwXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGN1cnJ5MihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiBmICh4LCB5KTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLmN1cnJ5MiA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5GdW5jdGlvbiAoW2EsIGIsIGNdKSwgYSwgYiwgY10sXG4gICAgaW1wbDogY3VycnkyXG4gIH07XG5cbiAgLy8jIGN1cnJ5MyA6OiAoKGEsIGIsIGMpIC0+IGQpIC0+IGEgLT4gYiAtPiBjIC0+IGRcbiAgLy8uXG4gIC8vLiBDdXJyaWVzIHRoZSBnaXZlbiB0ZXJuYXJ5IGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29uc3QgcmVwbGFjZVN0cmluZyA9IFMuY3VycnkzICgod2hhdCwgcmVwbGFjZW1lbnQsIHN0cmluZykgPT5cbiAgLy8uIC4gICBzdHJpbmcucmVwbGFjZSAod2hhdCwgcmVwbGFjZW1lbnQpXG4gIC8vLiAuIClcbiAgLy8uXG4gIC8vLiA+IHJlcGxhY2VTdHJpbmcgKCdiYW5hbmEnKSAoJ29yYW5nZScpICgnYmFuYW5hIGljZWNyZWFtJylcbiAgLy8uICdvcmFuZ2UgaWNlY3JlYW0nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gY3VycnkzKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHopIHtcbiAgICAgICAgICByZXR1cm4gZiAoeCwgeSwgeik7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5jdXJyeTMgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuRnVuY3Rpb24gKFthLCBiLCBjLCBkXSksIGEsIGIsIGMsIGRdLFxuICAgIGltcGw6IGN1cnJ5M1xuICB9O1xuXG4gIC8vIyBjdXJyeTQgOjogKChhLCBiLCBjLCBkKSAtPiBlKSAtPiBhIC0+IGIgLT4gYyAtPiBkIC0+IGVcbiAgLy8uXG4gIC8vLiBDdXJyaWVzIHRoZSBnaXZlbiBxdWF0ZXJuYXJ5IGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29uc3QgY3JlYXRlUmVjdCA9IFMuY3Vycnk0ICgoeCwgeSwgd2lkdGgsIGhlaWdodCkgPT5cbiAgLy8uIC4gICAoe3gsIHksIHdpZHRoLCBoZWlnaHR9KVxuICAvLy4gLiApXG4gIC8vLlxuICAvLy4gPiBjcmVhdGVSZWN0ICgwKSAoMCkgKDEwKSAoMTApXG4gIC8vLiB7eDogMCwgeTogMCwgd2lkdGg6IDEwLCBoZWlnaHQ6IDEwfVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGN1cnJ5NChmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHopIHtcbiAgICAgICAgICAgIHJldHVybiBmICh3LCB4LCB5LCB6KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uY3Vycnk0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkZ1bmN0aW9uIChbYSwgYiwgYywgZCwgZV0pLCBhLCBiLCBjLCBkLCBlXSxcbiAgICBpbXBsOiBjdXJyeTRcbiAgfTtcblxuICAvLyMgY3Vycnk1IDo6ICgoYSwgYiwgYywgZCwgZSkgLT4gZikgLT4gYSAtPiBiIC0+IGMgLT4gZCAtPiBlIC0+IGZcbiAgLy8uXG4gIC8vLiBDdXJyaWVzIHRoZSBnaXZlbiBxdWluYXJ5IGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gY29uc3QgdG9VcmwgPSBTLmN1cnJ5NSAoKHByb3RvY29sLCBjcmVkcywgaG9zdG5hbWUsIHBvcnQsIHBhdGhuYW1lKSA9PlxuICAvLy4gLiAgIHByb3RvY29sICsgJy8vJyArXG4gIC8vLiAuICAgUy5tYXliZSAoJycpIChTLmZsaXAgKFMuY29uY2F0KSAoJ0AnKSkgKGNyZWRzKSArXG4gIC8vLiAuICAgaG9zdG5hbWUgK1xuICAvLy4gLiAgIFMubWF5YmUgKCcnKSAoUy5jb25jYXQgKCc6JykpIChwb3J0KSArXG4gIC8vLiAuICAgcGF0aG5hbWVcbiAgLy8uIC4gKVxuICAvLy5cbiAgLy8uID4gdG9VcmwgKCdodHRwczonKSAoUy5Ob3RoaW5nKSAoJ2V4YW1wbGUuY29tJykgKFMuSnVzdCAoJzQ0MycpKSAoJy9mb28vYmFyJylcbiAgLy8uICdodHRwczovL2V4YW1wbGUuY29tOjQ0My9mb28vYmFyJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGN1cnJ5NShmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih3KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbih6KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmICh2LCB3LCB4LCB5LCB6KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLmN1cnJ5NSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5GdW5jdGlvbiAoW2EsIGIsIGMsIGQsIGUsIHJdKSwgYSwgYiwgYywgZCwgZSwgcl0sXG4gICAgaW1wbDogY3Vycnk1XG4gIH07XG5cbiAgLy8uICMjIyBDb21wb3NpdGlvblxuXG4gIC8vIyBjb21wb3NlIDo6IFNlbWlncm91cG9pZCBzID0+IHMgYiBjIC0+IHMgYSBiIC0+IHMgYSBjXG4gIC8vLlxuICAvLy4gQ3VycmllZCB2ZXJzaW9uIG9mIFtgWi5jb21wb3NlYF1bXS5cbiAgLy8uXG4gIC8vLiBXaGVuIHNwZWNpYWxpemVkIHRvIEZ1bmN0aW9uLCBgY29tcG9zZWAgY29tcG9zZXMgdHdvIHVuYXJ5IGZ1bmN0aW9ucyxcbiAgLy8uIGZyb20gcmlnaHQgdG8gbGVmdCAodGhpcyBpcyB0aGUgQiBjb21iaW5hdG9yIGZyb20gY29tYmluYXRvcnkgbG9naWMpLlxuICAvLy5cbiAgLy8uIFRoZSBnZW5lcmFsaXplZCB0eXBlIHNpZ25hdHVyZSBpbmRpY2F0ZXMgdGhhdCBgY29tcG9zZWAgaXMgY29tcGF0aWJsZVxuICAvLy4gd2l0aCBhbnkgW1NlbWlncm91cG9pZF1bXS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHBpcGVgXSgjcGlwZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmNvbXBvc2UgKE1hdGguc3FydCkgKFMuYWRkICgxKSkgKDk5KVxuICAvLy4gMTBcbiAgLy8uIGBgYFxuICBfLmNvbXBvc2UgPSB7XG4gICAgY29uc3RzOiB7czogW1ouU2VtaWdyb3Vwb2lkXX0sXG4gICAgdHlwZXM6IFtzIChiKSAoYyksIHMgKGEpIChiKSwgcyAoYSkgKGMpXSxcbiAgICBpbXBsOiBjdXJyeTIgKFouY29tcG9zZSlcbiAgfTtcblxuICAvLyMgcGlwZSA6OiBGb2xkYWJsZSBmID0+IGYgKEFueSAtPiBBbnkpIC0+IGEgLT4gYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgc2VxdWVuY2Ugb2YgZnVuY3Rpb25zIGFzc3VtZWQgdG8gYmUgdW5hcnkgYW5kIGEgdmFsdWUgb2YgYW55XG4gIC8vLiB0eXBlLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBzZXF1ZW5jZSBvZiB0cmFuc2Zvcm1hdGlvbnNcbiAgLy8uIHRvIHRoZSBpbml0aWFsIHZhbHVlLlxuICAvLy5cbiAgLy8uIEluIGdlbmVyYWwgdGVybXMsIGBwaXBlYCBwZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGNvbXBvc2l0aW9uIG9mIGEgc2VxdWVuY2VcbiAgLy8uIG9mIGZ1bmN0aW9ucy4gYHBpcGUgKFtmLCBnLCBoXSkgKHgpYCBpcyBlcXVpdmFsZW50IHRvIGBoIChnIChmICh4KSkpYC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucGlwZSAoW1MuYWRkICgxKSwgTWF0aC5zcXJ0LCBTLnN1YiAoMSldKSAoOTkpXG4gIC8vLiA5XG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcGlwZShmcykge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gcmVkdWNlIChUKSAoeCkgKGZzKTtcbiAgICB9O1xuICB9XG4gIF8ucGlwZSA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5Gb2xkYWJsZV19LFxuICAgIHR5cGVzOiBbZiAoRm4gKCQuQW55KSAoJC5BbnkpKSwgYSwgYl0sXG4gICAgaW1wbDogcGlwZVxuICB9O1xuXG4gIC8vIyBwaXBlSyA6OiAoRm9sZGFibGUgZiwgQ2hhaW4gbSkgPT4gZiAoQW55IC0+IG0gQW55KSAtPiBtIGEgLT4gbSBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzZXF1ZW5jZSBvZiBmdW5jdGlvbnMgYXNzdW1lZCB0byBiZSB1bmFyeSB3aGljaCByZXR1cm4gdmFsdWVzXG4gIC8vLiB3aXRoIGEgW0NoYWluXVtdLCBhbmQgYSB2YWx1ZSBvZiB0aGF0IENoYWluLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0XG4gIC8vLiBvZiBhcHBseWluZyB0aGUgc2VxdWVuY2Ugb2YgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBpbml0aWFsIHZhbHVlLlxuICAvLy5cbiAgLy8uIEluIGdlbmVyYWwgdGVybXMsIGBwaXBlS2AgcGVyZm9ybXMgbGVmdC10by1yaWdodCBbS2xlaXNsaV1bXSBjb21wb3NpdGlvblxuICAvLy4gb2YgYW4gc2VxdWVuY2Ugb2YgZnVuY3Rpb25zLiBgcGlwZUsgKFtmLCBnLCBoXSkgKHgpYCBpcyBlcXVpdmFsZW50IHRvXG4gIC8vLiBgY2hhaW4gKGgpIChjaGFpbiAoZykgKGNoYWluIChmKSAoeCkpKWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnBpcGVLIChbUy50YWlsLCBTLnRhaWwsIFMuaGVhZF0pIChTLkp1c3QgKFsxLCAyLCAzLCA0XSkpXG4gIC8vLiBKdXN0ICgzKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBpcGVLKGZzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBaLnJlZHVjZSAoZnVuY3Rpb24oeCwgZikgeyByZXR1cm4gWi5jaGFpbiAoZiwgeCk7IH0sIHgsIGZzKTtcbiAgICB9O1xuICB9XG4gIF8ucGlwZUsgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRm9sZGFibGVdLCBtOiBbWi5DaGFpbl19LFxuICAgIHR5cGVzOiBbZiAoRm4gKCQuQW55KSAobSAoJC5BbnkpKSksIG0gKGEpLCBtIChiKV0sXG4gICAgaW1wbDogcGlwZUtcbiAgfTtcblxuICAvLyMgb24gOjogKGIgLT4gYiAtPiBjKSAtPiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gY1xuICAvLy5cbiAgLy8uIFRha2VzIGEgYmluYXJ5IGZ1bmN0aW9uIGBmYCwgYSB1bmFyeSBmdW5jdGlvbiBgZ2AsIGFuZCB0d29cbiAgLy8uIHZhbHVlcyBgeGAgYW5kIGB5YC4gUmV0dXJucyBgZiAoZyAoeCkpIChnICh5KSlgLlxuICAvLy5cbiAgLy8uIFRoaXMgaXMgdGhlIFAgY29tYmluYXRvciBmcm9tIGNvbWJpbmF0b3J5IGxvZ2ljLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5vbiAoUy5jb25jYXQpIChTLnJldmVyc2UpIChbMSwgMiwgM10pIChbNCwgNSwgNl0pXG4gIC8vLiBbMywgMiwgMSwgNiwgNSwgNF1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBvbihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICAgICAgcmV0dXJuIGYgKGcgKHgpKSAoZyAoeSkpO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8ub24gPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW0ZuIChiKSAoRm4gKGIpIChjKSksIEZuIChhKSAoYiksIGEsIGEsIGNdLFxuICAgIGltcGw6IG9uXG4gIH07XG5cbiAgLy8uICMjIyBQYWlyIHR5cGVcbiAgLy8uXG4gIC8vLiBQYWlyIGlzIHRoZSBjYW5vbmljYWwgcHJvZHVjdCB0eXBlOiBhIHZhbHVlIG9mIHR5cGUgYFBhaXIgYSBiYCBhbHdheXNcbiAgLy8uIGNvbnRhaW5zIGV4YWN0bHkgdHdvIHZhbHVlczogb25lIG9mIHR5cGUgYGFgOyBvbmUgb2YgdHlwZSBgYmAuXG4gIC8vLlxuICAvLy4gVGhlIGltcGxlbWVudGF0aW9uIGlzIHByb3ZpZGVkIGJ5IFtzYW5jdHVhcnktcGFpcl1bXS5cblxuICAvLyMgUGFpclR5cGUgOjogVHlwZSAtPiBUeXBlIC0+IFR5cGVcbiAgLy8uXG4gIC8vLiBBIFtgQmluYXJ5VHlwZWBdW0JpbmFyeVR5cGVdIGZvciB1c2Ugd2l0aCBbc2FuY3R1YXJ5LWRlZl1bXS5cblxuICAvLyMgUGFpciA6OiBhIC0+IGIgLT4gUGFpciBhIGJcbiAgLy8uXG4gIC8vLiBQYWlyJ3Mgc29sZSBkYXRhIGNvbnN0cnVjdG9yLiBBZGRpdGlvbmFsbHksIGl0IHNlcnZlcyBhcyB0aGVcbiAgLy8uIFBhaXIgW3R5cGUgcmVwcmVzZW50YXRpdmVdW10uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLlBhaXIgKCdmb28nKSAoNDIpXG4gIC8vLiBQYWlyICgnZm9vJykgKDQyKVxuICAvLy4gYGBgXG4gIF8uUGFpciA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbYSwgYiwgJFBhaXIgKGEpIChiKV0sXG4gICAgaW1wbDogUGFpclxuICB9O1xuXG4gIC8vIyBmc3QgOjogUGFpciBhIGIgLT4gYVxuICAvLy5cbiAgLy8uIGBmc3QgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYHhgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5mc3QgKFMuUGFpciAoJ2ZvbycpICg0MikpXG4gIC8vLiAnZm9vJ1xuICAvLy4gYGBgXG4gIF8uZnN0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskUGFpciAoYSkgKGIpLCBhXSxcbiAgICBpbXBsOiBQYWlyLmZzdFxuICB9O1xuXG4gIC8vIyBzbmQgOjogUGFpciBhIGIgLT4gYlxuICAvLy5cbiAgLy8uIGBzbmQgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYHlgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zbmQgKFMuUGFpciAoJ2ZvbycpICg0MikpXG4gIC8vLiA0MlxuICAvLy4gYGBgXG4gIF8uc25kID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskUGFpciAoYSkgKGIpLCBiXSxcbiAgICBpbXBsOiBQYWlyLnNuZFxuICB9O1xuXG4gIC8vIyBzd2FwIDo6IFBhaXIgYSBiIC0+IFBhaXIgYiBhXG4gIC8vLlxuICAvLy4gYHN3YXAgKFBhaXIgKHgpICh5KSlgIGlzIGVxdWl2YWxlbnQgdG8gYFBhaXIgKHkpICh4KWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnN3YXAgKFMuUGFpciAoJ2ZvbycpICg0MikpXG4gIC8vLiBQYWlyICg0MikgKCdmb28nKVxuICAvLy4gYGBgXG4gIF8uc3dhcCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJFBhaXIgKGEpIChiKSwgJFBhaXIgKGIpIChhKV0sXG4gICAgaW1wbDogUGFpci5zd2FwXG4gIH07XG5cbiAgLy8uICMjIyBNYXliZSB0eXBlXG4gIC8vLlxuICAvLy4gVGhlIE1heWJlIHR5cGUgcmVwcmVzZW50cyBvcHRpb25hbCB2YWx1ZXM6IGEgdmFsdWUgb2YgdHlwZSBgTWF5YmUgYWAgaXNcbiAgLy8uIGVpdGhlciBOb3RoaW5nICh0aGUgZW1wdHkgdmFsdWUpIG9yIGEgSnVzdCB3aG9zZSB2YWx1ZSBpcyBvZiB0eXBlIGBhYC5cbiAgLy8uXG4gIC8vLiBUaGUgaW1wbGVtZW50YXRpb24gaXMgcHJvdmlkZWQgYnkgW3NhbmN0dWFyeS1tYXliZV1bXS5cblxuICAvLyMgTWF5YmVUeXBlIDo6IFR5cGUgLT4gVHlwZVxuICAvLy5cbiAgLy8uIEEgW2BVbmFyeVR5cGVgXVtVbmFyeVR5cGVdIGZvciB1c2Ugd2l0aCBbc2FuY3R1YXJ5LWRlZl1bXS5cblxuICAvLyMgTWF5YmUgOjogVHlwZVJlcCBNYXliZVxuICAvLy5cbiAgLy8uIE1heWJlIFt0eXBlIHJlcHJlc2VudGF0aXZlXVtdLlxuXG4gIC8vIyBOb3RoaW5nIDo6IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBUaGUgZW1wdHkgdmFsdWUgb2YgdHlwZSBgTWF5YmUgYWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLk5vdGhpbmdcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuXG4gIC8vIyBKdXN0IDo6IGEgLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uIENvbnN0cnVjdHMgYSB2YWx1ZSBvZiB0eXBlIGBNYXliZSBhYCBmcm9tIGEgdmFsdWUgb2YgdHlwZSBgYWAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLkp1c3QgKDQyKVxuICAvLy4gSnVzdCAoNDIpXG4gIC8vLiBgYGBcbiAgXy5KdXN0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFthLCAkTWF5YmUgKGEpXSxcbiAgICBpbXBsOiBKdXN0XG4gIH07XG5cbiAgLy8jIGlzTm90aGluZyA6OiBNYXliZSBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gTWF5YmUgaXMgTm90aGluZzsgYGZhbHNlYCBpZiBpdCBpcyBhIEp1c3QuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmlzTm90aGluZyAoUy5Ob3RoaW5nKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5pc05vdGhpbmcgKFMuSnVzdCAoNDIpKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBpc05vdGhpbmcobWF5YmUpIHtcbiAgICByZXR1cm4gbWF5YmUuaXNOb3RoaW5nO1xuICB9XG4gIF8uaXNOb3RoaW5nID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskTWF5YmUgKGEpLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGlzTm90aGluZ1xuICB9O1xuXG4gIC8vIyBpc0p1c3QgOjogTWF5YmUgYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIE1heWJlIGlzIGEgSnVzdDsgYGZhbHNlYCBpZiBpdCBpcyBOb3RoaW5nLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pc0p1c3QgKFMuSnVzdCAoNDIpKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5pc0p1c3QgKFMuTm90aGluZylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaXNKdXN0KG1heWJlKSB7XG4gICAgcmV0dXJuIG1heWJlLmlzSnVzdDtcbiAgfVxuICBfLmlzSnVzdCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJE1heWJlIChhKSwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBpc0p1c3RcbiAgfTtcblxuICAvLyMgZnJvbU1heWJlIDo6IGEgLT4gTWF5YmUgYSAtPiBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBkZWZhdWx0IHZhbHVlIGFuZCBhIE1heWJlLCBhbmQgcmV0dXJucyB0aGUgTWF5YmUncyB2YWx1ZVxuICAvLy4gaWYgdGhlIE1heWJlIGlzIGEgSnVzdDsgdGhlIGRlZmF1bHQgdmFsdWUgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZnJvbU1heWJlX2BdKCNmcm9tTWF5YmVfKSBhbmRcbiAgLy8uIFtgbWF5YmVUb051bGxhYmxlYF0oI21heWJlVG9OdWxsYWJsZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZyb21NYXliZSAoMCkgKFMuSnVzdCAoNDIpKVxuICAvLy4gNDJcbiAgLy8uXG4gIC8vLiA+IFMuZnJvbU1heWJlICgwKSAoUy5Ob3RoaW5nKVxuICAvLy4gMFxuICAvLy4gYGBgXG4gIF8uZnJvbU1heWJlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFthLCAkTWF5YmUgKGEpLCBhXSxcbiAgICBpbXBsOiBDIChtYXliZSkgKEkpXG4gIH07XG5cbiAgLy8jIGZyb21NYXliZV8gOjogKCgpIC0+IGEpIC0+IE1heWJlIGEgLT4gYVxuICAvLy5cbiAgLy8uIFZhcmlhbnQgb2YgW2Bmcm9tTWF5YmVgXSgjZnJvbU1heWJlKSB3aGljaCB0YWtlcyBhIHRodW5rIHNvIHRoZSBkZWZhdWx0XG4gIC8vLiB2YWx1ZSBpcyBvbmx5IGNvbXB1dGVkIGlmIHJlcXVpcmVkLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gZnVuY3Rpb24gZmliKG4pIHsgcmV0dXJuIG4gPD0gMSA/IG4gOiBmaWIgKG4gLSAyKSArIGZpYiAobiAtIDEpOyB9XG4gIC8vLlxuICAvLy4gPiBTLmZyb21NYXliZV8gKCgpID0+IGZpYiAoMzApKSAoUy5KdXN0ICgxMDAwMDAwKSlcbiAgLy8uIDEwMDAwMDBcbiAgLy8uXG4gIC8vLiA+IFMuZnJvbU1heWJlXyAoKCkgPT4gZmliICgzMCkpIChTLk5vdGhpbmcpXG4gIC8vLiA4MzIwNDBcbiAgLy8uIGBgYFxuICBfLmZyb21NYXliZV8gPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuVGh1bmsgKGEpLCAkTWF5YmUgKGEpLCBhXSxcbiAgICBpbXBsOiBDIChtYXliZV8pIChJKVxuICB9O1xuXG4gIC8vIyBtYXliZVRvTnVsbGFibGUgOjogTWF5YmUgYSAtPiBOdWxsYWJsZSBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgZ2l2ZW4gTWF5YmUncyB2YWx1ZSBpZiB0aGUgTWF5YmUgaXMgYSBKdXN0OyBgbnVsbGAgb3RoZXJ3aXNlLlxuICAvLy4gW051bGxhYmxlXVtdIGlzIGRlZmluZWQgaW4gW3NhbmN0dWFyeS1kZWZdW10uXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bmcm9tTWF5YmVgXSgjZnJvbU1heWJlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWF5YmVUb051bGxhYmxlIChTLkp1c3QgKDQyKSlcbiAgLy8uIDQyXG4gIC8vLlxuICAvLy4gPiBTLm1heWJlVG9OdWxsYWJsZSAoUy5Ob3RoaW5nKVxuICAvLy4gbnVsbFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1heWJlVG9OdWxsYWJsZShtYXliZSkge1xuICAgIHJldHVybiBtYXliZS5pc0p1c3QgPyBtYXliZS52YWx1ZSA6IG51bGw7XG4gIH1cbiAgXy5tYXliZVRvTnVsbGFibGUgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyRNYXliZSAoYSksICQuTnVsbGFibGUgKGEpXSxcbiAgICBpbXBsOiBtYXliZVRvTnVsbGFibGVcbiAgfTtcblxuICAvLyMgdG9NYXliZSA6OiBhPyAtPiBNYXliZSBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBhbmQgcmV0dXJucyBOb3RoaW5nIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGA7XG4gIC8vLiBKdXN0IHRoZSB2YWx1ZSBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRvTWF5YmUgKG51bGwpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLnRvTWF5YmUgKDQyKVxuICAvLy4gSnVzdCAoNDIpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdG9NYXliZSh4KSB7XG4gICAgcmV0dXJuIHggPT0gbnVsbCA/IE5vdGhpbmcgOiBKdXN0ICh4KTtcbiAgfVxuICBfLnRvTWF5YmUgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW2EsICRNYXliZSAoYSldLFxuICAgIGltcGw6IHRvTWF5YmVcbiAgfTtcblxuICAvLyMgbWF5YmUgOjogYiAtPiAoYSAtPiBiKSAtPiBNYXliZSBhIC0+IGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHZhbHVlIG9mIGFueSB0eXBlLCBhIGZ1bmN0aW9uLCBhbmQgYSBNYXliZS4gSWYgdGhlIE1heWJlIGlzXG4gIC8vLiBhIEp1c3QsIHRoZSByZXR1cm4gdmFsdWUgaXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZnVuY3Rpb24gdG9cbiAgLy8uIHRoZSBKdXN0J3MgdmFsdWUuIE90aGVyd2lzZSwgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHJldHVybmVkLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbWF5YmVfYF0oI21heWJlXykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1heWJlICgwKSAoUy5wcm9wICgnbGVuZ3RoJykpIChTLkp1c3QgKCdyZWZ1Z2UnKSlcbiAgLy8uIDZcbiAgLy8uXG4gIC8vLiA+IFMubWF5YmUgKDApIChTLnByb3AgKCdsZW5ndGgnKSkgKFMuTm90aGluZylcbiAgLy8uIDBcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtYXliZSh4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihtYXliZSkge1xuICAgICAgICByZXR1cm4gbWF5YmUuaXNKdXN0ID8gZiAobWF5YmUudmFsdWUpIDogeDtcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLm1heWJlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtiLCBGbiAoYSkgKGIpLCAkTWF5YmUgKGEpLCBiXSxcbiAgICBpbXBsOiBtYXliZVxuICB9O1xuXG4gIC8vIyBtYXliZV8gOjogKCgpIC0+IGIpIC0+IChhIC0+IGIpIC0+IE1heWJlIGEgLT4gYlxuICAvLy5cbiAgLy8uIFZhcmlhbnQgb2YgW2BtYXliZWBdKCNtYXliZSkgd2hpY2ggdGFrZXMgYSB0aHVuayBzbyB0aGUgZGVmYXVsdCB2YWx1ZVxuICAvLy4gaXMgb25seSBjb21wdXRlZCBpZiByZXF1aXJlZC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IGZ1bmN0aW9uIGZpYihuKSB7IHJldHVybiBuIDw9IDEgPyBuIDogZmliIChuIC0gMikgKyBmaWIgKG4gLSAxKTsgfVxuICAvLy5cbiAgLy8uID4gUy5tYXliZV8gKCgpID0+IGZpYiAoMzApKSAoTWF0aC5zcXJ0KSAoUy5KdXN0ICgxMDAwMDAwKSlcbiAgLy8uIDEwMDBcbiAgLy8uXG4gIC8vLiA+IFMubWF5YmVfICgoKSA9PiBmaWIgKDMwKSkgKE1hdGguc3FydCkgKFMuTm90aGluZylcbiAgLy8uIDgzMjA0MFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1heWJlXyh0aHVuaykge1xuICAgIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24obWF5YmUpIHtcbiAgICAgICAgcmV0dXJuIG1heWJlLmlzSnVzdCA/IGYgKG1heWJlLnZhbHVlKSA6IHRodW5rICgpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8ubWF5YmVfID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlRodW5rIChiKSwgRm4gKGEpIChiKSwgJE1heWJlIChhKSwgYl0sXG4gICAgaW1wbDogbWF5YmVfXG4gIH07XG5cbiAgLy8jIGp1c3RzIDo6IChGaWx0ZXJhYmxlIGYsIEZ1bmN0b3IgZikgPT4gZiAoTWF5YmUgYSkgLT4gZiBhXG4gIC8vLlxuICAvLy4gRGlzY2FyZHMgZWFjaCBlbGVtZW50IHdoaWNoIGlzIE5vdGhpbmcsIGFuZCB1bndyYXBzIGVhY2ggZWxlbWVudCB3aGljaCBpc1xuICAvLy4gYSBKdXN0LiBSZWxhdGVkIHRvIEhhc2tlbGwncyBgY2F0TWF5YmVzYCBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGxlZnRzYF0oI2xlZnRzKSBhbmQgW2ByaWdodHNgXSgjcmlnaHRzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuanVzdHMgKFtTLkp1c3QgKCdmb28nKSwgUy5Ob3RoaW5nLCBTLkp1c3QgKCdiYXonKV0pXG4gIC8vLiBbJ2ZvbycsICdiYXonXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGp1c3RzKG1heWJlcykge1xuICAgIHJldHVybiBtYXAgKHZhbHVlKSAoZmlsdGVyIChpc0p1c3QpIChtYXliZXMpKTtcbiAgfVxuICBfLmp1c3RzID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZpbHRlcmFibGUsIFouRnVuY3Rvcl19LFxuICAgIHR5cGVzOiBbZiAoJE1heWJlIChhKSksIGYgKGEpXSxcbiAgICBpbXBsOiBqdXN0c1xuICB9O1xuXG4gIC8vIyBtYXBNYXliZSA6OiAoRmlsdGVyYWJsZSBmLCBGdW5jdG9yIGYpID0+IChhIC0+IE1heWJlIGIpIC0+IGYgYSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCBhIHN0cnVjdHVyZSwgYXBwbGllcyB0aGUgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50XG4gIC8vLiBvZiB0aGUgc3RydWN0dXJlLCBhbmQgcmV0dXJucyB0aGUgXCJzdWNjZXNzZnVsXCIgcmVzdWx0cy4gSWYgdGhlIHJlc3VsdCBvZlxuICAvLy4gYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIHRvIGFuIGVsZW1lbnQgaXMgTm90aGluZywgdGhlIHJlc3VsdCBpcyBkaXNjYXJkZWQ7XG4gIC8vLiBpZiB0aGUgcmVzdWx0IGlzIGEgSnVzdCwgdGhlIEp1c3QncyB2YWx1ZSBpcyBpbmNsdWRlZC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwTWF5YmUgKFMuaGVhZCkgKFtbXSwgWzEsIDIsIDNdLCBbXSwgWzQsIDUsIDZdLCBbXV0pXG4gIC8vLiBbMSwgNF1cbiAgLy8uXG4gIC8vLiA+IFMubWFwTWF5YmUgKFMuaGVhZCkgKHt4OiBbMSwgMiwgM10sIHk6IFtdLCB6OiBbNCwgNSwgNl19KVxuICAvLy4ge3g6IDEsIHo6IDR9XG4gIC8vLiBgYGBcbiAgXy5tYXBNYXliZSA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5GaWx0ZXJhYmxlLCBaLkZ1bmN0b3JdfSxcbiAgICB0eXBlczogW0ZuIChhKSAoJE1heWJlIChiKSksIGYgKGEpLCBmIChiKV0sXG4gICAgaW1wbDogQiAoQiAoanVzdHMpKSAobWFwKVxuICB9O1xuXG4gIC8vIyBlbmNhc2UgOjogKGEgLT4gYikgLT4gYSAtPiBNYXliZSBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB1bmFyeSBmdW5jdGlvbiBgZmAgd2hpY2ggbWF5IHRocm93IGFuZCBhIHZhbHVlIGB4YCBvZiBhbnkgdHlwZSxcbiAgLy8uIGFuZCBhcHBsaWVzIGBmYCB0byBgeGAgaW5zaWRlIGEgYHRyeWAgYmxvY2suIElmIGFuIGV4Y2VwdGlvbiBpcyBjYXVnaHQsXG4gIC8vLiB0aGUgcmV0dXJuIHZhbHVlIGlzIE5vdGhpbmc7IG90aGVyd2lzZSB0aGUgcmV0dXJuIHZhbHVlIGlzIEp1c3QgdGhlXG4gIC8vLiByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIGB4YC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGVuY2FzZUVpdGhlcmBdKCNlbmNhc2VFaXRoZXIpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5lbmNhc2UgKGV2YWwpICgnMSArIDEnKVxuICAvLy4gSnVzdCAoMilcbiAgLy8uXG4gIC8vLiA+IFMuZW5jYXNlIChldmFsKSAoJzEgKycpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZW5jYXNlKGYpIHtcbiAgICByZXR1cm4gQiAoZWl0aGVyVG9NYXliZSkgKGVuY2FzZUVpdGhlciAoSSkgKGYpKTtcbiAgfVxuICBfLmVuY2FzZSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKGEpIChiKSwgYSwgJE1heWJlIChiKV0sXG4gICAgaW1wbDogZW5jYXNlXG4gIH07XG5cbiAgLy8jIGVuY2FzZTIgOjogKGEgLT4gYiAtPiBjKSAtPiBhIC0+IGIgLT4gTWF5YmUgY1xuICAvLy5cbiAgLy8uIEJpbmFyeSB2ZXJzaW9uIG9mIFtgZW5jYXNlYF0oI2VuY2FzZSkuXG4gIF8uZW5jYXNlMiA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKGEpIChGbiAoYikgKGMpKSwgYSwgYiwgJE1heWJlIChjKV0sXG4gICAgaW1wbDogQiAoQiAoQiAoZWl0aGVyVG9NYXliZSkpKSAoZW5jYXNlRWl0aGVyMiAoSSkpXG4gIH07XG5cbiAgLy8jIGVuY2FzZTMgOjogKGEgLT4gYiAtPiBjIC0+IGQpIC0+IGEgLT4gYiAtPiBjIC0+IE1heWJlIGRcbiAgLy8uXG4gIC8vLiBUZXJuYXJ5IHZlcnNpb24gb2YgW2BlbmNhc2VgXSgjZW5jYXNlKS5cbiAgXy5lbmNhc2UzID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtGbiAoYSkgKEZuIChiKSAoRm4gKGMpIChkKSkpLCBhLCBiLCBjLCAkTWF5YmUgKGQpXSxcbiAgICBpbXBsOiBCIChCIChCIChCIChlaXRoZXJUb01heWJlKSkpKSAoZW5jYXNlRWl0aGVyMyAoSSkpXG4gIH07XG5cbiAgLy8jIG1heWJlVG9FaXRoZXIgOjogYSAtPiBNYXliZSBiIC0+IEVpdGhlciBhIGJcbiAgLy8uXG4gIC8vLiBDb252ZXJ0cyBhIE1heWJlIHRvIGFuIEVpdGhlci4gTm90aGluZyBiZWNvbWVzIGEgTGVmdCAoY29udGFpbmluZyB0aGVcbiAgLy8uIGZpcnN0IGFyZ3VtZW50KTsgYSBKdXN0IGJlY29tZXMgYSBSaWdodC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGVpdGhlclRvTWF5YmVgXSgjZWl0aGVyVG9NYXliZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1heWJlVG9FaXRoZXIgKCdFeHBlY3RpbmcgYW4gaW50ZWdlcicpIChTLnBhcnNlSW50ICgxMCkgKCd4eXonKSlcbiAgLy8uIExlZnQgKCdFeHBlY3RpbmcgYW4gaW50ZWdlcicpXG4gIC8vLlxuICAvLy4gPiBTLm1heWJlVG9FaXRoZXIgKCdFeHBlY3RpbmcgYW4gaW50ZWdlcicpIChTLnBhcnNlSW50ICgxMCkgKCc0MicpKVxuICAvLy4gUmlnaHQgKDQyKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1heWJlVG9FaXRoZXIoeCkge1xuICAgIHJldHVybiBtYXliZSAoTGVmdCAoeCkpIChSaWdodCk7XG4gIH1cbiAgXy5tYXliZVRvRWl0aGVyID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFthLCAkTWF5YmUgKGIpLCAkRWl0aGVyIChhKSAoYildLFxuICAgIGltcGw6IG1heWJlVG9FaXRoZXJcbiAgfTtcblxuICAvLy4gIyMjIEVpdGhlciB0eXBlXG4gIC8vLlxuICAvLy4gVGhlIEVpdGhlciB0eXBlIHJlcHJlc2VudHMgdmFsdWVzIHdpdGggdHdvIHBvc3NpYmlsaXRpZXM6IGEgdmFsdWUgb2YgdHlwZVxuICAvLy4gYEVpdGhlciBhIGJgIGlzIGVpdGhlciBhIExlZnQgd2hvc2UgdmFsdWUgaXMgb2YgdHlwZSBgYWAgb3IgYSBSaWdodCB3aG9zZVxuICAvLy4gdmFsdWUgaXMgb2YgdHlwZSBgYmAuXG4gIC8vLlxuICAvLy4gVGhlIGltcGxlbWVudGF0aW9uIGlzIHByb3ZpZGVkIGJ5IFtzYW5jdHVhcnktZWl0aGVyXVtdLlxuXG4gIC8vIyBFaXRoZXJUeXBlIDo6IFR5cGUgLT4gVHlwZSAtPiBUeXBlXG4gIC8vLlxuICAvLy4gQSBbYEJpbmFyeVR5cGVgXVtCaW5hcnlUeXBlXSBmb3IgdXNlIHdpdGggW3NhbmN0dWFyeS1kZWZdW10uXG5cbiAgLy8jIEVpdGhlciA6OiBUeXBlUmVwIEVpdGhlclxuICAvLy5cbiAgLy8uIEVpdGhlciBbdHlwZSByZXByZXNlbnRhdGl2ZV1bXS5cblxuICAvLyMgTGVmdCA6OiBhIC0+IEVpdGhlciBhIGJcbiAgLy8uXG4gIC8vLiBDb25zdHJ1Y3RzIGEgdmFsdWUgb2YgdHlwZSBgRWl0aGVyIGEgYmAgZnJvbSBhIHZhbHVlIG9mIHR5cGUgYGFgLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5MZWZ0ICgnQ2Fubm90IGRpdmlkZSBieSB6ZXJvJylcbiAgLy8uIExlZnQgKCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKVxuICAvLy4gYGBgXG4gIF8uTGVmdCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbYSwgJEVpdGhlciAoYSkgKGIpXSxcbiAgICBpbXBsOiBMZWZ0XG4gIH07XG5cbiAgLy8jIFJpZ2h0IDo6IGIgLT4gRWl0aGVyIGEgYlxuICAvLy5cbiAgLy8uIENvbnN0cnVjdHMgYSB2YWx1ZSBvZiB0eXBlIGBFaXRoZXIgYSBiYCBmcm9tIGEgdmFsdWUgb2YgdHlwZSBgYmAuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLlJpZ2h0ICg0MilcbiAgLy8uIFJpZ2h0ICg0MilcbiAgLy8uIGBgYFxuICBfLlJpZ2h0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtiLCAkRWl0aGVyIChhKSAoYildLFxuICAgIGltcGw6IFJpZ2h0XG4gIH07XG5cbiAgLy8jIGlzTGVmdCA6OiBFaXRoZXIgYSBiIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gRWl0aGVyIGlzIGEgTGVmdDsgYGZhbHNlYCBpZiBpdCBpcyBhIFJpZ2h0LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pc0xlZnQgKFMuTGVmdCAoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5pc0xlZnQgKFMuUmlnaHQgKDQyKSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaXNMZWZ0KGVpdGhlcikge1xuICAgIHJldHVybiBlaXRoZXIuaXNMZWZ0O1xuICB9XG4gIF8uaXNMZWZ0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskRWl0aGVyIChhKSAoYiksICQuQm9vbGVhbl0sXG4gICAgaW1wbDogaXNMZWZ0XG4gIH07XG5cbiAgLy8jIGlzUmlnaHQgOjogRWl0aGVyIGEgYiAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIEVpdGhlciBpcyBhIFJpZ2h0OyBgZmFsc2VgIGlmIGl0IGlzIGEgTGVmdC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuaXNSaWdodCAoUy5SaWdodCAoNDIpKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5pc1JpZ2h0IChTLkxlZnQgKCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaXNSaWdodChlaXRoZXIpIHtcbiAgICByZXR1cm4gZWl0aGVyLmlzUmlnaHQ7XG4gIH1cbiAgXy5pc1JpZ2h0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskRWl0aGVyIChhKSAoYiksICQuQm9vbGVhbl0sXG4gICAgaW1wbDogaXNSaWdodFxuICB9O1xuXG4gIC8vIyBmcm9tRWl0aGVyIDo6IGIgLT4gRWl0aGVyIGEgYiAtPiBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBkZWZhdWx0IHZhbHVlIGFuZCBhbiBFaXRoZXIsIGFuZCByZXR1cm5zIHRoZSBSaWdodCB2YWx1ZVxuICAvLy4gaWYgdGhlIEVpdGhlciBpcyBhIFJpZ2h0OyB0aGUgZGVmYXVsdCB2YWx1ZSBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZyb21FaXRoZXIgKDApIChTLlJpZ2h0ICg0MikpXG4gIC8vLiA0MlxuICAvLy5cbiAgLy8uID4gUy5mcm9tRWl0aGVyICgwKSAoUy5MZWZ0ICg0MikpXG4gIC8vLiAwXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZnJvbUVpdGhlcih4KSB7XG4gICAgcmV0dXJuIGVpdGhlciAoSyAoeCkpIChJKTtcbiAgfVxuICBfLmZyb21FaXRoZXIgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogW2IsICRFaXRoZXIgKGEpIChiKSwgYl0sXG4gICAgaW1wbDogZnJvbUVpdGhlclxuICB9O1xuXG4gIC8vIyB0b0VpdGhlciA6OiBhIC0+IGI/IC0+IEVpdGhlciBhIGJcbiAgLy8uXG4gIC8vLiBDb252ZXJ0cyBhbiBhcmJpdHJhcnkgdmFsdWUgdG8gYW4gRWl0aGVyOiBhIExlZnQgaWYgdGhlIHZhbHVlIGlzIGBudWxsYFxuICAvLy4gb3IgYHVuZGVmaW5lZGA7IGEgUmlnaHQgb3RoZXJ3aXNlLiBUaGUgZmlyc3QgYXJndW1lbnQgc3BlY2lmaWVzIHRoZVxuICAvLy4gdmFsdWUgb2YgdGhlIExlZnQgaW4gdGhlIFwiZmFpbHVyZVwiIGNhc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRvRWl0aGVyICgnWFlaJykgKG51bGwpXG4gIC8vLiBMZWZ0ICgnWFlaJylcbiAgLy8uXG4gIC8vLiA+IFMudG9FaXRoZXIgKCdYWVonKSAoJ0FCQycpXG4gIC8vLiBSaWdodCAoJ0FCQycpXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoUy5wcm9wICgnMCcpKVxuICAvLy4gLiAgICAgICAoUy50b0VpdGhlciAoJ0ludmFsaWQgcHJvdG9jb2wnKVxuICAvLy4gLiAgICAgICAgICAgICAgICAgICAoJ2Z0cDovL2V4YW1wbGUuY29tLycubWF0Y2ggKC9eaHR0cHM/Oi8pKSlcbiAgLy8uIExlZnQgKCdJbnZhbGlkIHByb3RvY29sJylcbiAgLy8uXG4gIC8vLiA+IFMubWFwIChTLnByb3AgKCcwJykpXG4gIC8vLiAuICAgICAgIChTLnRvRWl0aGVyICgnSW52YWxpZCBwcm90b2NvbCcpXG4gIC8vLiAuICAgICAgICAgICAgICAgICAgICgnaHR0cHM6Ly9leGFtcGxlLmNvbS8nLm1hdGNoICgvXmh0dHBzPzovKSkpXG4gIC8vLiBSaWdodCAoJ2h0dHBzOicpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdG9FaXRoZXIoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geSA9PSBudWxsID8gTGVmdCAoeCkgOiBSaWdodCAoeSk7XG4gICAgfTtcbiAgfVxuICBfLnRvRWl0aGVyID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFthLCBiLCAkRWl0aGVyIChhKSAoYildLFxuICAgIGltcGw6IHRvRWl0aGVyXG4gIH07XG5cbiAgLy8jIGVpdGhlciA6OiAoYSAtPiBjKSAtPiAoYiAtPiBjKSAtPiBFaXRoZXIgYSBiIC0+IGNcbiAgLy8uXG4gIC8vLiBUYWtlcyB0d28gZnVuY3Rpb25zIGFuZCBhbiBFaXRoZXIsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgLy8uIGFwcGx5aW5nIHRoZSBmaXJzdCBmdW5jdGlvbiB0byB0aGUgTGVmdCdzIHZhbHVlLCBpZiB0aGUgRWl0aGVyXG4gIC8vLiBpcyBhIExlZnQsIG9yIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlIHNlY29uZCBmdW5jdGlvbiB0byB0aGVcbiAgLy8uIFJpZ2h0J3MgdmFsdWUsIGlmIHRoZSBFaXRoZXIgaXMgYSBSaWdodC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZWl0aGVyIChTLnRvVXBwZXIpIChTLnNob3cpIChTLkxlZnQgKCdDYW5ub3QgZGl2aWRlIGJ5IHplcm8nKSlcbiAgLy8uICdDQU5OT1QgRElWSURFIEJZIFpFUk8nXG4gIC8vLlxuICAvLy4gPiBTLmVpdGhlciAoUy50b1VwcGVyKSAoUy5zaG93KSAoUy5SaWdodCAoNDIpKVxuICAvLy4gJzQyJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGVpdGhlcihsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHIpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihlaXRoZXIpIHtcbiAgICAgICAgcmV0dXJuIChlaXRoZXIuaXNMZWZ0ID8gbCA6IHIpIChlaXRoZXIudmFsdWUpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uZWl0aGVyID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtGbiAoYSkgKGMpLCBGbiAoYikgKGMpLCAkRWl0aGVyIChhKSAoYiksIGNdLFxuICAgIGltcGw6IGVpdGhlclxuICB9O1xuXG4gIC8vIyBsZWZ0cyA6OiAoRmlsdGVyYWJsZSBmLCBGdW5jdG9yIGYpID0+IGYgKEVpdGhlciBhIGIpIC0+IGYgYVxuICAvLy5cbiAgLy8uIERpc2NhcmRzIGVhY2ggZWxlbWVudCB3aGljaCBpcyBhIFJpZ2h0LCBhbmQgdW53cmFwcyBlYWNoIGVsZW1lbnQgd2hpY2ggaXNcbiAgLy8uIGEgTGVmdC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHJpZ2h0c2BdKCNyaWdodHMpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5sZWZ0cyAoW1MuUmlnaHQgKDIwKSwgUy5MZWZ0ICgnZm9vJyksIFMuUmlnaHQgKDEwKSwgUy5MZWZ0ICgnYmFyJyldKVxuICAvLy4gWydmb28nLCAnYmFyJ11cbiAgLy8uIGBgYFxuICBfLmxlZnRzID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZpbHRlcmFibGUsIFouRnVuY3Rvcl19LFxuICAgIHR5cGVzOiBbZiAoJEVpdGhlciAoYSkgKGIpKSwgZiAoYSldLFxuICAgIGltcGw6IEIgKG1hcCAodmFsdWUpKSAoZmlsdGVyIChpc0xlZnQpKVxuICB9O1xuXG4gIC8vIyByaWdodHMgOjogKEZpbHRlcmFibGUgZiwgRnVuY3RvciBmKSA9PiBmIChFaXRoZXIgYSBiKSAtPiBmIGJcbiAgLy8uXG4gIC8vLiBEaXNjYXJkcyBlYWNoIGVsZW1lbnQgd2hpY2ggaXMgYSBMZWZ0LCBhbmQgdW53cmFwcyBlYWNoIGVsZW1lbnQgd2hpY2ggaXNcbiAgLy8uIGEgUmlnaHQuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BsZWZ0c2BdKCNsZWZ0cykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJpZ2h0cyAoW1MuUmlnaHQgKDIwKSwgUy5MZWZ0ICgnZm9vJyksIFMuUmlnaHQgKDEwKSwgUy5MZWZ0ICgnYmFyJyldKVxuICAvLy4gWzIwLCAxMF1cbiAgLy8uIGBgYFxuICBfLnJpZ2h0cyA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5GaWx0ZXJhYmxlLCBaLkZ1bmN0b3JdfSxcbiAgICB0eXBlczogW2YgKCRFaXRoZXIgKGEpIChiKSksIGYgKGIpXSxcbiAgICBpbXBsOiBCIChtYXAgKHZhbHVlKSkgKGZpbHRlciAoaXNSaWdodCkpXG4gIH07XG5cbiAgLy8jIHRhZ0J5IDo6IChhIC0+IEJvb2xlYW4pIC0+IGEgLT4gRWl0aGVyIGEgYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgcHJlZGljYXRlIGFuZCBhIHZhbHVlLCBhbmQgcmV0dXJucyBhIFJpZ2h0IG9mIHRoZSB2YWx1ZSBpZiBpdFxuICAvLy4gc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGU7IGEgTGVmdCBvZiB0aGUgdmFsdWUgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50YWdCeSAoUy5vZGQpICgwKVxuICAvLy4gTGVmdCAoMClcbiAgLy9cbiAgLy8uID4gUy50YWdCeSAoUy5vZGQpICgxKVxuICAvLy4gUmlnaHQgKDEpXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdGFnQnkocHJlZCkge1xuICAgIHJldHVybiBpZkVsc2UgKHByZWQpIChSaWdodCkgKExlZnQpO1xuICB9XG4gIF8udGFnQnkgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlIChhKSwgYSwgJEVpdGhlciAoYSkgKGEpXSxcbiAgICBpbXBsOiB0YWdCeVxuICB9O1xuXG4gIC8vIyBlbmNhc2VFaXRoZXIgOjogKEVycm9yIC0+IGwpIC0+IChhIC0+IHIpIC0+IGEgLT4gRWl0aGVyIGwgclxuICAvLy5cbiAgLy8uIFRha2VzIHR3byB1bmFyeSBmdW5jdGlvbnMsIGBmYCBhbmQgYGdgLCB0aGUgc2Vjb25kIG9mIHdoaWNoIG1heSB0aHJvdyxcbiAgLy8uIGFuZCBhIHZhbHVlIGB4YCBvZiBhbnkgdHlwZS4gQXBwbGllcyBgZ2AgdG8gYHhgIGluc2lkZSBhIGB0cnlgIGJsb2NrLlxuICAvLy4gSWYgYW4gZXhjZXB0aW9uIGlzIGNhdWdodCwgdGhlIHJldHVybiB2YWx1ZSBpcyBhIExlZnQgY29udGFpbmluZyB0aGVcbiAgLy8uIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gdGhlIGNhdWdodCBFcnJvciBvYmplY3Q7IG90aGVyd2lzZSB0aGUgcmV0dXJuXG4gIC8vLiB2YWx1ZSBpcyBhIFJpZ2h0IGNvbnRhaW5pbmcgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZ2AgdG8gYHhgLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZW5jYXNlYF0oI2VuY2FzZSkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVuY2FzZUVpdGhlciAoUy5JKSAoSlNPTi5wYXJzZSkgKCdbXCJmb29cIixcImJhclwiLFwiYmF6XCJdJylcbiAgLy8uIFJpZ2h0IChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLlxuICAvLy4gPiBTLmVuY2FzZUVpdGhlciAoUy5JKSAoSlNPTi5wYXJzZSkgKCdbJylcbiAgLy8uIExlZnQgKG5ldyBTeW50YXhFcnJvciAoJ1VuZXhwZWN0ZWQgZW5kIG9mIEpTT04gaW5wdXQnKSlcbiAgLy8uXG4gIC8vLiA+IFMuZW5jYXNlRWl0aGVyIChTLnByb3AgKCdtZXNzYWdlJykpIChKU09OLnBhcnNlKSAoJ1snKVxuICAvLy4gTGVmdCAoJ1VuZXhwZWN0ZWQgZW5kIG9mIEpTT04gaW5wdXQnKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGVuY2FzZUVpdGhlcihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIFJpZ2h0IChnICh4KSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiBMZWZ0IChmIChlcnIpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uZW5jYXNlRWl0aGVyID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtGbiAoJC5FcnJvcikgKGwpLCBGbiAoYSkgKHIpLCBhLCAkRWl0aGVyIChsKSAocildLFxuICAgIGltcGw6IGVuY2FzZUVpdGhlclxuICB9O1xuXG4gIC8vIyBlbmNhc2VFaXRoZXIyIDo6IChFcnJvciAtPiBsKSAtPiAoYSAtPiBiIC0+IHIpIC0+IGEgLT4gYiAtPiBFaXRoZXIgbCByXG4gIC8vLlxuICAvLy4gQmluYXJ5IHZlcnNpb24gb2YgW2BlbmNhc2VFaXRoZXJgXSgjZW5jYXNlRWl0aGVyKS5cbiAgZnVuY3Rpb24gZW5jYXNlRWl0aGVyMihmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBSaWdodCAoZyAoeCkgKHkpKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBMZWZ0IChmIChlcnIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5lbmNhc2VFaXRoZXIyID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtGbiAoJC5FcnJvcikgKGwpLCBGbiAoYSkgKEZuIChiKSAocikpLCBhLCBiLCAkRWl0aGVyIChsKSAocildLFxuICAgIGltcGw6IGVuY2FzZUVpdGhlcjJcbiAgfTtcblxuICAvLyMgZW5jYXNlRWl0aGVyMyA6OiAoRXJyb3IgLT4gbCkgLT4gKGEgLT4gYiAtPiBjIC0+IHIpIC0+IGEgLT4gYiAtPiBjIC0+IEVpdGhlciBsIHJcbiAgLy8uXG4gIC8vLiBUZXJuYXJ5IHZlcnNpb24gb2YgW2BlbmNhc2VFaXRoZXJgXSgjZW5jYXNlRWl0aGVyKS5cbiAgZnVuY3Rpb24gZW5jYXNlRWl0aGVyMyhmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGcpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHopIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBSaWdodCAoZyAoeCkgKHkpICh6KSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIExlZnQgKGYgKGVycikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5lbmNhc2VFaXRoZXIzID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFtGbiAoJC5FcnJvcikgKGwpLFxuICAgICAgICAgICAgRm4gKGEpIChGbiAoYikgKEZuIChjKSAocikpKSxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgICRFaXRoZXIgKGwpIChyKV0sXG4gICAgaW1wbDogZW5jYXNlRWl0aGVyM1xuICB9O1xuXG4gIC8vIyBlaXRoZXJUb01heWJlIDo6IEVpdGhlciBhIGIgLT4gTWF5YmUgYlxuICAvLy5cbiAgLy8uIENvbnZlcnRzIGFuIEVpdGhlciB0byBhIE1heWJlLiBBIExlZnQgYmVjb21lcyBOb3RoaW5nOyBhIFJpZ2h0IGJlY29tZXNcbiAgLy8uIGEgSnVzdC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYG1heWJlVG9FaXRoZXJgXSgjbWF5YmVUb0VpdGhlcikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmVpdGhlclRvTWF5YmUgKFMuTGVmdCAoJ0Nhbm5vdCBkaXZpZGUgYnkgemVybycpKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5laXRoZXJUb01heWJlIChTLlJpZ2h0ICg0MikpXG4gIC8vLiBKdXN0ICg0MilcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBlaXRoZXJUb01heWJlKGVpdGhlcikge1xuICAgIHJldHVybiBlaXRoZXIuaXNMZWZ0ID8gTm90aGluZyA6IEp1c3QgKGVpdGhlci52YWx1ZSk7XG4gIH1cbiAgXy5laXRoZXJUb01heWJlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskRWl0aGVyIChhKSAoYiksICRNYXliZSAoYildLFxuICAgIGltcGw6IGVpdGhlclRvTWF5YmVcbiAgfTtcblxuICAvLy4gIyMjIExvZ2ljXG5cbiAgLy8jIGFuZCA6OiBCb29sZWFuIC0+IEJvb2xlYW4gLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIEJvb2xlYW4gXCJhbmRcIi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYW5kIChmYWxzZSkgKGZhbHNlKVxuICAvLy4gZmFsc2VcbiAgLy8uXG4gIC8vLiA+IFMuYW5kIChmYWxzZSkgKHRydWUpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5hbmQgKHRydWUpIChmYWxzZSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmFuZCAodHJ1ZSkgKHRydWUpXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYW5kKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHggJiYgeTtcbiAgICB9O1xuICB9XG4gIF8uYW5kID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkJvb2xlYW4sICQuQm9vbGVhbiwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBhbmRcbiAgfTtcblxuICAvLyMgb3IgOjogQm9vbGVhbiAtPiBCb29sZWFuIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBCb29sZWFuIFwib3JcIi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMub3IgKGZhbHNlKSAoZmFsc2UpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5vciAoZmFsc2UpICh0cnVlKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5vciAodHJ1ZSkgKGZhbHNlKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy5vciAodHJ1ZSkgKHRydWUpXG4gIC8vLiB0cnVlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gb3IoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geCB8fCB5O1xuICAgIH07XG4gIH1cbiAgXy5vciA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5Cb29sZWFuLCAkLkJvb2xlYW4sICQuQm9vbGVhbl0sXG4gICAgaW1wbDogb3JcbiAgfTtcblxuICAvLyMgbm90IDo6IEJvb2xlYW4gLT4gQm9vbGVhblxuICAvLy5cbiAgLy8uIEJvb2xlYW4gXCJub3RcIi5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYGNvbXBsZW1lbnRgXSgjY29tcGxlbWVudCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm5vdCAoZmFsc2UpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLm5vdCAodHJ1ZSlcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbm90KHgpIHtcbiAgICByZXR1cm4gIXg7XG4gIH1cbiAgXy5ub3QgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuQm9vbGVhbiwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBub3RcbiAgfTtcblxuICAvLyMgY29tcGxlbWVudCA6OiAoYSAtPiBCb29sZWFuKSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHVuYXJ5IHByZWRpY2F0ZSBhbmQgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYW5kIHJldHVybnMgdGhlIGxvZ2ljYWxcbiAgLy8uIG5lZ2F0aW9uIG9mIGFwcGx5aW5nIHRoZSBwcmVkaWNhdGUgdG8gdGhlIHZhbHVlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbm90YF0oI25vdCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBOdW1iZXIuaXNJbnRlZ2VyICg0MilcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuY29tcGxlbWVudCAoTnVtYmVyLmlzSW50ZWdlcikgKDQyKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBfLmNvbXBsZW1lbnQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlIChhKSwgYSwgJC5Cb29sZWFuXSxcbiAgICBpbXBsOiBCIChub3QpXG4gIH07XG5cbiAgLy8jIGlmRWxzZSA6OiAoYSAtPiBCb29sZWFuKSAtPiAoYSAtPiBiKSAtPiAoYSAtPiBiKSAtPiBhIC0+IGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHVuYXJ5IHByZWRpY2F0ZSwgYSB1bmFyeSBcImlmXCIgZnVuY3Rpb24sIGEgdW5hcnkgXCJlbHNlXCJcbiAgLy8uIGZ1bmN0aW9uLCBhbmQgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZlxuICAvLy4gYXBwbHlpbmcgdGhlIFwiaWZcIiBmdW5jdGlvbiB0byB0aGUgdmFsdWUgaWYgdGhlIHZhbHVlIHNhdGlzZmllc1xuICAvLy4gdGhlIHByZWRpY2F0ZTsgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgXCJlbHNlXCIgZnVuY3Rpb24gdG8gdGhlXG4gIC8vLiB2YWx1ZSBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B3aGVuYF0oI3doZW4pIGFuZCBbYHVubGVzc2BdKCN1bmxlc3MpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pZkVsc2UgKHggPT4geCA8IDApIChNYXRoLmFicykgKE1hdGguc3FydCkgKC0xKVxuICAvLy4gMVxuICAvLy5cbiAgLy8uID4gUy5pZkVsc2UgKHggPT4geCA8IDApIChNYXRoLmFicykgKE1hdGguc3FydCkgKDE2KVxuICAvLy4gNFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGlmRWxzZShwcmVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGYpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIChwcmVkICh4KSA/IGYgOiBnKSAoeCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5pZkVsc2UgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlIChhKSwgRm4gKGEpIChiKSwgRm4gKGEpIChiKSwgYSwgYl0sXG4gICAgaW1wbDogaWZFbHNlXG4gIH07XG5cbiAgLy8jIHdoZW4gOjogKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB1bmFyeSBwcmVkaWNhdGUsIGEgdW5hcnkgZnVuY3Rpb24sIGFuZCBhIHZhbHVlIG9mIGFueSB0eXBlLCBhbmRcbiAgLy8uIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGlmIHRoZSB2YWx1ZVxuICAvLy4gc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGU7IHRoZSB2YWx1ZSBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B1bmxlc3NgXSgjdW5sZXNzKSBhbmQgW2BpZkVsc2VgXSgjaWZFbHNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMud2hlbiAoeCA9PiB4ID49IDApIChNYXRoLnNxcnQpICgxNilcbiAgLy8uIDRcbiAgLy8uXG4gIC8vLiA+IFMud2hlbiAoeCA9PiB4ID49IDApIChNYXRoLnNxcnQpICgtMSlcbiAgLy8uIC0xXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gd2hlbihwcmVkKSB7XG4gICAgcmV0dXJuIEMgKGlmRWxzZSAocHJlZCkpIChJKTtcbiAgfVxuICBfLndoZW4gPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlIChhKSwgRm4gKGEpIChhKSwgYSwgYV0sXG4gICAgaW1wbDogd2hlblxuICB9O1xuXG4gIC8vIyB1bmxlc3MgOjogKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB1bmFyeSBwcmVkaWNhdGUsIGEgdW5hcnkgZnVuY3Rpb24sIGFuZCBhIHZhbHVlIG9mIGFueSB0eXBlLCBhbmRcbiAgLy8uIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGlmIHRoZSB2YWx1ZVxuICAvLy4gZG9lcyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlOyB0aGUgdmFsdWUgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgd2hlbmBdKCN3aGVuKSBhbmQgW2BpZkVsc2VgXSgjaWZFbHNlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudW5sZXNzICh4ID0+IHggPCAwKSAoTWF0aC5zcXJ0KSAoMTYpXG4gIC8vLiA0XG4gIC8vLlxuICAvLy4gPiBTLnVubGVzcyAoeCA9PiB4IDwgMCkgKE1hdGguc3FydCkgKC0xKVxuICAvLy4gLTFcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB1bmxlc3MocHJlZCkge1xuICAgIHJldHVybiBpZkVsc2UgKHByZWQpIChJKTtcbiAgfVxuICBfLnVubGVzcyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5QcmVkaWNhdGUgKGEpLCBGbiAoYSkgKGEpLCBhLCBhXSxcbiAgICBpbXBsOiB1bmxlc3NcbiAgfTtcblxuICAvLyMgYWxsUGFzcyA6OiBGb2xkYWJsZSBmID0+IGYgKGEgLT4gQm9vbGVhbikgLT4gYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdHJ1Y3R1cmUgY29udGFpbmluZyB6ZXJvIG9yIG1vcmUgcHJlZGljYXRlcywgYW5kIGEgdmFsdWVcbiAgLy8uIG9mIGFueSB0eXBlLiBSZXR1cm5zIGB0cnVlYCBbaWZmXVtdIHRoZSB2YWx1ZSBzYXRpc2ZpZXMgYWxsIG9mIHRoZVxuICAvLy4gcHJlZGljYXRlcy4gTm9uZSBvZiB0aGUgc3Vic2VxdWVudCBwcmVkaWNhdGVzIHdpbGwgYmUgYXBwbGllZCBhZnRlclxuICAvLy4gdGhlIGZpcnN0IHByZWRpY2F0ZSBub3Qgc2F0aXNmaWVkLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hbGxQYXNzIChbUy50ZXN0ICgvcS8pLCBTLnRlc3QgKC91LyksIFMudGVzdCAoL2kvKV0pICgncXVpZXNzZW5jZScpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmFsbFBhc3MgKFtTLnRlc3QgKC9xLyksIFMudGVzdCAoL3UvKSwgUy50ZXN0ICgvaS8pXSkgKCdmaXNzaXBhcm91cycpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGFsbFBhc3MocHJlZHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIFoucmVkdWNlIChmdW5jdGlvbihiLCBwKSB7IHJldHVybiBiICYmIHAgKHgpOyB9LCB0cnVlLCBwcmVkcyk7XG4gICAgfTtcbiAgfVxuICBfLmFsbFBhc3MgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRm9sZGFibGVdfSxcbiAgICB0eXBlczogW2YgKCQuUHJlZGljYXRlIChhKSksIGEsICQuQm9vbGVhbl0sXG4gICAgaW1wbDogYWxsUGFzc1xuICB9O1xuXG4gIC8vIyBhbnlQYXNzIDo6IEZvbGRhYmxlIGYgPT4gZiAoYSAtPiBCb29sZWFuKSAtPiBhIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cnVjdHVyZSBjb250YWluaW5nIHplcm8gb3IgbW9yZSBwcmVkaWNhdGVzLCBhbmQgYSB2YWx1ZVxuICAvLy4gb2YgYW55IHR5cGUuIFJldHVybnMgYHRydWVgIFtpZmZdW10gdGhlIHZhbHVlIHNhdGlzZmllcyBhbnkgb2YgdGhlXG4gIC8vLiBwcmVkaWNhdGVzLiBOb25lIG9mIHRoZSBzdWJzZXF1ZW50IHByZWRpY2F0ZXMgd2lsbCBiZSBhcHBsaWVkIGFmdGVyXG4gIC8vLiB0aGUgZmlyc3QgcHJlZGljYXRlIHNhdGlzZmllZC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuYW55UGFzcyAoW1MudGVzdCAoL3EvKSwgUy50ZXN0ICgvdS8pLCBTLnRlc3QgKC9pLyldKSAoJ2luY2FuZGVzY2VudCcpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmFueVBhc3MgKFtTLnRlc3QgKC9xLyksIFMudGVzdCAoL3UvKSwgUy50ZXN0ICgvaS8pXSkgKCdlbXBhdGh5JylcbiAgLy8uIGZhbHNlXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYW55UGFzcyhwcmVkcykge1xuICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gWi5yZWR1Y2UgKGZ1bmN0aW9uKGIsIHApIHsgcmV0dXJuIGIgfHwgcCAoeCk7IH0sIGZhbHNlLCBwcmVkcyk7XG4gICAgfTtcbiAgfVxuICBfLmFueVBhc3MgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRm9sZGFibGVdfSxcbiAgICB0eXBlczogW2YgKCQuUHJlZGljYXRlIChhKSksIGEsICQuQm9vbGVhbl0sXG4gICAgaW1wbDogYW55UGFzc1xuICB9O1xuXG4gIC8vLiAjIyMgQXJyYXlcblxuICAvLyMgc2xpY2UgOjogSW50ZWdlciAtPiBJbnRlZ2VyIC0+IEFycmF5IGEgLT4gTWF5YmUgKEFycmF5IGEpXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdGFydCBpbmRleCBgaWAsIGFuIGVuZCBpbmRleCBgamAsIGFuZCBhbiBhcnJheSwgYW5kIHJldHVybnNcbiAgLy8uIEp1c3QgdGhlIGBbaSxqKWAgc2xpY2Ugb2YgdGhlIGFycmF5IGlmIHBvc3NpYmxlOyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uIEEgbmVnYXRpdmUgaW5kZXggcmVwcmVzZW50cyBhbiBvZmZzZXQgZnJvbSB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheS5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHRha2VgXSgjdGFrZSksIFtgZHJvcGBdKCNkcm9wKSwgW2B0YWtlTGFzdGBdKCN0YWtlTGFzdCksXG4gIC8vLiBhbmQgW2Bkcm9wTGFzdGBdKCNkcm9wTGFzdCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNsaWNlICgxKSAoMykgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0IChbJ2InLCAnYyddKVxuICAvLy5cbiAgLy8uID4gUy5zbGljZSAoLTMpICgtMSkgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0IChbJ2MnLCAnZCddKVxuICAvLy5cbiAgLy8uID4gUy5zbGljZSAoMSkgKDYpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHNsaWNlKHN0YXJ0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVuZCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHhzKSB7XG4gICAgICAgIHZhciBmcm9tSWR4ID0gc3RhcnQgPCAwID8gc3RhcnQgKyB4cy5sZW5ndGggOiBzdGFydDtcbiAgICAgICAgdmFyIHRvSWR4ID0gZW5kIDwgMCA/IGVuZCArIHhzLmxlbmd0aCA6IGVuZDtcblxuICAgICAgICByZXR1cm4gTWF0aC5hYnMgKHN0YXJ0KSA8PSB4cy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgIE1hdGguYWJzIChlbmQpIDw9IHhzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgZnJvbUlkeCA8PSB0b0lkeCA/XG4gICAgICAgICAgICAgICAgIEp1c3QgKHhzLnNsaWNlIChmcm9tSWR4LCB0b0lkeCkpIDpcbiAgICAgICAgICAgICAgICAgTm90aGluZztcbiAgICAgIH07XG4gICAgfTtcbiAgfVxuICBfLnNsaWNlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkludGVnZXIsICQuSW50ZWdlciwgJC5BcnJheSAoYSksICRNYXliZSAoJC5BcnJheSAoYSkpXSxcbiAgICBpbXBsOiBzbGljZVxuICB9O1xuXG4gIC8vIyBhdCA6OiBJbnRlZ2VyIC0+IEFycmF5IGEgLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgSnVzdCB0aGUgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gYXJyYXkgYXQgdGhlIHNwZWNpZmllZCBpbmRleCBpZlxuICAvLy4gdGhlIGluZGV4IGlzIHdpdGhpbiB0aGUgYXJyYXkncyBib3VuZHM7IE5vdGhpbmcgb3RoZXJ3aXNlLiBBIG5lZ2F0aXZlXG4gIC8vLiBpbmRleCByZXByZXNlbnRzIGFuIG9mZnNldCBmcm9tIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hdCAoMikgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0ICgnYycpXG4gIC8vLlxuICAvLy4gPiBTLmF0ICg1KSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuYXQgKC0yKSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QgKCdkJylcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBhdChuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHhzKSB7XG4gICAgICB2YXIgaWR4ID0gbiA8IDAgPyB4cy5sZW5ndGggKyBuIDogbjtcbiAgICAgIHJldHVybiBpZHggPCAwIHx8IGlkeCA+PSB4cy5sZW5ndGggPyBOb3RoaW5nIDogSnVzdCAoeHNbaWR4XSk7XG4gICAgfTtcbiAgfVxuICBfLmF0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkludGVnZXIsICQuQXJyYXkgKGEpLCAkTWF5YmUgKGEpXSxcbiAgICBpbXBsOiBhdFxuICB9O1xuXG4gIC8vIyBoZWFkIDo6IEFycmF5IGEgLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgSnVzdCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgZ2l2ZW4gYXJyYXkgaWYgdGhlIGFycmF5IGNvbnRhaW5zXG4gIC8vLiBhdCBsZWFzdCBvbmUgZWxlbWVudDsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmhlYWQgKFsxLCAyLCAzXSlcbiAgLy8uIEp1c3QgKDEpXG4gIC8vLlxuICAvLy4gPiBTLmhlYWQgKFtdKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGhlYWQoeHMpIHtcbiAgICByZXR1cm4geHMubGVuZ3RoID4gMCA/IEp1c3QgKHhzWzBdKSA6IE5vdGhpbmc7XG4gIH1cbiAgXy5oZWFkID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkFycmF5IChhKSwgJE1heWJlIChhKV0sXG4gICAgaW1wbDogaGVhZFxuICB9O1xuXG4gIC8vIyBsYXN0IDo6IEFycmF5IGEgLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgSnVzdCB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBhcnJheSBpZiB0aGUgYXJyYXkgY29udGFpbnNcbiAgLy8uIGF0IGxlYXN0IG9uZSBlbGVtZW50OyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubGFzdCAoWzEsIDIsIDNdKVxuICAvLy4gSnVzdCAoMylcbiAgLy8uXG4gIC8vLiA+IFMubGFzdCAoW10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbGFzdCh4cykge1xuICAgIHJldHVybiB4cy5sZW5ndGggPiAwID8gSnVzdCAoeHNbeHMubGVuZ3RoIC0gMV0pIDogTm90aGluZztcbiAgfVxuICBfLmxhc3QgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuQXJyYXkgKGEpLCAkTWF5YmUgKGEpXSxcbiAgICBpbXBsOiBsYXN0XG4gIH07XG5cbiAgLy8jIHRhaWwgOjogQXJyYXkgYSAtPiBNYXliZSAoQXJyYXkgYSlcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgYWxsIGJ1dCB0aGUgZmlyc3Qgb2YgdGhlIGdpdmVuIGFycmF5J3MgZWxlbWVudHMgaWYgdGhlXG4gIC8vLiBhcnJheSBjb250YWlucyBhdCBsZWFzdCBvbmUgZWxlbWVudDsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRhaWwgKFsxLCAyLCAzXSlcbiAgLy8uIEp1c3QgKFsyLCAzXSlcbiAgLy8uXG4gIC8vLiA+IFMudGFpbCAoW10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gdGFpbCh4cykge1xuICAgIHJldHVybiB4cy5sZW5ndGggPiAwID8gSnVzdCAoeHMuc2xpY2UgKDEpKSA6IE5vdGhpbmc7XG4gIH1cbiAgXy50YWlsID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkFycmF5IChhKSwgJE1heWJlICgkLkFycmF5IChhKSldLFxuICAgIGltcGw6IHRhaWxcbiAgfTtcblxuICAvLyMgaW5pdCA6OiBBcnJheSBhIC0+IE1heWJlIChBcnJheSBhKVxuICAvLy5cbiAgLy8uIFJldHVybnMgSnVzdCBhbGwgYnV0IHRoZSBsYXN0IG9mIHRoZSBnaXZlbiBhcnJheSdzIGVsZW1lbnRzIGlmIHRoZVxuICAvLy4gYXJyYXkgY29udGFpbnMgYXQgbGVhc3Qgb25lIGVsZW1lbnQ7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pbml0IChbMSwgMiwgM10pXG4gIC8vLiBKdXN0IChbMSwgMl0pXG4gIC8vLlxuICAvLy4gPiBTLmluaXQgKFtdKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGluaXQoeHMpIHtcbiAgICByZXR1cm4geHMubGVuZ3RoID4gMCA/IEp1c3QgKHhzLnNsaWNlICgwLCAtMSkpIDogTm90aGluZztcbiAgfVxuICBfLmluaXQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuQXJyYXkgKGEpLCAkTWF5YmUgKCQuQXJyYXkgKGEpKV0sXG4gICAgaW1wbDogaW5pdFxuICB9O1xuXG4gIC8vIyB0YWtlIDo6IEludGVnZXIgLT4gQXJyYXkgYSAtPiBNYXliZSAoQXJyYXkgYSlcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgdGhlIGZpcnN0IE4gZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5IGlmIE4gaXMgZ3JlYXRlclxuICAvLy4gdGhhbiBvciBlcXVhbCB0byB6ZXJvIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXk7XG4gIC8vLiBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudGFrZSAoMikgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0IChbJ2EnLCAnYiddKVxuICAvLy5cbiAgLy8uID4gUy50YWtlICg1KSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLlxuICAvLy4gPiBTLnRha2UgKDYpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRha2Uobikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgcmV0dXJuIG4gPj0gMCAmJiBuIDw9IHhzLmxlbmd0aCA/IEp1c3QgKHhzLnNsaWNlICgwLCBuKSkgOiBOb3RoaW5nO1xuICAgIH07XG4gIH1cbiAgXy50YWtlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkludGVnZXIsICQuQXJyYXkgKGEpLCAkTWF5YmUgKCQuQXJyYXkgKGEpKV0sXG4gICAgaW1wbDogdGFrZVxuICB9O1xuXG4gIC8vIyB0YWtlTGFzdCA6OiBJbnRlZ2VyIC0+IEFycmF5IGEgLT4gTWF5YmUgKEFycmF5IGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IHRoZSBsYXN0IE4gZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5IGlmIE4gaXMgZ3JlYXRlclxuICAvLy4gdGhhbiBvciBlcXVhbCB0byB6ZXJvIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXk7XG4gIC8vLiBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudGFrZUxhc3QgKDIpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gSnVzdCAoWydkJywgJ2UnXSlcbiAgLy8uXG4gIC8vLiA+IFMudGFrZUxhc3QgKDUpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gSnVzdCAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uXG4gIC8vLiA+IFMudGFrZUxhc3QgKDYpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRha2VMYXN0KG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIHJldHVybiBuID49IDAgJiYgbiA8PSB4cy5sZW5ndGggPyBKdXN0ICh4cy5zbGljZSAoeHMubGVuZ3RoIC0gbikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogTm90aGluZztcbiAgICB9O1xuICB9XG4gIF8udGFrZUxhc3QgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuSW50ZWdlciwgJC5BcnJheSAoYSksICRNYXliZSAoJC5BcnJheSAoYSkpXSxcbiAgICBpbXBsOiB0YWtlTGFzdFxuICB9O1xuXG4gIC8vIyBkcm9wIDo6IEludGVnZXIgLT4gQXJyYXkgYSAtPiBNYXliZSAoQXJyYXkgYSlcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgYWxsIGJ1dCB0aGUgZmlyc3QgTiBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gYXJyYXkgaWYgTiBpc1xuICAvLy4gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHplcm8gYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbGVuZ3RoIG9mXG4gIC8vLiB0aGUgYXJyYXk7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5kcm9wICgyKSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QgKFsnYycsICdkJywgJ2UnXSlcbiAgLy8uXG4gIC8vLiA+IFMuZHJvcCAoNSkgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBKdXN0IChbXSlcbiAgLy8uXG4gIC8vLiA+IFMuZHJvcCAoNikgKFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZHJvcChuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHhzKSB7XG4gICAgICByZXR1cm4gbiA+PSAwICYmIG4gPD0geHMubGVuZ3RoID8gSnVzdCAoeHMuc2xpY2UgKG4pKSA6IE5vdGhpbmc7XG4gICAgfTtcbiAgfVxuICBfLmRyb3AgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuSW50ZWdlciwgJC5BcnJheSAoYSksICRNYXliZSAoJC5BcnJheSAoYSkpXSxcbiAgICBpbXBsOiBkcm9wXG4gIH07XG5cbiAgLy8jIGRyb3BMYXN0IDo6IEludGVnZXIgLT4gQXJyYXkgYSAtPiBNYXliZSAoQXJyYXkgYSlcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgYWxsIGJ1dCB0aGUgbGFzdCBOIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheSBpZiBOIGlzXG4gIC8vLiBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gemVybyBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBsZW5ndGggb2ZcbiAgLy8uIHRoZSBhcnJheTsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmRyb3BMYXN0ICgyKSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIEp1c3QgKFsnYScsICdiJywgJ2MnXSlcbiAgLy8uXG4gIC8vLiA+IFMuZHJvcExhc3QgKDUpIChbJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddKVxuICAvLy4gSnVzdCAoW10pXG4gIC8vLlxuICAvLy4gPiBTLmRyb3BMYXN0ICg2KSAoWydhJywgJ2InLCAnYycsICdkJywgJ2UnXSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBkcm9wTGFzdChuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHhzKSB7XG4gICAgICByZXR1cm4gbiA+PSAwICYmIG4gPD0geHMubGVuZ3RoID8gSnVzdCAoeHMuc2xpY2UgKDAsIHhzLmxlbmd0aCAtIG4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IE5vdGhpbmc7XG4gICAgfTtcbiAgfVxuICBfLmRyb3BMYXN0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkludGVnZXIsICQuQXJyYXkgKGEpLCAkTWF5YmUgKCQuQXJyYXkgKGEpKV0sXG4gICAgaW1wbDogZHJvcExhc3RcbiAgfTtcblxuICAvLyMgc2l6ZSA6OiBGb2xkYWJsZSBmID0+IGYgYSAtPiBJbnRlZ2VyXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNpemUgKFtdKVxuICAvLy4gMFxuICAvLy5cbiAgLy8uID4gUy5zaXplIChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAzXG4gIC8vLlxuICAvLy4gPiBTLnNpemUgKE5pbClcbiAgLy8uIDBcbiAgLy8uXG4gIC8vLiA+IFMuc2l6ZSAoQ29ucyAoJ2ZvbycpIChDb25zICgnYmFyJykgKENvbnMgKCdiYXonKSAoTmlsKSkpKVxuICAvLy4gM1xuICAvLy5cbiAgLy8uID4gUy5zaXplIChTLk5vdGhpbmcpXG4gIC8vLiAwXG4gIC8vLlxuICAvLy4gPiBTLnNpemUgKFMuSnVzdCAoJ3F1dXgnKSlcbiAgLy8uIDFcbiAgLy8uXG4gIC8vLiA+IFMuc2l6ZSAoUy5QYWlyICgnaWdub3JlZCEnKSAoJ2NvdW50ZWQhJykpXG4gIC8vLiAxXG4gIC8vLiBgYGBcbiAgXy5zaXplID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFtmIChhKSwgJC5JbnRlZ2VyXSxcbiAgICBpbXBsOiBaLnNpemVcbiAgfTtcblxuICAvLyMgYXBwZW5kIDo6IChBcHBsaWNhdGl2ZSBmLCBTZW1pZ3JvdXAgKGYgYSkpID0+IGEgLT4gZiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBlbmRpbmcgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BwcmVwZW5kYF0oI3ByZXBlbmQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5hcHBlbmQgKDMpIChbMSwgMl0pXG4gIC8vLiBbMSwgMiwgM11cbiAgLy8uXG4gIC8vLiA+IFMuYXBwZW5kICgzKSAoQ29ucyAoMSkgKENvbnMgKDIpIChOaWwpKSlcbiAgLy8uIENvbnMgKDEpIChDb25zICgyKSAoQ29ucyAoMykgKE5pbCkpKVxuICAvLy5cbiAgLy8uID4gUy5hcHBlbmQgKFsxXSkgKFMuTm90aGluZylcbiAgLy8uIEp1c3QgKFsxXSlcbiAgLy8uXG4gIC8vLiA+IFMuYXBwZW5kIChbM10pIChTLkp1c3QgKFsxLCAyXSkpXG4gIC8vLiBKdXN0IChbMSwgMiwgM10pXG4gIC8vLiBgYGBcbiAgXy5hcHBlbmQgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbGljYXRpdmUsIFouU2VtaWdyb3VwXX0sXG4gICAgdHlwZXM6IFthLCBmIChhKSwgZiAoYSldLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5hcHBlbmQpXG4gIH07XG5cbiAgLy8jIHByZXBlbmQgOjogKEFwcGxpY2F0aXZlIGYsIFNlbWlncm91cCAoZiBhKSkgPT4gYSAtPiBmIGEgLT4gZiBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHByZXBlbmRpbmcgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BhcHBlbmRgXSgjYXBwZW5kKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucHJlcGVuZCAoMSkgKFsyLCAzXSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy5cbiAgLy8uID4gUy5wcmVwZW5kICgxKSAoQ29ucyAoMikgKENvbnMgKDMpIChOaWwpKSlcbiAgLy8uIENvbnMgKDEpIChDb25zICgyKSAoQ29ucyAoMykgKE5pbCkpKVxuICAvLy5cbiAgLy8uID4gUy5wcmVwZW5kIChbMV0pIChTLk5vdGhpbmcpXG4gIC8vLiBKdXN0IChbMV0pXG4gIC8vLlxuICAvLy4gPiBTLnByZXBlbmQgKFsxXSkgKFMuSnVzdCAoWzIsIDNdKSlcbiAgLy8uIEp1c3QgKFsxLCAyLCAzXSlcbiAgLy8uIGBgYFxuICBfLnByZXBlbmQgPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouQXBwbGljYXRpdmUsIFouU2VtaWdyb3VwXX0sXG4gICAgdHlwZXM6IFthLCBmIChhKSwgZiAoYSldLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5wcmVwZW5kKVxuICB9O1xuXG4gIC8vIyBqb2luV2l0aCA6OiBTdHJpbmcgLT4gQXJyYXkgU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIEpvaW5zIHRoZSBzdHJpbmdzIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQgc2VwYXJhdGVkIGJ5IHRoZSBmaXJzdCBhcmd1bWVudC5cbiAgLy8uXG4gIC8vLiBQcm9wZXJ0aWVzOlxuICAvLy5cbiAgLy8uICAgLSBgZm9yYWxsIHMgOjogU3RyaW5nLCB0IDo6IFN0cmluZy5cbiAgLy8uICAgICAgUy5qb2luV2l0aCAocykgKFMuc3BsaXRPbiAocykgKHQpKSA9IHRgXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BzcGxpdE9uYF0oI3NwbGl0T24pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5qb2luV2l0aCAoJzonKSAoWydmb28nLCAnYmFyJywgJ2JheiddKVxuICAvLy4gJ2ZvbzpiYXI6YmF6J1xuICAvLy4gYGBgXG4gIF8uam9pbldpdGggPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkLkFycmF5ICgkLlN0cmluZyksICQuU3RyaW5nXSxcbiAgICBpbXBsOiBpbnZva2UxICgnam9pbicpXG4gIH07XG5cbiAgLy8jIGVsZW0gOjogKFNldG9pZCBhLCBGb2xkYWJsZSBmKSA9PiBhIC0+IGYgYSAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSB2YWx1ZSBhbmQgYSBzdHJ1Y3R1cmUgYW5kIHJldHVybnMgYHRydWVgIFtpZmZdW10gdGhlIHZhbHVlIGlzIGFuXG4gIC8vLiBlbGVtZW50IG9mIHRoZSBzdHJ1Y3R1cmUuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BmaW5kYF0oI2ZpbmQpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5lbGVtICgnYycpIChbJ2EnLCAnYicsICdjJ10pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmVsZW0gKCd4JykgKFsnYScsICdiJywgJ2MnXSlcbiAgLy8uIGZhbHNlXG4gIC8vLlxuICAvLy4gPiBTLmVsZW0gKDMpICh7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmVsZW0gKDgpICh7eDogMSwgeTogMiwgejogM30pXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5lbGVtICgwKSAoUy5KdXN0ICgwKSlcbiAgLy8uIHRydWVcbiAgLy8uXG4gIC8vLiA+IFMuZWxlbSAoMCkgKFMuSnVzdCAoMSkpXG4gIC8vLiBmYWxzZVxuICAvLy5cbiAgLy8uID4gUy5lbGVtICgwKSAoUy5Ob3RoaW5nKVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBfLmVsZW0gPSB7XG4gICAgY29uc3RzOiB7YTogW1ouU2V0b2lkXSwgZjogW1ouRm9sZGFibGVdfSxcbiAgICB0eXBlczogW2EsIGYgKGEpLCAkLkJvb2xlYW5dLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5lbGVtKVxuICB9O1xuXG4gIC8vIyBmaW5kIDo6IEZvbGRhYmxlIGYgPT4gKGEgLT4gQm9vbGVhbikgLT4gZiBhIC0+IE1heWJlIGFcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBzdHJ1Y3R1cmUgYW5kIHJldHVybnMgSnVzdCB0aGUgbGVmdG1vc3QgZWxlbWVudFxuICAvLy4gb2YgdGhlIHN0cnVjdHVyZSB3aGljaCBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZTsgTm90aGluZyBpZiB0aGVyZSBpcyBub1xuICAvLy4gc3VjaCBlbGVtZW50LlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZWxlbWBdKCNlbGVtKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZmluZCAoUy5sdCAoMCkpIChbMSwgLTIsIDMsIC00LCA1XSlcbiAgLy8uIEp1c3QgKC0yKVxuICAvLy5cbiAgLy8uID4gUy5maW5kIChTLmx0ICgwKSkgKFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBmaW5kKHByZWQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIHJldHVybiBaLnJlZHVjZSAoXG4gICAgICAgIGZ1bmN0aW9uKG0sIHgpIHtcbiAgICAgICAgICByZXR1cm4gbS5pc0p1c3QgPyBtIDogcHJlZCAoeCkgPyBKdXN0ICh4KSA6IE5vdGhpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIE5vdGhpbmcsXG4gICAgICAgIHhzXG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgXy5maW5kID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFskLlByZWRpY2F0ZSAoYSksIGYgKGEpLCAkTWF5YmUgKGEpXSxcbiAgICBpbXBsOiBmaW5kXG4gIH07XG5cbiAgLy8jIGZvbGRNYXAgOjogKE1vbm9pZCBtLCBGb2xkYWJsZSBmKSA9PiBUeXBlUmVwIG0gLT4gKGEgLT4gbSkgLT4gZiBhIC0+IG1cbiAgLy8uXG4gIC8vLiBDdXJyaWVkIHZlcnNpb24gb2YgW2BaLmZvbGRNYXBgXVtdLiBEZWNvbnN0cnVjdHMgYSBmb2xkYWJsZSBieSBtYXBwaW5nXG4gIC8vLiBldmVyeSBlbGVtZW50IHRvIGEgbW9ub2lkIGFuZCBjb25jYXRlbmF0aW5nIHRoZSByZXN1bHRzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5mb2xkTWFwIChTdHJpbmcpIChmID0+IGYubmFtZSkgKFtNYXRoLnNpbiwgTWF0aC5jb3MsIE1hdGgudGFuXSlcbiAgLy8uICdzaW5jb3N0YW4nXG4gIC8vLiBgYGBcbiAgXy5mb2xkTWFwID0ge1xuICAgIGNvbnN0czoge2I6IFtaLk1vbm9pZF0sIGY6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFtUeXBlUmVwIChiKSwgRm4gKGEpIChiKSwgZiAoYSksIGJdLFxuICAgIGltcGw6IGN1cnJ5MyAoWi5mb2xkTWFwKVxuICB9O1xuXG4gIC8vIyB1bmZvbGRyIDo6IChiIC0+IE1heWJlIChQYWlyIGEgYikpIC0+IGIgLT4gQXJyYXkgYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgZnVuY3Rpb24gYW5kIGEgc2VlZCB2YWx1ZSwgYW5kIHJldHVybnMgYW4gYXJyYXkgZ2VuZXJhdGVkIGJ5XG4gIC8vLiBhcHBseWluZyB0aGUgZnVuY3Rpb24gcmVwZWF0ZWRseS4gVGhlIGFycmF5IGlzIGluaXRpYWxseSBlbXB0eS4gVGhlXG4gIC8vLiBmdW5jdGlvbiBpcyBpbml0aWFsbHkgYXBwbGllZCB0byB0aGUgc2VlZCB2YWx1ZS4gRWFjaCBhcHBsaWNhdGlvblxuICAvLy4gb2YgdGhlIGZ1bmN0aW9uIHNob3VsZCByZXN1bHQgaW4gZWl0aGVyOlxuICAvLy5cbiAgLy8uICAgLSBOb3RoaW5nLCBpbiB3aGljaCBjYXNlIHRoZSBhcnJheSBpcyByZXR1cm5lZDsgb3JcbiAgLy8uXG4gIC8vLiAgIC0gSnVzdCBhIHBhaXIsIGluIHdoaWNoIGNhc2UgdGhlIGZpcnN0IGVsZW1lbnQgaXMgYXBwZW5kZWQgdG9cbiAgLy8uICAgICB0aGUgYXJyYXkgYW5kIHRoZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBzZWNvbmQgZWxlbWVudC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudW5mb2xkciAobiA9PiBuIDwgNSA/IFMuSnVzdCAoUy5QYWlyIChuKSAobiArIDEpKSA6IFMuTm90aGluZykgKDEpXG4gIC8vLiBbMSwgMiwgMywgNF1cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiB1bmZvbGRyKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yICh2YXIgbSA9IGYgKHgpOyBtLmlzSnVzdDsgbSA9IGYgKG0udmFsdWUuc25kKSkge1xuICAgICAgICByZXN1bHQucHVzaCAobS52YWx1ZS5mc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIF8udW5mb2xkciA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKGIpICgkTWF5YmUgKCRQYWlyIChhKSAoYikpKSwgYiwgJC5BcnJheSAoYSldLFxuICAgIGltcGw6IHVuZm9sZHJcbiAgfTtcblxuICAvLyMgcmFuZ2UgOjogSW50ZWdlciAtPiBJbnRlZ2VyIC0+IEFycmF5IEludGVnZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbnNlY3V0aXZlIGludGVnZXJzIHN0YXJ0aW5nIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50XG4gIC8vLiBhbmQgZW5kaW5nIHdpdGggdGhlIHNlY29uZCBhcmd1bWVudCBtaW51cyBvbmUuIFJldHVybnMgYFtdYCBpZiB0aGUgc2Vjb25kXG4gIC8vLiBhcmd1bWVudCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yYW5nZSAoMCkgKDEwKVxuICAvLy4gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDldXG4gIC8vLlxuICAvLy4gPiBTLnJhbmdlICgtNSkgKDApXG4gIC8vLiBbLTUsIC00LCAtMywgLTIsIC0xXVxuICAvLy5cbiAgLy8uID4gUy5yYW5nZSAoMCkgKC01KVxuICAvLy4gW11cbiAgLy8uIGBgYFxuICBmdW5jdGlvbiByYW5nZShmcm9tKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHRvKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBuID0gZnJvbTsgbiA8IHRvOyBuICs9IDEpIHJlc3VsdC5wdXNoIChuKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICBfLnJhbmdlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkludGVnZXIsICQuSW50ZWdlciwgJC5BcnJheSAoJC5JbnRlZ2VyKV0sXG4gICAgaW1wbDogcmFuZ2VcbiAgfTtcblxuICAvLyMgZ3JvdXBCeSA6OiAoYSAtPiBhIC0+IEJvb2xlYW4pIC0+IEFycmF5IGEgLT4gQXJyYXkgKEFycmF5IGEpXG4gIC8vLlxuICAvLy4gU3BsaXRzIGl0cyBhcnJheSBhcmd1bWVudCBpbnRvIGFuIGFycmF5IG9mIGFycmF5cyBvZiBlcXVhbCxcbiAgLy8uIGFkamFjZW50IGVsZW1lbnRzLiBFcXVhbGl0eSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBmdW5jdGlvblxuICAvLy4gcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LiBJdHMgYmVoYXZpb3VyIGNhbiBiZSBzdXJwcmlzaW5nXG4gIC8vLiBmb3IgZnVuY3Rpb25zIHRoYXQgYXJlbid0IHJlZmxleGl2ZSwgdHJhbnNpdGl2ZSwgYW5kIHN5bW1ldHJpY1xuICAvLy4gKHNlZSBbZXF1aXZhbGVuY2VdW10gcmVsYXRpb24pLlxuICAvLy5cbiAgLy8uIFByb3BlcnRpZXM6XG4gIC8vLlxuICAvLy4gICAtIGBmb3JhbGwgZiA6OiBhIC0+IGEgLT4gQm9vbGVhbiwgeHMgOjogQXJyYXkgYS5cbiAgLy8uICAgICAgUy5qb2luIChTLmdyb3VwQnkgKGYpICh4cykpID0geHNgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmdyb3VwQnkgKFMuZXF1YWxzKSAoWzEsIDEsIDIsIDEsIDFdKVxuICAvLy4gW1sxLCAxXSwgWzJdLCBbMSwgMV1dXG4gIC8vLlxuICAvLy4gPiBTLmdyb3VwQnkgKHggPT4geSA9PiB4ICsgeSA9PT0gMCkgKFsyLCAtMywgMywgMywgMywgNCwgLTQsIDRdKVxuICAvLy4gW1syXSwgWy0zLCAzLCAzLCAzXSwgWzQsIC00XSwgWzRdXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGdyb3VwQnkoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgaWYgKHhzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgdmFyIHgwID0geHNbMF07ICAgICAgICAgLy8gOjogYVxuICAgICAgdmFyIGFjdGl2ZSA9IFt4MF07ICAgICAgLy8gOjogQXJyYXkgYVxuICAgICAgdmFyIHJlc3VsdCA9IFthY3RpdmVdOyAgLy8gOjogQXJyYXkgKEFycmF5IGEpXG4gICAgICBmb3IgKHZhciBpZHggPSAxOyBpZHggPCB4cy5sZW5ndGg7IGlkeCArPSAxKSB7XG4gICAgICAgIHZhciB4ID0geHNbaWR4XTtcbiAgICAgICAgaWYgKGYgKHgwKSAoeCkpIGFjdGl2ZS5wdXNoICh4KTsgZWxzZSByZXN1bHQucHVzaCAoYWN0aXZlID0gW3gwID0geF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4gIF8uZ3JvdXBCeSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKGEpICgkLlByZWRpY2F0ZSAoYSkpLCAkLkFycmF5IChhKSwgJC5BcnJheSAoJC5BcnJheSAoYSkpXSxcbiAgICBpbXBsOiBncm91cEJ5XG4gIH07XG5cbiAgLy8jIHJldmVyc2UgOjogKEFwcGxpY2F0aXZlIGYsIEZvbGRhYmxlIGYsIE1vbm9pZCAoZiBhKSkgPT4gZiBhIC0+IGYgYVxuICAvLy5cbiAgLy8uIFJldmVyc2VzIHRoZSBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5yZXZlcnNlIChbMSwgMiwgM10pXG4gIC8vLiBbMywgMiwgMV1cbiAgLy8uXG4gIC8vLiA+IFMucmV2ZXJzZSAoQ29ucyAoMSkgKENvbnMgKDIpIChDb25zICgzKSAoTmlsKSkpKVxuICAvLy4gQ29ucyAoMykgKENvbnMgKDIpIChDb25zICgxKSAoTmlsKSkpXG4gIC8vLlxuICAvLy4gPiBTLnBpcGUgKFtTLnNwbGl0T24gKCcnKSwgUy5yZXZlcnNlLCBTLmpvaW5XaXRoICgnJyldKSAoJ2FiYycpXG4gIC8vLiAnY2JhJ1xuICAvLy4gYGBgXG4gIF8ucmV2ZXJzZSA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5BcHBsaWNhdGl2ZSwgWi5Gb2xkYWJsZSwgWi5Nb25vaWRdfSxcbiAgICB0eXBlczogW2YgKGEpLCBmIChhKV0sXG4gICAgaW1wbDogWi5yZXZlcnNlXG4gIH07XG5cbiAgLy8jIHNvcnQgOjogKE9yZCBhLCBBcHBsaWNhdGl2ZSBtLCBGb2xkYWJsZSBtLCBNb25vaWQgKG0gYSkpID0+IG0gYSAtPiBtIGFcbiAgLy8uXG4gIC8vLiBQZXJmb3JtcyBhIFtzdGFibGUgc29ydF1bXSBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZSwgdXNpbmdcbiAgLy8uIFtgWi5sdGVgXVtdIGZvciBjb21wYXJpc29ucy5cbiAgLy8uXG4gIC8vLiBQcm9wZXJ0aWVzOlxuICAvLy5cbiAgLy8uICAgLSBgUy5zb3J0IChTLnNvcnQgKG0pKSA9IFMuc29ydCAobSlgIChpZGVtcG90ZW5jZSlcbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHNvcnRCeWBdKCNzb3J0QnkpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zb3J0IChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiBbJ2JhcicsICdiYXonLCAnZm9vJ11cbiAgLy8uXG4gIC8vLiA+IFMuc29ydCAoW1MuTGVmdCAoNCksIFMuUmlnaHQgKDMpLCBTLkxlZnQgKDIpLCBTLlJpZ2h0ICgxKV0pXG4gIC8vLiBbTGVmdCAoMiksIExlZnQgKDQpLCBSaWdodCAoMSksIFJpZ2h0ICgzKV1cbiAgLy8uIGBgYFxuICBfLnNvcnQgPSB7XG4gICAgY29uc3RzOiB7YTogW1ouT3JkXSwgbTogW1ouQXBwbGljYXRpdmUsIFouRm9sZGFibGUsIFouTW9ub2lkXX0sXG4gICAgdHlwZXM6IFttIChhKSwgbSAoYSldLFxuICAgIGltcGw6IFouc29ydFxuICB9O1xuXG4gIC8vIyBzb3J0QnkgOjogKE9yZCBiLCBBcHBsaWNhdGl2ZSBtLCBGb2xkYWJsZSBtLCBNb25vaWQgKG0gYSkpID0+IChhIC0+IGIpIC0+IG0gYSAtPiBtIGFcbiAgLy8uXG4gIC8vLiBQZXJmb3JtcyBhIFtzdGFibGUgc29ydF1bXSBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIHN0cnVjdHVyZSwgdXNpbmdcbiAgLy8uIFtgWi5sdGVgXVtdIHRvIGNvbXBhcmUgdGhlIHZhbHVlcyBwcm9kdWNlZCBieSBhcHBseWluZyB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgLy8uIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgc3RydWN0dXJlLlxuICAvLy5cbiAgLy8uIFByb3BlcnRpZXM6XG4gIC8vLlxuICAvLy4gICAtIGBTLnNvcnRCeSAoZikgKFMuc29ydEJ5IChmKSAobSkpID0gUy5zb3J0QnkgKGYpIChtKWAgKGlkZW1wb3RlbmNlKVxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgc29ydGBdKCNzb3J0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc29ydEJ5IChTLnByb3AgKCdyYW5rJykpIChbXG4gIC8vLiAuICAge3Jhbms6IDcsIHN1aXQ6ICdzcGFkZXMnfSxcbiAgLy8uIC4gICB7cmFuazogNSwgc3VpdDogJ2hlYXJ0cyd9LFxuICAvLy4gLiAgIHtyYW5rOiAyLCBzdWl0OiAnaGVhcnRzJ30sXG4gIC8vLiAuICAge3Jhbms6IDUsIHN1aXQ6ICdzcGFkZXMnfSxcbiAgLy8uIC4gXSlcbiAgLy8uIFsge3Jhbms6IDIsIHN1aXQ6ICdoZWFydHMnfSxcbiAgLy8uIC4ge3Jhbms6IDUsIHN1aXQ6ICdoZWFydHMnfSxcbiAgLy8uIC4ge3Jhbms6IDUsIHN1aXQ6ICdzcGFkZXMnfSxcbiAgLy8uIC4ge3Jhbms6IDcsIHN1aXQ6ICdzcGFkZXMnfSBdXG4gIC8vLlxuICAvLy4gPiBTLnNvcnRCeSAoUy5wcm9wICgnc3VpdCcpKSAoW1xuICAvLy4gLiAgIHtyYW5rOiA3LCBzdWl0OiAnc3BhZGVzJ30sXG4gIC8vLiAuICAge3Jhbms6IDUsIHN1aXQ6ICdoZWFydHMnfSxcbiAgLy8uIC4gICB7cmFuazogMiwgc3VpdDogJ2hlYXJ0cyd9LFxuICAvLy4gLiAgIHtyYW5rOiA1LCBzdWl0OiAnc3BhZGVzJ30sXG4gIC8vLiAuIF0pXG4gIC8vLiBbIHtyYW5rOiA1LCBzdWl0OiAnaGVhcnRzJ30sXG4gIC8vLiAuIHtyYW5rOiAyLCBzdWl0OiAnaGVhcnRzJ30sXG4gIC8vLiAuIHtyYW5rOiA3LCBzdWl0OiAnc3BhZGVzJ30sXG4gIC8vLiAuIHtyYW5rOiA1LCBzdWl0OiAnc3BhZGVzJ30gXVxuICAvLy4gYGBgXG4gIC8vLlxuICAvLy4gSWYgZGVzY2VuZGluZyBvcmRlciBpcyBkZXNpcmVkLCBvbmUgbWF5IHVzZSBbYERlc2NlbmRpbmdgXVtdOlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zb3J0QnkgKERlc2NlbmRpbmcpIChbODMsIDk3LCAxMTAsIDk5LCAxMTYsIDExNywgOTcsIDExNCwgMTIxXSlcbiAgLy8uIFsxMjEsIDExNywgMTE2LCAxMTQsIDExMCwgOTksIDk3LCA5NywgODNdXG4gIC8vLiBgYGBcbiAgXy5zb3J0QnkgPSB7XG4gICAgY29uc3RzOiB7YjogW1ouT3JkXSwgbTogW1ouQXBwbGljYXRpdmUsIFouRm9sZGFibGUsIFouTW9ub2lkXX0sXG4gICAgdHlwZXM6IFtGbiAoYSkgKGIpLCBtIChhKSwgbSAoYSldLFxuICAgIGltcGw6IGN1cnJ5MiAoWi5zb3J0QnkpXG4gIH07XG5cbiAgLy8jIHppcCA6OiBBcnJheSBhIC0+IEFycmF5IGIgLT4gQXJyYXkgKFBhaXIgYSBiKVxuICAvLy5cbiAgLy8uIFJldHVybnMgYW4gYXJyYXkgb2YgcGFpcnMgb2YgY29ycmVzcG9uZGluZyBlbGVtZW50cyBmcm9tIHRoZSBnaXZlblxuICAvLy4gYXJyYXlzLiBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgYXJyYXkgaXMgZXF1YWwgdG8gdGhlIGxlbmd0aCBvZlxuICAvLy4gdGhlIHNob3J0ZXIgaW5wdXQgYXJyYXkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B6aXBXaXRoYF0oI3ppcFdpdGgpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy56aXAgKFsnYScsICdiJ10pIChbJ3gnLCAneScsICd6J10pXG4gIC8vLiBbUGFpciAoJ2EnKSAoJ3gnKSwgUGFpciAoJ2InKSAoJ3knKV1cbiAgLy8uXG4gIC8vLiA+IFMuemlwIChbMSwgMywgNV0pIChbMiwgNF0pXG4gIC8vLiBbUGFpciAoMSkgKDIpLCBQYWlyICgzKSAoNCldXG4gIC8vLiBgYGBcbiAgXy56aXAgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuQXJyYXkgKGEpLCAkLkFycmF5IChiKSwgJC5BcnJheSAoJFBhaXIgKGEpIChiKSldLFxuICAgIGltcGw6IHppcFdpdGggKFBhaXIpXG4gIH07XG5cbiAgLy8jIHppcFdpdGggOjogKGEgLT4gYiAtPiBjKSAtPiBBcnJheSBhIC0+IEFycmF5IGIgLT4gQXJyYXkgY1xuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHJlc3VsdCBvZiBjb21iaW5pbmcsIHBhaXJ3aXNlLCB0aGUgZ2l2ZW4gYXJyYXlzIHVzaW5nIHRoZVxuICAvLy4gZ2l2ZW4gYmluYXJ5IGZ1bmN0aW9uLiBUaGUgbGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgYXJyYXkgaXMgZXF1YWwgdG8gdGhlXG4gIC8vLiBsZW5ndGggb2YgdGhlIHNob3J0ZXIgaW5wdXQgYXJyYXkuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B6aXBgXSgjemlwKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuemlwV2l0aCAoYSA9PiBiID0+IGEgKyBiKSAoWydhJywgJ2InXSkgKFsneCcsICd5JywgJ3onXSlcbiAgLy8uIFsnYXgnLCAnYnknXVxuICAvLy5cbiAgLy8uID4gUy56aXBXaXRoIChhID0+IGIgPT4gW2EsIGJdKSAoWzEsIDMsIDVdKSAoWzIsIDRdKVxuICAvLy4gW1sxLCAyXSwgWzMsIDRdXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHppcFdpdGgoZikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHlzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluICh4cy5sZW5ndGgsIHlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbjsgaWR4ICs9IDEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCAoZiAoeHNbaWR4XSkgKHlzW2lkeF0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uemlwV2l0aCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbRm4gKGEpIChGbiAoYikgKGMpKSwgJC5BcnJheSAoYSksICQuQXJyYXkgKGIpLCAkLkFycmF5IChjKV0sXG4gICAgaW1wbDogemlwV2l0aFxuICB9O1xuXG4gIC8vLiAjIyMgT2JqZWN0XG5cbiAgLy8jIHByb3AgOjogU3RyaW5nIC0+IGEgLT4gYlxuICAvLy5cbiAgLy8uIFRha2VzIGEgcHJvcGVydHkgbmFtZSBhbmQgYW4gb2JqZWN0IHdpdGgga25vd24gcHJvcGVydGllcyBhbmQgcmV0dXJuc1xuICAvLy4gdGhlIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuIElmIGZvciBzb21lIHJlYXNvbiB0aGUgb2JqZWN0XG4gIC8vLiBsYWNrcyB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LCBhIHR5cGUgZXJyb3IgaXMgdGhyb3duLlxuICAvLy5cbiAgLy8uIEZvciBhY2Nlc3NpbmcgcHJvcGVydGllcyBvZiB1bmNlcnRhaW4gb2JqZWN0cywgdXNlIFtgZ2V0YF0oI2dldCkgaW5zdGVhZC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucHJvcCAoJ2EnKSAoe2E6IDEsIGI6IDJ9KVxuICAvLy4gMVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHZhciBvYmogPSB0b09iamVjdCAoeCk7XG4gICAgICBpZiAoa2V5IGluIG9iaikgcmV0dXJuIG9ialtrZXldO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ+KAmHByb3DigJkgZXhwZWN0ZWQgb2JqZWN0IHRvIGhhdmUgYSBwcm9wZXJ0eSBuYW1lZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICfigJgnICsga2V5ICsgJ+KAmTsgJyArIHNob3cgKHgpICsgJyBkb2VzIG5vdCcpO1xuICAgIH07XG4gIH1cbiAgXy5wcm9wID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgYSwgYl0sXG4gICAgaW1wbDogcHJvcFxuICB9O1xuXG4gIC8vIyBwcm9wcyA6OiBBcnJheSBTdHJpbmcgLT4gYSAtPiBiXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwcm9wZXJ0eSBwYXRoIChhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcykgYW5kIGFuIG9iamVjdCB3aXRoXG4gIC8vLiBrbm93biBzdHJ1Y3R1cmUgYW5kIHJldHVybnMgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoLiBJZiBmb3Igc29tZVxuICAvLy4gcmVhc29uIHRoZSBwYXRoIGRvZXMgbm90IGV4aXN0LCBhIHR5cGUgZXJyb3IgaXMgdGhyb3duLlxuICAvLy5cbiAgLy8uIEZvciBhY2Nlc3NpbmcgcHJvcGVydHkgcGF0aHMgb2YgdW5jZXJ0YWluIG9iamVjdHMsIHVzZSBbYGdldHNgXSgjZ2V0cylcbiAgLy8uIGluc3RlYWQuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnByb3BzIChbJ2EnLCAnYicsICdjJ10pICh7YToge2I6IHtjOiAxfX19KVxuICAvLy4gMVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHByb3BzKHBhdGgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHBhdGgucmVkdWNlIChmdW5jdGlvbih4LCBrZXkpIHtcbiAgICAgICAgdmFyIG9iaiA9IHRvT2JqZWN0ICh4KTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmopIHJldHVybiBvYmpba2V5XTtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvciAoJ+KAmHByb3Bz4oCZIGV4cGVjdGVkIG9iamVjdCB0byBoYXZlIGEgcHJvcGVydHkgYXQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3cgKHBhdGgpICsgJzsgJyArIHNob3cgKHgpICsgJyBkb2VzIG5vdCcpO1xuICAgICAgfSwgeCk7XG4gICAgfTtcbiAgfVxuICBfLnByb3BzID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkFycmF5ICgkLlN0cmluZyksIGEsIGJdLFxuICAgIGltcGw6IHByb3BzXG4gIH07XG5cbiAgLy8jIGdldCA6OiAoQW55IC0+IEJvb2xlYW4pIC0+IFN0cmluZyAtPiBhIC0+IE1heWJlIGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHByZWRpY2F0ZSwgYSBwcm9wZXJ0eSBuYW1lLCBhbmQgYW4gb2JqZWN0IGFuZCByZXR1cm5zIEp1c3QgdGhlXG4gIC8vLiB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBwcm9wZXJ0eSBpZiBpdCBleGlzdHMgYW5kIHRoZSB2YWx1ZVxuICAvLy4gc2F0aXNmaWVzIHRoZSBnaXZlbiBwcmVkaWNhdGU7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgZ2V0c2BdKCNnZXRzKSBhbmQgW2Bwcm9wYF0oI3Byb3ApLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5nZXQgKFMuaXMgKCQuTnVtYmVyKSkgKCd4JykgKHt4OiAxLCB5OiAyfSlcbiAgLy8uIEp1c3QgKDEpXG4gIC8vLlxuICAvLy4gPiBTLmdldCAoUy5pcyAoJC5OdW1iZXIpKSAoJ3gnKSAoe3g6ICcxJywgeTogJzInfSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZ2V0IChTLmlzICgkLk51bWJlcikpICgneCcpICh7fSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZ2V0IChTLmlzICgkLkFycmF5ICgkLk51bWJlcikpKSAoJ3gnKSAoe3g6IFsxLCAyLCAzXX0pXG4gIC8vLiBKdXN0IChbMSwgMiwgM10pXG4gIC8vLlxuICAvLy4gPiBTLmdldCAoUy5pcyAoJC5BcnJheSAoJC5OdW1iZXIpKSkgKCd4JykgKHt4OiBbMSwgMiwgMywgbnVsbF19KVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIGdldChwcmVkKSB7XG4gICAgcmV0dXJuIEIgKEIgKGZpbHRlciAocHJlZCkpKSAoZ2V0Xyk7XG4gIH1cbiAgXy5nZXQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuUHJlZGljYXRlICgkLkFueSksICQuU3RyaW5nLCBhLCAkTWF5YmUgKGIpXSxcbiAgICBpbXBsOiBnZXRcbiAgfTtcblxuICAvLyMgZ2V0cyA6OiAoQW55IC0+IEJvb2xlYW4pIC0+IEFycmF5IFN0cmluZyAtPiBhIC0+IE1heWJlIGJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHByZWRpY2F0ZSwgYSBwcm9wZXJ0eSBwYXRoIChhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyksIGFuZFxuICAvLy4gYW4gb2JqZWN0IGFuZCByZXR1cm5zIEp1c3QgdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBwYXRoIGlmIHN1Y2ggYSBwYXRoXG4gIC8vLiBleGlzdHMgYW5kIHRoZSB2YWx1ZSBzYXRpc2ZpZXMgdGhlIGdpdmVuIHByZWRpY2F0ZTsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BnZXRgXSgjZ2V0KS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZ2V0cyAoUy5pcyAoJC5OdW1iZXIpKSAoWydhJywgJ2InLCAnYyddKSAoe2E6IHtiOiB7YzogNDJ9fX0pXG4gIC8vLiBKdXN0ICg0MilcbiAgLy8uXG4gIC8vLiA+IFMuZ2V0cyAoUy5pcyAoJC5OdW1iZXIpKSAoWydhJywgJ2InLCAnYyddKSAoe2E6IHtiOiB7YzogJzQyJ319fSlcbiAgLy8uIE5vdGhpbmdcbiAgLy8uXG4gIC8vLiA+IFMuZ2V0cyAoUy5pcyAoJC5OdW1iZXIpKSAoWydhJywgJ2InLCAnYyddKSAoe30pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZ2V0cyhwcmVkKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBaLmZpbHRlciAocHJlZCwga2V5cy5yZWR1Y2UgKGZ1bmN0aW9uKG1heWJlLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gWi5jaGFpbiAoZ2V0XyAoa2V5KSwgbWF5YmUpO1xuICAgICAgICB9LCBKdXN0ICh4KSkpO1xuICAgICAgfTtcbiAgICB9O1xuICB9XG4gIF8uZ2V0cyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5QcmVkaWNhdGUgKCQuQW55KSwgJC5BcnJheSAoJC5TdHJpbmcpLCBhLCAkTWF5YmUgKGIpXSxcbiAgICBpbXBsOiBnZXRzXG4gIH07XG5cbiAgLy8uICMjIyBTdHJNYXBcbiAgLy8uXG4gIC8vLiBTdHJNYXAgaXMgYW4gYWJicmV2aWF0aW9uIG9mIF9zdHJpbmcgbWFwXy4gQSBzdHJpbmcgbWFwIGlzIGFuIG9iamVjdCxcbiAgLy8uIHN1Y2ggYXMgYHtmb286IDEsIGJhcjogMiwgYmF6OiAzfWAsIHdob3NlIHZhbHVlcyBhcmUgYWxsIG1lbWJlcnMgb2ZcbiAgLy8uIHRoZSBzYW1lIHR5cGUuIEZvcm1hbGx5LCBhIHZhbHVlIGlzIGEgbWVtYmVyIG9mIHR5cGUgYFN0ck1hcCBhYCBpZiBpdHNcbiAgLy8uIFt0eXBlIGlkZW50aWZpZXJdW10gaXMgYCdPYmplY3QnYCBhbmQgdGhlIHZhbHVlcyBvZiBpdHMgZW51bWVyYWJsZSBvd25cbiAgLy8uIHByb3BlcnRpZXMgYXJlIGFsbCBtZW1iZXJzIG9mIHR5cGUgYGFgLlxuXG4gIC8vIyBzaW5nbGV0b24gOjogU3RyaW5nIC0+IGEgLT4gU3RyTWFwIGFcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cmluZyBhbmQgYSB2YWx1ZSBvZiBhbnkgdHlwZSwgYW5kIHJldHVybnMgYSBzdHJpbmcgbWFwIHdpdGhcbiAgLy8uIGEgc2luZ2xlIGVudHJ5IChtYXBwaW5nIHRoZSBrZXkgdG8gdGhlIHZhbHVlKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc2luZ2xldG9uICgnZm9vJykgKDQyKVxuICAvLy4ge2ZvbzogNDJ9XG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc2luZ2xldG9uKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBzdHJNYXAgPSB7fTtcbiAgICAgIHN0ck1hcFtrZXldID0gdmFsO1xuICAgICAgcmV0dXJuIHN0ck1hcDtcbiAgICB9O1xuICB9XG4gIF8uc2luZ2xldG9uID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgYSwgJC5TdHJNYXAgKGEpXSxcbiAgICBpbXBsOiBzaW5nbGV0b25cbiAgfTtcblxuICAvLyMgaW5zZXJ0IDo6IFN0cmluZyAtPiBhIC0+IFN0ck1hcCBhIC0+IFN0ck1hcCBhXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdHJpbmcsIGEgdmFsdWUgb2YgYW55IHR5cGUsIGFuZCBhIHN0cmluZyBtYXAsIGFuZCByZXR1cm5zIGFcbiAgLy8uIHN0cmluZyBtYXAgY29tcHJpc2luZyBhbGwgdGhlIGVudHJpZXMgb2YgdGhlIGdpdmVuIHN0cmluZyBtYXAgcGx1cyB0aGVcbiAgLy8uIGVudHJ5IHNwZWNpZmllZCBieSB0aGUgZmlyc3QgdHdvIGFyZ3VtZW50cyAod2hpY2ggdGFrZXMgcHJlY2VkZW5jZSkuXG4gIC8vLlxuICAvLy4gRXF1aXZhbGVudCB0byBIYXNrZWxsJ3MgYGluc2VydGAgZnVuY3Rpb24uIFNpbWlsYXIgdG8gQ2xvanVyZSdzIGBhc3NvY2BcbiAgLy8uIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5pbnNlcnQgKCdjJykgKDMpICh7YTogMSwgYjogMn0pXG4gIC8vLiB7YTogMSwgYjogMiwgYzogM31cbiAgLy8uXG4gIC8vLiA+IFMuaW5zZXJ0ICgnYScpICg0KSAoe2E6IDEsIGI6IDJ9KVxuICAvLy4ge2E6IDQsIGI6IDJ9XG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gaW5zZXJ0KGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihzdHJNYXApIHtcbiAgICAgICAgcmV0dXJuIFouY29uY2F0IChzdHJNYXAsIHNpbmdsZXRvbiAoa2V5KSAodmFsKSk7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbiAgXy5pbnNlcnQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCBhLCAkLlN0ck1hcCAoYSksICQuU3RyTWFwIChhKV0sXG4gICAgaW1wbDogaW5zZXJ0XG4gIH07XG5cbiAgLy8jIHJlbW92ZSA6OiBTdHJpbmcgLT4gU3RyTWFwIGEgLT4gU3RyTWFwIGFcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHN0cmluZyBhbmQgYSBzdHJpbmcgbWFwLCBhbmQgcmV0dXJucyBhIHN0cmluZyBtYXAgY29tcHJpc2luZyBhbGxcbiAgLy8uIHRoZSBlbnRyaWVzIG9mIHRoZSBnaXZlbiBzdHJpbmcgbWFwIGV4Y2VwdCB0aGUgb25lIHdob3NlIGtleSBtYXRjaGVzIHRoZVxuICAvLy4gZ2l2ZW4gc3RyaW5nIChpZiBzdWNoIGEga2V5IGV4aXN0cykuXG4gIC8vLlxuICAvLy4gRXF1aXZhbGVudCB0byBIYXNrZWxsJ3MgYGRlbGV0ZWAgZnVuY3Rpb24uIFNpbWlsYXIgdG8gQ2xvanVyZSdzIGBkaXNzb2NgXG4gIC8vLiBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmVtb3ZlICgnYycpICh7YTogMSwgYjogMiwgYzogM30pXG4gIC8vLiB7YTogMSwgYjogMn1cbiAgLy8uXG4gIC8vLiA+IFMucmVtb3ZlICgnYycpICh7fSlcbiAgLy8uIHt9XG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJNYXApIHtcbiAgICAgIHZhciByZXN1bHQgPSBaLmNvbmNhdCAoc3RyTWFwLCB7fSk7XG4gICAgICBkZWxldGUgcmVzdWx0W2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbiAgXy5yZW1vdmUgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkLlN0ck1hcCAoYSksICQuU3RyTWFwIChhKV0sXG4gICAgaW1wbDogcmVtb3ZlXG4gIH07XG5cbiAgLy8jIGtleXMgOjogU3RyTWFwIGEgLT4gQXJyYXkgU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUga2V5cyBvZiB0aGUgZ2l2ZW4gc3RyaW5nIG1hcCwgaW4gYXJiaXRyYXJ5IG9yZGVyLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zb3J0IChTLmtleXMgKHtiOiAyLCBjOiAzLCBhOiAxfSkpXG4gIC8vLiBbJ2EnLCAnYicsICdjJ11cbiAgLy8uIGBgYFxuICBfLmtleXMgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyTWFwIChhKSwgJC5BcnJheSAoJC5TdHJpbmcpXSxcbiAgICBpbXBsOiBPYmplY3Qua2V5c1xuICB9O1xuXG4gIC8vIyB2YWx1ZXMgOjogU3RyTWFwIGEgLT4gQXJyYXkgYVxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gc3RyaW5nIG1hcCwgaW4gYXJiaXRyYXJ5IG9yZGVyLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zb3J0IChTLnZhbHVlcyAoe2E6IDEsIGM6IDMsIGI6IDJ9KSlcbiAgLy8uIFsxLCAyLCAzXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHZhbHVlcyhzdHJNYXApIHtcbiAgICByZXR1cm4gWi5tYXAgKGZ1bmN0aW9uKGspIHsgcmV0dXJuIHN0ck1hcFtrXTsgfSwgT2JqZWN0LmtleXMgKHN0ck1hcCkpO1xuICB9XG4gIF8udmFsdWVzID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0ck1hcCAoYSksICQuQXJyYXkgKGEpXSxcbiAgICBpbXBsOiB2YWx1ZXNcbiAgfTtcblxuICAvLyMgcGFpcnMgOjogU3RyTWFwIGEgLT4gQXJyYXkgKFBhaXIgU3RyaW5nIGEpXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUga2V54oCTdmFsdWUgcGFpcnMgb2YgdGhlIGdpdmVuIHN0cmluZyBtYXAsIGluIGFyYml0cmFyeSBvcmRlci5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuc29ydCAoUy5wYWlycyAoe2I6IDIsIGE6IDEsIGM6IDN9KSlcbiAgLy8uIFtQYWlyICgnYScpICgxKSwgUGFpciAoJ2InKSAoMiksIFBhaXIgKCdjJykgKDMpXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBhaXJzKHN0ck1hcCkge1xuICAgIHJldHVybiBaLm1hcCAoZnVuY3Rpb24oaykgeyByZXR1cm4gUGFpciAoaykgKHN0ck1hcFtrXSk7IH0sXG4gICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyAoc3RyTWFwKSk7XG4gIH1cbiAgXy5wYWlycyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJNYXAgKGEpLCAkLkFycmF5ICgkUGFpciAoJC5TdHJpbmcpIChhKSldLFxuICAgIGltcGw6IHBhaXJzXG4gIH07XG5cbiAgLy8jIGZyb21QYWlycyA6OiBGb2xkYWJsZSBmID0+IGYgKFBhaXIgU3RyaW5nIGEpIC0+IFN0ck1hcCBhXG4gIC8vLlxuICAvLy4gUmV0dXJucyBhIHN0cmluZyBtYXAgY29udGFpbmluZyB0aGUga2V54oCTdmFsdWUgcGFpcnMgc3BlY2lmaWVkIGJ5IHRoZVxuICAvLy4gZ2l2ZW4gW0ZvbGRhYmxlXVtdLiBJZiBhIGtleSBhcHBlYXJzIGluIG11bHRpcGxlIHBhaXJzLCB0aGUgcmlnaHRtb3N0XG4gIC8vLiBwYWlyIHRha2VzIHByZWNlZGVuY2UuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmZyb21QYWlycyAoW1MuUGFpciAoJ2EnKSAoMSksIFMuUGFpciAoJ2InKSAoMiksIFMuUGFpciAoJ2MnKSAoMyldKVxuICAvLy4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gIC8vLlxuICAvLy4gPiBTLmZyb21QYWlycyAoW1MuUGFpciAoJ3gnKSAoMSksIFMuUGFpciAoJ3gnKSAoMildKVxuICAvLy4ge3g6IDJ9XG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgcmV0dXJuIFoucmVkdWNlIChmdW5jdGlvbihzdHJNYXAsIHBhaXIpIHtcbiAgICAgIHN0ck1hcFtwYWlyLmZzdF0gPSBwYWlyLnNuZDtcbiAgICAgIHJldHVybiBzdHJNYXA7XG4gICAgfSwge30sIHBhaXJzKTtcbiAgfVxuICBfLmZyb21QYWlycyA9IHtcbiAgICBjb25zdHM6IHtmOiBbWi5Gb2xkYWJsZV19LFxuICAgIHR5cGVzOiBbZiAoJFBhaXIgKCQuU3RyaW5nKSAoYSkpLCAkLlN0ck1hcCAoYSldLFxuICAgIGltcGw6IGZyb21QYWlyc1xuICB9O1xuXG4gIC8vLiAjIyMgTnVtYmVyXG5cbiAgLy8jIG5lZ2F0ZSA6OiBWYWxpZE51bWJlciAtPiBWYWxpZE51bWJlclxuICAvLy5cbiAgLy8uIE5lZ2F0ZXMgaXRzIGFyZ3VtZW50LlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5uZWdhdGUgKDEyLjUpXG4gIC8vLiAtMTIuNVxuICAvLy5cbiAgLy8uID4gUy5uZWdhdGUgKC00MilcbiAgLy8uIDQyXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbmVnYXRlKG4pIHtcbiAgICByZXR1cm4gLW47XG4gIH1cbiAgXy5uZWdhdGUgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuVmFsaWROdW1iZXIsICQuVmFsaWROdW1iZXJdLFxuICAgIGltcGw6IG5lZ2F0ZVxuICB9O1xuXG4gIC8vIyBhZGQgOjogRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBzdW0gb2YgdHdvIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLmFkZCAoMSkgKDEpXG4gIC8vLiAyXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gYWRkKHgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHggKyB5O1xuICAgIH07XG4gIH1cbiAgXy5hZGQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuRmluaXRlTnVtYmVyLCAkLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXJdLFxuICAgIGltcGw6IGFkZFxuICB9O1xuXG4gIC8vIyBzdW0gOjogRm9sZGFibGUgZiA9PiBmIEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXJcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGdpdmVuIGFycmF5IG9mIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnN1bSAoWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gMTVcbiAgLy8uXG4gIC8vLiA+IFMuc3VtIChbXSlcbiAgLy8uIDBcbiAgLy8uXG4gIC8vLiA+IFMuc3VtIChTLkp1c3QgKDQyKSlcbiAgLy8uIDQyXG4gIC8vLlxuICAvLy4gPiBTLnN1bSAoUy5Ob3RoaW5nKVxuICAvLy4gMFxuICAvLy4gYGBgXG4gIF8uc3VtID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFtmICgkLkZpbml0ZU51bWJlciksICQuRmluaXRlTnVtYmVyXSxcbiAgICBpbXBsOiByZWR1Y2UgKGFkZCkgKDApXG4gIH07XG5cbiAgLy8jIHN1YiA6OiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlclxuICAvLy5cbiAgLy8uIFRha2VzIGEgZmluaXRlIG51bWJlciBgbmAgYW5kIHJldHVybnMgdGhlIF9zdWJ0cmFjdCBgbmBfIGZ1bmN0aW9uLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXAgKFMuc3ViICgxKSkgKFsxLCAyLCAzXSlcbiAgLy8uIFswLCAxLCAyXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHN1Yih5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB4IC0geTtcbiAgICB9O1xuICB9XG4gIF8uc3ViID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyXSxcbiAgICBpbXBsOiBzdWJcbiAgfTtcblxuICAvLyMgbXVsdCA6OiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlclxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdHdvIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm11bHQgKDQpICgyKVxuICAvLy4gOFxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG11bHQoeCkge1xuICAgIHJldHVybiBmdW5jdGlvbih5KSB7XG4gICAgICByZXR1cm4geCAqIHk7XG4gICAgfTtcbiAgfVxuICBfLm11bHQgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuRmluaXRlTnVtYmVyLCAkLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXJdLFxuICAgIGltcGw6IG11bHRcbiAgfTtcblxuICAvLyMgcHJvZHVjdCA6OiBGb2xkYWJsZSBmID0+IGYgRmluaXRlTnVtYmVyIC0+IEZpbml0ZU51bWJlclxuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhlIGdpdmVuIGFycmF5IG9mIChmaW5pdGUpIG51bWJlcnMuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnByb2R1Y3QgKFsxLCAyLCAzLCA0LCA1XSlcbiAgLy8uIDEyMFxuICAvLy5cbiAgLy8uID4gUy5wcm9kdWN0IChbXSlcbiAgLy8uIDFcbiAgLy8uXG4gIC8vLiA+IFMucHJvZHVjdCAoUy5KdXN0ICg0MikpXG4gIC8vLiA0MlxuICAvLy5cbiAgLy8uID4gUy5wcm9kdWN0IChTLk5vdGhpbmcpXG4gIC8vLiAxXG4gIC8vLiBgYGBcbiAgXy5wcm9kdWN0ID0ge1xuICAgIGNvbnN0czoge2Y6IFtaLkZvbGRhYmxlXX0sXG4gICAgdHlwZXM6IFtmICgkLkZpbml0ZU51bWJlciksICQuRmluaXRlTnVtYmVyXSxcbiAgICBpbXBsOiByZWR1Y2UgKG11bHQpICgxKVxuICB9O1xuXG4gIC8vIyBkaXYgOjogTm9uWmVyb0Zpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBub24temVybyBmaW5pdGUgbnVtYmVyIGBuYCBhbmQgcmV0dXJucyB0aGUgX2RpdmlkZSBieSBgbmBfXG4gIC8vLiBmdW5jdGlvbi5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWFwIChTLmRpdiAoMikpIChbMCwgMSwgMiwgM10pXG4gIC8vLiBbMCwgMC41LCAxLCAxLjVdXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gZGl2KHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHggLyB5O1xuICAgIH07XG4gIH1cbiAgXy5kaXYgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuTm9uWmVyb0Zpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXIsICQuRmluaXRlTnVtYmVyXSxcbiAgICBpbXBsOiBkaXZcbiAgfTtcblxuICAvLyMgcG93IDo6IEZpbml0ZU51bWJlciAtPiBGaW5pdGVOdW1iZXIgLT4gRmluaXRlTnVtYmVyXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBmaW5pdGUgbnVtYmVyIGBuYCBhbmQgcmV0dXJucyB0aGUgX3Bvd2VyIG9mIGBuYF8gZnVuY3Rpb24uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm1hcCAoUy5wb3cgKDIpKSAoWy0zLCAtMiwgLTEsIDAsIDEsIDIsIDNdKVxuICAvLy4gWzksIDQsIDEsIDAsIDEsIDQsIDldXG4gIC8vLlxuICAvLy4gPiBTLm1hcCAoUy5wb3cgKDAuNSkpIChbMSwgNCwgOSwgMTYsIDI1XSlcbiAgLy8uIFsxLCAyLCAzLCA0LCA1XVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBvdyhleHApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYmFzZSkge1xuICAgICAgcmV0dXJuIE1hdGgucG93IChiYXNlLCBleHApO1xuICAgIH07XG4gIH1cbiAgXy5wb3cgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuRmluaXRlTnVtYmVyLCAkLkZpbml0ZU51bWJlciwgJC5GaW5pdGVOdW1iZXJdLFxuICAgIGltcGw6IHBvd1xuICB9O1xuXG4gIC8vIyBtZWFuIDo6IEZvbGRhYmxlIGYgPT4gZiBGaW5pdGVOdW1iZXIgLT4gTWF5YmUgRmluaXRlTnVtYmVyXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgbWVhbiBvZiB0aGUgZ2l2ZW4gYXJyYXkgb2YgKGZpbml0ZSkgbnVtYmVycy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubWVhbiAoWzEsIDIsIDMsIDQsIDVdKVxuICAvLy4gSnVzdCAoMylcbiAgLy8uXG4gIC8vLiA+IFMubWVhbiAoW10pXG4gIC8vLiBOb3RoaW5nXG4gIC8vLlxuICAvLy4gPiBTLm1lYW4gKFMuSnVzdCAoNDIpKVxuICAvLy4gSnVzdCAoNDIpXG4gIC8vLlxuICAvLy4gPiBTLm1lYW4gKFMuTm90aGluZylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBtZWFuKGZvbGRhYmxlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFoucmVkdWNlIChcbiAgICAgIGZ1bmN0aW9uKGFjYywgbikge1xuICAgICAgICBhY2MudG90YWwgKz0gbjtcbiAgICAgICAgYWNjLmNvdW50ICs9IDE7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LFxuICAgICAge3RvdGFsOiAwLCBjb3VudDogMH0sXG4gICAgICBmb2xkYWJsZVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdC5jb3VudCA+IDAgPyBKdXN0IChyZXN1bHQudG90YWwgLyByZXN1bHQuY291bnQpIDogTm90aGluZztcbiAgfVxuICBfLm1lYW4gPSB7XG4gICAgY29uc3RzOiB7ZjogW1ouRm9sZGFibGVdfSxcbiAgICB0eXBlczogW2YgKCQuRmluaXRlTnVtYmVyKSwgJE1heWJlICgkLkZpbml0ZU51bWJlcildLFxuICAgIGltcGw6IG1lYW5cbiAgfTtcblxuICAvLy4gIyMjIEludGVnZXJcblxuICAvLyMgZXZlbiA6OiBJbnRlZ2VyIC0+IEJvb2xlYW5cbiAgLy8uXG4gIC8vLiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gaW50ZWdlciBpcyBldmVuOyBgZmFsc2VgIGlmIGl0IGlzIG9kZC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMuZXZlbiAoNDIpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLmV2ZW4gKDk5KVxuICAvLy4gZmFsc2VcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBldmVuKG4pIHtcbiAgICByZXR1cm4gbiAlIDIgPT09IDA7XG4gIH1cbiAgXy5ldmVuID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkludGVnZXIsICQuQm9vbGVhbl0sXG4gICAgaW1wbDogZXZlblxuICB9O1xuXG4gIC8vIyBvZGQgOjogSW50ZWdlciAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGludGVnZXIgaXMgb2RkOyBgZmFsc2VgIGlmIGl0IGlzIGV2ZW4uXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLm9kZCAoOTkpXG4gIC8vLiB0cnVlXG4gIC8vLlxuICAvLy4gPiBTLm9kZCAoNDIpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG9kZChuKSB7XG4gICAgcmV0dXJuIG4gJSAyICE9PSAwO1xuICB9XG4gIF8ub2RkID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkludGVnZXIsICQuQm9vbGVhbl0sXG4gICAgaW1wbDogb2RkXG4gIH07XG5cbiAgLy8uICMjIyBQYXJzZVxuXG4gIC8vIyBwYXJzZURhdGUgOjogU3RyaW5nIC0+IE1heWJlIFZhbGlkRGF0ZVxuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIEp1c3QgdGhlIGRhdGUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZ1xuICAvLy4gaWYgaXQgZG9lcyBpbiBmYWN0IHJlcHJlc2VudCBhIGRhdGU7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wYXJzZURhdGUgKCcyMDExLTAxLTE5VDE3OjQwOjAwWicpXG4gIC8vLiBKdXN0IChuZXcgRGF0ZSAoJzIwMTEtMDEtMTlUMTc6NDA6MDAuMDAwWicpKVxuICAvLy5cbiAgLy8uID4gUy5wYXJzZURhdGUgKCd0b2RheScpXG4gIC8vLiBOb3RoaW5nXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gcGFyc2VEYXRlKHMpIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlIChzKTtcbiAgICByZXR1cm4gaXNOYU4gKGRhdGUudmFsdWVPZiAoKSkgPyBOb3RoaW5nIDogSnVzdCAoZGF0ZSk7XG4gIH1cbiAgXy5wYXJzZURhdGUgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkTWF5YmUgKCQuVmFsaWREYXRlKV0sXG4gICAgaW1wbDogcGFyc2VEYXRlXG4gIH07XG5cbiAgLy8gIHJlcXVpcmVkTm9uQ2FwdHVyaW5nR3JvdXAgOjogQXJyYXkgU3RyaW5nIC0+IFN0cmluZ1xuICBmdW5jdGlvbiByZXF1aXJlZE5vbkNhcHR1cmluZ0dyb3VwKHhzKSB7XG4gICAgcmV0dXJuICcoPzonICsgeHMuam9pbiAoJ3wnKSArICcpJztcbiAgfVxuXG4gIC8vICBvcHRpb25hbE5vbkNhcHR1cmluZ0dyb3VwIDo6IEFycmF5IFN0cmluZyAtPiBTdHJpbmdcbiAgZnVuY3Rpb24gb3B0aW9uYWxOb25DYXB0dXJpbmdHcm91cCh4cykge1xuICAgIHJldHVybiByZXF1aXJlZE5vbkNhcHR1cmluZ0dyb3VwICh4cykgKyAnPyc7XG4gIH1cblxuICAvLyAgdmFsaWRGbG9hdFJlcHIgOjogUmVnRXhwXG4gIHZhciB2YWxpZEZsb2F0UmVwciA9IG5ldyBSZWdFeHAgKFxuICAgICdeJyArICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQtb2Ytc3RyaW5nIGFuY2hvclxuICAgICdcXFxccyonICsgICAgICAgICAgICAgICAgICAvLyBhbnkgbnVtYmVyIG9mIGxlYWRpbmcgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgJ1srLV0/JyArICAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCBzaWduXG4gICAgcmVxdWlyZWROb25DYXB0dXJpbmdHcm91cCAoW1xuICAgICAgJ0luZmluaXR5JywgICAgICAgICAgICAgLy8gXCJJbmZpbml0eVwiXG4gICAgICAnTmFOJywgICAgICAgICAgICAgICAgICAvLyBcIk5hTlwiXG4gICAgICByZXF1aXJlZE5vbkNhcHR1cmluZ0dyb3VwIChbXG4gICAgICAgICdbMC05XSsnLCAgICAgICAgICAgICAvLyBudW1iZXJcbiAgICAgICAgJ1swLTldK1suXVswLTldKycsICAgIC8vIG51bWJlciB3aXRoIGludGVyaW9yIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgJ1swLTldK1suXScsICAgICAgICAgIC8vIG51bWJlciB3aXRoIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgJ1suXVswLTldKycgICAgICAgICAgIC8vIG51bWJlciB3aXRoIGxlYWRpbmcgZGVjaW1hbCBwb2ludFxuICAgICAgXSkgK1xuICAgICAgb3B0aW9uYWxOb25DYXB0dXJpbmdHcm91cCAoW1xuICAgICAgICAnW0VlXScgKyAgICAgICAgICAgICAgLy8gXCJFXCIgb3IgXCJlXCJcbiAgICAgICAgJ1srLV0/JyArICAgICAgICAgICAgIC8vIG9wdGlvbmFsIHNpZ25cbiAgICAgICAgJ1swLTldKycgICAgICAgICAgICAgIC8vIGV4cG9uZW50XG4gICAgICBdKVxuICAgIF0pICtcbiAgICAnXFxcXHMqJyArICAgICAgICAgICAgICAgICAgLy8gYW55IG51bWJlciBvZiB0cmFpbGluZyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcbiAgICAnJCcgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgYW5jaG9yXG4gICk7XG5cbiAgLy8jIHBhcnNlRmxvYXQgOjogU3RyaW5nIC0+IE1heWJlIE51bWJlclxuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIEp1c3QgdGhlIG51bWJlciByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nXG4gIC8vLiBpZiBpdCBkb2VzIGluIGZhY3QgcmVwcmVzZW50IGEgbnVtYmVyOyBOb3RoaW5nIG90aGVyd2lzZS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucGFyc2VGbG9hdCAoJy0xMjMuNDUnKVxuICAvLy4gSnVzdCAoLTEyMy40NSlcbiAgLy8uXG4gIC8vLiA+IFMucGFyc2VGbG9hdCAoJ2Zvby5iYXInKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBhcnNlRmxvYXRfKHMpIHtcbiAgICByZXR1cm4gdmFsaWRGbG9hdFJlcHIudGVzdCAocykgPyBKdXN0IChwYXJzZUZsb2F0IChzKSkgOiBOb3RoaW5nO1xuICB9XG4gIF8ucGFyc2VGbG9hdCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsICRNYXliZSAoJC5OdW1iZXIpXSxcbiAgICBpbXBsOiBwYXJzZUZsb2F0X1xuICB9O1xuXG4gIC8vICBSYWRpeCA6OiBUeXBlXG4gIHZhciBSYWRpeCA9ICQuTnVsbGFyeVR5cGVcbiAgICAoJ3NhbmN0dWFyeS9SYWRpeCcpXG4gICAgKCcnKVxuICAgIChmdW5jdGlvbih4KSB7IHJldHVybiAkLkludGVnZXIuX3Rlc3QgKHgpICYmIHggPj0gMiAmJiB4IDw9IDM2OyB9KTtcblxuICAvLyMgcGFyc2VJbnQgOjogUmFkaXggLT4gU3RyaW5nIC0+IE1heWJlIEludGVnZXJcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHJhZGl4IChhbiBpbnRlZ2VyIGJldHdlZW4gMiBhbmQgMzYgaW5jbHVzaXZlKSBhbmQgYSBzdHJpbmcsXG4gIC8vLiBhbmQgcmV0dXJucyBKdXN0IHRoZSBudW1iZXIgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZyBpZiBpdCBkb2VzIGluXG4gIC8vLiBmYWN0IHJlcHJlc2VudCBhIG51bWJlciBpbiB0aGUgYmFzZSBzcGVjaWZpZWQgYnkgdGhlIHJhZGl4OyBOb3RoaW5nXG4gIC8vLiBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gVGhpcyBmdW5jdGlvbiBpcyBzdHJpY3RlciB0aGFuIFtgcGFyc2VJbnRgXVtwYXJzZUludF06IGEgc3RyaW5nXG4gIC8vLiBpcyBjb25zaWRlcmVkIHRvIHJlcHJlc2VudCBhbiBpbnRlZ2VyIG9ubHkgaWYgYWxsIGl0cyBub24tcHJlZml4XG4gIC8vLiBjaGFyYWN0ZXJzIGFyZSBtZW1iZXJzIG9mIHRoZSBjaGFyYWN0ZXIgc2V0IHNwZWNpZmllZCBieSB0aGUgcmFkaXguXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnBhcnNlSW50ICgxMCkgKCctNDInKVxuICAvLy4gSnVzdCAoLTQyKVxuICAvLy5cbiAgLy8uID4gUy5wYXJzZUludCAoMTYpICgnMHhGRicpXG4gIC8vLiBKdXN0ICgyNTUpXG4gIC8vLlxuICAvLy4gPiBTLnBhcnNlSW50ICgxNikgKCcweEdHJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBwYXJzZUludF8ocmFkaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIGNoYXJzZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJy5zbGljZSAoMCwgcmFkaXgpO1xuICAgICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwICgnXlsnICsgY2hhcnNldCArICddKyQnLCAnaScpO1xuXG4gICAgICB2YXIgdCA9IHMucmVwbGFjZSAoL15bKy1dLywgJycpO1xuICAgICAgaWYgKHBhdHRlcm4udGVzdCAocmFkaXggPT09IDE2ID8gdC5yZXBsYWNlICgvXjB4L2ksICcnKSA6IHQpKSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VJbnQgKHMsIHJhZGl4KTtcbiAgICAgICAgaWYgKCQuSW50ZWdlci5fdGVzdCAobikpIHJldHVybiBKdXN0IChuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOb3RoaW5nO1xuICAgIH07XG4gIH1cbiAgXy5wYXJzZUludCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbUmFkaXgsICQuU3RyaW5nLCAkTWF5YmUgKCQuSW50ZWdlcildLFxuICAgIGltcGw6IHBhcnNlSW50X1xuICB9O1xuXG4gIC8vIyBwYXJzZUpzb24gOjogKEFueSAtPiBCb29sZWFuKSAtPiBTdHJpbmcgLT4gTWF5YmUgYVxuICAvLy5cbiAgLy8uIFRha2VzIGEgcHJlZGljYXRlIGFuZCBhIHN0cmluZyB3aGljaCBtYXkgb3IgbWF5IG5vdCBiZSB2YWxpZCBKU09OLCBhbmRcbiAgLy8uIHJldHVybnMgSnVzdCB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGBKU09OLnBhcnNlYCB0byB0aGUgc3RyaW5nICppZiogdGhlXG4gIC8vLiByZXN1bHQgc2F0aXNmaWVzIHRoZSBwcmVkaWNhdGU7IE5vdGhpbmcgb3RoZXJ3aXNlLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5wYXJzZUpzb24gKFMuaXMgKCQuQXJyYXkgKCQuSW50ZWdlcikpKSAoJ1snKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5wYXJzZUpzb24gKFMuaXMgKCQuQXJyYXkgKCQuSW50ZWdlcikpKSAoJ1tcIjFcIixcIjJcIixcIjNcIl0nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5wYXJzZUpzb24gKFMuaXMgKCQuQXJyYXkgKCQuSW50ZWdlcikpKSAoJ1swLDEuNSwzLDQuNV0nKVxuICAvLy4gTm90aGluZ1xuICAvLy5cbiAgLy8uID4gUy5wYXJzZUpzb24gKFMuaXMgKCQuQXJyYXkgKCQuSW50ZWdlcikpKSAoJ1sxLDIsM10nKVxuICAvLy4gSnVzdCAoWzEsIDIsIDNdKVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHBhcnNlSnNvbihwcmVkKSB7XG4gICAgcmV0dXJuIEIgKGZpbHRlciAocHJlZCkpIChlbmNhc2UgKEpTT04ucGFyc2UpKTtcbiAgfVxuICBfLnBhcnNlSnNvbiA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5QcmVkaWNhdGUgKCQuQW55KSwgJC5TdHJpbmcsICRNYXliZSAoYSldLFxuICAgIGltcGw6IHBhcnNlSnNvblxuICB9O1xuXG4gIC8vLiAjIyMgUmVnRXhwXG5cbiAgLy8gIE1hdGNoIDo6IFR5cGVcbiAgdmFyIE1hdGNoID0gJC5SZWNvcmRUeXBlICh7XG4gICAgbWF0Y2g6ICQuU3RyaW5nLFxuICAgIGdyb3VwczogJC5BcnJheSAoJE1heWJlICgkLlN0cmluZykpXG4gIH0pO1xuXG4gIC8vICB0b01hdGNoIDo6IEFycmF5IFN0cmluZz8gLT4gTWF0Y2hcbiAgZnVuY3Rpb24gdG9NYXRjaChzcykge1xuICAgIHJldHVybiB7bWF0Y2g6IHNzWzBdLCBncm91cHM6IFoubWFwICh0b01heWJlLCBzcy5zbGljZSAoMSkpfTtcbiAgfVxuXG4gIC8vICB3aXRoUmVnZXggOjogKFJlZ0V4cCwgKCkgLT4gYSkgLT4gYVxuICBmdW5jdGlvbiB3aXRoUmVnZXgocGF0dGVybiwgdGh1bmspIHtcbiAgICB2YXIgbGFzdEluZGV4ID0gcGF0dGVybi5sYXN0SW5kZXg7XG4gICAgdmFyIHJlc3VsdCA9IHRodW5rICgpO1xuICAgIHBhdHRlcm4ubGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyMgcmVnZXggOjogUmVnZXhGbGFncyAtPiBTdHJpbmcgLT4gUmVnRXhwXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBbUmVnZXhGbGFnc11bXSBhbmQgYSBwYXR0ZXJuLCBhbmQgcmV0dXJucyBhIFJlZ0V4cC5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMucmVnZXggKCdnJykgKCc6XFxcXGQrOicpXG4gIC8vLiAvOlxcZCs6L2dcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiByZWdleChmbGFncykge1xuICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwIChzb3VyY2UsIGZsYWdzKTtcbiAgICB9O1xuICB9XG4gIF8ucmVnZXggPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuUmVnZXhGbGFncywgJC5TdHJpbmcsICQuUmVnRXhwXSxcbiAgICBpbXBsOiByZWdleFxuICB9O1xuXG4gIC8vIyByZWdleEVzY2FwZSA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBzdHJpbmcgd2hpY2ggbWF5IGNvbnRhaW4gcmVndWxhciBleHByZXNzaW9uIG1ldGFjaGFyYWN0ZXJzLFxuICAvLy4gYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aG9zZSBtZXRhY2hhcmFjdGVycyBlc2NhcGVkLlxuICAvLy5cbiAgLy8uIFByb3BlcnRpZXM6XG4gIC8vLlxuICAvLy4gICAtIGBmb3JhbGwgcyA6OiBTdHJpbmcuXG4gIC8vLiAgICAgIFMudGVzdCAoUy5yZWdleCAoJycpIChTLnJlZ2V4RXNjYXBlIChzKSkpIChzKSA9IHRydWVgXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnJlZ2V4RXNjYXBlICgnLT0qe1hZWn0qPS0nKVxuICAvLy4gJ1xcXFwtPVxcXFwqXFxcXHtYWVpcXFxcfVxcXFwqPVxcXFwtJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICByZXR1cm4gcy5yZXBsYWNlICgvWy1bXFxde30oKSorPy4sXFxcXF4kfCNcXHNdL2csICdcXFxcJCYnKTtcbiAgfVxuICBfLnJlZ2V4RXNjYXBlID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgJC5TdHJpbmddLFxuICAgIGltcGw6IHJlZ2V4RXNjYXBlXG4gIH07XG5cbiAgLy8jIHRlc3QgOjogUmVnRXhwIC0+IFN0cmluZyAtPiBCb29sZWFuXG4gIC8vLlxuICAvLy4gVGFrZXMgYSBwYXR0ZXJuIGFuZCBhIHN0cmluZywgYW5kIHJldHVybnMgYHRydWVgIFtpZmZdW10gdGhlIHBhdHRlcm5cbiAgLy8uIG1hdGNoZXMgdGhlIHN0cmluZy5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMudGVzdCAoL15hLykgKCdhYmFjdXMnKVxuICAvLy4gdHJ1ZVxuICAvLy5cbiAgLy8uID4gUy50ZXN0ICgvXmEvKSAoJ2JhbmFuYScpXG4gIC8vLiBmYWxzZVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHRlc3QocGF0dGVybikge1xuICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gd2l0aFJlZ2V4IChwYXR0ZXJuLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBhdHRlcm4udGVzdCAocyk7IH0pO1xuICAgIH07XG4gIH1cbiAgXy50ZXN0ID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlJlZ0V4cCwgJC5TdHJpbmcsICQuQm9vbGVhbl0sXG4gICAgaW1wbDogdGVzdFxuICB9O1xuXG4gIC8vIyBtYXRjaCA6OiBOb25HbG9iYWxSZWdFeHAgLT4gU3RyaW5nIC0+IE1heWJlIHsgbWF0Y2ggOjogU3RyaW5nLCBncm91cHMgOjogQXJyYXkgKE1heWJlIFN0cmluZykgfVxuICAvLy5cbiAgLy8uIFRha2VzIGEgcGF0dGVybiBhbmQgYSBzdHJpbmcsIGFuZCByZXR1cm5zIEp1c3QgYSBtYXRjaCByZWNvcmQgaWYgdGhlXG4gIC8vLiBwYXR0ZXJuIG1hdGNoZXMgdGhlIHN0cmluZzsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gYGdyb3VwcyA6OiBBcnJheSAoTWF5YmUgU3RyaW5nKWAgYWNrbm93bGVkZ2VzIHRoZSBleGlzdGVuY2Ugb2Ygb3B0aW9uYWxcbiAgLy8uIGNhcHR1cmluZyBncm91cHMuXG4gIC8vLlxuICAvLy4gUHJvcGVydGllczpcbiAgLy8uXG4gIC8vLiAgIC0gYGZvcmFsbCBwIDo6IFBhdHRlcm4sIHMgOjogU3RyaW5nLlxuICAvLy4gICAgICBTLmhlYWQgKFMubWF0Y2hBbGwgKFMucmVnZXggKCdnJykgKHApKSAocykpXG4gIC8vLiAgICAgID0gUy5tYXRjaCAoUy5yZWdleCAoJycpIChwKSkgKHMpYFxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbWF0Y2hBbGxgXSgjbWF0Y2hBbGwpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXRjaCAoLyhnb29kKT9ieWUvKSAoJ2dvb2RieWUnKVxuICAvLy4gSnVzdCAoe21hdGNoOiAnZ29vZGJ5ZScsIGdyb3VwczogW0p1c3QgKCdnb29kJyldfSlcbiAgLy8uXG4gIC8vLiA+IFMubWF0Y2ggKC8oZ29vZCk/YnllLykgKCdieWUnKVxuICAvLy4gSnVzdCAoe21hdGNoOiAnYnllJywgZ3JvdXBzOiBbTm90aGluZ119KVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1hdGNoKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFoubWFwICh0b01hdGNoLCB0b01heWJlIChzLm1hdGNoIChwYXR0ZXJuKSkpO1xuICAgIH07XG4gIH1cbiAgXy5tYXRjaCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5Ob25HbG9iYWxSZWdFeHAsICQuU3RyaW5nLCAkTWF5YmUgKE1hdGNoKV0sXG4gICAgaW1wbDogbWF0Y2hcbiAgfTtcblxuICAvLyMgbWF0Y2hBbGwgOjogR2xvYmFsUmVnRXhwIC0+IFN0cmluZyAtPiBBcnJheSB7IG1hdGNoIDo6IFN0cmluZywgZ3JvdXBzIDo6IEFycmF5IChNYXliZSBTdHJpbmcpIH1cbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHBhdHRlcm4gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaCByZWNvcmRzLlxuICAvLy5cbiAgLy8uIGBncm91cHMgOjogQXJyYXkgKE1heWJlIFN0cmluZylgIGFja25vd2xlZGdlcyB0aGUgZXhpc3RlbmNlIG9mIG9wdGlvbmFsXG4gIC8vLiBjYXB0dXJpbmcgZ3JvdXBzLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbWF0Y2hgXSgjbWF0Y2gpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5tYXRjaEFsbCAoL0AoW2Etel0rKS9nKSAoJ0hlbGxvLCB3b3JsZCEnKVxuICAvLy4gW11cbiAgLy8uXG4gIC8vLiA+IFMubWF0Y2hBbGwgKC9AKFthLXpdKykvZykgKCdIZWxsbywgQGZvbyEgSGVsbG8sIEBiYXIhIEhlbGxvLCBAYmF6IScpXG4gIC8vLiBbIHttYXRjaDogJ0Bmb28nLCBncm91cHM6IFtKdXN0ICgnZm9vJyldfSxcbiAgLy8uIC4ge21hdGNoOiAnQGJhcicsIGdyb3VwczogW0p1c3QgKCdiYXInKV19LFxuICAvLy4gLiB7bWF0Y2g6ICdAYmF6JywgZ3JvdXBzOiBbSnVzdCAoJ2JheicpXX0gXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIG1hdGNoQWxsKHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHdpdGhSZWdleCAocGF0dGVybiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1bmZvbGRyIChmdW5jdGlvbihfKSB7XG4gICAgICAgICAgcmV0dXJuIFoubWFwIChmdW5jdGlvbihzcykge1xuICAgICAgICAgICAgcmV0dXJuIFBhaXIgKHRvTWF0Y2ggKHNzKSkgKG51bGwpO1xuICAgICAgICAgIH0sIHRvTWF5YmUgKHBhdHRlcm4uZXhlYyAocykpKTtcbiAgICAgICAgfSkgKFtdKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgXy5tYXRjaEFsbCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5HbG9iYWxSZWdFeHAsICQuU3RyaW5nLCAkLkFycmF5IChNYXRjaCldLFxuICAgIGltcGw6IG1hdGNoQWxsXG4gIH07XG5cbiAgLy8uICMjIyBTdHJpbmdcblxuICAvLyMgdG9VcHBlciA6OiBTdHJpbmcgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyB0aGUgdXBwZXItY2FzZSBlcXVpdmFsZW50IG9mIGl0cyBhcmd1bWVudC5cbiAgLy8uXG4gIC8vLiBTZWUgYWxzbyBbYHRvTG93ZXJgXSgjdG9Mb3dlcikuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnRvVXBwZXIgKCdBQkMgZGVmIDEyMycpXG4gIC8vLiAnQUJDIERFRiAxMjMnXG4gIC8vLiBgYGBcbiAgXy50b1VwcGVyID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLlN0cmluZywgJC5TdHJpbmddLFxuICAgIGltcGw6IGludm9rZTAgKCd0b1VwcGVyQ2FzZScpXG4gIH07XG5cbiAgLy8jIHRvTG93ZXIgOjogU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFJldHVybnMgdGhlIGxvd2VyLWNhc2UgZXF1aXZhbGVudCBvZiBpdHMgYXJndW1lbnQuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B0b1VwcGVyYF0oI3RvVXBwZXIpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50b0xvd2VyICgnQUJDIGRlZiAxMjMnKVxuICAvLy4gJ2FiYyBkZWYgMTIzJ1xuICAvLy4gYGBgXG4gIF8udG9Mb3dlciA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsICQuU3RyaW5nXSxcbiAgICBpbXBsOiBpbnZva2UwICgndG9Mb3dlckNhc2UnKVxuICB9O1xuXG4gIC8vIyB0cmltIDo6IFN0cmluZyAtPiBTdHJpbmdcbiAgLy8uXG4gIC8vLiBTdHJpcHMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy50cmltICgnXFx0XFx0IGZvbyBiYXIgXFxuJylcbiAgLy8uICdmb28gYmFyJ1xuICAvLy4gYGBgXG4gIF8udHJpbSA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsICQuU3RyaW5nXSxcbiAgICBpbXBsOiBpbnZva2UwICgndHJpbScpXG4gIH07XG5cbiAgLy8jIHN0cmlwUHJlZml4IDo6IFN0cmluZyAtPiBTdHJpbmcgLT4gTWF5YmUgU3RyaW5nXG4gIC8vLlxuICAvLy4gUmV0dXJucyBKdXN0IHRoZSBwb3J0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcgKHRoZSBzZWNvbmQgYXJndW1lbnQpIGxlZnRcbiAgLy8uIGFmdGVyIHJlbW92aW5nIHRoZSBnaXZlbiBwcmVmaXggKHRoZSBmaXJzdCBhcmd1bWVudCkgaWYgdGhlIHN0cmluZyBzdGFydHNcbiAgLy8uIHdpdGggdGhlIHByZWZpeDsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BzdHJpcFN1ZmZpeGBdKCNzdHJpcFN1ZmZpeCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnN0cmlwUHJlZml4ICgnaHR0cHM6Ly8nKSAoJ2h0dHBzOi8vc2FuY3R1YXJ5LmpzLm9yZycpXG4gIC8vLiBKdXN0ICgnc2FuY3R1YXJ5LmpzLm9yZycpXG4gIC8vLlxuICAvLy4gPiBTLnN0cmlwUHJlZml4ICgnaHR0cHM6Ly8nKSAoJ2h0dHA6Ly9zYW5jdHVhcnkuanMub3JnJylcbiAgLy8uIE5vdGhpbmdcbiAgLy8uIGBgYFxuICBmdW5jdGlvbiBzdHJpcFByZWZpeChwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIGlkeCA9IHByZWZpeC5sZW5ndGg7XG4gICAgICByZXR1cm4gcy5zbGljZSAoMCwgaWR4KSA9PT0gcHJlZml4ID8gSnVzdCAocy5zbGljZSAoaWR4KSkgOiBOb3RoaW5nO1xuICAgIH07XG4gIH1cbiAgXy5zdHJpcFByZWZpeCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsICQuU3RyaW5nLCAkTWF5YmUgKCQuU3RyaW5nKV0sXG4gICAgaW1wbDogc3RyaXBQcmVmaXhcbiAgfTtcblxuICAvLyMgc3RyaXBTdWZmaXggOjogU3RyaW5nIC0+IFN0cmluZyAtPiBNYXliZSBTdHJpbmdcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIEp1c3QgdGhlIHBvcnRpb24gb2YgdGhlIGdpdmVuIHN0cmluZyAodGhlIHNlY29uZCBhcmd1bWVudCkgbGVmdFxuICAvLy4gYWZ0ZXIgcmVtb3ZpbmcgdGhlIGdpdmVuIHN1ZmZpeCAodGhlIGZpcnN0IGFyZ3VtZW50KSBpZiB0aGUgc3RyaW5nIGVuZHNcbiAgLy8uIHdpdGggdGhlIHN1ZmZpeDsgTm90aGluZyBvdGhlcndpc2UuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BzdHJpcFByZWZpeGBdKCNzdHJpcFByZWZpeCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnN0cmlwU3VmZml4ICgnLm1kJykgKCdSRUFETUUubWQnKVxuICAvLy4gSnVzdCAoJ1JFQURNRScpXG4gIC8vLlxuICAvLy4gPiBTLnN0cmlwU3VmZml4ICgnLm1kJykgKCdSRUFETUUnKVxuICAvLy4gTm90aGluZ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHN0cmlwU3VmZml4KHN1ZmZpeCkge1xuICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgaWR4ID0gcy5sZW5ndGggLSBzdWZmaXgubGVuZ3RoOyAgLy8gdmFsdWUgbWF5IGJlIG5lZ2F0aXZlXG4gICAgICByZXR1cm4gcy5zbGljZSAoaWR4KSA9PT0gc3VmZml4ID8gSnVzdCAocy5zbGljZSAoMCwgaWR4KSkgOiBOb3RoaW5nO1xuICAgIH07XG4gIH1cbiAgXy5zdHJpcFN1ZmZpeCA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsICQuU3RyaW5nLCAkTWF5YmUgKCQuU3RyaW5nKV0sXG4gICAgaW1wbDogc3RyaXBTdWZmaXhcbiAgfTtcblxuICAvLyMgd29yZHMgOjogU3RyaW5nIC0+IEFycmF5IFN0cmluZ1xuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiB3b3JkcyB0aGUgc3RyaW5nIGNvbnRhaW5zXG4gIC8vLiAod29yZHMgYXJlIGRlbGltaXRlZCBieSB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMpLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdW53b3Jkc2BdKCN1bndvcmRzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMud29yZHMgKCcgZm9vIGJhciBiYXogJylcbiAgLy8uIFsnZm9vJywgJ2JhcicsICdiYXonXVxuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHdvcmRzKHMpIHtcbiAgICB2YXIgd29yZHMgPSBzLnNwbGl0ICgvXFxzKy8pO1xuICAgIHZhciBsZW4gPSB3b3Jkcy5sZW5ndGg7XG4gICAgcmV0dXJuIHdvcmRzLnNsaWNlICh3b3Jkc1swXSA9PT0gJycgPyAxIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRzW2xlbiAtIDFdID09PSAnJyA/IGxlbiAtIDEgOiBsZW4pO1xuICB9XG4gIF8ud29yZHMgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkLkFycmF5ICgkLlN0cmluZyldLFxuICAgIGltcGw6IHdvcmRzXG4gIH07XG5cbiAgLy8jIHVud29yZHMgOjogQXJyYXkgU3RyaW5nIC0+IFN0cmluZ1xuICAvLy5cbiAgLy8uIFRha2VzIGFuIGFycmF5IG9mIHdvcmRzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgb2Ygam9pbmluZyB0aGUgd29yZHNcbiAgLy8uIHdpdGggc2VwYXJhdGluZyBzcGFjZXMuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2B3b3Jkc2BdKCN3b3JkcykuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnVud29yZHMgKFsnZm9vJywgJ2JhcicsICdiYXonXSlcbiAgLy8uICdmb28gYmFyIGJheidcbiAgLy8uIGBgYFxuICBfLnVud29yZHMgPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuQXJyYXkgKCQuU3RyaW5nKSwgJC5TdHJpbmddLFxuICAgIGltcGw6IGludm9rZTEgKCdqb2luJykgKCcgJylcbiAgfTtcblxuICAvLyMgbGluZXMgOjogU3RyaW5nIC0+IEFycmF5IFN0cmluZ1xuICAvLy5cbiAgLy8uIFRha2VzIGEgc3RyaW5nIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiBsaW5lcyB0aGUgc3RyaW5nIGNvbnRhaW5zXG4gIC8vLiAobGluZXMgYXJlIGRlbGltaXRlZCBieSBuZXdsaW5lczogYCdcXG4nYCBvciBgJ1xcclxcbidgIG9yIGAnXFxyJ2ApLlxuICAvLy4gVGhlIHJlc3VsdGluZyBzdHJpbmdzIGRvIG5vdCBjb250YWluIG5ld2xpbmVzLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgdW5saW5lc2BdKCN1bmxpbmVzKS5cbiAgLy8uXG4gIC8vLiBgYGBqYXZhc2NyaXB0XG4gIC8vLiA+IFMubGluZXMgKCdmb29cXG5iYXJcXG5iYXpcXG4nKVxuICAvLy4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gbGluZXMocykge1xuICAgIHJldHVybiBzID09PSAnJyA/IFtdXG4gICAgICAgICAgICAgICAgICAgIDogKHMucmVwbGFjZSAoL1xcclxcbj8vZywgJ1xcbicpKS5tYXRjaCAoL14oPz1bXFxzXFxTXSkuKi9nbSk7XG4gIH1cbiAgXy5saW5lcyA9IHtcbiAgICBjb25zdHM6IHt9LFxuICAgIHR5cGVzOiBbJC5TdHJpbmcsICQuQXJyYXkgKCQuU3RyaW5nKV0sXG4gICAgaW1wbDogbGluZXNcbiAgfTtcblxuICAvLyMgdW5saW5lcyA6OiBBcnJheSBTdHJpbmcgLT4gU3RyaW5nXG4gIC8vLlxuICAvLy4gVGFrZXMgYW4gYXJyYXkgb2YgbGluZXMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiBqb2luaW5nIHRoZSBsaW5lc1xuICAvLy4gYWZ0ZXIgYXBwZW5kaW5nIGEgdGVybWluYXRpbmcgbGluZSBmZWVkIChgJ1xcbidgKSB0byBlYWNoLlxuICAvLy5cbiAgLy8uIFNlZSBhbHNvIFtgbGluZXNgXSgjbGluZXMpLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy51bmxpbmVzIChbJ2ZvbycsICdiYXInLCAnYmF6J10pXG4gIC8vLiAnZm9vXFxuYmFyXFxuYmF6XFxuJ1xuICAvLy4gYGBgXG4gIGZ1bmN0aW9uIHVubGluZXMoeHMpIHtcbiAgICByZXR1cm4geHMucmVkdWNlIChmdW5jdGlvbihzLCB4KSB7IHJldHVybiBzICsgeCArICdcXG4nOyB9LCAnJyk7XG4gIH1cbiAgXy51bmxpbmVzID0ge1xuICAgIGNvbnN0czoge30sXG4gICAgdHlwZXM6IFskLkFycmF5ICgkLlN0cmluZyksICQuU3RyaW5nXSxcbiAgICBpbXBsOiB1bmxpbmVzXG4gIH07XG5cbiAgLy8jIHNwbGl0T24gOjogU3RyaW5nIC0+IFN0cmluZyAtPiBBcnJheSBTdHJpbmdcbiAgLy8uXG4gIC8vLiBSZXR1cm5zIHRoZSBzdWJzdHJpbmdzIG9mIGl0cyBzZWNvbmQgYXJndW1lbnQgc2VwYXJhdGVkIGJ5IG9jY3VycmVuY2VzXG4gIC8vLiBvZiBpdHMgZmlyc3QgYXJndW1lbnQuXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2Bqb2luV2l0aGBdKCNqb2luV2l0aCkgYW5kIFtgc3BsaXRPblJlZ2V4YF0oI3NwbGl0T25SZWdleCkuXG4gIC8vLlxuICAvLy4gYGBgamF2YXNjcmlwdFxuICAvLy4gPiBTLnNwbGl0T24gKCc6OicpICgnZm9vOjpiYXI6OmJheicpXG4gIC8vLiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAgLy8uIGBgYFxuICBfLnNwbGl0T24gPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuU3RyaW5nLCAkLlN0cmluZywgJC5BcnJheSAoJC5TdHJpbmcpXSxcbiAgICBpbXBsOiBpbnZva2UxICgnc3BsaXQnKVxuICB9O1xuXG4gIC8vIyBzcGxpdE9uUmVnZXggOjogR2xvYmFsUmVnRXhwIC0+IFN0cmluZyAtPiBBcnJheSBTdHJpbmdcbiAgLy8uXG4gIC8vLiBUYWtlcyBhIHBhdHRlcm4gYW5kIGEgc3RyaW5nLCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHNwbGl0dGluZyB0aGVcbiAgLy8uIHN0cmluZyBhdCBldmVyeSBub24tb3ZlcmxhcHBpbmcgb2NjdXJyZW5jZSBvZiB0aGUgcGF0dGVybi5cbiAgLy8uXG4gIC8vLiBQcm9wZXJ0aWVzOlxuICAvLy5cbiAgLy8uICAgLSBgZm9yYWxsIHMgOjogU3RyaW5nLCB0IDo6IFN0cmluZy5cbiAgLy8uICAgICAgUy5qb2luV2l0aCAocylcbiAgLy8uICAgICAgICAgICAgICAgICAoUy5zcGxpdE9uUmVnZXggKFMucmVnZXggKCdnJykgKFMucmVnZXhFc2NhcGUgKHMpKSkgKHQpKVxuICAvLy4gICAgICA9IHRgXG4gIC8vLlxuICAvLy4gU2VlIGFsc28gW2BzcGxpdE9uYF0oI3NwbGl0T24pLlxuICAvLy5cbiAgLy8uIGBgYGphdmFzY3JpcHRcbiAgLy8uID4gUy5zcGxpdE9uUmVnZXggKC9bLDtdWyBdKi9nKSAoJ2ZvbywgYmFyLCBiYXonKVxuICAvLy4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gIC8vLlxuICAvLy4gPiBTLnNwbGl0T25SZWdleCAoL1ssO11bIF0qL2cpICgnZm9vO2JhcjtiYXonKVxuICAvLy4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gIC8vLiBgYGBcbiAgZnVuY3Rpb24gc3BsaXRPblJlZ2V4KHBhdHRlcm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIHdpdGhSZWdleCAocGF0dGVybiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAgIHZhciBtYXRjaDtcbiAgICAgICAgd2hpbGUgKChtYXRjaCA9IHBhdHRlcm4uZXhlYyAocykpICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAocGF0dGVybi5sYXN0SW5kZXggPT09IGxhc3RJbmRleCAmJiBtYXRjaFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmIChwYXR0ZXJuLmxhc3RJbmRleCA9PT0gcy5sZW5ndGgpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBwYXR0ZXJuLmxhc3RJbmRleCArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCAocy5zbGljZSAobGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoIChzLnNsaWNlIChsYXN0SW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cbiAgXy5zcGxpdE9uUmVnZXggPSB7XG4gICAgY29uc3RzOiB7fSxcbiAgICB0eXBlczogWyQuR2xvYmFsUmVnRXhwLCAkLlN0cmluZywgJC5BcnJheSAoJC5TdHJpbmcpXSxcbiAgICBpbXBsOiBzcGxpdE9uUmVnZXhcbiAgfTtcblxuICByZXR1cm4gY3JlYXRlICh7XG4gICAgY2hlY2tUeXBlczogKFxuICAgICAgLyogZ2xvYmFsIHByb2Nlc3M6ZmFsc2UgKi9cbiAgICAgIHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJ1xuICAgICAgfHwgcHJvY2VzcyA9PSBudWxsXG4gICAgICB8fCBwcm9jZXNzLmVudiA9PSBudWxsXG4gICAgICB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgKSxcbiAgICBlbnY6IFouY29uY2F0ICgkLmVudiwgW1xuICAgICAgJC5GaW5pdGVOdW1iZXIsXG4gICAgICAkLk5vblplcm9GaW5pdGVOdW1iZXIsXG4gICAgICAkRWl0aGVyICgkLlVua25vd24pICgkLlVua25vd24pLFxuICAgICAgRm4gKCQuVW5rbm93bikgKCQuVW5rbm93biksXG4gICAgICAkLkdsb2JhbFJlZ0V4cCxcbiAgICAgICQuTm9uR2xvYmFsUmVnRXhwLFxuICAgICAgJC5JbnRlZ2VyLFxuICAgICAgJC5Ob25OZWdhdGl2ZUludGVnZXIsXG4gICAgICAkTWF5YmUgKCQuVW5rbm93biksXG4gICAgICAkLkFycmF5MiAoJC5Vbmtub3duKSAoJC5Vbmtub3duKSxcbiAgICAgICRQYWlyICgkLlVua25vd24pICgkLlVua25vd24pLFxuICAgICAgJC5SZWdleEZsYWdzLFxuICAgICAgJC5UeXBlLFxuICAgICAgJC5UeXBlQ2xhc3MsXG4gICAgICAkLlZhbGlkRGF0ZSxcbiAgICAgICQuVmFsaWROdW1iZXJcbiAgICBdKVxuICB9KTtcblxufSkpO1xuXG4vLy4gWyM0MzhdOiAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9zYW5jdHVhcnktanMvc2FuY3R1YXJ5L2lzc3Vlcy80Mzhcbi8vLiBbQXBwbHldOiAgICAgICAgICAgICAgICAgICAgdjpmYW50YXN5bGFuZC9mYW50YXN5LWxhbmQjYXBwbHlcbi8vLiBbQmluYXJ5VHlwZV06ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiNCaW5hcnlUeXBlXG4vLy4gW0NoYWluXTogICAgICAgICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWluXG4vLy4gW0VpdGhlcl06ICAgICAgICAgICAgICAgICAgICNlaXRoZXItdHlwZVxuLy8uIFtGYW50YXN5IExhbmRdOiAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZFxuLy8uIFtGb2xkYWJsZV06ICAgICAgICAgICAgICAgICB2OmZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNmb2xkYWJsZVxuLy8uIFtHSUdPXTogICAgICAgICAgICAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9HYXJiYWdlX2luLF9nYXJiYWdlX291dFxuLy8uIFtIYXNrZWxsXTogICAgICAgICAgICAgICAgICBodHRwczovL3d3dy5oYXNrZWxsLm9yZy9cbi8vLiBbS2xlaXNsaV06ICAgICAgICAgICAgICAgICAgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvS2xlaXNsaV9jYXRlZ29yeVxuLy8uIFtNYXliZV06ICAgICAgICAgICAgICAgICAgICAjbWF5YmUtdHlwZVxuLy8uIFtOdWxsYWJsZV06ICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktZGVmI051bGxhYmxlXG4vLy4gW1B1cmVTY3JpcHRdOiAgICAgICAgICAgICAgIGh0dHA6Ly93d3cucHVyZXNjcmlwdC5vcmcvXG4vLy4gW1JhbWRhXTogICAgICAgICAgICAgICAgICAgIGh0dHA6Ly9yYW1kYWpzLmNvbS9cbi8vLiBbUmVnZXhGbGFnc106ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZiNSZWdleEZsYWdzXG4vLy4gW1NlbWlncm91cG9pZF06ICAgICAgICAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3NlbWlncm91cG9pZFxuLy8uIFtVbmFyeVR5cGVdOiAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktZGVmI1VuYXJ5VHlwZVxuLy8uIFtgJC50ZXN0YF06ICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktZGVmI3Rlc3Rcbi8vLiBbYERlc2NlbmRpbmdgXTogICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlc2NlbmRpbmcjRGVzY2VuZGluZ1xuLy8uIFtgUi5fX2BdOiAgICAgICAgICAgICAgICAgICBodHRwOi8vcmFtZGFqcy5jb20vZG9jcy8jX19cbi8vLiBbYFIuYmluZGBdOiAgICAgICAgICAgICAgICAgaHR0cDovL3JhbWRhanMuY29tL2RvY3MvI2JpbmRcbi8vLiBbYFIuaW52b2tlcmBdOiAgICAgICAgICAgICAgaHR0cDovL3JhbWRhanMuY29tL2RvY3MvI2ludm9rZXJcbi8vLiBbYFouYWx0YF06ICAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNhbHRcbi8vLiBbYFouYXBgXTogICAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNhcFxuLy8uIFtgWi5hcEZpcnN0YF06ICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2FwRmlyc3Rcbi8vLiBbYFouYXBTZWNvbmRgXTogICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNhcFNlY29uZFxuLy8uIFtgWi5iaW1hcGBdOiAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2JpbWFwXG4vLy4gW2BaLmNoYWluYF06ICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjY2hhaW5cbi8vLiBbYFouY2hhaW5SZWNgXTogICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNjaGFpblJlY1xuLy8uIFtgWi5jb21wb3NlYF06ICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2NvbXBvc2Vcbi8vLiBbYFouY29uY2F0YF06ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNjb25jYXRcbi8vLiBbYFouY29udHJhbWFwYF06ICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNjb250cmFtYXBcbi8vLiBbYFouZHJvcFdoaWxlYF06ICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNkcm9wV2hpbGVcbi8vLiBbYFouZHVwbGljYXRlYF06ICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNkdXBsaWNhdGVcbi8vLiBbYFouZW1wdHlgXTogICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNlbXB0eVxuLy8uIFtgWi5lcXVhbHNgXTogICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2VxdWFsc1xuLy8uIFtgWi5leHRlbmRgXTogICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2V4dGVuZFxuLy8uIFtgWi5leHRyYWN0YF06ICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2V4dHJhY3Rcbi8vLiBbYFouZmlsdGVyYF06ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNmaWx0ZXJcbi8vLiBbYFouZmxpcGBdOiAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNmbGlwXG4vLy4gW2BaLmZvbGRNYXBgXTogICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZm9sZE1hcFxuLy8uIFtgWi5ndGBdOiAgICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI2d0XG4vLy4gW2BaLmd0ZWBdOiAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjZ3RlXG4vLy4gW2BaLmlkYF06ICAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjaWRcbi8vLiBbYFouaW52ZXJ0YF06ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNpbnZlcnRcbi8vLiBbYFouam9pbmBdOiAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNqb2luXG4vLy4gW2BaLmx0YF06ICAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjbHRcbi8vLiBbYFoubHRlYF06ICAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNsdGVcbi8vLiBbYFoubWFwYF06ICAgICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNtYXBcbi8vLiBbYFoubWFwTGVmdGBdOiAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNtYXBMZWZ0XG4vLy4gW2BaLm9mYF06ICAgICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjb2Zcbi8vLiBbYFoucHJvbWFwYF06ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNwcm9tYXBcbi8vLiBbYFoucmVqZWN0YF06ICAgICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNyZWplY3Rcbi8vLiBbYFouc2VxdWVuY2VgXTogICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LXR5cGUtY2xhc3NlcyNzZXF1ZW5jZVxuLy8uIFtgWi50YWtlV2hpbGVgXTogICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI3Rha2VXaGlsZVxuLy8uIFtgWi50cmF2ZXJzZWBdOiAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzI3RyYXZlcnNlXG4vLy4gW2BaLnplcm9gXTogICAgICAgICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWNsYXNzZXMjemVyb1xuLy8uIFtgc2hvd2BdOiAgICAgICAgICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktc2hvdyNzaG93XG4vLy4gW2VxdWl2YWxlbmNlXTogICAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VxdWl2YWxlbmNlX3JlbGF0aW9uXG4vLy4gW2lmZl06ICAgICAgICAgICAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lmX2FuZF9vbmx5X2lmXG4vLy4gW3BhcnNlSW50XTogICAgICAgICAgICAgICAgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL3BhcnNlSW50XG4vLy4gW3BhcnRpYWwgZnVuY3Rpb25zXTogICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1BhcnRpYWxfZnVuY3Rpb25cbi8vLiBbcmFtZGEvcmFtZGEjNjgzXTogICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3JhbWRhL3JhbWRhL2lzc3Vlcy82ODNcbi8vLiBbcmFtZGEvcmFtZGEjMTQxM106ICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL3JhbWRhL3JhbWRhL2lzc3Vlcy8xNDEzXG4vLy4gW3JhbWRhL3JhbWRhIzE0MTldOiAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yYW1kYS9yYW1kYS9wdWxsLzE0MTlcbi8vLiBbc2FuY3R1YXJ5LWRlZl06ICAgICAgICAgICAgdjpzYW5jdHVhcnktanMvc2FuY3R1YXJ5LWRlZlxuLy8uIFtzYW5jdHVhcnktZWl0aGVyXTogICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktZWl0aGVyXG4vLy4gW3NhbmN0dWFyeS1tYXliZV06ICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS1tYXliZVxuLy8uIFtzYW5jdHVhcnktcGFpcl06ICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktcGFpclxuLy8uIFtzYW5jdHVhcnktc2hvd106ICAgICAgICAgICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktc2hvd1xuLy8uIFtzYW5jdHVhcnktdHlwZS1jbGFzc2VzXTogICB2OnNhbmN0dWFyeS1qcy9zYW5jdHVhcnktdHlwZS1jbGFzc2VzXG4vLy4gW3N0YWJsZSBzb3J0XTogICAgICAgICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NvcnRpbmdfYWxnb3JpdGhtI1N0YWJpbGl0eVxuLy8uIFt0aHJ1c2hdOiAgICAgICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcmFnYW53YWxkLWRlcHJlY2F0ZWQvaG9tb2ljb25pYy9ibG9iL21hc3Rlci8yMDA4LTEwLTMwL3RocnVzaC5tYXJrZG93blxuLy8uIFt0b3RhbCBmdW5jdGlvbnNdOiAgICAgICAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QYXJ0aWFsX2Z1bmN0aW9uI1RvdGFsX2Z1bmN0aW9uXG4vLy4gW3R5cGUgY2hlY2tpbmddOiAgICAgICAgICAgICN0eXBlLWNoZWNraW5nXG4vLy4gW3R5cGUgaWRlbnRpZmllcl06ICAgICAgICAgIHY6c2FuY3R1YXJ5LWpzL3NhbmN0dWFyeS10eXBlLWlkZW50aWZpZXJzXG4vLy4gW3R5cGUgcmVwcmVzZW50YXRpdmVdOiAgICAgIHY6ZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3R5cGUtcmVwcmVzZW50YXRpdmVzXG4vLy4gW3ZhcmlhZGljIGZ1bmN0aW9uc106ICAgICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhcmlhZGljX2Z1bmN0aW9uXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG5pbXBvcnQgcHJpbnRNZSBmcm9tIFwiLi9wcmludC5qc1wiO1xuY29uc3QgeyByZWR1Y2UsIGNvbmNhdCwgbWFwIH0gPSByZXF1aXJlKFwic2FuY3R1YXJ5XCIpO1xuXG5mdW5jdGlvbiBqb2luKGxpc3QsIHNlcGFyYXRvcikge1xuICByZXR1cm4gcmVkdWNlKGNvbmNhdCkoXCJcIikobWFwKHggPT4gY29uY2F0KHgpKHNlcGFyYXRvcikpKGxpc3QpKTtcbn1cblxuZnVuY3Rpb24gY29tcG9uZW50KCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29uc3QgYnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcblxuICBlbGVtZW50LmlubmVySFRNTCA9IGpvaW4oW1wiSGVsbG9cIiwgXCJXZWJwYWNrXCJdLCBcIiBcIik7XG5cbiAgYnRuLmlubmVySFRNTCA9IFwiQ2xpY2sgbWUgYW5kIGNoZWNrIHRoZSBjb25zb2xlXCI7XG4gIGJ0bi5vbmNsaWNrID0gcHJpbnRNZTtcbiAgZWxlbWVudC5hcHBlbmRDaGlsZChidG4pO1xuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbXBvbmVudCgpKTtcbiIsIi8qIGVzbGludC1lbnYgbm9kZSAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwcmludE1lKCkge1xuICBjb25zb2xlLmxvZyAoJ0kgZ2V0IGNhbGxlZCBmcm9tIHByaW50LmpzIScpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==
